<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Libuv 事件循环</h1>
<p>前面的课程中，我们了解了 Node.js 的基础架构。接下来，我们深入学习 Node.js 架构的实现：事件循环。事件循环是 Node.js 的内在驱动引擎，深入了解事件循环，将会帮助我们更好地理解和使用 Node.js。比如说，我们做 APM 时会监控事件循环延迟的情况，这会导致很多用户经常收到相关的告警，当我们深入理解了事件循环后，就会明白这个问题出现的原因，从而避免它的出现。</p>
<p>我们已经学过事件循环的概念，今天就深入来讲事件循环是如何实现的。</p>
<h2>如何理解事件循环？</h2>
<p>事件循环是很多软件中的概念，尤其是基于事件驱动的软件，大家应该都不陌生。事件循环代表了应用的整个生命周期，事件循环结束意味着应用也就退出了。前面课程中介绍过，事件循环本质上是一个生产者 / 消费者模型，在应用的生命周期中，生产者和消费者不断生产和处理任务，并通过事件驱动模块驱动着应用的运行，通常我们称为一个“死循环”。</p>
<p>那这个“死循环”到底长啥样呢？我们先来看一个朴素版的事件循环系统。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventSystem</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 任务队列</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = [];
  }

  <span class="hljs-comment">// 追加任务</span>
  <span class="hljs-title function_">enQueue</span>(<span class="hljs-params">func</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(func);
  }

  <span class="hljs-comment">// 事件循环</span>
  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span>) {
         <span class="hljs-keyword">const</span> func = <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">shift</span>();
         <span class="hljs-title function_">func</span>();
       }
    }
  }
}
<span class="hljs-comment">// 新建一个事件循环系统</span>
<span class="hljs-keyword">const</span> eventSystem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSystem</span>();

<span class="hljs-comment">// 生产任务</span>
eventSystem.<span class="hljs-title function_">enQueue</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'hi'</span>);
});

<span class="hljs-comment">// 启动事件循环</span>
eventSystem.<span class="hljs-title function_">run</span>();

<span class="hljs-comment">// 生产任务</span>
eventSystem.<span class="hljs-title function_">enQueue</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'hi'</span>);
});
</code></pre>
<p>以上代码实现了一个非常朴素的事件循环系统，大概逻辑如下：</p>
<ol>
<li>
<p>新建一个事件循环系统；</p>
</li>
<li>
<p>生产任务；</p>
</li>
<li>
<p>启动事件循环系统处理任务。</p>
</li>
</ol>
<p>但我们发现没有任务的时候，事件循环系统就陷入了死循环，这不仅浪费了 CPU，新的任务也无法继续添加了。因此，在一个事件循环系统中，如何处理没有任务时的情况非常关键。这应该怎么解决呢？我们先来优化一下这个朴素版的事件循环。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventSystem</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// 需要处理的任务队列</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = [];
        <span class="hljs-comment">// 标记是否需要退出事件循环</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stop</span> = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 有任务时调用该函数"唤醒" await</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">wakeup</span> = <span class="hljs-literal">null</span>;
    }
    <span class="hljs-comment">// 没有任务时，事件循环的进入"阻塞"状态</span>
    <span class="hljs-title function_">wait</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {
            <span class="hljs-comment">// 记录 resolve，可能在睡眠期间有任务到来，则需要提前唤醒</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">wakeup</span> = <span class="hljs-function">() =></span> {
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">wakeup</span> = <span class="hljs-literal">null</span>;
                <span class="hljs-title function_">resolve</span>();
            };
        });
    }
    <span class="hljs-comment">// 停止事件循环，如果正在"阻塞"，则"唤醒它"</span>
    <span class="hljs-title function_">setStop</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stop</span> = <span class="hljs-number">1</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">wakeup</span> &#x26;&#x26; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">wakeup</span>();
    }
    <span class="hljs-comment">// 生产任务</span>
    <span class="hljs-title function_">enQueue</span>(<span class="hljs-params">func</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(func);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">wakeup</span> &#x26;&#x26; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">wakeup</span>();
    }

    <span class="hljs-comment">// 处理任务队列</span>
    <span class="hljs-title function_">handleTask</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// 本轮事件循环的回调中加入的任务，下一轮事件循环再处理，防止其他任务没有机会处理</span>
        <span class="hljs-keyword">const</span> queue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = [];
        <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) {
            <span class="hljs-keyword">const</span> func = queue.<span class="hljs-title function_">shift</span>();
            <span class="hljs-title function_">func</span>();
        }
    }

    <span class="hljs-comment">// 事件循环的实现</span>
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// 如果 stop 等于 1 则退出事件循环</span>
        <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stop</span> === <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 处理任务，可能没有任务需要处理</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleTask</span>();
            <span class="hljs-comment">// 处理任务过程中如果设置了 stop 标记则退出事件循环</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stop</span> === <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-comment">// 没有任务了，进入睡眠</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">wait</span>();
            }
        }
        <span class="hljs-comment">// 退出前可能还有任务没处理，处理完再退出</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleTask</span>();
    }
}

<span class="hljs-comment">// 新建一个事件循环系统</span>
<span class="hljs-keyword">const</span> eventSystem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSystem</span>();

<span class="hljs-comment">// 启动前生成的任务</span>
eventSystem.<span class="hljs-title function_">enQueue</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'1'</span>);
});

<span class="hljs-comment">// 模拟定时生成一个任务</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    eventSystem.<span class="hljs-title function_">enQueue</span>(<span class="hljs-function">() =></span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'3'</span>);
        eventSystem.<span class="hljs-title function_">setStop</span>();
    });
}, <span class="hljs-number">1000</span>);

<span class="hljs-comment">// 启动事件循环</span>
eventSystem.<span class="hljs-title function_">run</span>();

<span class="hljs-comment">// 启动后生成的任务</span>
eventSystem.<span class="hljs-title function_">enQueue</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'2'</span>);
});
</code></pre>
<p>麻雀虽小但五脏俱全，以上代码虽然只是个 demo，但已经具备了事件循环的一些核心功能。</p>
<ol>
<li>
<p>事件循环的整体架构是一个 while 循环。</p>
</li>
<li>
<p>定义任务类型和队列，这里只有一种任务类型和一个队列，比如 Node.js 里有好几种，每种类型的任务有不同的作用。</p>
</li>
<li>
<p>没有任务的时候怎么处理：进入阻塞状态，而不是靠忙轮询。</p>
</li>
</ol>
<p>第 3 点是事件循环系统中非常重要的逻辑，因为事件循环属于生产者 / 消费者模式，任务队列中不可能一直都有任务需要处理，这就意味着生产任务可以是一个异步的过程，所以事件循环系统就需要有一种<strong>等待 / 唤醒机制</strong>。但这会带来两个问题：如何实现等待 / 唤醒机制？什么时候需要退出？</p>
<p>这和具体的业务场景有关，在该事件循环中，没有任务的时候就会一直等待而不是退出。除非用户手动执行 setStop 退出。而在 Node.js 中，如果没有 actived 状态的 handle 和 request 并且 close 阶段没有任务时就会自动退出，具体可以参考 uv__loop_alive 函数。那如何实现等待 / 唤醒呢？这里使用的是 await Promise 来模拟睡眠达到等待的效果，而在 Libuv 中，通过在 Poll IO 阶段使用操作系统的事件驱动模块实现等待 / 唤醒机制。</p>
<h2>其他软件的事件循环</h2>
<p>在学习 Libuv 事件循环实现之前，我们先来看看其他软件的事件循环实现，这会让我们更深入地认识事件循环。因为事件循环并不是 Libuv 中独有的，而是一个通用的概念，如果你不感兴趣，也可以直接去看 Libuv 事件循环的内容。</p>
<p><strong>Nginx</strong></p>
<p>Nginx 和 Libuv 的底层技术类似，它也实现了一个事件循环，虽然细节不一样，但整体流程是相似的。下面，我们就简单来看一下 Nginx 1.23.1 的事件循环。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ngx_worker_process_cycle</span><span class="hljs-params">(<span class="hljs-type">ngx_cycle_t</span> *cycle, <span class="hljs-type">void</span> *data)</span>
{
    <span class="hljs-comment">// 事件循环</span>
    <span class="hljs-keyword">for</span> ( ;; ) {
        <span class="hljs-comment">// 是否需要退出</span>
        <span class="hljs-keyword">if</span> (ngx_exiting) {
            <span class="hljs-comment">// 是否还有定时器节点，有的话需要先处理再退出</span>
            <span class="hljs-keyword">if</span> (ngx_event_no_timers_left() == NGX_OK) {
                ngx_worker_process_exit(cycle);
            }
        }
        <span class="hljs-comment">// 处理定时器和其他事件</span>
        ngx_process_events_and_timers(cycle);
    }
}
</code></pre>
<p>ngx_worker_process_cycle 是在子进程里执行的函数，在一个 for 循环中不断调用 ngx_process_events_and_timers，接着看一下 ngx_process_events_and_timers。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">ngx_process_events_and_timers</span>(ngx_cycle_t *cycle)
{
    <span class="hljs-comment">// 找到最快到期的定时器</span>
    timer = <span class="hljs-built_in">ngx_event_find_timer</span>();
    <span class="hljs-comment">// 调用事件驱动模块等待就绪事件或者定时器超时</span>
    (void) <span class="hljs-built_in">ngx_process_events</span>(cycle, timer, flags);
    <span class="hljs-comment">// 处理事件</span>
    <span class="hljs-built_in">ngx_event_process_posted</span>(cycle, &#x26;ngx_posted_accept_events);

    <span class="hljs-comment">// 处理过期的定时器</span>
    <span class="hljs-built_in">ngx_event_expire_timers</span>();
    
    <span class="hljs-comment">// 处理事件</span>
    <span class="hljs-built_in">ngx_event_process_posted</span>(cycle, &#x26;ngx_posted_events);
}
</code></pre>
<p>可以看到 Nginx 事件循环的实现，整体架构非常清晰。</p>
<p><strong>Redis</strong></p>
<p>我们再看一下 Redis 0.1 的事件循环。</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">aeMain</span><span class="hljs-params">(aeEventLoop *eventLoop)</span>
{
    eventLoop->stop = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (!eventLoop->stop)
        aeProcessEvents(eventLoop, AE_ALL_EVENTS);
}
</code></pre>
<p>接着看 aeProcessEvents。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">aeProcessEvents</span><span class="hljs-params">(aeEventLoop *eventLoop, <span class="hljs-type">int</span> flags)</span>
{
    <span class="hljs-type">int</span> maxfd = <span class="hljs-number">0</span>, numfd = <span class="hljs-number">0</span>, processed = <span class="hljs-number">0</span>;
    fd_set rfds, wfds, efds;
    aeFileEvent *fe = eventLoop->fileEventHead;
    aeTimeEvent *te;
    <span class="hljs-comment">// 初始化变量</span>
    FD_ZERO(&#x26;rfds);
    FD_ZERO(&#x26;wfds);
    FD_ZERO(&#x26;efds);

    <span class="hljs-comment">// 处理文件事件</span>
    <span class="hljs-keyword">if</span> (flags &#x26; AE_FILE_EVENTS) {
        <span class="hljs-keyword">while</span> (fe != <span class="hljs-literal">NULL</span>) {
            <span class="hljs-comment">// 根据需要处理的事件，设置对应的变量对应的位</span>
            <span class="hljs-keyword">if</span> (fe->mask &#x26; AE_READABLE) FD_SET(fe->fd, &#x26;rfds);
            <span class="hljs-keyword">if</span> (fe->mask &#x26; AE_WRITABLE) FD_SET(fe->fd, &#x26;wfds);
            <span class="hljs-keyword">if</span> (fe->mask &#x26; AE_EXCEPTION) FD_SET(fe->fd, &#x26;efds);
            <span class="hljs-comment">// 记录最大文件描述符 select 的时候需要用</span>
            <span class="hljs-keyword">if</span> (maxfd &#x3C; fe->fd) maxfd = fe->fd;
            numfd++;
            fe = fe->next;
        }
    }
    <span class="hljs-comment">// 有文件事件需要处理</span>
    <span class="hljs-comment">// 或者没有文件事件需要处理但是有 time 事件并且没有设置 AE_DONT_WAIT 标记</span>
    <span class="hljs-keyword">if</span> (numfd || ((flags &#x26; AE_TIME_EVENTS) &#x26;&#x26; !(flags &#x26; AE_DONT_WAIT))) {
        <span class="hljs-type">int</span> retval;
        aeTimeEvent *shortest = <span class="hljs-literal">NULL</span>;
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tv</span>, *<span class="hljs-title">tvp</span>;</span>
        <span class="hljs-comment">// 有 time 事件需要处理，并且没有设置 AE_DONT_WAIT 标记，则 select 可能会定时阻塞（如果有time节点的话）</span>
        <span class="hljs-keyword">if</span> (flags &#x26; AE_TIME_EVENTS &#x26;&#x26; !(flags &#x26; AE_DONT_WAIT))
            <span class="hljs-comment">// 找出最快到期的节点</span>
            shortest = aeSearchNearestTimer(eventLoop);
        <span class="hljs-comment">// 有待到期的time节点</span>
        <span class="hljs-keyword">if</span> (shortest) {
            <span class="hljs-comment">// 计算超时时间</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 没有到期的time节点</span>
            <span class="hljs-comment">// 设置了AE_DONT_WAIT，则不会阻塞在select</span>
            <span class="hljs-keyword">if</span> (flags &#x26; AE_DONT_WAIT) {
                tv.tv_sec = tv.tv_usec = <span class="hljs-number">0</span>;
                tvp = &#x26;tv;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 一直阻塞直到有事件发生</span>
                tvp = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* wait forever */</span>
            }
        }
        <span class="hljs-comment">// 调用事件驱动模块等待时间触发或者超时</span>
        retval = select(maxfd+<span class="hljs-number">1</span>, &#x26;rfds, &#x26;wfds, &#x26;efds, tvp);
        <span class="hljs-comment">// 有事件触发则处理</span>
        <span class="hljs-keyword">if</span> (retval > <span class="hljs-number">0</span>) {
            fe = eventLoop->fileEventHead;
            <span class="hljs-keyword">while</span>(fe != <span class="hljs-literal">NULL</span>) {
                <span class="hljs-comment">// 执行回调</span>
                fe->fileProc(eventLoop, fe->fd, fe->clientData, mask);
            }
        }
    }
    
    <span class="hljs-comment">// 处理time事件</span>
    <span class="hljs-keyword">if</span> (flags &#x26; AE_TIME_EVENTS) {
        te = eventLoop->timeEventHead;
        <span class="hljs-keyword">while</span>(te) {
            <span class="hljs-comment">// 获取当前时间</span>
            aeGetTime(&#x26;now_sec, &#x26;now_ms);
            <span class="hljs-comment">// 到期了</span>
            <span class="hljs-keyword">if</span> (now_sec > te->when_sec ||
                (now_sec == te->when_sec &#x26;&#x26; now_ms >= te->when_ms))
            {
                <span class="hljs-comment">// 执行回调</span>
                te->timeProc(eventLoop, id, te->clientData);
            } <span class="hljs-keyword">else</span> {
                te = te->next;
            }
        }
    }
    <span class="hljs-comment">// 处理的事件个数</span>
    <span class="hljs-keyword">return</span> processed;
}
</code></pre>
<p>Redis 的代码虽然多，但逻辑还是很清晰的，大致上也是利用事件驱动模块处理事件和定时器。另外，早期的 Redis 使用的是 select 而不是 epoll。不过我们也不需要过多纠结它的细节，只需要大致了解它的处理过程就行。</p>
<h2>Libuv 的事件循环</h2>
<p>下图是事件循环整体的执行流程，可以看到事件循环分为多个阶段，每个阶段都有自己的作用，接下来将会详细介绍这些阶段的作用是什么。但是我们不会按照事件循环中先后顺序来介绍各个阶段，而是先介绍简单的阶段，再介绍复杂的阶段，这更有助于我们理解。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fccdc87a915441b9640edeea9e06e12~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>Libuv 事件循环具体在 uv_run 函数中实现。uv_run 中执行 while 循环，然后串行处理各种阶段（phase）的事件回调，所以当一个任务执行时间过长，就会影响后面任务的执行，导致事件循环延迟过高。下面，我们来看一下具体的代码。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_run</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, uv_run_mode mode)</span> {
    <span class="hljs-type">int</span> timeout;
    <span class="hljs-type">int</span> r;
    <span class="hljs-type">int</span> ran_pending;
    <span class="hljs-keyword">while</span> (r != <span class="hljs-number">0</span> &#x26;&#x26; loop->stop_flag == <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 更新当前时间，每轮事件循环会缓存这个时间，避免过多系统调用损耗性能</span>
        uv__update_time(loop);
        <span class="hljs-comment">// 执行定时器回调</span>
        uv__run_timers(loop);
        <span class="hljs-comment">// 执行 pending 回调</span>
        uv__run_pending(loop);
        <span class="hljs-comment">// 继续执行各种队列</span>
        uv__run_idle(loop);
        uv__run_prepare(loop);
        timeout = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 计算 Poll IO 阻塞时间</span>
        timeout = uv_backend_timeout(loop);
        <span class="hljs-comment">// Poll IO timeout是 epoll_wait 的等待时间</span>
        uv__io_poll(loop, timeout);
        <span class="hljs-comment">// 继续执行各种队列</span>
        uv__run_check(loop);
        uv__run_closing_handles(loop);
        <span class="hljs-comment">// 是否还有活跃任务，有则继续下一轮事件循环</span>
        r = uv__loop_alive(loop);
    }
    <span class="hljs-keyword">return</span> r;
}

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uv__loop_alive</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uv_loop_t</span>* loop)</span> {
  <span class="hljs-keyword">return</span> uv__has_active_handles(loop) ||
         uv__has_active_reqs(loop) ||
         loop->closing_handles != <span class="hljs-literal">NULL</span>;
}
</code></pre>
<p>相比前面介绍的事件循环，Libuv 的事件循环多了一些阶段，不过 uv_run 的代码还是很清晰的，就是逐个处理各个阶段的任务，Libuv 分为几个阶段，下面分别讲解各个阶段的相关逻辑。</p>
<ol>
<li>prepare、check、idle 阶段</li>
</ol>
<p>prepare、check、idle 在 Libuv 事件循环中属于比较简单的阶段，它们的实现是一样的，只是执行时机不一样，所以我们这里只讲解 idle 阶段。我们知道 Libuv 分为 handle 和 request。而 idle 阶段的任务是属于 handle。下面我们通过一个例子，看看 idle 阶段的任务是如何创建和处理的。</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&#x3C;uv.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">idle_cb</span><span class="hljs-params">(<span class="hljs-type">uv_idle_t</span> *handle)</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"idle callback\n"</span>);
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">uv_idle_t</span> idle;
    <span class="hljs-comment">// 初始化</span>
    uv_idle_init(uv_default_loop(), &#x26;idle);
    <span class="hljs-comment">// 启动，每轮事件循环都会执行 idle_cb</span>
    uv_idle_start(&#x26;idle, idle_cb);
    uv_run(uv_default_loop(), UV_RUN_DEFAULT);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>上面的代码中，Libuv 会在每一轮事件循环的 idle 阶段执行回调 idle_cb。我们分析一下这个过程。使用前，首先定义一个 uv_idle_t 结构体，然后执行 uv_idle_init 进行 handle 的初始化。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_idle_init</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv_idle_t</span>* handle)</span> {
    uv__handle_init(loop, (<span class="hljs-type">uv_handle_t</span>*)handle, UV_IDLE);
    handle->idle_cb = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_idle_init 函数主要是做一些初始化操作，继续看 start 函数。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_idle_start</span><span class="hljs-params">(<span class="hljs-type">uv_idle_t</span>* handle, uv_idle_cb cb)</span> {
    <span class="hljs-comment">// 如果已经执行过 start 函数则直接返回</span>
    <span class="hljs-keyword">if</span> (uv__is_active(handle)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (cb == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> UV_EINVAL;
    QUEUE_INSERT_HEAD(&#x26;handle->loop->idle_handles, &#x26;handle-><span class="hljs-built_in">queue</span>);
    handle->idle_cb = cb;
    uv__handle_start(handle);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_idle_start 用于设置回调，把 handle 插入事件循环中的 idle_handles 队列，idle_handles 则保存了 idle 阶段的任务。接着执行 uv_run 开始事件循环，在事件循环的 idle 阶段会逐个执行里面的节点的回调。我们看看 Libuv 在事件循环的 idle 阶段是如何处理的。</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv__run_idle</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop)</span> {
    <span class="hljs-type">uv_prepare_t</span>* h;
    QUEUE <span class="hljs-built_in">queue</span>;
    QUEUE* q;
    <span class="hljs-comment">/*
        把该类型对应的队列中所有节点摘下来挂载到 queue 变量，
        相当于清空 idle_handles 队列，因为如果直接遍历
        idle_handles 队列，在执行回调的时候如果一直往 idle_handles
        队列加节点，会导致下面的 while 循环无法退出。
        先移除的话，新插入的节点在下一轮事件循环才会被处理。
    */</span>
    QUEUE_MOVE(&#x26;loop->idle_handles, &#x26;<span class="hljs-built_in">queue</span>);
    <span class="hljs-comment">// 遍历队列，执行每个节点里面的函数</span>
    <span class="hljs-keyword">while</span> (!QUEUE_EMPTY(&#x26;<span class="hljs-built_in">queue</span>)) {
        <span class="hljs-comment">// 取下当前待处理的节点，即队列的头</span>
        q = QUEUE_HEAD(&#x26;<span class="hljs-built_in">queue</span>);
        <span class="hljs-comment">/*
            取得该节点对应的整个结构体的基地址，
            即通过结构体成员取得结构体首地址
        */</span>
        h = QUEUE_DATA(q, <span class="hljs-type">uv_idle_t</span>, <span class="hljs-built_in">queue</span>);
        <span class="hljs-comment">// 把该节点移出当前队列</span>
        QUEUE_REMOVE(q);
        <span class="hljs-comment">// 重新插入原来的队列</span>
        QUEUE_INSERT_TAIL(&#x26;loop->idle_handles, q);
        <span class="hljs-comment">// 执行回调函数</span>
        h->idle_cb(h);
    }
}
</code></pre>
<p>uv__run_idle 函数的逻辑很简单，就是逐个执行 idle_handles 队列的节点。不过有一个地方需要注意，节点被移出队列后，又执行 QUEUE_INSERT_TAIL 重新插入到队列了，所以这三个阶段的任务是每次事件循环都会被执行的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a99da985b933447daeee1c2dbebdf6f7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我们回顾一开始的代码，因为设置了 Libuv 的运行模式是默认模式（UV_RUN_DEFAULT）。又因为有 active 状态的 handle（idle 节点），所以事件循环是不会退出的，它会一直执行回调。如果要退出怎么办，或者说不需要执行 idle 队列的某个节点了该怎么办？只需要 uv_idle_stop 就可以了。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_idle_stop</span><span class="hljs-params">(<span class="hljs-type">uv_idle_t</span>* handle)</span> {
    <span class="hljs-keyword">if</span> (!uv__is_active(handle)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 把 handle 从 idle 队列中移除，但是还挂载到 handle_queue 中</span>
    QUEUE_REMOVE(&#x26;handle-><span class="hljs-built_in">queue</span>);
    <span class="hljs-comment">// 清除 active 标记位并且减去事件循环中 handle 的 active 数</span>
    uv__handle_stop(handle);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_idle_stop 会停止 uv_idle_t handle 并移出 idle 队列，但是不会把 handle 移出事件循环的 handle 队列，如果想把 handle 移出事件循环的 handle 队列，需要调用 uv_close，uv_close 除了调用 uv_idle_stop，还会把 handle 移出 handle 队列，一会分析 close 阶段的时候再具体讲。</p>
<p>另外需要注意的是，虽然 idle、check、prepare 回调会在每一轮事件循环被执行，但是 idle 阶段比较特殊，当存在 idle 任务时，事件循环不会阻塞在 Poll IO 阶段，所以 idle 任务的回调会一直执行，而如果是 prepare 或 check 任务，事件循环会阻塞在 Poll IO 阶段，从 Poll IO 阶段返回时，才会继续执行 prepare 或 check 回调，比如下面的例子中，回调只会被执行一次。</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&#x3C;uv.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">prep_cb</span><span class="hljs-params">(<span class="hljs-type">uv_prepare_t</span> *handle)</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Prep callback\n"</span>);
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">uv_prepare_t</span> prep;
    uv_prepare_init(uv_default_loop(), &#x26;prep);
    uv_prepare_start(&#x26;prep, prep_cb);
    <span class="hljs-comment">// 执行一次 prep_cb 然后进入阻塞状态</span>
    uv_run(uv_default_loop(), UV_RUN_DEFAULT);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ol start="2">
<li>pending 阶段</li>
</ol>
<p>pending 阶段用于处理 Poll IO 阶段产生的一些回调，比如连接失败时的回调或者 UDP 数据发送结束的写回调。下面来看一个例子。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv__tcp_connect</span><span class="hljs-params">(...)</span> {
  <span class="hljs-keyword">do</span> {
    errno = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 非阻塞式发起连接</span>
    r = connect(uv__stream_fd(handle), addr, addrlen);
  } <span class="hljs-keyword">while</span> (r == <span class="hljs-number">-1</span> &#x26;&#x26; errno == EINTR);
  <span class="hljs-comment">// 连接失败或还没成功</span>
  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">-1</span> &#x26;&#x26; errno != <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span> (errno == EINPROGRESS) <span class="hljs-comment">// 连接中的错误码</span>
      ; <span class="hljs-comment">/* not an error */</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (errno == ECONNREFUSED)
      handle->delayed_error = UV__ERR(ECONNREFUSED);
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">return</span> UV__ERR(errno);
  }
  <span class="hljs-comment">// 产生 pending 任务</span>
  <span class="hljs-keyword">if</span> (handle->delayed_error)
    uv__io_feed(handle->loop, &#x26;handle->io_watcher);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv__tcp_connect 调用 connect 函数以非阻塞方式发起 TCP 连接，当 connect 返回时，可能处于连接中或者失败，从代码中可以看到当 errno 是 ECONNREFUSED 时，Libuv 会执行 uv__io_feed 函数。</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv__io_feed</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv__io_t</span>* w)</span> {
  <span class="hljs-keyword">if</span> (QUEUE_EMPTY(&#x26;w->pending_queue))
    QUEUE_INSERT_TAIL(&#x26;loop->pending_queue, &#x26;w->pending_queue);
}
</code></pre>
<p>uv__io_feed 函数会把一个 IO 观察者插入到 pending 队列，从中也可以看到 pending 阶段是和 IO 相关的。接下来看一下 pending 阶段的处理。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uv__run_pending</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop)</span> {
  QUEUE* q;
  QUEUE pq;
  <span class="hljs-type">uv__io_t</span>* w;
  <span class="hljs-keyword">if</span> (QUEUE_EMPTY(&#x26;loop->pending_queue))
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 把 pending_queue 队列的节点移到 pq，清空 pending_queue</span>
  QUEUE_MOVE(&#x26;loop->pending_queue, &#x26;pq);
  <span class="hljs-comment">// 遍历 pq 队列</span>
  <span class="hljs-keyword">while</span> (!QUEUE_EMPTY(&#x26;pq)) {
    <span class="hljs-comment">// 取出当前第一个需要处理的节点</span>
    q = QUEUE_HEAD(&#x26;pq);
    <span class="hljs-comment">// 把当前需要处理的节点移出队列</span>
    QUEUE_REMOVE(q);
    <span class="hljs-comment">// 重置一下 prev 和 next 指针</span>
    QUEUE_INIT(q);
    w = QUEUE_DATA(q, <span class="hljs-type">uv__io_t</span>, pending_queue);
    <span class="hljs-comment">// 执行回调</span>
    w->cb(loop, w, POLLOUT);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</code></pre>
<p>pending 阶段的处理逻辑比较简单，就是遍历队列，然后执行每个节点的回调，这里需要注意的是，回调的入参是 loop、IO 观察者和可写事件。</p>
<ol start="3">
<li>close 阶段</li>
</ol>
<p>close 是 Libuv 每轮事件循环中最后的一个阶段。对于一个 handle，有四个通用的操作函数，分别是 init、start、stop 和 close。init 和 start 比较好理解，那么 stop 和 close 有什么区别呢？</p>
<p>stop 通常意味着这个 handle 处于暂停状态，后续还可以调用 start 重新激活，同时还挂载在事件循环的 handle 队列。比如可以使用 uv_timer_stop 停止一个定时器，然后再执行 uv_timer_start 重启这个定时器。但是 close 意味着这个 handle 已经被关闭了，不再重新使用，同时也会被移出事件循环的 handle 队列。另外， close 操作支持传入一个回调，这个回调会在 close 阶段被执行，比如用于释放动态申请的内存。close 阶段的任务由 uv_close 产生。</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv_close</span><span class="hljs-params">(<span class="hljs-type">uv_handle_t</span>* handle, uv_close_cb close_cb)</span> {
    <span class="hljs-comment">// 正在关闭，但是还没执行回调等后置操作</span>
    handle->flags |= UV_HANDLE_CLOSING;
    handle->close_cb = close_cb;
    <span class="hljs-comment">// 根据 handle 类型执行不同的操作，通常是 stop 这个 handle</span>
    <span class="hljs-keyword">switch</span> (handle->type) {
        <span class="hljs-keyword">case</span> UV_PREPARE:
            uv__prepare_close((<span class="hljs-type">uv_prepare_t</span>*)handle);
                <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> UV_CHECK:
            uv__check_close((<span class="hljs-type">uv_check_t</span>*)handle);
            <span class="hljs-keyword">break</span>;
        ...
        <span class="hljs-keyword">default</span>:
            assert(<span class="hljs-number">0</span>);
    }
    uv__make_close_pending(handle);
}
</code></pre>
<p>uv_close 设置 handle 的回调和状态，然后根据 handle 类型调对应的 close 函数，一般就是 stop 这个 handle。比如 prepare 的 close 函数：</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv__prepare_close</span><span class="hljs-params">(<span class="hljs-type">uv_prepare_t</span>* handle)</span> {
    uv_prepare_stop(handle);
}
</code></pre>
<p>接着，执行 uv__make_close_pending 以头插法往 close 队列插入一个任务。</p>
<pre><code class="hljs language-c"><span class="hljs-comment">// 头插法插入 close 队列，在 close 阶段被执行</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">uv__make_close_pending</span><span class="hljs-params">(<span class="hljs-type">uv_handle_t</span>* handle)</span> {
    handle->next_closing = handle->loop->closing_handles;
    handle->loop->closing_handles = handle;
}
</code></pre>
<p>最后，在 close 阶段逐个处理。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__run_closing_handles</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop)</span> {
    <span class="hljs-type">uv_handle_t</span>* p;
    <span class="hljs-type">uv_handle_t</span>* q;
    p = loop->closing_handles;
    loop->closing_handles = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">while</span> (p) {
        q = p->next_closing;
        uv__finish_close(p);
        p = q;
    }
}

<span class="hljs-comment">// 执行 close 阶段的回调</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__finish_close</span><span class="hljs-params">(<span class="hljs-type">uv_handle_t</span>* handle)</span> {
    handle->flags |= UV_HANDLE_CLOSED;
    <span class="hljs-comment">// ...</span>
    uv__handle_unref(handle);
    <span class="hljs-comment">// 移出 handle 队列</span>
    QUEUE_REMOVE(&#x26;handle->handle_queue);
    <span class="hljs-comment">// 执行回调</span>
    <span class="hljs-keyword">if</span> (handle->close_cb) {
        handle->close_cb(handle);
    }
}
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbfc8af2249c40539b14da1c5957c887~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下面看一个使用了uv_close 的例子（代码来自 Libuv 中的文件监听模块，省略部分代码）。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_fs_poll_start</span><span class="hljs-params">(...)</span> {    
    <span class="hljs-comment">// 分配一块堆内存</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_ctx</span>* <span class="hljs-title">ctx</span> =</span> uv__calloc(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(*ctx) + len);
    <span class="hljs-comment">// 保存到 handle 中</span>
    handle->poll_ctx = ctx;
}
</code></pre>
<p>uv_fs_poll_start 用于执行开始监听文件的操作，它在 handle 里挂载了一个在堆上分配的结构体，当结束监听的时候，需要释放掉这块内存。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_fs_poll_stop</span><span class="hljs-params">(<span class="hljs-type">uv_fs_poll_t</span>* handle)</span> {
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_ctx</span>* <span class="hljs-title">ctx</span>;</span>
    ctx = handle->poll_ctx;
    handle->poll_ctx = <span class="hljs-literal">NULL</span>;
    uv_close((<span class="hljs-type">uv_handle_t</span>*)&#x26;ctx->timer_handle, timer_close_cb);
}
</code></pre>
<p>uv_fs_poll_stop 通过 uv_close 函数关闭 handle，并传入了回调 timer_close_cb，所以在 close 阶段就会执行 timer_close_cb。</p>
<pre><code class="hljs language-c"><span class="hljs-comment">// 释放上下文结构体的内存</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timer_close_cb</span><span class="hljs-params">(<span class="hljs-type">uv_handle_t</span>* handle)</span> {
    uv__free(container_of(handle, <span class="hljs-keyword">struct</span> poll_ctx, timer_handle));
}
</code></pre>
<p>可以看到，最后在 close 阶段释放这块内存。</p>
<ol start="4">
<li>timer 阶段</li>
</ol>
<p>timer 阶段是用于实现定时器的，定时器是大多数基于事件驱动架构的软件需要实现的部分。因为 V8 中没有提供定时器的功能，在前端时是由浏览器实现的，而在 Node.js 里，定时器由 Libuv 实现。</p>
<p>定时器的实现原理很简单，主要是借助事件驱动模块的阻塞时间来实现，通常就是维护了一个数据结构，然后把最快到期的时间设置为事件驱动模块的阻塞时间，如果一定时间内没有其他事件触发，那么进程就会从事件驱动模块中返回，从而处理定时器。但是因为定时器使用非常频繁，所以如何实现一个高性能的定时器是需要重点考虑的事情。</p>
<p>Libuv 中，在底层里面维护了一个最小堆，每个定时节点就是堆里面的一个节点，越早超时的节点就在越上面。等到定时器阶段的时候， Libuv 就会从上往下去遍历这个最小堆判断当前节点有没有超时，如果碰到没有到期的节点，那么后面节点也不需要去判断了，因为根据最小堆的性质，最早到期的节点都没有到期，那么它后面节点显然也不会到期。如果当前节点到期了，那么就会执行它的回调，并且把它移出这个最小堆。</p>
<p>定时器的概念是超时后会执行一个回调，如果用户需要周期性执行一个回调，例如 Node.js setInterval 的这种场景，就可以给这个节点设置了repeat 标记，那么这个节点每次超时执行完回调后，就会被重新插入到最小堆中，等待下一次的超时。有意思的是，Libuv 的定时器支持 timeout1 后触发第一次超时，后续每隔 timeout2 触发一次超时。整体结构如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b1cd9450b84efc8347a90cf9d01f12~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下面，我们再来看一下定时器的使用。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
    <span class="hljs-type">v_timer_t</span> once;
    uv_timer_init(uv_default_loop(), &#x26;once);
    <span class="hljs-comment">// 超时后执行 once_cb，0 表示只执行一次回调，设置为 n 代表第一次超时后，下次超时时间</span>
    uv_timer_start(&#x26;once, once_cb, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);
    uv_run(uv_default_loop(), UV_RUN_DEFAULT);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        
}
</code></pre>
<p>我们从 uv_timer_init 函数开始分析。</p>
<pre><code class="hljs language-c"><span class="hljs-comment">// 初始化uv_timer_t结构体</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">uv_timer_init</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv_timer_t</span>* handle)</span> {
    uv__handle_init(loop, (<span class="hljs-type">uv_handle_t</span>*)handle, UV_TIMER);
    handle->timer_cb = <span class="hljs-literal">NULL</span>;
    handle->repeat = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_timer_init 函数和其他阶段的 init 函数一样，用于初始化 handle 的一些字段。接着看 start 函数，该函数是启动一个定时器（省略部分代码）。</p>
<pre><code class="hljs language-c"><span class="hljs-comment">// 启动一个计时器</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">uv_timer_start</span><span class="hljs-params">(<span class="hljs-type">uv_timer_t</span>* handle,
                   uv_timer_cb cb,
                   <span class="hljs-type">uint64_t</span> timeout,
                   <span class="hljs-type">uint64_t</span> repeat)</span> {
        <span class="hljs-type">uint64_t</span> clamped_timeout;
        <span class="hljs-comment">// 重新执行 start 的时候先把之前的停掉</span>
        <span class="hljs-keyword">if</span> (uv__is_active(handle))
            uv_timer_stop(handle);
        <span class="hljs-comment">// 超时时间，为绝对值</span>
        clamped_timeout = handle->loop->time + timeout;
        <span class="hljs-comment">// 初始化回调，超时时间，是否重复计时，赋予一个独立无二的 id</span>
        handle->timer_cb = cb;
        handle->timeout = clamped_timeout;
        handle->repeat = repeat;
        handle->start_id = handle->loop->timer_counter++;
        <span class="hljs-comment">// 插入最小堆</span>
        heap_insert(timer_heap(handle->loop), (<span class="hljs-keyword">struct</span> heap_node) &#x26;handle->heap_node, timer_less_than);
        <span class="hljs-comment">// 激活该 handle</span>
        uv__handle_start(handle);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_timer_start 函数首先初始化 handle 里的某些字段，包括超时回调，是否重复启动定时器，超时的绝对时间等，接着把 handle 节点插入到最小堆中，heap_insert 会根据该节点的超时时间动态调整最小堆，最后给这个 handle 打上标记，并激活这个handle。在 timer 阶段时就会判断有没有定时器超时，有则执行回调。</p>
<pre><code class="hljs language-c"><span class="hljs-comment">// 找出已经超时的节点，并且执行里面的回调</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">uv__run_timers</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop)</span> {
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heap_node</span>* <span class="hljs-title">heap_node</span>;</span>
    <span class="hljs-type">uv_timer_t</span>* handle;
    <span class="hljs-keyword">for</span> (;;) {
        heap_node = heap_min(timer_heap(loop));
        <span class="hljs-keyword">if</span> (heap_node == <span class="hljs-literal">NULL</span>)
            <span class="hljs-keyword">break</span>;
        handle = container_of(heap_node, <span class="hljs-type">uv_timer_t</span>, heap_node);
        <span class="hljs-comment">// 如果当前节点的时间大于当前时间则返回，说明后面的节点也没有超时</span>
        <span class="hljs-keyword">if</span> (handle->timeout > loop->time)
            <span class="hljs-keyword">break</span>;
        <span class="hljs-comment">// 移除该计时器节点</span>
        uv_timer_stop(handle);
        <span class="hljs-comment">// 如果设置了 repeat 则重新插入最小堆，等待下次超时</span>
        uv_timer_again(handle);
        <span class="hljs-comment">// 执行超时回调</span>
        handle->timer_cb(handle);
    }
}
</code></pre>
<p>uv__run_timers 函数的逻辑很明了，就是遍历最小堆，找出当前超时的节点。因为最小堆的性质是父节点肯定比孩子小。所以如果找到一个节点，它没有超时，则后面的节点也不会超时。对于超时的节点就执行它的回调。执行完回调后，还有两个关键的操作：第一是 uv_timer_stop；第二是 uv_timer_again。</p>
<pre><code class="hljs language-c"><span class="hljs-comment">// 停止一个计时器</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">uv_timer_stop</span><span class="hljs-params">(<span class="hljs-type">uv_timer_t</span>* handle)</span> {
    <span class="hljs-keyword">if</span> (!uv__is_active(handle))
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 从最小堆中移除该计时器节点</span>
    heap_remove(timer_heap(handle->loop), (<span class="hljs-keyword">struct</span> heap_node*) &#x26;handle->heap_node, timer_less_than);
    <span class="hljs-comment">// 清除激活状态和 handle 的 active 数减一</span>
    uv__handle_stop(handle);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_timer_stop 的逻辑很简单，就是把 handle 从二叉堆中删除。uv_timer_again 则是为了支持 setInterval 这种场景。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_timer_again</span><span class="hljs-params">(<span class="hljs-type">uv_timer_t</span>* handle)</span> {
    <span class="hljs-comment">// 如果设置了 repeat 标记说明计时器是需要重复触发的</span>
    <span class="hljs-keyword">if</span> (handle->repeat) {
        <span class="hljs-comment">// 先把旧的计时器节点从最小堆中移除，然后再重新开启一个计时器</span>
        uv_timer_stop(handle);
        uv_timer_start(handle, handle->timer_cb, handle->repeat, handle->repeat);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>如果 handle 设置了 repeat 标记，则在该 handle 第一次超时后，每隔 repeat 毫秒就会继续执行超时回调。这就是 Node.js 里定时器的底层原理，但 Node.js 并不是每次调 setTimeout 的时候都往最小堆插入一个节点，因为这样会引起 JS 层和 C、C++ 层频繁通信，导致性能损毁。因此在 Node.js 里，只有一个关于 uv_timer_s 的 handle，它在 JS 层维护了一个数据结构，每次计算出最快到期节点的时间，然后修改 Libuv handle 的超时时间。</p>
<p>timer 阶段是依赖事件驱动模块实现的，因为事件驱动模块可能会引起线程阻塞，为了保证线程可以按时执行定时器的回调，事件驱动模块会定时阻塞，阻塞的时长就是最快到期的定时器节点的时长，下面 Poll IO 阶段会详细介绍。</p>
<h2>Poll IO 阶段</h2>
<p>Poll IO 是 Libuv 最重要的一个阶段，可以说 Libuv 的驱动引擎。网络 IO、线程池完成任务、信号处理等回调都是在这个阶段处理的，所以这也是<strong>最复杂的一个阶段</strong>。这个阶段本质上是对各个操作系统事件驱动模块的封装，比如 Linux 的 epoll 和 MacOS 的 kqueue 等，这部分的技术也是大多数软件中用到的，所以也很通用。开始分析这个阶段之前，我们先了解一下 Poll IO 阶段最重要的数据结构 IO 观察者。</p>
<p><strong>IO</strong> <strong>观察者</strong></p>
<p>IO 观察者是 Libuv 中的核心数据结构，本质上是封装了文件<strong>描述符、感兴趣的事件和回调</strong>的结构体。那它是如何作用于事件驱动模块的呢，我们下面详细分析。</p>
<pre><code class="hljs language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uv__io_s</span> {</span>
    <span class="hljs-comment">// 事件触发后的回调</span>
    uv__io_cb cb;
    <span class="hljs-comment">// 用于插入队列</span>
    <span class="hljs-type">void</span>* pending_queue[<span class="hljs-number">2</span>];
    <span class="hljs-type">void</span>* watcher_queue[<span class="hljs-number">2</span>];
    <span class="hljs-comment">// 保存当前感兴趣的事件，还没有同步的操作系统。每次设置时首先保存事件在这个字段，然后 Poll IO 阶段再操作事件驱动模块更新到操作系统</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pevents; 
    <span class="hljs-comment">// 保存更新到操作系统的事件，每次 Poll IO 阶段更新 pevents 的值到操作系统后就把 pevents 同步到 events</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> events;
    <span class="hljs-comment">// 标记对哪个文件描述符的事件感兴趣</span>
    <span class="hljs-type">int</span> fd;
};
</code></pre>
<p>Libuv 会维护一个 IO 观察者队列，根据 IO 观察者描述的信息，在Poll IO 阶段往底层的事件驱动模块注册相应的信息。当注册的事件触发时，IO 观察者的回调就会被执行。接下来看看 IO 观察者的一些操作。</p>
<h3><strong>初始化</strong> <strong>IO</strong> <strong>观察者</strong></h3>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv__io_init</span><span class="hljs-params">(<span class="hljs-type">uv__io_t</span>* w, uv__io_cb cb, <span class="hljs-type">int</span> fd)</span> {  
    <span class="hljs-comment">// 初始化队列，回调，需要监听的 fd  </span>
    QUEUE_INIT(&#x26;w->pending_queue);  
    QUEUE_INIT(&#x26;w->watcher_queue);  
    w->cb = cb;  
    w->fd = fd;  
    w->events = <span class="hljs-number">0</span>;  
    w->pevents = <span class="hljs-number">0</span>;  
}  
</code></pre>
<p>pevents 表示应用当前感兴趣的事件，events 字段表示当前设置到操作系统的事件，因为应用设置感兴趣时是直接修改 pevents 的，但是这个信息并不会实时同步到操作系统，而是在 Poll IO 阶段才进行同步，所以需要两个字段记录，后面我们会看到它们具体的作用。</p>
<h3><strong>注册事件</strong></h3>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv__io_start</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv__io_t</span>* w, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> events)</span> {  
    <span class="hljs-comment">// 设置当前感兴趣的事件，但还没有同步到操作系统，等到 Poll IO 阶段再同步  </span>
    w->pevents |= events;  
    <span class="hljs-comment">// 扩容 loop->watchers，如果需要的话</span>
    maybe_resize(loop, w->fd + <span class="hljs-number">1</span>); 
    <span class="hljs-comment">// 事件没有变化则直接返回 </span>
    <span class="hljs-keyword">if</span> (w->events == w->pevents)  
        <span class="hljs-keyword">return</span>;  
    <span class="hljs-comment">// IO 观察者如果还没插入队列则插入 IO 观察者队列，等待 Poll IO 阶段的处理  </span>
    <span class="hljs-keyword">if</span> (QUEUE_EMPTY(&#x26;w->watcher_queue))  
        QUEUE_INSERT_TAIL(&#x26;loop->watcher_queue, &#x26;w->watcher_queue);  
    <span class="hljs-comment">// 保存映射关系，事件触发时通过 fd 获取对应的 IO 观察者，见 Poll IO 阶段的处理逻辑</span>
    <span class="hljs-keyword">if</span> (loop->watchers[w->fd] == <span class="hljs-literal">NULL</span>) {  
        loop->watchers[w->fd] = w;  
        loop->nfds++;  
    }  
}  
</code></pre>
<p>uv__io_start 函数的逻辑主要如下。</p>
<ol>
<li>保存当前感兴趣的事情，但是还没有同步到操作系统。</li>
</ol>

<ol start="2">
<li>把一个 IO 观察者插入到事件循环的观察者队列中，然后 Libuv 在 Poll IO 阶段会处理这个队列的数据，比如注册到操作系统中。</li>
</ol>

<ol start="3">
<li>在 watchers 数组中保存一个映射关系，当从事件驱动模块返回时，Libuv 会根据拿到的 fd 从 watchers 中找到对应的 IO 观察者，从而执行回调，具体逻辑可参考下面的内容。</li>
</ol>
<h3><strong>注销事件</strong></h3>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv__io_stop</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv__io_t</span>* w, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> events)</span> {
  <span class="hljs-comment">// 清除不感兴趣的事件</span>
  w->pevents &#x26;= ~events;
  <span class="hljs-comment">/* 
      如果对任何事件都不感兴趣了，则把 loop->watchers[w->fd] 置 NULL，Poll IO 阶段会用到。
      如果还有感兴趣的事件
          并且还没有在 IO 观察者队列，则插入，等待 Poll IO阶段修改操作系统数据。
          已经插入 IO 观察者队列了，则等待 Poll IO 阶段修改操作系统数据即可
  */</span>
  <span class="hljs-keyword">if</span> (w->pevents == <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// 移出 IO 观察者队列</span>
    QUEUE_REMOVE(&#x26;w->watcher_queue);
    QUEUE_INIT(&#x26;w->watcher_queue);
    w->events = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 置空，但是不会修改操作系统的数据，所以之前感兴趣的事件还是可能触发，</span>
    <span class="hljs-comment">// Poll IO 阶段 需要通过 loop->watchers[w->fd] 为 NULL 进行过滤</span>
    <span class="hljs-keyword">if</span> (w == loop->watchers[w->fd]) {
      loop->watchers[w->fd] = <span class="hljs-literal">NULL</span>;
      loop->nfds--;
    }
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (QUEUE_EMPTY(&#x26;w->watcher_queue))
    QUEUE_INSERT_TAIL(&#x26;loop->watcher_queue, &#x26;w->watcher_queue);
}
</code></pre>
<p>uv__io_stop 用于修改 IO 观察者感兴趣的事件，主要逻辑如下。</p>
<ol>
<li>修改当前感兴趣的事件，但是还没有同步到操作系统。</li>
</ol>

<ol start="2">
<li>如果还有感兴趣的事件并且 IO 观察者还没有插入 IO 观察者队列，则插入队列，否则不需要操作，因为修改的事件会在 Poll IO 阶段同步到操作系统，只需要保证 IO 观察者在队列里就行。</li>
</ol>

<ol start="3">
<li>如果当前没有感兴趣的事件，则需要移出 IO 观察者队列，并删除 fd 到 IO 观察者的映射关系，但是不会实时地从事件驱动模块中注销这个 fd 的事件，因为 uv__io_stop 的语义是注销事件，后续还可以通过 uv__io_start 重新注册事件，所以实现上选择了先不注销事件驱动模块中的 fd 事件，减少一次系统调用，如果后续没有调用 uv__io_start，而又有事件触发时，Libuv 才会真正注销事件驱动中该 fd 对应的事件。</li>
</ol>
<p>另外需要注意的是，当调用 uv__io_stop 注销事件时，注销的事件可能已经触发，比如在回调 1 里注销了回调 2 的事件，所以在 Poll IO 阶段时需要根据 pevents 进行判断，过滤已经被注销的事件，也就是说不需要执行相应的回调了。</p>
<h3><strong>关闭</strong> <strong>IO</strong> <strong>观察者</strong></h3>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv__io_close</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv__io_t</span>* w)</span> {
  <span class="hljs-comment">// 注销事件</span>
  uv__io_stop(loop, w, POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI);
  <span class="hljs-comment">// 移出 pending 队列，如果在的话</span>
  QUEUE_REMOVE(&#x26;w->pending_queue);
  <span class="hljs-comment">// 从操作系</span>
  <span class="hljs-keyword">if</span> (w->fd != <span class="hljs-number">-1</span>)
    uv__platform_invalidate_fd(loop, w->fd);
}
</code></pre>
<p>uv__io_close 首先调用了 uv__io_stop 注销所有事件，然后调用 uv__platform_invalidate_fd。</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv__platform_invalidate_fd</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">int</span> fd)</span> {
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span>* <span class="hljs-title">events</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">dummy</span>;</span>
    <span class="hljs-type">uintptr_t</span> i;
    <span class="hljs-type">uintptr_t</span> nfds;
    <span class="hljs-comment">// events 和 nfds 为本轮 Poll IO 阶段返回的，代表触发的事件和个数</span>
    events = (<span class="hljs-keyword">struct</span> epoll_event*) loop->watchers[loop->nwatchers];
    nfds = (<span class="hljs-type">uintptr_t</span>) loop->watchers[loop->nwatchers + <span class="hljs-number">1</span>];
    <span class="hljs-comment">// 修改对应的结构体的 fd 为 -1</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &#x3C; nfds; i++)
      <span class="hljs-keyword">if</span> (events[i].data.fd == fd)
        events[i].data.fd = <span class="hljs-number">-1</span>;

    <span class="hljs-built_in">memset</span>(&#x26;dummy, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(dummy));
    <span class="hljs-comment">// 从事件驱动模块注销 fd</span>
    epoll_ctl(loop->backend_fd, EPOLL_CTL_DEL, fd, &#x26;dummy);
}
</code></pre>
<p>uv__platform_invalidate_fd 会修改 Poll IO 阶段返回的事件结构体的 fd 为 -1。接着从事件驱动模块注销这个 fd 感兴趣的所有事件，这两步都是必要的，因为删除操作系统中感兴趣的事件只能保证后面不会触发，但是这个事件可能已经在本轮 Poll IO 阶段中触发，并等待处理，比如回调 1 里关闭了回调 2 的 IO 观察者，所以 Poll IO 阶段需要根据 fd 是否为 -1 进行过滤。</p>
<p>和 uv__io_stop 不一样的是，uv__io_close 会实时注销事件驱动模块中该 fd 对应的事件，因为 uv__io_close 的语义是这个 IO 观察者不会再被使用了，并且通常调用 uv__io_close 后 Libuv 会马上关闭 fd，如果这时候不实时地调用事件驱动模块注销该 fd 的事件，那就没有机会注销了。我们可以看看操作系统的代码：</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">do_epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *epds, <span class="hljs-type">bool</span> nonblock)</span>
{
    <span class="hljs-type">int</span> error;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span>
    error = -EBADF;
    <span class="hljs-comment">// 通过 fd 获取对应的结构体，已经关闭的 fd 则不会有对应的结构体</span>
    tf = fdget(fd);
    <span class="hljs-keyword">if</span> (!tf.file)
        <span class="hljs-keyword">goto</span> error_fput;
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>可以看到，当我们调用事件驱动模块注销一个 fd 的事件时，如果这个 fd 已经被关闭，则会报错，所以 uv__io_close 需要在 fd 关闭之前注销 fd 的事件。</p>
<p>了解了 IO 观察者后，下面我们开始分析 Poll IO 阶段，Poll IO 具体处理逻辑在 uv__io_poll 这个函数。这个函数比较复杂，我们分开分析。</p>
<h3><strong>处理</strong> <strong>IO</strong> <strong>观察者注册事件</strong></h3>
<p>应用订阅的事件会首先保存到 IO 观察者中，然后在 Poll IO 阶段被处理，而不是在订阅时就实时处理，尽可能避免过多系统调用。</p>
<pre><code class="hljs language-c"><span class="hljs-type">uv__io_t</span>* w;
<span class="hljs-comment">// 遍历 IO 观察者队列</span>
<span class="hljs-keyword">while</span> (!QUEUE_EMPTY(&#x26;loop->watcher_queue)) {
    <span class="hljs-comment">// 取出当前头节点</span>
    q = QUEUE_HEAD(&#x26;loop->watcher_queue);
    <span class="hljs-comment">// 移出队列</span>
    QUEUE_REMOVE(q);
    <span class="hljs-comment">// 重置节点的前后指针</span>
    QUEUE_INIT(q);
    <span class="hljs-comment">// 通过结构体成功获取结构体首地址</span>
    w = QUEUE_DATA(q, <span class="hljs-type">uv__io_t</span>, watcher_queue);
    <span class="hljs-comment">// 设置当前感兴趣的事件</span>
    e.events = w->pevents;
    <span class="hljs-comment">// 记录 fd，事件触发后再通过 fd 从 loop->watchs 字段里找到对应的 IO 观察者</span>
    e.data.fd = w->fd;
    <span class="hljs-comment">// w->events 为 0 ，则新增，否则修改</span>
    <span class="hljs-keyword">if</span> (w->events == <span class="hljs-number">0</span>)
        op = EPOLL_CTL_ADD;
    <span class="hljs-keyword">else</span>
        op = EPOLL_CTL_MOD;
    <span class="hljs-comment">// 修改 epoll 的数据</span>
    epoll_ctl(loop->backend_fd, op, w->fd, &#x26;e);
    <span class="hljs-comment">// 记录当前最新的状态</span>
    w->events = w->pevents;
}
</code></pre>
<p>第一步首先遍历 IO 观察者，修改 epoll 的数据，即注册 fd 感兴趣的事件，epoll 需要针对每个 IO 观察者调用一次系统调用 epoll_ctl，相比来说 kqueue 支持批量操作。</p>
<pre><code class="hljs language-c">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kevent</span> <span class="hljs-title">events</span>[1024];</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kevent</span>* <span class="hljs-title">ev</span>;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">spec</span>;</span>
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nevents;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> revents;
  QUEUE* q;
  <span class="hljs-type">uv__io_t</span>* w;

  nevents = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">while</span> (!QUEUE_EMPTY(&#x26;loop->watcher_queue)) {
    q = QUEUE_HEAD(&#x26;loop->watcher_queue);
    QUEUE_REMOVE(q);
    QUEUE_INIT(q);

    w = QUEUE_DATA(q, <span class="hljs-type">uv__io_t</span>, watcher_queue);
    <span class="hljs-comment">// 之前没有设置 POLLIN，但现在设置 POLLIN，则通知操作系统</span>
    <span class="hljs-keyword">if</span> ((w->events &#x26; POLLIN) == <span class="hljs-number">0</span> &#x26;&#x26; (w->pevents &#x26; POLLIN) != <span class="hljs-number">0</span>) {
      filter = EVFILT_READ;
      fflags = <span class="hljs-number">0</span>;
      op = EV_ADD;
      <span class="hljs-comment">// 把字段的值设置到第 n 个 kevent 结构体</span>
      EV_SET(events + nevents, w->fd, filter, op, fflags, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
      <span class="hljs-comment">// 如果还没到 1024 个则继续操作，到 1024 个后调用系统调用函数 kevent 进行批量操作</span>
      <span class="hljs-keyword">if</span> (++nevents == ARRAY_SIZE(events)) {
        <span class="hljs-keyword">if</span> (kevent(loop->backend_fd, events, nevents, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>))
          <span class="hljs-built_in">abort</span>();
        <span class="hljs-comment">// 重置索引</span>
        nevents = <span class="hljs-number">0</span>;
      }
    }
    <span class="hljs-comment">// 省略部分代码</span>
  }
</code></pre>
<p>可以看到 kqueue 可以累积多个 IO 观察者的事件进行批量设置，这样可以减少系统调用的次数，一定程度提高性能。接着看处理完 IO 观察者后的逻辑。</p>
<h3><strong>等待事件触发或超时</strong></h3>
<pre><code class="hljs language-c"><span class="hljs-comment">// 阻塞等待事件或超时，events 保存就绪的事件，nfds 保存就绪的事件个数</span>
<span class="hljs-type">int</span> nfds = epoll_wait(loop->backend_fd, events, ARRAY_SIZE(events),  timeout);
</code></pre>
<p>epoll_wait 用于阻塞等待事件的触发，这就是前面提到的阻塞 / 唤醒机制的实现。epoll_wait 除了在事件触发时返回，还支持超时的概念，也就是如果超过一定的时间还没有事件触发，则返回。阻塞时间的计算规则如下：</p>
<ol>
<li>0 代表不阻塞；</li>
</ol>

<ol start="2">
<li>> 0 代表最多阻塞一段时间；</li>
</ol>

<ol start="3">
<li>&#x3C; 0 代表一直阻塞，直到有事件发生。</li>
</ol>
<p>Libuv 中，这个超时时间由 uv_backend_timeout 实现。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_backend_timeout</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uv_loop_t</span>* loop)</span> {
    <span class="hljs-comment">// 下面几种情况下返回 0 ，即不阻塞在epoll_wait</span>
    <span class="hljs-keyword">if</span> (loop->stop_flag != <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 没有事件需要处理，则不需要阻塞 poll io 阶段</span>
    <span class="hljs-keyword">if</span> (!uv__has_active_handles(loop) &#x26;&#x26; !uv__has_active_reqs(loop))
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">// idle 阶段有任务，不阻塞，尽快返回处理 idle 任务</span>
    <span class="hljs-keyword">if</span> (!QUEUE_EMPTY(&#x26;loop->idle_handles))
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 同上</span>
    <span class="hljs-keyword">if</span> (!QUEUE_EMPTY(&#x26;loop->pending_queue))
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 同上</span>
    <span class="hljs-keyword">if</span> (loop->closing_handles)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 返回下一个最早过期的时间，即最早超时的节点</span>
    <span class="hljs-keyword">return</span> uv__next_timeout(loop);
}
</code></pre>
<p>从 uv_backend_timeout 中可以知道，Libuv 的各个阶段中，只有 prepare 和 check 阶段的任务不会影响 Poll IO 阶段的超时时间的计算。回到 uv_backend_timeout，除了返回 0 的情况外，剩下的就是计算最快超时的节点的时间，以此作为事件循环阻塞的最长时间，因为 Libuv 需要保证定时器按时执行。下面看看定时器的计算逻辑。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv__next_timeout</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uv_loop_t</span>* loop)</span> {
  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heap_node</span>* <span class="hljs-title">heap_node</span>;</span>
  <span class="hljs-type">const</span> <span class="hljs-type">uv_timer_t</span>* handle;
  <span class="hljs-type">uint64_t</span> diff;
  heap_node = heap_min(timer_heap(loop));
  <span class="hljs-comment">// 没有定时器则事件循环一直阻塞</span>
  <span class="hljs-keyword">if</span> (heap_node == <span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  handle = container_of(heap_node, <span class="hljs-type">uv_timer_t</span>, heap_node);
  <span class="hljs-comment">// 已经超时的节点会被 timer 阶段执行，这里不太可能出现</span>
  <span class="hljs-keyword">if</span> (handle->timeout &#x3C;= loop->time)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 计算最快超时的节点还需要多久超时，以此作为事件循环的最长阻塞时间</span>
  diff = handle->timeout - loop->time;
  <span class="hljs-keyword">if</span> (diff > INT_MAX)
    diff = INT_MAX;
  <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) diff;
}
</code></pre>
<p>uv__next_timeout 判断是否有定时器，有则返回最快到期节点的时间。</p>
<p><strong>处理触发的事件</strong></p>
<p>从上面的分析中可知， epoll_wait 返回时，可能是超时，也可能是有事件触发，具体需要根据 epoll_wait 的返回值判断，epoll_wait 返回值表示有多少个 fd 的事件触发了。</p>
<pre><code class="hljs language-ini">/*
    epoll_wait 可能会引起主线程阻塞，具体要根据 Libuv 当前的情况。所以
    wait 返回后需要更新当前的时间，否则在使用的时候时间差会比较大。因为
    Libuv 会在每轮时间循环开始的时候缓存当前时间这个值。其他地方直接使用，
    而不是每次都去获取。
*/
uv__update_time(loop)<span class="hljs-comment">;</span>
// 遍历有事件触发的 fd
for (<span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; nfds; i++) {</span>
    // 哪个 fd 触发了什么事情
    <span class="hljs-attr">pe</span> = events + i<span class="hljs-comment">;</span>
    <span class="hljs-attr">fd</span> = pe->data.fd<span class="hljs-comment">;</span>
    // 根据 fd 获取 IO 观察者
    <span class="hljs-attr">w</span> = loop->watchers[fd]<span class="hljs-comment">;</span>
    // 执行回调
    if (pe->events != 0) {
        w->cb(loop, w, pe->events)<span class="hljs-comment">;</span>
    }
}
</code></pre>
<p>通过 epoll_wait 返回的事件和个数，从根据事件结构体找到关联的 IO 观察者，然后执行对应回调即可。</p>
<h3><strong>删除事件的处理</strong></h3>
<p>刚才介绍的是事件注册到事件触发和处理的过程，还有一个重要的事情需要处理，那就是过滤掉已经注销的事件。这个事情的重点在于，如果之前订阅的事件触发了，但目前又不感兴趣了，应该如何处理这种过期的事件，这个过期事件可能来源于 Libuv 还没有同步最新的数据到操作系统，也可能来源于前面的回调删除了后面回调的事件或 IO 观察者，比如在回调 1 里注销了回调 2 的事件，那么就不需要执行回调 2 了。接下来看如何实现对这些情况的判断。</p>
<pre><code class="hljs language-c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &#x3C; nfds; i++) {
    pe = events + i;
    fd = pe->data.fd;
    <span class="hljs-comment">// fd 无效则不需要处理了（调用了 uv__io_close）</span>
    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)
        <span class="hljs-keyword">continue</span>;
    <span class="hljs-comment">// IO 观察者已经被删除则不需要执行回调了（调用了 uv__io_stop），并且删除操作系统的数据</span>
    w = loop->watchers[fd];
    <span class="hljs-keyword">if</span> (w == <span class="hljs-literal">NULL</span>) {
        epoll_ctl(loop->backend_fd, EPOLL_CTL_DEL, fd, pe);
        <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-comment">// 和当前感兴趣的事件 w->pevents 进行 &#x26; 操作，保证剩下的事件 pe->events 已经触发且感兴趣的</span>
    pe->events &#x26;= w->pevents | POLLERR | POLLHUP;
    <span class="hljs-keyword">if</span> (pe->events != <span class="hljs-number">0</span>) {
        w->cb(loop, w, pe->events);
    }
}
</code></pre>
<p>从上面代码中可以看到，Libuv 会根据 uv__io_stop 和 uv__io_close 设置的各种标记进行过滤，避免处理过期的事件。下面是 Poll IO 阶段的整体流程图。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fed18550e7894797b812088845b1a246~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>总结</h2>
<p>事件循环是一个非常通用的技术，简单来说就是在一个循环中不断地处理生产者产生的任务。这节课我们介绍了事件循环的概念，然后按照简单到复杂的顺序，梳理了事件循环各个执行阶段的具体实现，可以清晰地了解到 Node.js 中哪些任务是在哪个阶段被执行的。</p>
<p>其中，Poll IO 阶段是<strong>最重要也是最复杂</strong>的一个阶段， Node.js 的网络 IO、线程池完成任务、信号处理等回调都是在这个阶段处理的。因此，我们要重点学习它，具体有以下几点。</p>
<ul>
<li>事件驱动是操作系统提供的一种订阅 / 发布机制，由 IO 多路复用模块实现，且不同操作系统中提供的系统调用不一样，我们需要了解它的工作原理和使用方式。</li>
</ul>

<ul>
<li>IO 观察者是 Poll IO 阶段最重要的数据结构，它本质上是封装了 fd、感兴趣的事件和回调函数。结合事件驱动模块，就可以实现对 fd 的处理，例如网络数据的读写。</li>
</ul>
<p>希望大家看完本节课内容后，对 Libuv 的事件循环有更深刻的理解，同时对事件循环概念和对如何实现一个事件循环也有更多的认识。</p></div>
</body></html>