<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Node.js 中 HTTP 模块的实现和使用</h1>
<p>HTTP 模块是大部分开发者使用得最多的模块，但是在使用过程中，大家有没有用想过它是如何实现的呢？比如有没有想过一个 HTTP 服务器是怎么实现的呢？一个 HTTP 解析器又是如何实现的呢？这节课我们就来学习一下 HTTP 协议的知识、HTTP 解析器的使用和 Node.js 的 HTTP 模块的实现。</p>
<p>通过 HTTP 模块我们不仅可以了解 Node.js 中 HTTP 模块的实现和使用原理，而且还会加深我们对 HTTP 协议本身的学习，比如 Connect 原理、协议升级等。</p>
<h1>HTTP 协议</h1>
<p>HTTP 协议是一种基于客户端 / 服务器架构的无状态的应用层协议。这一概念里有 3 个关键词，我们看看具体的解释：</p>
<ol>
<li>客户端 / 服务器架构：客户端主动发起请求，服务器被动响应。</li>
<li>无状态：每个请求都会被单独解析，处理，没有依赖关系。</li>
<li>应用层协议：底层可以基于 TCP、UDP 和 Unix 域等。</li>
</ol>
<p>讲完 HTTP 协议的概念，我们再接着来看 HTTP 的请求 / 响应是如何定义的。了解了请求和响应的定义，我们就会对 HTTP 协议的工作流程有更清晰的了解。</p>
<p><strong>请求报文</strong></p>
<p>HTTP 是基于请求 / 响应格式的，首先看一下 HTTP 请求报文的格式，如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a74bf760ade24eb99e2398cf4f1a268e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>请求报文分为请求行，请求头和请求体 3 个部分，它们是如下这么定义的。</p>
<ol>
<li>请求行分为请求方法（GET、POST 等）、请求 URL和协议版本（比如 HTTP / 1.1）。</li>
<li>请求头包括多个键值对，用于传递请求的信息，比如 cookie。</li>
<li>请求体用于传递额外的业务数据，通常用于 POST、PUT 请求方法，如果请求体是已知的大小时，可以通过请求头 content-length 表示请求体的内容大小，这样服务器收到请求时就会根据 content-length 读取对应字节数的数据，如下图所示。</li>
</ol>
<pre><code class="hljs language-makefile">POST / HTTP/1.1
<span class="hljs-section">Host: localhost:8888</span>
<span class="hljs-section">Connection: close</span>
<span class="hljs-section">Content-Length: 18</span>

<span class="hljs-section">{"hello":"world2"}</span>
</code></pre>
<p>如果请求体是未知大小的，需要动态计算，则可以通过设置请求头 Transfer-Encoding: chunked，然后在请求体中按照 chunk 大小 + chunk 内容的方式传输动态的数据，示例如下。</p>
<pre><code class="hljs language-vbnet">POST / HTTP/<span class="hljs-number">1.1</span>
<span class="hljs-symbol">Host:</span> localhost:<span class="hljs-number">8888</span>
<span class="hljs-symbol">Connection:</span> close
Transfer-Encoding: chunked

<span class="hljs-number">11</span>
{<span class="hljs-string">"hello"</span>:<span class="hljs-string">"world"</span>}
<span class="hljs-number">12</span>
{<span class="hljs-string">"hello"</span>:<span class="hljs-string">"world2"</span>}
<span class="hljs-number">0</span>\r\n\r\n
</code></pre>
<p><strong>响应报文</strong></p>
<p>响应报文和请求报文类似，包括响应行、响应头和响应体。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d12f4b8ecea44ac9d90f3157d20ff27~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<ol>
<li>响应行包括协议版本（比如 HTTP / 1.1）、响应状态码（表示请求结果）和响应状态码描述（描述请求结果）。</li>
<li>响应头和请求头类似，是一系列的键对值。</li>
<li>响应体是服务器返回给客户的的数据，有些请求方法是没有响应体的，比如 head 方法。和请求类似，响应体中的数据也是可以通过 content-length 告诉客户端返回的数据大小。</li>
</ol>
<pre><code class="hljs language-yaml"><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span>
<span class="hljs-attr">Date:</span> <span class="hljs-string">Fri,</span> <span class="hljs-number">06</span> <span class="hljs-string">Jan</span> <span class="hljs-number">2023 14:15:48 </span><span class="hljs-string">GMT</span>
<span class="hljs-attr">Connection:</span> <span class="hljs-string">close</span>
<span class="hljs-attr">Content-Length:</span> <span class="hljs-number">2</span>

<span class="hljs-string">ok</span>
</code></pre>
<p>同样，也可以使用 Transfer-Encoding: chunked 表示。</p>
<pre><code class="hljs language-yaml"><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span>
<span class="hljs-attr">Date:</span> <span class="hljs-string">Fri,</span> <span class="hljs-number">06</span> <span class="hljs-string">Jan</span> <span class="hljs-number">2023 14:14:03 </span><span class="hljs-string">GMT</span>
<span class="hljs-attr">Connection:</span> <span class="hljs-string">close</span>
<span class="hljs-attr">Transfer-Encoding:</span> <span class="hljs-string">chunked</span>

<span class="hljs-number">2</span>
<span class="hljs-string">ok</span>
<span class="hljs-number">2</span>
<span class="hljs-string">ok</span>
<span class="hljs-number">0</span><span class="hljs-string">\r\n\r\n</span>
</code></pre>
<h1>HTTP 解析器</h1>
<p>了解了 HTTP 协议后，我们来看一下 HTTP 协议解析器，这部分也很重要。因为对收到的数据，不管是客户端还是服务器都要按照 HTTP 协议规范解析出一个个请求和响应。Node.js 目前使用的解析器是 <a href="https://github.com/nodejs/llhttp" target="_blank" rel="nofollow noopener noreferrer">llhttp</a>，llhttp 是以钩子函数的方式工作的，它支持了很多类型的钩子，具体可以参考 <a href="https://github.com/nodejs/llhttp/blob/main/src/native/api.h" target="_blank" rel="nofollow noopener noreferrer">llhttp_settings_s</a>，它的使用方式如下。</p>
<ol>
<li>首先下载源码：git clone <a href="https://github.com/nodejs/llhttp%E3%80%82" target="_blank" rel="nofollow noopener noreferrer">https://github.com/nodejs/llhttp。</a></li>
<li>然后安装 npx 工具：npm i npx -g。</li>
<li>然后执行 ts 生成 C 代码： npm i &#x26;&#x26; npx ts-node bin/generate.ts，或者执行 make generate。</li>
<li>这时候 build 目录下生成了 llhttp.h 和 llhttp.c，再加上 native 下的 c 代码，就是 llhttp 的全部代码，我们可以把他复制到自己的项目中直接使用，也可以以静态库或动态库的方式使用，执行 make all 就会在 build 目录下生成静态和动态库，我们把头文件 llhttp.h 和静态库或动态库复制到自己项目里使用，编译的时候加上 -lllhttp -L. 即可（可以参考 <a href="https://github.com/theanarkh/llhttp-demo" target="_blank" rel="nofollow noopener noreferrer">llhttp-demo</a> 和 <a href="https://github.com/theanarkh/multi-thread-server" target="_blank" rel="nofollow noopener noreferrer">multi-thread-serve</a>）。</li>
</ol>
<p>完成了前面的步骤后，接着来看一下如何在代码里使用 llhttp，初始化解析器的时候，我们可以设置解析类型，是请求或响应报文，然后设置解析状态的回调，比如解析道 URL 时回调，解析到 header 时回调，然后收到数据时执行 llhttp_execute 解析，llhttp 就会触发不同的钩子，下面是解析请求报文的例子。</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;string.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"llhttp.h"</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LEN 2048</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">on_message_begin</span><span class="hljs-params">(<span class="hljs-type">llhttp_t</span>* parser)</span>
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"parse start\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">on_url</span><span class="hljs-params">(<span class="hljs-type">llhttp_t</span>* parser, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* at, <span class="hljs-type">size_t</span> length)</span>
{
    <span class="hljs-type">char</span> url[MAX_LEN];
    <span class="hljs-built_in">strncpy</span>(url, at, length);
    url[length] = <span class="hljs-string">'\0'</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"on_url: %s\n"</span>, url);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">on_header_field</span><span class="hljs-params">(<span class="hljs-type">llhttp_t</span>* parser, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* at, <span class="hljs-type">size_t</span> length)</span>
{
    <span class="hljs-type">char</span> header_field[MAX_LEN];
    <span class="hljs-built_in">strncpy</span>(header_field, at, length);
    header_field[length] = <span class="hljs-string">'\0'</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"head field: %s\n"</span>, header_field);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">on_header_value</span><span class="hljs-params">(<span class="hljs-type">llhttp_t</span>* parser, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* at, <span class="hljs-type">size_t</span> length)</span>
{
    <span class="hljs-type">char</span> header_value[MAX_LEN];
    <span class="hljs-built_in">strncpy</span>(header_value, at, length);
    header_value[length] = <span class="hljs-string">'\0'</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"head value: %s\n"</span>, header_value);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">on_headers_complete</span><span class="hljs-params">(<span class="hljs-type">llhttp_t</span>* parser)</span>
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"on_headers_complete, major: %d, major: %d, keep-alive: %d, upgrade: %d\n"</span>, parser->http_major, parser->http_minor, llhttp_should_keep_alive(parser), parser->upgrade);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">on_body</span><span class="hljs-params">(<span class="hljs-type">llhttp_t</span>* parser, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* at, <span class="hljs-type">size_t</span> length)</span>
{
    <span class="hljs-type">char</span> body[MAX_LEN];
    <span class="hljs-built_in">strncpy</span>(body, at, length);
    body[length] = <span class="hljs-string">'\0'</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"on_body: %s\n"</span>, body);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">on_message_complete</span><span class="hljs-params">(<span class="hljs-type">llhttp_t</span>* parser)</span>
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"on_message_complete\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">llhttp_t</span> parser;
    <span class="hljs-type">llhttp_settings_t</span> settings;
    llhttp_settings_init(&#x26;settings);
    llhttp_init(&#x26;parser, HTTP_REQUEST, &#x26;settings);

    settings.on_message_begin = on_message_begin;
    settings.on_url = on_url;
    settings.on_header_field = on_header_field;
    settings.on_header_value = on_header_value;
    settings.on_headers_complete = on_headers_complete;
    settings.on_body = on_body;
    settings.on_message_complete = on_message_complete;
    
    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* request = <span class="hljs-string">"POST /index.html HTTP/1.1\r\nconnection:close\r\ncontent-length: 1\r\n\r\n1\r\n\r\n"</span>;
    <span class="hljs-type">int</span> request_len = <span class="hljs-built_in">strlen</span>(request);

    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">llhttp_errno</span> <span class="hljs-title">err</span> =</span> llhttp_execute(&#x26;parser, request, request_len);
    <span class="hljs-keyword">if</span> (err != HPE_OK) {
       <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Parse error: %s %s\n"</span>, llhttp_errno_name(err), parser.reason);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>编译执行上面代码就会看到多个钩子函数的输出，这就是 llhttp 解析器的使用原理，Node.js 里也是这样使用的。</p>
<h1>HTTP服务器</h1>
<p>了解了 HTTP 协议，也知道了 HTTP 解析器的使用方式后，接着来看 HTTP 服务器是如何使用 HTTP 解析器处理请求的。下面是 Node.js 中创建服务器的例子。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">http</span> = require(<span class="hljs-string">'http'</span>)<span class="hljs-comment">;  </span>
http.createServer((req, res) => {  
  res.write('hello')<span class="hljs-comment">;  </span>
  res.end()<span class="hljs-comment">;  </span>
})  
.listen(3000)<span class="hljs-comment">;  </span>
</code></pre>
<p>我们沿着 createServer 开始分析。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createServer</span>(<span class="hljs-params">opts, requestListener</span>) {  
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(opts, requestListener);  
}  
</code></pre>
<p>createServer 中创建了一个 Server 对象，来看看 Server 初始化的逻辑。</p>
<pre><code class="hljs language-kotlin">function Server(options, requestListener) {  
  <span class="hljs-comment">// 可以自定义表示请求的对象和响应的对象  </span>
  <span class="hljs-keyword">this</span>[kIncomingMessage] = options.IncomingMessage || IncomingMessage;  
  <span class="hljs-keyword">this</span>[kServerResponse] = options.ServerResponse || ServerResponse;  
  <span class="hljs-comment">// HTTP 头最大字节数  </span>
  <span class="hljs-keyword">this</span>.maxHeaderSize = options.maxHeaderSize;  
  <span class="hljs-comment">// 允许半关闭  </span>
  net.Server.call(<span class="hljs-keyword">this</span>, { allowHalfOpen: <span class="hljs-literal">true</span> });  
  <span class="hljs-comment">// 有请求时的回调  </span>
  <span class="hljs-keyword">if</span> (requestListener) {  
    <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'request'</span>, requestListener);  
  }  
  <span class="hljs-comment">// 服务器 socket 读端关闭时是否允许继续处理队列里的响应（TCP 上有多个请求，管道化）  </span>
  <span class="hljs-keyword">this</span>.httpAllowHalfOpen = <span class="hljs-literal">false</span>;  
  <span class="hljs-comment">// 有连接时的回调，由 net 模块触发  </span>
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'connection'</span>, connectionListener);  
  <span class="hljs-comment">// 服务器下所有请求和响应的超时时间  </span>
  <span class="hljs-keyword">this</span>.timeout = <span class="hljs-number">0</span>;  
  <span class="hljs-comment">// 同一个 TCP 连接上，两个请求之前最多间隔的时间   </span>
  <span class="hljs-keyword">this</span>.keepAliveTimeout = <span class="hljs-number">5000</span>;  
  <span class="hljs-comment">// HTTP 头的最大个数</span>
  <span class="hljs-keyword">this</span>.maxHeadersCount = <span class="hljs-literal">null</span>;  
  <span class="hljs-comment">// 解析头部的最长时间，防止 ddos  </span>
  <span class="hljs-keyword">this</span>.headersTimeout = <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>; 
}  
</code></pre>
<p>Server 中主要做了一些字段的初始化，并且监听了 connection 和 request 两个事件，当有连接到来时会触发 connection 事件，connection 事件的处理函数会调用 HTTP 解析器进行数据的解析，当解析出一个 HTTP 请求时就会触发 request 事件通知用户。</p>
<p>创建了 Server 对象后，接着我们调用它的 listen 函数。因为 HTTP Server 继承于 net.Server，所以执行 HTTP Server 的 listen 函数时，其实是执行了 net.Serve 的 listen 函数，net.Server 的 listen 函数前面我们已经分析过，就不再分析。当有请求到来时，会触发 connection 事件，从而执行 connectionListener。</p>
<pre><code class="hljs language-ini">function connectionListener(socket) {  
  defaultTriggerAsyncIdScope(  
    getOrSetAsyncId(socket), connectionListenerInternal, this, socket  
  )<span class="hljs-comment">;  </span>
}  

// socket 表示新连接  
function connectionListenerInternal(server, socket) {  
  // socket 所属 server  
  <span class="hljs-attr">socket.server</span> = server<span class="hljs-comment">;  </span>
  // 分配一个 HTTP 解析器  
  const <span class="hljs-attr">parser</span> = parsers.alloc()<span class="hljs-comment">;  </span>
  // 初始化解析器
  parser.initialize(HTTPParser.REQUEST, ...)<span class="hljs-comment">;  </span>
  // 关联起来
  <span class="hljs-attr">parser.socket</span> = socket<span class="hljs-comment">;  </span>
  <span class="hljs-attr">socket.parser</span> = parser<span class="hljs-comment">;  </span>
  
  const <span class="hljs-attr">state</span> = {  
    onData: null,  
    // 同一 TCP 连接上，请求和响应的的队列，线头阻塞的原理  
    outgoing: <span class="hljs-section">[]</span>,  
    incoming: <span class="hljs-section">[]</span>,   
  }<span class="hljs-comment">;  </span>
  // 监听 TCP 上的数据，开始解析 HTTP 报文  
  <span class="hljs-attr">state.onData</span> = socketOnData.bind(undefined, 
                                   server, 
                                   socket, 
                                   parser, 
                                   state)<span class="hljs-comment">;  </span>
  socket.on('data', state.onData)<span class="hljs-comment">;</span>
  // 解析 HTTP 头部完成后执行的回调  
  <span class="hljs-attr">parser.onIncoming</span> = parserOnIncoming.bind(undefined, 
                                            server, 
                                            socket, 
                                            state)<span class="hljs-comment">;  </span>
  /*
    如果 handle 是继承 StreamBase 的流，则在 C++ 层解析 HTTP 请求报文，
    否则使用上面的 socketOnData 函数处理 HTTP 请求报文，
    TCP 模块的 isStreamBase 为 true 
  */
  if (socket._handle &#x26;&#x26; socket._handle.isStreamBase &#x26;&#x26;  
      !socket._handle._consumed) {  
    <span class="hljs-attr">parser._consumed</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;  </span>
    <span class="hljs-attr">socket._handle._consumed</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;  </span>
    parser.consume(socket._handle)<span class="hljs-comment">;  </span>
  }  
  // 执行 llhttp_execute 时的回调
  parser<span class="hljs-section">[kOnExecute]</span> = onParserExecute.bind(undefined, 
                                            server, 
                                            socket, 
                                            parser, 
                                            state)<span class="hljs-comment">;   </span>
}  
</code></pre>
<p>上面的 connectionListenerInternal 函数中首先分配了一个 HTTP 解析器，HTTP 解析器由以下代码管理。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">parsers</span> = new FreeList(<span class="hljs-string">'parsers'</span>, <span class="hljs-number">1000</span>, function parsersCb() {
  const <span class="hljs-attr">parser</span> = new HTTPParser()<span class="hljs-comment">;</span>

  cleanParser(parser)<span class="hljs-comment">;</span>

  <span class="hljs-attr">parser.onIncoming</span> = null<span class="hljs-comment">;</span>
  // 各种钩子毁掉
  parser<span class="hljs-section">[kOnHeaders]</span> = parserOnHeaders<span class="hljs-comment">;</span>
  parser<span class="hljs-section">[kOnHeadersComplete]</span> = parserOnHeadersComplete<span class="hljs-comment">;</span>
  parser<span class="hljs-section">[kOnBody]</span> = parserOnBody<span class="hljs-comment">;</span>
  parser<span class="hljs-section">[kOnMessageComplete]</span> = parserOnMessageComplete<span class="hljs-comment">;</span>

  return parser<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p>parsers 用于管理 HTTP 解析器，它负责分配 HTTP 解析器，并且在 HTTP 解析器不再使用时缓存起来给下次使用，而不是每次都创建一个新的解析器。分配完 HTTP 解析器后就开始等待 TCP 上数据的到来，即 HTTP 请求报文。但是这里有一个逻辑需要注意，上面代码中 Node.js 监听了 socket 的 data 事件，处理函数为 socketOnData，下面是 socketOnData 的逻辑。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">socketOnData</span>(<span class="hljs-params">server, socket, parser, state, d</span>) {  
  <span class="hljs-comment">// 交给 HTTP 解析器处理，返回已经解析的字节数  </span>
  <span class="hljs-keyword">const</span> ret = parser.<span class="hljs-title function_">execute</span>(d);  
}  
</code></pre>
<p>socketOnData 调用 HTTP 解析器处理数据，这看起来没什么问题，但是有一个逻辑我们可能会忽略掉，看一下下面的代码。</p>
<pre><code class="hljs language-scss">if (socket._handle &#x26;&#x26; socket._handle.isStreamBase) {  
    parser<span class="hljs-selector-class">.consume</span>(socket._handle);  
}  
</code></pre>
<p>上面代码中，如果 socket._handle.isStreamBase 为 true（TCP handle 的 isStreamBase 为 true），则会执行 parser.consume(socket._handle)，这个是做什么的呢？</p>
<pre><code class="hljs language-scss">static void <span class="hljs-built_in">Consume</span>(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {
    Parser* parser;
    <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;parser, args.Holder());
    <span class="hljs-comment">// 解析出 C++ TCPWrap 对象</span>
    StreamBase* stream = StreamBase::FromObject(args[<span class="hljs-number">0</span>].As&#x3C;Object>());
    <span class="hljs-comment">// 注册 parser 成为流的消费者，即 TCP 数据的消费者</span>
    stream-><span class="hljs-built_in">PushStreamListener</span>(parser);
}
</code></pre>
<p>Consume 会注册 parser 会成为流的消费者，这个逻辑会覆盖掉刚才的 onData 函数，使得所有的数据直接由 parser 处理，看一下当数据到来时，parser 是如何处理的。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">OnStreamRead</span>(ssize_t nread, const uv_buf_t&#x26; buf) override {  
    <span class="hljs-comment">// 解析 HTTP 协议</span>
    Local&#x3C;Value> ret = <span class="hljs-built_in">Execute</span>(buf.base, nread);  
    <span class="hljs-comment">// 执行 kOnExecute 回调</span>
    Local&#x3C;Value> cb = <span class="hljs-selector-tag">object</span>()-><span class="hljs-built_in">Get</span>(env()-><span class="hljs-built_in">context</span>(), kOnExecute)<span class="hljs-selector-class">.ToLocalChecked</span>();  
    <span class="hljs-built_in">MakeCallback</span>(cb.As&#x3C;Function>(), <span class="hljs-number">1</span>, &#x26;ret);  
}  
</code></pre>
<p>在 OnStreamRead 中会源源不断地把数据交给 HTTP 解析器处理并执行 kOnExecute 回调，并且在解析的过程中，会不断触发对应的钩子函数。比如解析到 HTTP 头部时执行 parserOnHeaders。</p>
<pre><code class="hljs language-kotlin">function parserOnHeaders(headers, url) {
  <span class="hljs-comment">// 记录解析到的 HTTP 头</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.maxHeaderPairs &#x3C;= <span class="hljs-number">0</span> ||
      <span class="hljs-keyword">this</span>._headers.length &#x3C; <span class="hljs-keyword">this</span>.maxHeaderPairs) {
    <span class="hljs-keyword">this</span>._headers = <span class="hljs-keyword">this</span>._headers.concat(headers);
  }
  <span class="hljs-keyword">this</span>._url += url;
}
</code></pre>
<p>parserOnHeaders 会记录解析到的 HTTP 头，当解析完 HTTP 头 时会调用 parserOnHeadersComplete。</p>
<pre><code class="hljs language-ini">function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
                                 url, statusCode, statusMessage, upgrade,
                                 shouldKeepAlive) {
  const <span class="hljs-attr">parser</span> = this<span class="hljs-comment">;</span>
  const { socket } = parser<span class="hljs-comment">;</span>
  // 创建一个对象表示收到的 HTTP 请求
  const <span class="hljs-attr">ParserIncomingMessage</span> = (socket &#x26;&#x26; socket.server &#x26;&#x26;
                                 socket.server<span class="hljs-section">[kIncomingMessage]</span>) ||
                                 IncomingMessage<span class="hljs-comment">;</span>
  // 新建一个IncomingMessage对象
  const <span class="hljs-attr">incoming</span> = parser.incoming = new ParserIncomingMessage(socket)<span class="hljs-comment">;</span>
  // 执行回调
  return parser.onIncoming(incoming, shouldKeepAlive)<span class="hljs-comment">;</span>
}
</code></pre>
<p>parserOnHeadersComplete 中创建了一个对象来表示收到的 HTTP 请求，接着执行 onIncoming 函数，对应的是 parserOnIncoming。</p>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">parserOnIncoming</span>(server, socket, state, req, keepAlive) {  

  <span class="hljs-comment">// 请求入队（待处理的请求队列）  </span>
  state<span class="hljs-selector-class">.incoming</span><span class="hljs-selector-class">.push</span>(req);  
  <span class="hljs-comment">// 新建一个表示响应的对象  </span>
  const res = new server<span class="hljs-selector-attr">[kServerResponse]</span>(req);  
  <span class="hljs-comment">/*
     socket 当前已经在处理其它请求的响应，则先排队，
     否则挂载响应对象到 socket，作为当前处理的响应  
  */</span>
  if (socket._httpMessage) {  
    state<span class="hljs-selector-class">.outgoing</span><span class="hljs-selector-class">.push</span>(res);  
  } else {  
    res<span class="hljs-selector-class">.assignSocket</span>(socket);  
  }  
  
  <span class="hljs-comment">// 响应处理完毕后，需要做一些处理  </span>
  res<span class="hljs-selector-class">.on</span>('finish', resOnFinish.bind(undefined, 
                                    req, 
                                    res, 
                                    socket, 
                                    state, 
                                    server));  
  <span class="hljs-comment">// 触发 request 事件说明有请求到来  </span>
  server<span class="hljs-selector-class">.emit</span>('request', req, res);  
}  
</code></pre>
<p>我们看到这里会触发 request 事件通知用户有新请求到来，并传入request和response作为参数，这样用户就可以处理请求了。另外 Node.js 本身是不会处理 HTTP 请求体的数据，当 Node.js 解析到请求体时会执行 kOnBody 钩子函数，对应的是 parserOnBody 函数。</p>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">parserOnBody</span>(b, start, len) {
  <span class="hljs-comment">// IncomingMessage 对象，即 request 对象</span>
  const stream = this<span class="hljs-selector-class">.incoming</span>;
  <span class="hljs-comment">// Pretend this was the result of a stream._read call.</span>
  if (len > <span class="hljs-number">0</span> &#x26;&#x26; !stream._dumped) {
    const slice = <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.slice</span>(start, start + len);
    const ret = stream<span class="hljs-selector-class">.push</span>(slice);
    if (!ret)
      <span class="hljs-built_in">readStop</span>(this.socket);
  }
}
</code></pre>
<p>parserOnBody 会把数据 push 到请求对象 request 中，接着 Node.js 会触发 data 事件，所以我们可以通过以下方式获取 body 的数据。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> server= http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =></span> {  
  request.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =></span> {  
   <span class="hljs-comment">// 处理body  </span>
  });  
  request.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {  
   <span class="hljs-comment">// body结束  </span>
  });  
})  
</code></pre>
<p>了解了 HTTP 服务器的实现后，接着来看一下 HTTP 服务器的一些常见的特性，包括管道化、HTTP Connect 方法的实现和协议升级。</p>
<h3>HTTP 管道化的原理和实现</h3>
<p>HTTP 协议已经经历了几个版本的演进，接下来我们看一下在不同的 HTTP 协议版本中，HTTP 的请求 / 响应模型，然后再具体讲解 Node.js 中的 HTTP 管道化的实现。</p>
<p><strong>HTTP 1.0</strong></p>
<p>HTTP 1.0 的时候，是不支持管道化的。请求响应模型为客户端发送一个请求前，首先建立 TCP 连接，然后服务器返回一个响应，最后断开 TCP 连接，这种是最简单的实现方式，但是每次发送请求都需要走三次握手显然会带来一定的时间损耗。</p>
<p><strong>HTTP 1.1</strong></p>
<p>HTTP 1.1 版本开始支持管道化的特性，管道化的意思就是可以在一个 TCP 连接上并发发送多个请求，这样服务器就可以同时处理多个请求，但是由于 HTTP 1.1 协议的限制，多个请求的响应需要按序返回。也就是说先发送的请求会先被响应，因为在 HTTP1.1 中，没有字段标记请求和响应的对应关系，所以 HTTP 客户端会假设第一个返回的响应是对应第一个请求的。如果乱序返回，就会导致请求响应不对应的问题，流程如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/844d1d7633c34288896ebd69284d76f2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>HTTP 2.0</strong></p>
<p>而到了 HTTP 2.0，多个请求不仅可以共享一个 TCP 连接同时发送多个请求，响应也可以不按序返回。因为 HTTP 2.0 实现了新的协议格式，每个请求对应一个 StreamId，响应时也会携带 StreamId 标识该响应所属的请求，这样就算乱序返回，HTTP 客户端也可以知道响应所对应的请求，流程如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a02dddf5ce3484c881057aa50ee15fa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>但是 HTTP 2.0 也存在一些问题，因为它还是基于 TCP 的，而 TCP 数据是按序发送的，前面的数据（响应 2）发送失败会导致后面的数据（响应 1）无法发送，如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/757196caae814eadb2ce624510e27e9d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>HTTP 3</strong> <strong>.0</strong></p>
<p>为了解决 TCP 协议本身的问题，HTTP 3.0 中使用了 UDP / QUIC 协议作为底层的传输协议，UDP 的数据可以随便发送，没有顺序的概念，比如上图中的响应 2 发送失败不会影响响应 1 的发送，然后 UDP 本身的缺点由 QUIC 协议解决，比如 UDP 不能保证数据的可靠传输。</p>
<p>了解了 HTTP 请求响应模型的发展后，我们来看一下 Node.js 的 HTTP 模块是如何实现 HTTP 1.1 的管道化的。实现管道化的重点是<strong>需要管理好请求和响应的顺序和关系</strong>。当服务器在一个连接上收到多个 HTTP 请求时，它可以以串行的方式进行处理，当前面请求的响应返回到客户端后，再继续处理下一个请求。这种实现方式相对简单，但明显比较低效。</p>
<p>其实还有另一种实现方式，就是<strong>并行处理请求串行返回</strong>，它可以让请求得到尽快处理，比如两个请求都访问数据库，那并行处理两个请求肯定会比串行快得多。但这种实现方式相对比较复杂，而 Node.js 就采用了这种方式。下面我们来看一下 Node.js 中是如何实现的。</p>
<p>前面分析过，Node.js 在解析完 HTTP 头部的时候会执行 parserOnIncoming。</p>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">parserOnIncoming</span>(server, socket, state, req, keepAlive) {  
  <span class="hljs-comment">// 请求入队  </span>
  state<span class="hljs-selector-class">.incoming</span><span class="hljs-selector-class">.push</span>(req);  
  <span class="hljs-comment">// 新建一个表示响应的对象，一般是 ServerResponse  </span>
  const res = new server<span class="hljs-selector-attr">[kServerResponse]</span>(req);  
  <span class="hljs-comment">/*
    socket 当前已经在处理其它请求的响应，则先排队，
   否则挂载响应对象到 socket，作为当前处理的响应
  */</span>  
  if (socket._httpMessage) {  
    state<span class="hljs-selector-class">.outgoing</span><span class="hljs-selector-class">.push</span>(res);  
  } else {  
    res<span class="hljs-selector-class">.assignSocket</span>(socket); <span class="hljs-comment">// socket._httpMessage = res;  </span>
  }  
  <span class="hljs-comment">// 一个请求响应处理完毕后，需要做一些处理  </span>
  res<span class="hljs-selector-class">.on</span>('finish', resOnFinish.bind(undefined, 
                                        req, 
                                        res, 
                                        socket, 
                                        state, 
                                        server));  
  <span class="hljs-comment">// 触发 request 事件说明有请求到来  </span>
  server<span class="hljs-selector-class">.emit</span>('request', req, res);   
}  
</code></pre>
<p>从上面代码中可以看到，当 Node.js 解析 HTTP 请求头完成后，就会创建一个 ServerResponse 对象表示响应。然后判断当前是否有正在处理的响应，如果有则排队等待处理，否则就把新建的 ServerResponse 对象作为当前需要处理的响应，最后触发 request 事件通知用户层，用户就可以进行请求的处理了。</p>
<p>在上面的代码中我们看到，Node.js 维护了两个队列，分别是请求和响应队列。当前处理的请求在请求队列的队首，当前请求对应的响应会挂载到 socket 的 _httpMessage 属性上，但是我们看到 Node.js 会触发 request 事件通知用户有新请求到来，所有在管道化的情况下，Node.js 会并行处理多个请求（如果是 CPU 密集型的请求则实际上还是会变成串行，这和 Node.js 的单线程有关）。那 Node.js 是如何控制响应顺序的呢？我们知道每次触发 request 事件的时候，我们都会执行一个函数。比如下面的代码。</p>
<pre><code class="hljs language-javascript"> http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {  
  <span class="hljs-comment">// 一些网络IO  </span>
  <span class="hljs-comment">// 响应 </span>
  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'okay'</span>);  
});  
</code></pre>
<p>我们看到每个请求的处理是独立的。假设每个请求都去操作数据库，如果请求 2 比请求 1 先完成数据库的操作，从而请求 2 先执行 res.end。那岂不是请求 2 先返回？我们看一下 ServerResponse 和 OutgoingMessage的 实现，揭开迷雾。ServerResponse 是 OutgoingMessage 的子类。write 函数是在 OutgoingMessage 中实现的，write 的调用链路很长，我们不层层分析，直接看最后的节点。</p>
<pre><code class="hljs language-kotlin">function _writeRaw(<span class="hljs-keyword">data</span>, encoding, callback) {  
  <span class="hljs-keyword">const</span> conn = <span class="hljs-keyword">this</span>.socket;  
  <span class="hljs-comment">// socket 对应的响应是自己并且可写  </span>
  <span class="hljs-keyword">if</span> (conn &#x26;&#x26; conn._httpMessage === <span class="hljs-keyword">this</span> &#x26;&#x26; conn.writable) {  
    <span class="hljs-comment">// 如果有缓存的数据则先发送缓存的数据  </span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.outputData.length) {  
      <span class="hljs-keyword">this</span>._flushOutput(conn);  
    }  
    <span class="hljs-comment">// 接着发送当前需要发送的  </span>
    <span class="hljs-keyword">return</span> conn.write(<span class="hljs-keyword">data</span>, encoding, callback);  
  }  
  <span class="hljs-comment">// socket 当前处理的响应对象不是自己，则先缓存数据。  </span>
  <span class="hljs-keyword">this</span>.outputData.push({ <span class="hljs-keyword">data</span>, encoding, callback });  
  <span class="hljs-keyword">this</span>.outputSize += <span class="hljs-keyword">data</span>.length;  
  <span class="hljs-keyword">this</span>._onPendingData(<span class="hljs-keyword">data</span>.length);  
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.outputSize &#x3C; HIGH_WATER_MARK;  
}  
</code></pre>
<p>上面代码中，有一个关键的地方是当用户通过响应对象 res 返回数据给客户端时，Node.js 会判断 res 是不是当前正在处理的响应，如果是才会真正发送数据，否则会先把数据缓存起来。那么这些缓存的数据什么时候被发送出去呢？当一个响应结束的时候，Node.js 会触发 finish 事件，对应的处理函数是 resOnFinish。</p>
<pre><code class="hljs language-ini">function resOnFinish(req, res, socket, state, server) {  
        // 删除响应对应的请求  
        state.incoming.shift()<span class="hljs-comment">;  </span>
        clearIncoming(req)<span class="hljs-comment">;  </span>
        // 解除 socket 上挂载的响应对象  
        /*
                <span class="hljs-attr">socket._httpMessage</span> = null<span class="hljs-comment">;</span>
                <span class="hljs-attr">this.socket</span> = null<span class="hljs-comment">;</span>
        */
        res.detachSocket(socket)<span class="hljs-comment">;  </span>
        // 是不是最后一个响应  
        if (res._last) {  
            // 是则销毁 socket  
            if (typeof <span class="hljs-attr">socket.destroySoon</span> === <span class="hljs-string">'function'</span>) {  
             socket.destroySoon()<span class="hljs-comment">;  </span>
            } else {  
             socket.end()<span class="hljs-comment">;  </span>
            }  
        } else if (<span class="hljs-attr">state.outgoing.length</span> === <span class="hljs-number">0</span>) {  
          /*
            没有待处理的响应了，则重新设置超时时间，
            等待请求的到来，一定时间内没有请求则触发 timeout 事件
          */  
          if (server.keepAliveTimeout &#x26;&#x26; typeof <span class="hljs-attr">socket.setTimeout</span> === <span class="hljs-string">'function'</span>) {  
            socket.setTimeout(server.keepAliveTimeout)<span class="hljs-comment">;  </span>
            <span class="hljs-attr">state.keepAliveTimeoutSet</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;  </span>
          }  
        } else {  
          // 还有待处理的响应则获取下一个要处理的响应  
          const <span class="hljs-attr">m</span> = state.outgoing.shift()<span class="hljs-comment">;  </span>
          // 挂载到 socket 作为当前待处理的响应  
          if (m) {  
            m.assignSocket(socket)<span class="hljs-comment">;  </span>
          }  
        }  
}  
</code></pre>
<p>我们看到，Node.js 处理完一个响应后会做一些判断。这里主要分三类，我们分别分析。</p>
<ol>
<li>是否是最后一个响应？</li>
</ol>
<p>什么情况下会被认为是最后一个响应？我们知道，响应和请求是一一对应的，最后一个响应就意味着最后一个请求了，那么什么时候会被认为是最后一个请求呢？</p>
<p>非管道化的情况下，一个请求一个响应，然后客户端或服务器就会关闭 TCP 连接，那这种情况下，TCP 上第一个也是唯一一个请求就是最后一个请求。管道化的情况下，理论上就没有所谓的最后一个响应。但是在 HTTP 服务器的实现上会做一些限制。在管道化的情况下，可以通过设置 HTTP 响应头 connection 来定义是否在响应完毕后就断开连接，或者请求个数达到阈值也会强制断开。此外，当读端关闭的时候，也被认为是最后一个请求，毕竟不会再发送请求了。接下来，我们就重点看看读端关闭的逻辑。</p>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">socketOnEnd</span>(server, socket, parser, state) {  
  const ret = parser<span class="hljs-selector-class">.finish</span>();  
  <span class="hljs-comment">// 不允许半开关则终止请求的处理，不响应，关闭写端  </span>
  if (!server.httpAllowHalfOpen) {  
    <span class="hljs-built_in">abortIncoming</span>(state.incoming);  
    if (socket.writable) socket<span class="hljs-selector-class">.end</span>();  
  } else if (state.outgoing.length) {  
    <span class="hljs-comment">/*
      允许半开关，并且还有响应需要处理，
      标记响应队列最后一个节点为最后的响应，
      处理完就关闭 socket
    */</span>  
    state<span class="hljs-selector-class">.outgoing</span><span class="hljs-selector-attr">[state.outgoing.length - 1]</span><span class="hljs-selector-class">._last</span> = true;  
  } else if (socket._httpMessage) {  
    <span class="hljs-comment">/*
      没有等待处理的响应了，但是还有正在处理的响应，
      则标记为最后一个响应
     */</span>  
    socket<span class="hljs-selector-class">._httpMessage</span><span class="hljs-selector-class">._last</span> = true;  
  } else if (socket.writable) {  
    <span class="hljs-comment">// 否则关闭 socket 写端  </span>
    socket<span class="hljs-selector-class">.end</span>();  
  }  
}  
</code></pre>
<p>以上就是 Node.js 中判断是否是最后一个响应的一些情况，如果一个响应被认为是最后一个响应，那么发送响应后就会关闭连接。</p>
<ol start="2">
<li>响应队列为空</li>
</ol>
<p>如果不是最后一个响应的时候，Node.js 又是怎么处理的呢？如果当前的待处理响应队列为空，说明当前处理的响应是目前最后一个需要处理的，但不是 TCP 连接上最后一个响应。这时候，Node.js 会设置超时时间，如果超时还没有新的请求或者请求数达到阈值，则 Node.js 会关闭连接。</p>
<ol start="3">
<li>响应队列非空</li>
</ol>
<p>如果当前待处理队列非空，处理完当前请求后会继续处理下一个响应。并从队列中删除该响应。我们来看一下 Node.js 是如何处理下一个响应的。</p>
<pre><code class="hljs language-ini">// 把响应对象挂载到 socket，标记 socket 当前正在处理的响应  
<span class="hljs-attr">ServerResponse.prototype.assignSocket</span> = function assignSocket(socket) {  
  // 挂载到 socket上，标记是当前处理的响应  
  <span class="hljs-attr">socket._httpMessage</span> = this<span class="hljs-comment">;  </span>
  socket.on('close', onServerResponseClose)<span class="hljs-comment">;  </span>
  <span class="hljs-attr">this.socket</span> = socket<span class="hljs-comment">;  </span>
  this.emit('socket', socket)<span class="hljs-comment">;  </span>
  this._flush()<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
</code></pre>
<p>Node.js 是通过 _httpMessage 标记当前处理的响应的，配合响应队列来实现响应的按序返回。标记完后执行 _flush 发送响应的数据（如果这时候请求已经被处理完成），这样之前缓存的数据就可以被发送出去了，以下是 flush 的逻辑。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">OutgoingMessage.prototype._flush</span> = function _flush() {  
  const <span class="hljs-attr">socket</span> = this.socket<span class="hljs-comment">;  </span>
  if (socket &#x26;&#x26; socket.writable) {  
    const <span class="hljs-attr">ret</span> = this._flushOutput(socket)<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
  
<span class="hljs-attr">OutgoingMessage.prototype._flushOutput</span> = function _flushOutput(socket) {  
  // 缓存的数据 
  const <span class="hljs-attr">outputLength</span> = this.outputData.length<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">outputData</span> = this.outputData<span class="hljs-comment">;  </span>
  // 加塞，让数据一起发送出去  
  socket.cork()<span class="hljs-comment">;  </span>
  // 把缓存的数据写到 socket  
  let ret<span class="hljs-comment">;  </span>
  for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; outputLength; i++) {  </span>
    const { data, encoding, callback } = outputData<span class="hljs-section">[i]</span><span class="hljs-comment">;  </span>
    <span class="hljs-attr">ret</span> = socket.write(data, encoding, callback)<span class="hljs-comment">;  </span>
  }  
  socket.uncork()<span class="hljs-comment">;  </span>
  
  <span class="hljs-attr">this.outputData</span> = []<span class="hljs-comment">;  </span>
  this._onPendingData(-this.outputSize)<span class="hljs-comment">;  </span>
  <span class="hljs-attr">this.outputSize</span> = <span class="hljs-number">0</span><span class="hljs-comment">;  </span>
  
  return ret<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>flush 最终会调用 socket 对象把数据发送出去，以上就是 Node.js 中对于管道化的实现。</p>
<h3>HTTP Connect 方法的原理和实现</h3>
<p>HTTP Connect 方法用于客户端请求代理服务器时，指示代理服务器转发客户端的 TCP 数据到另一个服务器，同时把服务器的数据透明代理到客户端，流程如图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb929bf1b7fe4a11963d6547cd472cf6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下面通过一个例子理解一下这个过程。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);  
<span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);  
<span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">URL</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);  
<span class="hljs-comment">// 真正的服务器</span>
<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'ok'</span>)).<span class="hljs-title function_">listen</span>(<span class="hljs-number">9999</span>);
<span class="hljs-comment">// 创建一个 HTTP 服务器作为代理服务器  </span>
<span class="hljs-keyword">const</span> proxy = http.<span class="hljs-title function_">createServer</span>();  

<span class="hljs-comment">// 监听 connect 事件，有 HTTP CONNECT 请求时触发  </span>
proxy.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connect'</span>, <span class="hljs-function">(<span class="hljs-params">req, clientSocket, head</span>) =></span> {  
  <span class="hljs-comment">// 获取真正要连接的服务器地址并发起连接  </span>
  <span class="hljs-keyword">const</span> { port, hostname } = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">`http://<span class="hljs-subst">${req.url}</span>`</span>);  
  <span class="hljs-keyword">const</span> serverSocket = net.<span class="hljs-title function_">connect</span>(port || <span class="hljs-number">80</span>, hostname, <span class="hljs-function">() =></span> {  
    <span class="hljs-comment">// 连接成功告诉客户端  </span>
    clientSocket.<span class="hljs-title function_">write</span>(<span class="hljs-string">'HTTP/1.1 200 Connection Established\r\n'</span> +  
                       <span class="hljs-string">'Proxy-agent: Node.js-Proxy\r\n\r\n'</span>);  
    <span class="hljs-comment">// 透传客户端和服务器的数据    </span>
    serverSocket.<span class="hljs-title function_">write</span>(head);              
    serverSocket.<span class="hljs-title function_">pipe</span>(clientSocket);  
    clientSocket.<span class="hljs-title function_">pipe</span>(serverSocket);  
  });  
});  
  
proxy.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>, <span class="hljs-function">() =></span> {  
  <span class="hljs-comment">// 发起 HTTP Connect 请求  </span>
  <span class="hljs-keyword">const</span> req = http.<span class="hljs-title function_">get</span>({  
    <span class="hljs-comment">// 代理服务器的地址  </span>
    <span class="hljs-attr">port</span>: <span class="hljs-number">8888</span>,  
    <span class="hljs-attr">host</span>: <span class="hljs-string">'127.0.0.1'</span>,  
    <span class="hljs-attr">method</span>: <span class="hljs-string">'CONNECT'</span>,  
    <span class="hljs-comment">// 真正需要访问的服务器地址</span>
    <span class="hljs-attr">path</span>: <span class="hljs-string">'127.0.0.1:9999'</span>,
  });  
  <span class="hljs-comment">// CONNECT 请求成功后触发  </span>
  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connect'</span>, <span class="hljs-function">(<span class="hljs-params">res, socket, head</span>) =></span> {  
    <span class="hljs-comment">// 发送真正的请求  </span>
    socket.<span class="hljs-title function_">write</span>(<span class="hljs-string">'GET / HTTP/1.1\r\n'</span> +  
                 <span class="hljs-string">'Host: 127.0.0.1:9999\r\n'</span> +  
                 <span class="hljs-string">'Connection: close\r\n'</span> +  
                 <span class="hljs-string">'\r\n'</span>);  
    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =></span> {  
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk.<span class="hljs-title function_">toString</span>());  
    });  
    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {  
      proxy.<span class="hljs-title function_">close</span>();  
      server.<span class="hljs-title function_">close</span>();
    });  
  });  
});  
</code></pre>
<p>上面的例子首先创建了一个 HTTP 服务器，然后发起了一个 HTTP Connect 请求，这时候服务器会触发 connect 事件。connect 事件的处理函数会通过请求 URL 拿到需要代理的服务器地址，然后发起 TCP 连接，连接成功后，服务器给客户端返回了 200，接着客户端和服务器就可以传输 TCP 数据了，而代理服务器会透明转发。下面是客户端和代理服务器的通信过程。</p>
<ol>
<li>客户端发送的 HTTP Connect 请求报文。</li>
</ol>
<pre><code class="hljs language-makefile">CONNECT 127.0.0.1:9999 HTTP/1.1
<span class="hljs-section">Host: 127.0.0.1:8888</span>
<span class="hljs-section">Connection: close</span>
</code></pre>
<ol start="2">
<li>代理服务器连接服务器成功后，返回给客户端的响应报文。</li>
</ol>
<pre><code class="hljs">HTTP/1.1 200 Connection Established
</code></pre>
<ol start="3">
<li>客户端和服务器就可以通过代理服务器传输 TCP 数据了。</li>
</ol>
<p>我们也可以通过 WireShark 和过滤条件 tcp.srcport == 8888 || tcp.dstport == 8888 || tcp.srcport == 9999 || tcp.dstport == 9999 查看具体的通信过程。</p>
<p>下面我们看一下 Node.js 中 Connect 的实现。之前已经分析过，客户端和 Node.js 服务器建立 TCP 连接后，Node.js 收到数据时会执行 OnStreamRead 处理。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">OnStreamRead</span>(ssize_t nread, const uv_buf_t&#x26; buf) override {
    <span class="hljs-comment">// 解析 HTTP 请求</span>
    Local&#x3C;Value> ret = <span class="hljs-built_in">Execute</span>(buf.base, nread);
    Local&#x3C;Value> cb = <span class="hljs-selector-tag">object</span>()-><span class="hljs-built_in">Get</span>(env()-><span class="hljs-built_in">context</span>(), kOnExecute)<span class="hljs-selector-class">.ToLocalChecked</span>();
    <span class="hljs-comment">// 执行 kOnExecute 回调</span>
    <span class="hljs-built_in">MakeCallback</span>(cb.As&#x3C;Function>(), <span class="hljs-number">1</span>, &#x26;ret);
  }
</code></pre>
<p>OnStreamRead 通过 Execute 解析 HTTP 数据，然后执行 JS 回调 kOnExecute，对应的 JS 函数是onParserExecute。</p>
<pre><code class="hljs language-ini">// 连接上有数据到来  
function onParserExecute(server, socket, parser, state, ret) {
    onParserExecuteCommon(server, socket, parser, state, ret, undefined)<span class="hljs-comment">;</span>
}

function onParserExecuteCommon(server, socket, parser, state, ret, d) { 
  // 解析完 HTTP 头并且设置了 upgrade 字段
  if (parser.incoming &#x26;&#x26; parser.incoming.upgrade) {  
    // 处理 Upgrade 或者 CONNECT 请求  
    const <span class="hljs-attr">req</span> = parser.incoming<span class="hljs-comment">;  </span>
    const <span class="hljs-attr">eventName</span> = req.method === <span class="hljs-string">'CONNECT'</span> ?  <span class="hljs-string">'connect'</span> : <span class="hljs-string">'upgrade'</span><span class="hljs-comment">;  </span>
    // 监听了对应的事件或者是协议升级请求则处理，否则关闭连接  
    if (<span class="hljs-attr">eventName</span> === <span class="hljs-string">'upgrade'</span> || server.listenerCount(eventName) > <span class="hljs-number">0</span>) {  
      // 还没有解析的数据  
      const <span class="hljs-attr">bodyHead</span> = d.slice(ret, d.length)<span class="hljs-comment">;  </span>
      server.emit(eventName, req, socket, bodyHead)<span class="hljs-comment">;  </span>
    } else {  
      socket.destroy()<span class="hljs-comment">;  </span>
    }  
  }  
}  
</code></pre>
<p>onParserExecuteCommon 中会判断收到的请求是不是 Connect 或者协议升级请求，如果是并且监听了对应的事件则处理该请求，否则关闭连接，这就是 Node.js 中 Connect 的原理和实现了。</p>
<p>另外，在代码中我们发现一个有意思的地方，那就是在触发 connect 事件的时候，Node.js 给回调函数传入的参数。</p>
<pre><code class="hljs language-perl">server.emit(<span class="hljs-string">'connect'</span>, req, <span class="hljs-keyword">socket</span>, bodyHead);  
</code></pre>
<p>第一第二个参数没什么特别的，但是第三个参数就有意思了，bodyHead 代表的是 HTTP Connect 请求中除了请求行和 HTTP 头之外的数据。因为 Node.js 解析完 HTTP 头后就不继续处理了，而是把剩下的数据交给了用户。这样我们就可以做一些好玩的事情。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">http</span> = require(<span class="hljs-string">'http'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">net</span> = require(<span class="hljs-string">'net'</span>)<span class="hljs-comment">;  </span>
const { URL } = require('url')<span class="hljs-comment">;  </span>

const <span class="hljs-attr">server</span> = http.createServer((req, res) => res.end(<span class="hljs-string">'ok'</span>)).listen(<span class="hljs-number">9999</span>)<span class="hljs-comment">;</span>
  
const <span class="hljs-attr">proxy</span> = http.createServer()<span class="hljs-comment">;  </span>

proxy.on('connect', (req, clientSocket, head) => {  
  const { port, hostname } = new URL(`http://${req.url}`)<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">serverSocket</span> = net.connect(port || <span class="hljs-number">80</span>, hostname, () => {  
    clientSocket.write('HTTP/1.1 200 Connection Established\r\n' +  
                       'Proxy-agent: Node.js-Proxy\r\n\r\n')<span class="hljs-comment">;  </span>
    // 把 connect 请求剩下的数据转发给服务器                 
    serverSocket.write(head)<span class="hljs-comment">;  </span>
    serverSocket.pipe(clientSocket)<span class="hljs-comment">;  </span>
    clientSocket.pipe(serverSocket)<span class="hljs-comment">;  </span>
  })<span class="hljs-comment">;  </span>
})<span class="hljs-comment">;  </span>
  
proxy.listen(8888, () => {  
  const <span class="hljs-attr">net</span> = require(<span class="hljs-string">'net'</span>)<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">body</span> = <span class="hljs-string">'GET http://127.0.0.1:9999 HTTP/1.1\r\nConnection: close\r\n\r\n'</span><span class="hljs-comment">;  </span>
  const <span class="hljs-attr">socket</span> = net.connect(<span class="hljs-number">8888</span>)<span class="hljs-comment">;  </span>
  socket.write(`CONNECT 127.0.0.1:9999 HTTP/1.1\r\n\r\n${body}`)<span class="hljs-comment">;  </span>
  socket.setEncoding('utf-8')<span class="hljs-comment">;  </span>
  socket.on('data', (chunk) => {  
    console.log(chunk)<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;  </span>
  socket.on('end', () => {
    proxy.close()<span class="hljs-comment">;</span>
    server.close()<span class="hljs-comment">;</span>
  })
})<span class="hljs-comment">;  </span>
</code></pre>
<p>上面的代码中，我们新建一个 socket，然后自己构造 HTTP Connect 报文，并且在 HTTP 行后面加一个额外的字符串，这个字符串是一个 HTTP 请求，当 Node.js 服务器收到 Connect 请求后，connect 事件的处理函数会把 Connect 请求多余的那一部分数据传给真正的服务器，这样就可以在一个请求里做两个事情，节省了发送一个请求的时间。</p>
<h3>协议升级</h3>
<p>除了 HTTP Connect 特性外，HTTP 协议还有一个特性是<strong>协议升级</strong> <strong>。</strong> 协议升级就是先通过 HTTP 协议进行通信协商，然后升级到另一种协议，后续就可以使用另一种协议进行通信了，比如 Websocket 协议。</p>
<p>接着来，我们看看协议升级的过程。当客户端试图升级到一个新的协议时，先发送一个普通的 HTTP 请求，这个请求带有以下 header。</p>
<ol>
<li>Connection: Upgrade 表示这是一个升级请求。</li>
<li>Upgrade: 协议1,协议2 指定一项或多项协议名，按优先级排序，以逗号分隔。</li>
<li>根据不同的协议可以带上协议相关的 header，比如 WebSocket 的 Sec-WebSocket-Extensions。</li>
</ol>
<p>下面是一个协议升级请求的例子。</p>
<pre><code class="hljs language-makefile">GET / HTTP/1.1
<span class="hljs-section">Sec-WebSocket-Version: 13</span>
<span class="hljs-section">Sec-WebSocket-Key: G+Gcwl/FXe2fns7dF5aUIQ==</span>
<span class="hljs-section">Connection: Upgrade</span>
<span class="hljs-section">Upgrade: websocket</span>
<span class="hljs-section">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span>
<span class="hljs-section">Host: localhost:8888</span>
</code></pre>
<p>服务器收到升级请求后会返回相应的信息。</p>
<ol>
<li>Upgrade: websocket 表示同意升级到 WebSocket 协议。</li>
<li>Connection: Upgrade 表示协议升级响应。</li>
<li>根据不同的协议可以带上协议相关的 header，比如 WebSocket 的 Sec-WebSocket-Accept。</li>
</ol>
<p>下面是一个协议升级响应的例子。</p>
<pre><code class="hljs language-makefile">HTTP/1.1 101 Switching Protocols
<span class="hljs-section">Upgrade: websocket</span>
<span class="hljs-section">Connection: Upgrade</span>
<span class="hljs-section">Sec-WebSocket-Accept: 5psuA6qQUa3bYFsz3aqP5t3x8UA=</span>
</code></pre>
<p>接着，我们再通过一个例子看看 Node.js 中如何实现 WebSocket 协议升级。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> { createHash } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ws'</span>);

<span class="hljs-comment">// 创建一个 http server</span>
<span class="hljs-keyword">const</span> httpServer = http.<span class="hljs-title function_">createServer</span>();

<span class="hljs-comment">// 监听协议升级请求</span>
httpServer.<span class="hljs-title function_">on</span>(<span class="hljs-string">'upgrade'</span>, <span class="hljs-function">(<span class="hljs-params">req, socket, head</span>) =></span> {
    <span class="hljs-comment">// 按照 WebSocket 协议计算返回 header</span>
    <span class="hljs-keyword">const</span> digest = <span class="hljs-title function_">createHash</span>(<span class="hljs-string">'sha1'</span>)
    .<span class="hljs-title function_">update</span>(<span class="hljs-string">`<span class="hljs-subst">${req.headers[<span class="hljs-string">'sec-websocket-key'</span>]}</span>258EAFA5-E914-47DA-95CA-C5AB0DC85B11`</span>)
    .<span class="hljs-title function_">digest</span>(<span class="hljs-string">'base64'</span>);

    <span class="hljs-comment">// 设置返回状态码和 headers</span>
    <span class="hljs-keyword">const</span> headers = [
        <span class="hljs-string">'HTTP/1.1 101 Switching Protocols'</span>,
        <span class="hljs-string">'Upgrade: websocket'</span>,
        <span class="hljs-string">'Connection: Upgrade'</span>,
        <span class="hljs-string">`Sec-WebSocket-Accept: <span class="hljs-subst">${digest}</span>`</span>
    ];  
    socket.<span class="hljs-title function_">write</span>(headers.<span class="hljs-title function_">concat</span>(<span class="hljs-string">'\r\n'</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">'\r\n'</span>));
});

<span class="hljs-comment">// 启动服务器</span>
httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-comment">// 建立 Websocket 连接</span>
    <span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">'ws://localhost:8888'</span>);
    ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">'open'</span>, <span class="hljs-function">() =></span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'success'</span>);
        process.<span class="hljs-title function_">exit</span>();
    });
});
</code></pre>
<p>上面的代码中，首先建立了一个 HTTP 服务器并监听了 upgrade 事件，然后客户端创建了一个 WebSocket 连接，这时候服务器就会收到 upgrade 事件，upgrade 事件处理函数中，会根据请求计算出响应所需要的信息，接着给客户的返回 200 和相关的 HTTP 头表示同意协议升级，后续客户端和服务器之间就可以通过 WebSocket 协议进行通信了。流程如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c1db852fdca4c41910d3fc32a9d0a0c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h1>HTTP 客户端</h1>
<p>了解完 HTTP 服务器的实现和特性后，接着看一下 HTTP 客户端的实现。Node.js 中，可以通过 http.request 发送一个 HTTP 请求。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">url, options, cb</span>) {  
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientRequest</span>(url, options, cb);  
}  
</code></pre>
<p>request 中创建了一个 ClientRequest 对象表示一个 HTTP 请求，下面逐步分析具体的逻辑。</p>
<pre><code class="hljs language-kotlin">function ClientRequest(input, options, cb) {  
  <span class="hljs-comment">// 继承 OutgoingMessage  </span>
  OutgoingMessage.call(<span class="hljs-keyword">this</span>);  
  <span class="hljs-comment">// 是否使用 agent  </span>
  let agent = options.agent;   
  <span class="hljs-comment">// 忽略 agent 的处理，主要用于复用 TCP 连接，具体参考 _http_agent.js 和下面的 Agent 章节</span>
  <span class="hljs-keyword">this</span>.agent = agent;  
  <span class="hljs-comment">// 监听响应事件  </span>
  <span class="hljs-keyword">if</span> (cb) {  
    <span class="hljs-keyword">this</span>.once(<span class="hljs-string">'response'</span>, cb);  
  }  
  <span class="hljs-comment">// 使用 agent 时，socket 由 agent 提供，否则自己创建 socket  </span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.agent) {  
    <span class="hljs-keyword">this</span>.agent.addRequest(<span class="hljs-keyword">this</span>, options);  
  } <span class="hljs-keyword">else</span> {  
    <span class="hljs-comment">// 不使用 agent 则每次创建一个 socket，默认使用 net 模块的接口</span>
    <span class="hljs-keyword">this</span>.onSocket(net.createConnection(options)); 
  }  
  <span class="hljs-comment">// 连接成功后发送待缓存的数据，支持连接过程中，用户调用了 write 或者 end 的情况  </span>
  <span class="hljs-keyword">this</span>._deferToConnect(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, () => <span class="hljs-keyword">this</span>._flush());  
}  
</code></pre>
<p>获取一个 ClientRequest 实例后，不管是通过 agent 还是自己创建一个 TCP 连接，在连接成功后都会执行 onSocket，onSocket 函数逻辑如下。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// socket 可用时的回调  </span>
ClientRequest<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.onSocket</span> = function <span class="hljs-built_in">onSocket</span>(socket) {  
  process<span class="hljs-selector-class">.nextTick</span>(onSocketNT, this, socket);  
};  
  
function <span class="hljs-built_in">onSocketNT</span>(req, socket) {  
  <span class="hljs-comment">// 申请 socket 过程中，请求已经终止  </span>
  if (req.aborted) {
    <span class="hljs-comment">// 不使用 agent，直接销毁 socket  </span>
    if (!req.agent) {  
      socket<span class="hljs-selector-class">.destroy</span>();  
    } else {  
      <span class="hljs-comment">// 触发 free 事件，由 agent 处理 socket  </span>
      req<span class="hljs-selector-class">.emit</span>('close');  
      socket<span class="hljs-selector-class">.emit</span>('free');  
    }  
  } else {  
    <span class="hljs-comment">// 处理 socket  </span>
    <span class="hljs-built_in">tickOnSocket</span>(req, socket);  
  }  
}  
</code></pre>
<p>正常情况下，onSocketNT 中会执行 tickOnSocket 函数继续处理请求。</p>
<pre><code class="hljs language-ini">function tickOnSocket(req, socket) {  
    // 分配一个 HTTP 解析器解析响应数据  
    const <span class="hljs-attr">parser</span> = parsers.alloc()<span class="hljs-comment">;  </span>
    <span class="hljs-attr">req.socket</span> = socket<span class="hljs-comment">;  </span>
    // 初始化，处理响应报文  
    parser.initialize(HTTPParser.RESPONSE, ...)<span class="hljs-comment">;  </span>
    <span class="hljs-attr">parser.socket</span> = socket<span class="hljs-comment">;  </span>
    <span class="hljs-attr">parser.outgoing</span> = req<span class="hljs-comment">;  </span>
    <span class="hljs-attr">req.parser</span> = parser<span class="hljs-comment">;  </span>
    <span class="hljs-attr">socket.parser</span> = parser<span class="hljs-comment">;  </span>
    // socket 正处理的请求  
    <span class="hljs-attr">socket._httpMessage</span> = req<span class="hljs-comment">;  </span>
    // 解析完 HTTP 头部的回调  
    <span class="hljs-attr">parser.onIncoming</span> = parserOnIncomingClient<span class="hljs-comment">;  </span>
    socket.on('data', socketOnData)<span class="hljs-comment">;  </span>
    socket.on('end', socketOnEnd)<span class="hljs-comment">;  </span>
    req.emit('socket', socket)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>拿到一个 socket 后，申请一个 HTTP 解析器用于解析 HTTP 响应报文，然后监听 data 事件等待响应数据，对应的处理函数是 socketOnData。</p>
<pre><code class="hljs language-kotlin">function socketOnData(d) {  
  <span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">this</span>;  
  <span class="hljs-comment">// 请求对象</span>
  <span class="hljs-keyword">const</span> req = <span class="hljs-keyword">this</span>._httpMessage;  
  <span class="hljs-keyword">const</span> parser = <span class="hljs-keyword">this</span>.parser;  
  <span class="hljs-comment">// 交给 HTTP 解析器处理  </span>
  <span class="hljs-keyword">const</span> ret = parser.execute(d);  
  <span class="hljs-comment">// ...  </span>
}  
</code></pre>
<p>当 Node.js 收到响应报文时，会把数据交给 HTTP 解析器处理，HTTP 在解析的过程中会不断触发钩子函数，比如解析完 HTTP 头后会触发 kOnHeadersComplete 钩子，对应函数为 parserOnHeadersComplete。</p>
<pre><code class="hljs language-ini">function parserOnHeadersComplete(...) {  
  const <span class="hljs-attr">parser</span> = this<span class="hljs-comment">;  </span>
  const { socket } = parser<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">ParserIncomingMessage</span> = IncomingMessage<span class="hljs-comment">;  </span>
  // 新建一个 IncomingMessage 对象  
  const <span class="hljs-attr">incoming</span> = parser.incoming = new ParserIncomingMessage(socket)<span class="hljs-comment">;  </span>
  // 执行回调  
  return parser.onIncoming(incoming, shouldKeepAlive)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>解析完头部后会执行另一个回调 onIncoming，并传入 IncomingMessage 实例，onIncoming 的值是 parserOnIncomingClient。</p>
<pre><code class="hljs language-ini">function parserOnIncomingClient(res, shouldKeepAlive) {  
  const <span class="hljs-attr">socket</span> = this.socket<span class="hljs-comment">;  </span>
  // 请求对象  
  const <span class="hljs-attr">req</span> = socket._httpMessage<span class="hljs-comment">;  </span>
  <span class="hljs-attr">req.res</span> = res<span class="hljs-comment">;  </span>
  <span class="hljs-attr">res.req</span> = req<span class="hljs-comment">;  </span>
  // 监听响应结束事件，响应结束后会清除定时器、判断是否需要关闭 TCP 连接  
  res.on('end', responseOnEnd)<span class="hljs-comment">;  </span>
  // 请求终止了或 emit 返回 false 说明没有监听 response 事件，则丢弃数据  
  if (req.aborted || !req.emit('response', res))  
    res._dump()<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>从上面代码中可以看到，Node.js 解析完 HTTP 响应头时，就通过触发 response 事件执行了 http.request 设置的回调函数，例如下面代码中的回调。</p>
<pre><code class="hljs language-javascript">http.<span class="hljs-title function_">request</span>(<span class="hljs-string">'url'</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =></span> {  
    <span class="hljs-comment">// 解析body</span>
    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {  
      <span class="hljs-comment">//   </span>
    });
     <span class="hljs-comment">// 解析body结束，响应结束</span>
     res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {  
      <span class="hljs-comment">//   </span>
    });  
});  
<span class="hljs-comment">// ...</span>
</code></pre>
<p>因为 Node.js 不负责解析 HTTP body 数据，所以在 http.request 回调中可以通过 data 事件获取响应的数据，前面分析过，Node.js 收到 body 时会调用 kOnBody 钩子，对应的函数是 parserOnBody。</p>
<pre><code class="hljs language-ini">function parserOnBody(b, start, len) {  
    const <span class="hljs-attr">stream</span> = this.incoming<span class="hljs-comment">;  </span>
    // 数据
    const <span class="hljs-attr">slice</span> = b.slice(start, start + len)<span class="hljs-comment">;  </span>
    // 把数据 push 到流中，流会触发 data 事件  
    const <span class="hljs-attr">ret</span> = stream.push(slice)<span class="hljs-comment">;  </span>
    // 数据过载，暂停接收  
    if (!ret)  
      readStop(this.socket)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>parserOnBody 解析 body 过程中会不断往 res 流中 push 数据，从而不断触发 res 的 data 事件。解析 body 结束后会执行 kOnMessageComplete 钩子，对应函数为 parserOnMessageComplete。</p>
<pre><code class="hljs language-csharp"><span class="hljs-function">function <span class="hljs-title">parserOnMessageComplete</span>()</span> {  
    <span class="hljs-keyword">const</span> parser = <span class="hljs-keyword">this</span>;  
    <span class="hljs-keyword">const</span> stream = parser.incoming;  
    <span class="hljs-comment">// 流结束  </span>
    stream.push(<span class="hljs-literal">null</span>); 
}  
</code></pre>
<p>parserOnMessageComplete 中执行 push(null) 通知流读取结束，从而触发 res 的 end 事件，这样一个请求的响应过程就结束了。</p>
<p>分析完响应的处理后，接着再来看一下发送请求的逻辑。执行完 http.request 后，我们会得到一个表示请求的对象 ClientRequest，然后可以执行它的 write 方法发送 HTTP 请求数据，因为 ClientRequest 继承 OutgoingMessage，所以实际上调用的是 OutgoingMessage 的 write 函数。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">OutgoingMessage.prototype.write</span> = function write(chunk, encoding, callback) {  
  const <span class="hljs-attr">ret</span> = write_(this, chunk, encoding, callback, <span class="hljs-literal">false</span>)<span class="hljs-comment">;  </span>
  // 返回 false 说明先不要写入数据，等待 drain 事件后再写
  if (!ret)  
    this<span class="hljs-section">[kNeedDrain]</span> = true<span class="hljs-comment">;  </span>
  return ret<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
  
function write_(msg, chunk, encoding, callback, fromEnd) { 
  //  把请求行和请求头保存到 msg._header 中
  msg._implicitHeader()<span class="hljs-comment">;   </span>
    
  let ret<span class="hljs-comment">;  </span>
  // chunk 模式则需要额外加一下字段，否则直接发送  
  if (msg.chunkedEncoding &#x26;&#x26; chunk.length !== 0) {  
    const <span class="hljs-attr">len</span> = Buffer.byteLength(chunk, encoding)<span class="hljs-comment">;   </span>
    /* 
      chunk模式时，报文的格式如下 
      chunk长度，回车换行 
      数据 回车换行 
    */  
    msg._send(len.toString(16), 'latin1', null)<span class="hljs-comment">;  </span>
    msg._send(crlf_buf, null, null)<span class="hljs-comment">;  </span>
    msg._send(chunk, encoding, null)<span class="hljs-comment">;  </span>
    <span class="hljs-attr">ret</span> = msg._send(crlf_buf, null, callback)<span class="hljs-comment">;  </span>
  } else {  
    <span class="hljs-attr">ret</span> = msg._send(chunk, encoding, callback)<span class="hljs-comment">;  </span>
  }  
  
  return ret<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>write_ 函数首先拼接请求行和请求头，把它们保存到 _header 字段中，然后判断使用哪种方式发送 body 数据（如果有的话）。比如说，我们通过 http.request 拿到 ClientRequst 对象后，执行 ClientRequst 的 write 的函数，这时候 Node.js 无法知道 body 的具体大小，所以只能使用 chunk 模式进行发送。而如果是调用 ClientRequst 的 end 函数的话，Node.js 就可以直接算出 body 的长度，从而使用 content-length 模式。我们可以执行下面例子的代码，然后通过 WireShark 抓包观察（过滤条件为 tcp.srcport == 8888 || tcp.dstport == 8888）。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'ok'</span>)
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> client = http.<span class="hljs-title function_">request</span>({
        <span class="hljs-attr">port</span>: <span class="hljs-number">8888</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>
    });
    <span class="hljs-comment">// chunk 模式</span>
    client.<span class="hljs-title function_">write</span>(<span class="hljs-string">'hello'</span>);
    client.<span class="hljs-title function_">end</span>();
    <span class="hljs-comment">// content-length 模式</span>
    <span class="hljs-comment">// client.end('world');</span>
})
</code></pre>
<p>不管是 chunk 模式还是 content-length 模式，最终都是调用 _send 函数发送数据。</p>
<pre><code class="hljs language-kotlin">OutgoingMessage.prototype._send = function _send(<span class="hljs-keyword">data</span>, encoding, callback) {  
    <span class="hljs-comment">// 请求行 + 请求头 + 数据</span>
    <span class="hljs-keyword">data</span> = <span class="hljs-keyword">this</span>._header + <span class="hljs-keyword">data</span>;   
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._writeRaw(<span class="hljs-keyword">data</span>, encoding, callback);  
};  
  
OutgoingMessage.prototype._writeRaw = function _writeRaw(<span class="hljs-keyword">data</span>, encoding, callback) {     
    <span class="hljs-keyword">const</span> conn = <span class="hljs-keyword">this</span>.socket; 
    <span class="hljs-comment">// 已经建立了连接 &#x26;&#x26; 当前待处理的对象是自己 &#x26;&#x26; 可写</span>
    <span class="hljs-keyword">if</span> (conn &#x26;&#x26; conn._httpMessage === <span class="hljs-keyword">this</span> &#x26;&#x26; conn.writable) {
        <span class="hljs-comment">// 如果有缓存的数据则先发送缓存的数据</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.outputData.length) {
          <span class="hljs-keyword">this</span>._flushOutput(conn);
        }
        <span class="hljs-comment">// 接着发送当前需要发送的</span>
        <span class="hljs-keyword">return</span> conn.write(<span class="hljs-keyword">data</span>, encoding, callback);
    }
    <span class="hljs-comment">// 还不具备发送的条件，先缓存数据，等待条件满足</span>
    <span class="hljs-keyword">this</span>.outputData.push({ <span class="hljs-keyword">data</span>, encoding, callback });
    <span class="hljs-keyword">this</span>.outputSize += <span class="hljs-keyword">data</span>.length;
    <span class="hljs-keyword">this</span>._onPendingData(<span class="hljs-keyword">data</span>.length);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.outputSize &#x3C; HIGH_WATER_MARK;
}  
</code></pre>
<p>_writeRaw 中会判断当前是否满足发送的条件，比如是否已经建立了 TCP 连接，如果满足条件则直接调用 socket 发送数据，否则先缓存数据等待满足条件后再发送，比如连接成功后，Node.js 会调用 _flush 函数发送缓存的数据。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">OutgoingMessage.prototype._flush</span> = function _flush() {
  const <span class="hljs-attr">socket</span> = this.socket<span class="hljs-comment">;</span>
  const <span class="hljs-attr">ret</span> = this._flushOutput(socket)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

<span class="hljs-attr">OutgoingMessage.prototype._flushOutput</span> = function _flushOutput(socket) {
  // 之前设置了加塞，则操作 socket 先积攒数据
  while (this<span class="hljs-section">[kCorked]</span>) {
    this<span class="hljs-section">[kCorked]</span>--<span class="hljs-comment">;</span>
    socket.cork()<span class="hljs-comment">;</span>
  }

  const <span class="hljs-attr">outputLength</span> = this.outputData.length<span class="hljs-comment">;</span>
  const <span class="hljs-attr">outputData</span> = this.outputData<span class="hljs-comment">;</span>
  socket.cork()<span class="hljs-comment">;</span>
  // 把缓存的数据写到socket
  let ret<span class="hljs-comment">;</span>
  // 发送缓存的数据
  for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; outputLength; i++) {</span>
    const { data, encoding, callback } = outputData<span class="hljs-section">[i]</span><span class="hljs-comment">;</span>
    <span class="hljs-attr">ret</span> = socket.write(data, encoding, callback)<span class="hljs-comment">;</span>
  }
  socket.uncork()<span class="hljs-comment">;</span>
  // 更新数据结构
  <span class="hljs-attr">this.outputData</span> = []<span class="hljs-comment">;</span>
  this._onPendingData(-this.outputSize)<span class="hljs-comment">;</span>
  <span class="hljs-attr">this.outputSize</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>

  return ret<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>写完数据后，执行 ClientRequest 的 end 函数标记 HTTP 请求的结束。</p>
<h1>请求 Agent</h1>
<p>刚才讲解 HTTP 客户端时，我们讲到了 Agent 的概念，Agent 是对 TCP 连接进行了池化管理。简单的情况下，比如客户端发送一个 HTTP 请求之前，会先建立一个 TCP 连接，收到响应后会立刻关闭 TCP 连接。但是我们知道，TCP 的三次握手比较耗时，所以如果我们能复用 TCP 连接，在一个 TCP 连接上发送多个 HTTP 请求和接收多个 HTTP 响应，那性能肯定会得到一定的提升。</p>
<p>不过我们需要注意的是，Agent 的模式是在一个 TCP 连接上串行地发送请求和接收响应，不支持 HTTP PipeLine 模式。下面我们看一下 Agent 模块是如何实现 TCP 连接复用的。</p>
<pre><code class="hljs language-kotlin">function Agent(options) {  
  EventEmitter.call(<span class="hljs-keyword">this</span>);  
  <span class="hljs-keyword">this</span>.defaultPort = <span class="hljs-number">80</span>;  
  <span class="hljs-keyword">this</span>.protocol = <span class="hljs-string">'http:'</span>;  
  <span class="hljs-keyword">this</span>.options = { ...options };  
  <span class="hljs-comment">// path 字段表示是本机的进程间通信时使用的路径，比如 Unix 域路径  </span>
  <span class="hljs-keyword">this</span>.options.path = <span class="hljs-literal">null</span>;  
  <span class="hljs-comment">// socket 个数达到阈值后，等待空闲 socket 的请求  </span>
  <span class="hljs-keyword">this</span>.requests = {};  
  <span class="hljs-comment">// 正在使用的 socket  </span>
  <span class="hljs-keyword">this</span>.sockets = {};  
  <span class="hljs-comment">// 空闲 socket  </span>
  <span class="hljs-keyword">this</span>.freeSockets = {};  
  <span class="hljs-comment">// 空闲 socket 的存活时间  </span>
  <span class="hljs-keyword">this</span>.keepAliveMsecs = <span class="hljs-keyword">this</span>.options.keepAliveMsecs || <span class="hljs-number">1000</span>;  
  <span class="hljs-comment">/* 
    用完的 socket 是否放到空闲队列， 
      开启 keepalive 才会放到空闲队列， 
      不开启keepalive 
        还有等待 socket 的请求则复用 socket 
        没有等待 socket 的请求则直接销毁 socket 
  */</span>  
  <span class="hljs-keyword">this</span>.keepAlive = <span class="hljs-keyword">this</span>.options.keepAlive || <span class="hljs-literal">false</span>;  
  <span class="hljs-comment">// 最大的 socket 个数，包括正在使用的和空闲的 socket  </span>
  <span class="hljs-keyword">this</span>.maxSockets = <span class="hljs-keyword">this</span>.options.maxSockets || Agent.defaultMaxSockets;  
  <span class="hljs-comment">// 最大的空闲 socket 个数，超过后直接销毁  </span>
  <span class="hljs-keyword">this</span>.maxFreeSockets = <span class="hljs-keyword">this</span>.options.maxFreeSockets || <span class="hljs-number">256</span>;  
}  
</code></pre>
<p>Agent 维护了几个数据结构，分别是等待 socket 的请求、正在使用的 socket、空闲 socket。每一个数据结构是一个对象，对象的 key 是根据 HTTP 请求参数计算的，对象的值是一个队列，具体结构如图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a82b37cf5d3745b09286dcb5a657bee2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下面看一下 Agent 模块的具体实现。</p>
<h2>key 的计算</h2>
<p>key 的计算是池化管理的核心，正确地设计 key 的计算规则，才能更好地利用池化带来的好处。</p>
<pre><code class="hljs language-ini">// 一个请求对应的 key  
<span class="hljs-attr">Agent.prototype.getName</span> = function getName(options) {  
  let <span class="hljs-attr">name</span> = options.host || <span class="hljs-string">'localhost'</span><span class="hljs-comment">; </span>
  name += ':'<span class="hljs-comment">;  </span>
  if (options.port)  
    name += options.port<span class="hljs-comment">;  </span>
  name += ':'<span class="hljs-comment">;  </span>
  if (options.localAddress)  
    name += options.localAddress<span class="hljs-comment">;  </span>
  if (<span class="hljs-attr">options.family</span> === <span class="hljs-number">4</span> || options.family === <span class="hljs-number">6</span>)  
    name += `:${options.family}`<span class="hljs-comment">;  </span>
  if (options.socketPath)  
    name += `:${options.socketPath}`<span class="hljs-comment">; </span>
  return name<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
</code></pre>
<p>key 由 host、port、本地地址、地址簇类型、Unix 路径计算而来，所以不同的请求只有这些因子都一样的情况下才能复用连接。</p>
<h2>创建一个socket</h2>
<p>当调用方需要一个 socket，但是空闲 socket 队列里没有可用 socket 时就会创建一个新的 socket，对应的函数为 createSocket。</p>
<pre><code class="hljs language-javascript"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createSocket</span>(<span class="hljs-params">req, options, cb</span>) {  
   options = { ...options, ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> };  
   <span class="hljs-comment">// 计算 key</span>
   <span class="hljs-keyword">const</span> name = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getName</span>(options);  
   <span class="hljs-comment">// 创建 socket 完毕后执行的回调</span>
   <span class="hljs-keyword">const</span> <span class="hljs-title function_">oncreate</span> = (<span class="hljs-params">err, s</span>) => {  
     <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">sockets</span>[name]) {  
       <span class="hljs-variable language_">this</span>.<span class="hljs-property">sockets</span>[name] = [];  
     }  
     <span class="hljs-comment">// 插入正在使用的 socket 队列  </span>
     <span class="hljs-variable language_">this</span>.<span class="hljs-property">sockets</span>[name].<span class="hljs-title function_">push</span>(s); 
      <span class="hljs-comment">// 监听 socket 的一些事件，用于回收 socket </span>
     <span class="hljs-title function_">installListeners</span>(<span class="hljs-variable language_">this</span>, s, options); 
     <span class="hljs-comment">// 有可用 socket，通知调用方 </span>
     <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, s);  
   };  
   <span class="hljs-comment">// 创建一个新的 socket，默认使用 net.createConnection  </span>
   <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createConnection</span>(options, oncreate); 
 }  
   
 <span class="hljs-keyword">function</span> <span class="hljs-title function_">installListeners</span>(<span class="hljs-params">agent, s, options</span>) { 
   <span class="hljs-comment">/* 
     监听 socket 空闲事件，调用方使用完 socket 后触发，
     通知 agent socket 用完了，agent 会回收该 socket 到空闲队列   
   */</span> 
   s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'free'</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">onFree</span>(<span class="hljs-params"></span>) {  
     agent.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'free'</span>, s, options);  
   });  
   
   <span class="hljs-comment">// socket 关闭则 agent 会从 socket 队列中删除它  </span>
   s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">onClose</span>(<span class="hljs-params">err</span>) {  
     agent.<span class="hljs-title function_">removeSocket</span>(s, options);  
   });  
   
   <span class="hljs-comment">// 触发 agentRemove 事件，从 agent 中删除它，比如 socket 发生了错误  </span>
   s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'agentRemove'</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">onRemove</span>(<span class="hljs-params"></span>) {  
     agent.<span class="hljs-title function_">removeSocket</span>(s, options);  
     s.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">'close'</span>, onClose);  
     s.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">'free'</span>, onFree);  
     s.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">'agentRemove'</span>, onRemove);  
   });   
 }  
</code></pre>
<p>createSocket 首先调用 net 模块创建一个 socket，然后插入使用中的 socket 队列，最后通知调用方 socket 创建成功。同时 createSocket 也会监听 socket 的一些事件，比如 close 事件触发时从 Agent 的 socket 队列中删除该 socket，free 事件触发时通知 agent 回收该 socket。</p>
<h2>使用连接池</h2>
<p>接着我们看一下如何使用 Agent，刚才讲解 HTTP 客户端时讲过，当发起一个请求并且使用了 agent 时，Node.js 先调用 addRequest 创建一个连接，然后再发送请求。</p>
<pre><code class="hljs language-kotlin">function addRequest(req, options, port, localAddress) {  
  options = { ...options, ...<span class="hljs-keyword">this</span>.options };  
  <span class="hljs-comment">// 拿到请求对应的 key  </span>
  <span class="hljs-keyword">const</span> name = <span class="hljs-keyword">this</span>.getName(options);  
  <span class="hljs-comment">// 该 key 还没有在使用的 socekt 则初始化数据结构  </span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.sockets[name]) {  
    <span class="hljs-keyword">this</span>.sockets[name] = [];  
  }  
  <span class="hljs-comment">// 该 key 对应的空闲 socket 列表</span>
  <span class="hljs-keyword">const</span> freeLen = <span class="hljs-keyword">this</span>.freeSockets[name] ? <span class="hljs-keyword">this</span>.freeSockets[name].length : <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 该 key 对应的所有 socket 个数</span>
  <span class="hljs-keyword">const</span> sockLen = freeLen + <span class="hljs-keyword">this</span>.sockets[name].length;
  <span class="hljs-comment">// 该 key 有对应的空闲 socekt</span>
  <span class="hljs-keyword">if</span> (freeLen) {
    <span class="hljs-comment">// 获取一个该 key 对应的空闲 socket</span>
    <span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">this</span>.freeSockets[name].shift();
    <span class="hljs-comment">// 取完了删除，防止内存泄漏</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.freeSockets[name].length)
      delete <span class="hljs-keyword">this</span>.freeSockets[name];
    <span class="hljs-comment">// 设置 ref 标记，因为正在使用该socket</span>
    <span class="hljs-keyword">this</span>.reuseSocket(socket, req);
    <span class="hljs-comment">// 设置请求对应的 socket</span>
    setRequestSocket(<span class="hljs-keyword">this</span>, req, socket);
    <span class="hljs-comment">// 插入正在使用的socket队列</span>
    <span class="hljs-keyword">this</span>.sockets[name].push(socket);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sockLen &#x3C; <span class="hljs-keyword">this</span>.maxSockets) { 
    <span class="hljs-comment">/*
      如果该 key 没有对应的空闲 socket 并且使用的
      socket 个数还没有得到阈值，则继续创建
    */</span>
    <span class="hljs-keyword">this</span>.createSocket(req, options, handleSocketCreation(<span class="hljs-keyword">this</span>, req, <span class="hljs-literal">true</span>));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 没有空闲 socket 并且创建的个数也已经达到阈值了，</span>
    <span class="hljs-comment">// 则插入对待队列，等待该 key 下有空闲的 socket</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.requests[name]) {
      <span class="hljs-keyword">this</span>.requests[name] = [];
    }
    <span class="hljs-keyword">this</span>.requests[name].push(req);
  }
}  
</code></pre>
<p>addRequest 的代码很长，主要分为三种情况。</p>
<ol>
<li>有空闲 socket，则把它插入正在使用的 socket 队列中，并执行 setRequestSocket 通知调用方有可用 socket。</li>
</ol>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">setRequestSocket</span>(agent, req, socket) {  
  <span class="hljs-comment">// 通知请求 socket 创建成功  </span>
  req<span class="hljs-selector-class">.onSocket</span>(socket);   
}  

ClientRequest<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.onSocket</span> = function <span class="hljs-built_in">onSocket</span>(socket) {
  process<span class="hljs-selector-class">.nextTick</span>(onSocketNT, this, socket);
};

function <span class="hljs-built_in">onSocketNT</span>(req, socket) {
  <span class="hljs-built_in">tickOnSocket</span>(req, socket);
}

function <span class="hljs-built_in">tickOnSocket</span>(req, socket) {
  const parser = parsers<span class="hljs-selector-class">.alloc</span>();
  req<span class="hljs-selector-class">.socket</span> = socket;
  parser<span class="hljs-selector-class">.initialize</span>(HTTPParser.RESPONSE, ...);
  socket<span class="hljs-selector-class">.on</span>('error', socketErrorListener);
  socket<span class="hljs-selector-class">.on</span>('data', socketOnData);
  socket<span class="hljs-selector-class">.on</span>('end', socketOnEnd);
}
</code></pre>
<p>setRequestSocket 函数通过 req.onSocket(socket) 通知调用方有可用 socket，并分配了一个解析响应的 HTTP 解析器，这个刚才讲解 HTTP 客户端时已经讲过，就不再分析。</p>
<ol start="2">
<li>没有空闲 socket，但是使用的 socket 个数还没有达到阈值，则创建新的 socket，然后执行 handleSocketCreation，handleSocketCreation 中会执行 setRequestSocket 通知调用方。</li>
<li>没有空闲 socket 并且创建的个数也已经达到阈值了，则把请求插入等待 socket 队列，当有 socket 空闲时会触发 free 事件，我们看一下该事件的处理逻辑。</li>
</ol>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// this 为 Agent 对象</span>
<span class="hljs-keyword">this</span>.on(<span class="hljs-string">'free'</span>, (socket, options) => {
    <span class="hljs-comment">// 计算 key</span>
    <span class="hljs-keyword">const</span> name = <span class="hljs-keyword">this</span>.getName(options);
    <span class="hljs-comment">// socket还可写并且还有等待 socket 的请求，则复用 socket</span>
    <span class="hljs-keyword">if</span> (socket.writable &#x26;&#x26; <span class="hljs-keyword">this</span>.requests[name] &#x26;&#x26; <span class="hljs-keyword">this</span>.requests[name].length) {
      <span class="hljs-comment">// 拿到一个等待 socket 的请求，然后通知它有 socket 可用</span>
      <span class="hljs-keyword">const</span> req = <span class="hljs-keyword">this</span>.requests[name].shift();
      setRequestSocket(<span class="hljs-keyword">this</span>, req, socket);
      <span class="hljs-comment">// 没有等待 socket 的请求则删除，防止内存泄漏</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.requests[name].length === <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// don't leak</span>
        delete <span class="hljs-keyword">this</span>.requests[name];
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// socket 不可用写或者没有等待 socket 的请求了</span>
      <span class="hljs-keyword">const</span> req = socket._httpMessage;
      <span class="hljs-comment">// socket 可写并且允许复用 socket</span>
      <span class="hljs-keyword">if</span> (req &#x26;&#x26;
          req.shouldKeepAlive &#x26;&#x26;
          socket.writable &#x26;&#x26;
          <span class="hljs-keyword">this</span>.keepAlive) {
        let freeSockets = <span class="hljs-keyword">this</span>.freeSockets[name];
        <span class="hljs-comment">// 该 key 下当前的空闲 socket 个数</span>
        <span class="hljs-keyword">const</span> freeLen = freeSockets ? freeSockets.length : <span class="hljs-number">0</span>;
        let count = freeLen;
        <span class="hljs-comment">// 正在使用的 socket 个数</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sockets[name])
          count += <span class="hljs-keyword">this</span>.sockets[name].length;
        <span class="hljs-comment">// 该 key 使用的 socket 个数达到阈值或者空闲 socket 达到阈值，则不复用 socket，直接销毁 socket</span>
        <span class="hljs-keyword">if</span> (count > <span class="hljs-keyword">this</span>.maxSockets || freeLen >= <span class="hljs-keyword">this</span>.maxFreeSockets) {
          socket.destroy();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.keepSocketAlive(socket)) { <span class="hljs-comment">// 重新设置 socket 的存活时间，keepSocketAlive 一定返回 true</span>
          freeSockets = freeSockets || [];
          <span class="hljs-keyword">this</span>.freeSockets[name] = freeSockets;
          socket._httpMessage = <span class="hljs-literal">null</span>;
          <span class="hljs-comment">// 把 socket 从正在使用队列中移除</span>
          <span class="hljs-keyword">this</span>.removeSocket(socket, options);
          <span class="hljs-comment">// 插入 socket 空闲队列</span>
          freeSockets.push(socket);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// 不复用则直接销毁</span>
          socket.destroy();
        }
      } <span class="hljs-keyword">else</span> {
        socket.destroy();
      }
    }
  });
</code></pre>
<p>当有 socket 空闲时，分为以下几种情况。</p>
<ol>
<li>如果有等待 socket 的请求，则直接复用 socket。</li>
<li>如果没有等待 socket 的请求，允许复用并且 socket 个数没有达到阈值则插入空闲队列。</li>
<li>直接销毁。</li>
</ol>
<h2>Agent 的使用</h2>
<p>接下来，我们再通过一个例子来加深对 Agent 的理解。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);  

<span class="hljs-keyword">let</span> connections = <span class="hljs-number">0</span>;  

http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {  
    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'ok'</span>);
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-title function_">startClient</span>();
}).<span class="hljs-title function_">on</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'收到连接个数：'</span>, ++connections);  
});

<span class="hljs-keyword">function</span> <span class="hljs-title function_">startClient</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> options = { 
        <span class="hljs-attr">port</span>: <span class="hljs-number">8888</span>, 
        <span class="hljs-attr">headers</span>: {
            <span class="hljs-title class_">Connection</span>: <span class="hljs-string">'keep-alive'</span>,
        },
        <span class="hljs-attr">agent</span>: <span class="hljs-keyword">new</span> http.<span class="hljs-title class_">Agent</span>({ <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">maxSockets</span>: <span class="hljs-number">1</span> }),
    };
    <span class="hljs-comment">// 往同一个 host 和 port 发起两个连接</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">2</span>; i++) {
        <span class="hljs-keyword">let</span> index = i + <span class="hljs-number">1</span>;
        http.<span class="hljs-title function_">get</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =></span> {
            <span class="hljs-comment">// 监听 data 才能触发 end 事件</span>
            res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">() =></span> {});
            res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`request<span class="hljs-subst">${index}</span> end`</span>);
            });
        });
    }  
    <span class="hljs-keyword">let</span> requests = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(options.<span class="hljs-property">agent</span>.<span class="hljs-property">requests</span>)) {
        requests += v.<span class="hljs-property">length</span>;
    }
    <span class="hljs-comment">// 输出等待的请求个数，通过打印 options.agent.requests 可以看到请求对应的 key</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'等待 TCP 连接的请求数: '</span>, requests);
}
</code></pre>
<p>上面的代码中，首先创建了一个 HTTP 服务器，然后在客户端发起 HTTP 请求并使用 agent 管理 TCP 连接，但是 maxSocket 的值为 1，代表最多只能有一个 socket，而这时候客户端同时发送两个请求，所以有一个请求就会在排队，服务器也只收到了一个连接。</p>
<p>输出如下。</p>
<pre><code class="hljs language-arduino">等待 TCP 连接的请求数:  <span class="hljs-number">1</span>
收到连接个数： <span class="hljs-number">1</span>
request1 end
request2 end
</code></pre>
<p>可以看到 Agent 只创建了一个 socket，由两个请求是共用这个 socket，当一个请求用完这个 socket 后，下一个请求才会被发送。通过 WireShark 抓包如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a53859877ca24a3c8b09fe7868602b70~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如果把 maxSockets 改成 2，则输出如下。</p>
<pre><code class="hljs language-lua">等待 TCP 连接的请求数:  <span class="hljs-number">0</span>
收到连接个数： <span class="hljs-number">1</span>
收到连接个数： <span class="hljs-number">2</span>
request2 <span class="hljs-keyword">end</span>
request1 <span class="hljs-keyword">end</span>
/*
    或
    request1 <span class="hljs-keyword">end</span>
    request2 <span class="hljs-keyword">end</span>
*/
</code></pre>
<p>可以看到这时候 Agent 创建了两个 socket 给两个请求使用，最终哪个请求先返回也不确定。通过 WireShark 抓包如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f9328423acf4b3ebdee6ec421b7e20c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h1>总结</h1>
<p>HTTP 协议是我们日常工作中使用的最多的协议，在 Node.js 中，通过 API 可以非常简单地创建一个 HTTP 服务器和客户端，这背后其实涉及很多知识。这节课，我们从多方面对 Node.js 中的 HTTP 模块进行讲解，通过深入学习 Node.js 中 HTTP 模块的实现，可以加深我们对 HTTP 协议的理解，同时也帮助我们更好地使用 HTTP 模块。下面回顾一下这节课的内容。</p>
<ol>
<li>HTTP 协议是一种基于客户端 / 服务器架构的无状态的应用层协议，它的数据可以通过 TCP、UDP 和 Unix 进行传输。</li>
<li>llhttp 是目前 Node.js 的 HTTP 解析器，相对之前的解析器来说，llhttp 性能上有了比较大的提升。llhttp 通过钩子函数工作，通过了解 llhttp 的工作方式，不仅可以加深对 Node.js HTTP 模块的理解，我们还可以把 llhttp 用于自己的项目中。</li>
<li>详细讲解了 Node.js HTTP 服务器的实现过程，主要分为两个部分，首先通过 net 模块启动一个 TCP 服务器，然后通过 llhttp 来解析 TCP 服务器上收到的 HTTP 数据。除了基本的功能外，我们还介绍了 HTTP 管道化（在同一个 TCP 连接中并发发送多个请求，但是响应需要按序返回）、Connect 方法（通过 Connect 让 HTTP 代理服务器转发客户端的 TCP 流量到另一个真正的服务器中）以及协议升级（通过 HTTP 协议协商升级到另一个通信协议，后续就可以使用新的协议进行通信了）的功能，这些都是 HTTP 协议中比较核心的内容。</li>
<li>详细讲解了 HTTP 客户端的实现，HTTP 客户端的实现和服务器有点类似，首先创建一个 TCP 连接，然后发送 HTTP 请求报文，接着通过 llhttp 解析 TCP 连接上返回的 HTTP 响应报文。除了基本功能外，Node.js 还实现了 Agent 来管理客户端的 TCP 连接，它本质上是一个连接池，负责管理 Node.js 和第三方通信时的连接建立、空闲回收等。</li>
</ol></div>
</body></html>