<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Node.js 中 JS 和 C++对象的内存管理机制</h1>
<p>虽然 JS 自带 GC ，但开发者依然需要关注它的内存问题。 V8 会回收不再使用的对象，但如果开发者不再使用一个对象却保留了引用，该对象的内存就无法被释放，从而导致内存泄露。</p>
<p>Node.js 内部同样如此，Node.js 的维护者必须小心处理代码的逻辑以避免内存泄露。而且，相比前端，避免内存泄露在 Node.js 中更重要。前端页面通常不会长时间运行，刷新页面之后一切如初，但是 Node.js 通常作为长时间运行的进程，一旦发生内存泄露就会导致进程 OOM 退出。此外，如果释放了还需要使用的内存则会导致应用 Crash。这些情况都直接影响了服务的稳定性</p>
<p>在 Node.js 中，如果是单纯的 JS 对象，当我们不再使用该对象时，保证没有变量引用到该对象就可以保证它能被 GC。但如果是关联了 C++ 对象的 JS 对象，情况就复杂了。当我们不再使用该对象时，必须要保证 JS 和 C++ 对象共存亡和不要释放还需要使用的内存。Node.js 中解决这个问题主要是利用了 V8 提供的持久句柄和弱引用回调的机制。持久句柄保持对 JS 对象的引用使得不会被 GC，弱引用回调可以设置当只有该持久句柄引用了某 JS 对象时，这个 JS 对象可以被 GC 并执行持久句柄设置的回调函数，通过这个机制我们就可以解决这种复杂的场景。</p>
<p>本节课将会讲解不同场景下，Node.js 中 JS 和 C++ 对象的内存管理机制，这部分内容是非常核心的，其使用遍布 Node.js 整个项目中，理解它的实现将会帮助我们更深刻地理解 Node.js，同时也可以应用到我们的项目中。</p>
<h2>一个内存管理导致的问题</h2>
<p>之前写 Node.js Addon 的过程中，遇到了一个内存引起的 Crash 问题，最后经过排查发现是 ObjectWrap 弱引用导致的，代码如下，具体可以参考<a href="https://github.com/theanarkh/nodejs-book/tree/main/src/MemoryCase" target="_blank" rel="nofollow noopener noreferrer">这里</a>。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>: <span class="hljs-keyword">public</span> node::ObjectWrap {
   <span class="hljs-keyword">public</span>:
      <span class="hljs-built_in">Demo</span>(): node::<span class="hljs-built_in">ObjectWrap</span>() {
         <span class="hljs-built_in">uv_timer_init</span>(<span class="hljs-built_in">uv_default_loop</span>(), &#x26;timer);
         timer.data = <span class="hljs-keyword">this</span>;
         <span class="hljs-built_in">uv_timer_start</span>(&#x26;timer, [] (<span class="hljs-type">uv_timer_t</span> *timer) {
            Demo *demo = <span class="hljs-built_in">static_cast</span>&#x3C;Demo*>(timer->data);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"timeout%d\n"</span>, demo->i);
         }, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>);
      };
      ~<span class="hljs-built_in">Demo</span>() <span class="hljs-keyword">override</span> {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"~Demo\n"</span>);
      }
      <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">New</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
         Demo * demo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Demo</span>();
         <span class="hljs-comment">// 把 JS 的 new Demo() 对象和 C++ 的 Demo 对象互相关联起来</span>
         demo-><span class="hljs-built_in">Wrap</span>(args.<span class="hljs-built_in">This</span>());
         <span class="hljs-comment">// demo->Ref();</span>
         args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(args.<span class="hljs-built_in">This</span>());
      }

      <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">private</span>:
      <span class="hljs-type">uv_timer_t</span> timer;
};
</code></pre>
<p>在 Addon 中，定义了一个 Demo 的 C++ 类，然后导出这个类到 JS。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(
  Local&#x3C;Object> exports,
  Local&#x3C;Value> <span class="hljs-keyword">module</span>,
  Local&#x3C;Context> context
)</span> </span>{
  Isolate *isolate = context-><span class="hljs-built_in">GetIsolate</span>();
  Local&#x3C;FunctionTemplate> demo = FunctionTemplate::<span class="hljs-built_in">New</span>(isolate, Demo::New);
  <span class="hljs-type">const</span> <span class="hljs-type">char</span> * str = <span class="hljs-string">"Demo"</span>;
  Local&#x3C;String> name = String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, str, NewStringType::kNormal, <span class="hljs-built_in">strlen</span>(str)).<span class="hljs-built_in">ToLocalChecked</span>();
  demo-><span class="hljs-built_in">InstanceTemplate</span>()-><span class="hljs-built_in">SetInternalFieldCount</span>(<span class="hljs-number">1</span>);
  exports-><span class="hljs-built_in">Set</span>(context, name, demo-><span class="hljs-built_in">GetFunction</span>(context).<span class="hljs-built_in">ToLocalChecked</span>()).<span class="hljs-built_in">Check</span>();
}
</code></pre>
<p>然后在 JS 通过以下方式调用。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Demo</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">`./build/Release/addon`</span>);
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();
<span class="hljs-title function_">gc</span>();
</code></pre>
<p>当 JS 执行 new Demo 时就会执行 C++ 的 New 函数，然后创建一个 C++ Demo 对象，并且通过 Wrap 函数把 JS Demo 对象和 C++ Demo 对象关联起来，结构图如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09141fc0080348d1b1aab7ac41bc6fd5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>创建 C++ 对象时会注册一个定时器到 Libuv，该定时器会定期输出 Demo 对象 i 字段的值。但是执行代码的时候发现偶尔会出现 Crash。经过思考后想到应该是 Demo 对象被析构了，我接着给 Demo 类加了个析构函数。</p>
<pre><code class="hljs language-c++">~<span class="hljs-built_in">Demo</span>() {
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"~Demo\n"</span>);
}
</code></pre>
<p>最后发现，这个类对象居然被析构了。通过栈追踪发现逻辑来自于 ObjectWrap 的 WeakCallback。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e80fff4bc87a4a8ea7def5ac198717be~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>然后去看了一下 ObjectWrap::WeakCallback 的代码。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">WeakCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> v8::WeakCallbackInfo&#x3C;ObjectWrap>&#x26; data)</span> </span>{
   ObjectWrap* wrap = data.<span class="hljs-built_in">GetParameter</span>();
   wrap->handle_.<span class="hljs-built_in">Reset</span>();
   <span class="hljs-keyword">delete</span> wrap;
}
</code></pre>
<p>delete wrap 就是 delete 了 Demo 对象。而这个 WeakCallback 的源头来自 ObjectWrap 的 MakeWeak。</p>
<pre><code class="hljs language-c++"> <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">MakeWeak</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">persistent</span>().<span class="hljs-built_in">SetWeak</span>(<span class="hljs-keyword">this</span>, WeakCallback, v8::WeakCallbackType::kParameter);
 }
</code></pre>
<p>而 MakeWeak 的调用又来源于 Wrap。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Wrap</span><span class="hljs-params">(v8::Local&#x3C;v8::Object> handle)</span> </span>{
    <span class="hljs-comment">// 关联 C++ 对象和 Demo 对象</span>
    handle-><span class="hljs-built_in">SetAlignedPointerInInternalField</span>(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);
    <span class="hljs-built_in">persistent</span>().<span class="hljs-built_in">Reset</span>(v8::Isolate::<span class="hljs-built_in">GetCurrent</span>(), handle);
    <span class="hljs-built_in">MakeWeak</span>();
}
</code></pre>
<p>通过 Wrap 可以知道，ObjectWrap 默认情况下调用了 MakeWeak，也就是当只有 C++ Demo 对象引用 JS 层的对象时，该 JS 对象会被 GC。又因为 JS 层在创建完 Demo 对象后就离开了作用域，所以就导致了 JS Demo 对象最终被 C++ Demo 对象以弱引用的方式引用着，从而被 GC 了。这个问题的解决方式就是调用 ObjectWrap 的 Ref 函数消除弱引用（或者在 JS 层保持对这个对象的引用）。</p>
<pre><code class="hljs language-c++"> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Ref</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">persistent</span>().<span class="hljs-built_in">ClearWeak</span>();
    refs_++;
 }
</code></pre>
<p>Ref 函数清除了弱引用 JS 不会被 GC，从而 C++ Demo 对象也不会被析构。另外值得一提的是并不总是会发生 Crash，因为析构后的内存如果不被其他数据覆盖，那么我们还是可以继续访问的，而如果内存被其他数据覆盖之外，我们再通过指针访问就可能发生 Crash，但是不管怎么样，访问一个被析构的对象都是一种危险的操作。</p>
<h2>Node.js 的内存管理机制</h2>
<p>通过刚才的例子可以看到，内存管理是一个非常重要的知识，一不小心就会导致应用 Crash。在 Node.js 的实现中，内存管理和刚才的例子很相似，很多功能都是由 C++ 模块实现，然后暴露到 JS 使用的。</p>
<ol>
<li><strong>基于 HandleWrap 的内存管理机制</strong></li>
</ol>
<p>下面以 UDP 模块为例介绍基于 HandleWrap 的模块的内存管理机制，首先看一下 C++ 层的 UDP 模块给 JS 层暴露的功能。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UDPWrap::Initialize</span><span class="hljs-params">(Local&#x3C;Object> target,
                         Local&#x3C;Value> unused,
                         Local&#x3C;Context> context,
                         <span class="hljs-type">void</span>* priv)</span> </span>{
  Environment* env = Environment::<span class="hljs-built_in">GetCurrent</span>(context);
  <span class="hljs-comment">// 创建一个函数模版</span>
  Local&#x3C;FunctionTemplate> t = env-><span class="hljs-built_in">NewFunctionTemplate</span>(New);
  t-><span class="hljs-built_in">InstanceTemplate</span>()-><span class="hljs-built_in">SetInternalFieldCount</span>(<span class="hljs-number">1</span>);
  Local&#x3C;String> udpString = <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(env-><span class="hljs-built_in">isolate</span>(), <span class="hljs-string">"UDP"</span>);
  t-><span class="hljs-built_in">SetClassName</span>(udpString);
  <span class="hljs-comment">// 设置一些原型方法</span>
  env-><span class="hljs-built_in">SetProtoMethod</span>(t, <span class="hljs-string">"open"</span>, Open);
  <span class="hljs-comment">// 继承 HandleWrap 的方法，JS 层可以调用，比如 close</span>
  t-><span class="hljs-built_in">Inherit</span>(HandleWrap::<span class="hljs-built_in">GetConstructorTemplate</span>(env));
  <span class="hljs-comment">// 设置一系列函数</span>
  <span class="hljs-comment">// 暴露到 JS 层</span>
  target-><span class="hljs-built_in">Set</span>(env-><span class="hljs-built_in">context</span>(),
              udpString,
              t-><span class="hljs-built_in">GetFunction</span>(env-><span class="hljs-built_in">context</span>()).<span class="hljs-built_in">ToLocalChecked</span>()).<span class="hljs-built_in">Check</span>();
}
</code></pre>
<p>接着看一下在 JS 层是如何使用的。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">UDP</span> } = <span class="hljs-title function_">internalBinding</span>(<span class="hljs-string">'udp_wrap'</span>);
</code></pre>
<p>internalBinding 用于加载 C++ 模块，可以看到 C++ 模块暴露了一个对象 UDP，当我们创建一个 UDP Socket 时，就会相应的创建一个 C++ 层的 UDP 对象，以下为示例代码。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSocket</span>(<span class="hljs-params">type, listener</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(type, listener);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Socket</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handle</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">UDP</span>();
}
</code></pre>
<p>接下来看一下当执行 new UDP 时 C++ 的逻辑，根据 C++ 模块的定义，这时候会执行 UDPWrap::New。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UDPWrap::New</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
  Environment* env = Environment::<span class="hljs-built_in">GetCurrent</span>(args);
  <span class="hljs-comment">// args.This() 为 JS 层 this.handle 引用的对象</span>
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">UDPWrap</span>(env, args.<span class="hljs-built_in">This</span>());
}

UDPWrap::<span class="hljs-built_in">UDPWrap</span>(Environment* env, Local&#x3C;Object> object)
    : <span class="hljs-built_in">HandleWrap</span>(env, object, ...) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>UDPWrap 继承 HandleWrap，HandleWrap 继承 AsyncWrap，AsyncWrap 继承 BaseObject。我们直接看 BaseObject。</p>
<pre><code class="hljs language-c++">BaseObject::<span class="hljs-built_in">BaseObject</span>(Environment* env, v8::Local&#x3C;v8::Object> object)
    : <span class="hljs-built_in">persistent_handle_</span>(env-><span class="hljs-built_in">isolate</span>(), object), <span class="hljs-built_in">env_</span>(env) {
  <span class="hljs-comment">// 把 this存到 object中</span>
  object-><span class="hljs-built_in">SetAlignedPointerInInternalField</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">static_cast</span>&#x3C;<span class="hljs-type">void</span>*>(<span class="hljs-keyword">this</span>));
  <span class="hljs-comment">// env 退出释放当前 this 对象的内存</span>
  env-><span class="hljs-built_in">AddCleanupHook</span>(DeleteMe, <span class="hljs-built_in">static_cast</span>&#x3C;<span class="hljs-type">void</span>*>(<span class="hljs-keyword">this</span>));
}
</code></pre>
<p>前面的课程讲过，BaseObject 用于关联 JS 和 C++ 对象，关系图如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f12d1e1c5884074b9195af707efc57b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>因为 C++ 层通过持久句柄 persistent_handle_ 引用了 JS 的对象 object，所以就算 JS 层没有变量引用 object 它也不会被 GC。那么它什么时候会被 GC 呢？那就是当调用 Socket 的 close 时。</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Socket</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">close</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) {
  <span class="hljs-comment">// 下面是示例代码</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">handle</span>.<span class="hljs-title function_">close</span>();
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">handle</span> = <span class="hljs-literal">null</span>;
 }
</code></pre>
<p>这里有两个操作，首先调用了 C++ 的 close 函数，然后把 handle 置为 null，即不再引用。因为 UDP 继承了 HandleWrap，所以这里的 close 其实就是 HandleWrap 的 close。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrap::Close</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
  HandleWrap* wrap;
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap, args.<span class="hljs-built_in">Holder</span>());
  wrap-><span class="hljs-built_in">Close</span>(args[<span class="hljs-number">0</span>]);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrap::Close</span><span class="hljs-params">(Local&#x3C;Value> close_callback)</span> </span>{
  <span class="hljs-built_in">uv_close</span>(handle_, OnClose);
}
</code></pre>
<p>HandleWrap 是对 Libuv handle 的封装，所以需要先关闭 handle，接着在 close 阶段执行回调。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrap::OnClose</span><span class="hljs-params">(<span class="hljs-type">uv_handle_t</span>* handle)</span> </span>{
  <span class="hljs-comment">// BaseObjectPtr 管理 HandleWrap 对象</span>
  BaseObjectPtr&#x3C;HandleWrap> wrap { <span class="hljs-built_in">static_cast</span>&#x3C;HandleWrap*>(handle->data) };
  wrap-><span class="hljs-built_in">Detach</span>();
}
</code></pre>
<p>BaseObjectPtr 是一个智能指针（using BaseObjectPtr = BaseObjectPtrImpl&#x3C;T, false>），里面维护了 HandleWrap 对象。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">bool</span> kIsWeak>
BaseObjectPtrImpl&#x3C;T, kIsWeak>::<span class="hljs-built_in">BaseObjectPtrImpl</span>(T* target)
  : <span class="hljs-built_in">BaseObjectPtrImpl</span>() {
  data_.target = target;
  <span class="hljs-built_in">get</span>()-><span class="hljs-built_in">increase_refcount</span>();
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseObject::increase_refcount</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// 引用数加一</span>
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prev_refcount = <span class="hljs-built_in">pointer_data</span>()->strong_ptr_count++;
  <span class="hljs-comment">// 如果之前引用数为 0，则清除弱引用回调，防止被 GC</span>
  <span class="hljs-keyword">if</span> (prev_refcount == <span class="hljs-number">0</span> &#x26;&#x26; !persistent_handle_.<span class="hljs-built_in">IsEmpty</span>())
    persistent_handle_.<span class="hljs-built_in">ClearWeak</span>();
}
</code></pre>
<p>接着看一下 Detach 的逻辑。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseObject::Detach</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">pointer_data</span>()->is_detached = <span class="hljs-literal">true</span>;
}
</code></pre>
<p>Detach 只是设置了一个标记，在执行完 OnClose 后 BaseObjectPtr 会被析构。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">bool</span> kIsWeak>
BaseObjectPtrImpl&#x3C;T, kIsWeak>::~<span class="hljs-built_in">BaseObjectPtrImpl</span>() {
    <span class="hljs-comment">// get() 返回 BaseObject*</span>
    <span class="hljs-built_in">get</span>()-><span class="hljs-built_in">decrease_refcount</span>();
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseObject::decrease_refcount</span><span class="hljs-params">()</span> </span>{
  PointerData* metadata = <span class="hljs-built_in">pointer_data</span>();
  <span class="hljs-comment">// 引用数减一</span>
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> new_refcount = --metadata->strong_ptr_count;
  <span class="hljs-keyword">if</span> (new_refcount == <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// 为 true</span>
    <span class="hljs-keyword">if</span> (metadata->is_detached) {
      <span class="hljs-comment">// OnGCCollect 最终执行 delete this;</span>
      <span class="hljs-built_in">OnGCCollect</span>();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (metadata->wants_weak_jsobj &#x26;&#x26; !persistent_handle_.<span class="hljs-built_in">IsEmpty</span>()) {
      <span class="hljs-built_in">MakeWeak</span>();
    }
  }
}
</code></pre>
<p>BaseObjectPtr 析构后就会释放 this 指针指向的内存，从而 BaseObject 对象的字段 persistent_handle_ 对象（Global 类型）也被析构。</p>
<pre><code class="hljs language-c++">~<span class="hljs-built_in">Global</span>() { <span class="hljs-keyword">this</span>-><span class="hljs-built_in">Reset</span>(); }
</code></pre>
<p>Reset 使得 persistent_handle_不再引用 JS 对象，最终 JS 对象失去了所有的引用，从而 JS 对象也被 GC。可以通过一个例子看一下。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);
<span class="hljs-keyword">const</span> socket = dgram.<span class="hljs-title function_">createSocket</span>(<span class="hljs-string">'udp4'</span>);
socket.<span class="hljs-title function_">close</span>();
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">gc</span>();
}, <span class="hljs-number">1000</span>);
</code></pre>
<p>下面是具体的调用栈。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b63058caa21742c2ba21715f54758e01~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>HandleWrap 的子类比较复杂，因为在结束之前要保证先关闭 Libuv 的 handle。这种内存管理方式依赖于用户主动关闭 handle 才会释放内存。</p>
<ol start="2">
<li><strong>基于 ReqWrap 的内存管理机制</strong></li>
</ol>
<p>接下来看一下基于 ReqWrap 的请求对象的内存管理机制，以 TCP 的 TCPConnectWrap 为例，首先看一下 C++ 层 TCPConnectWrap 的定义。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 创建一个函数模版</span>
Local&#x3C;FunctionTemplate> cwt = BaseObject::<span class="hljs-built_in">MakeLazilyInitializedJSTemplate</span>(env);
cwt-><span class="hljs-built_in">Inherit</span>(AsyncWrap::<span class="hljs-built_in">GetConstructorTemplate</span>(env));
<span class="hljs-built_in">SetConstructorFunction</span>(context, target, <span class="hljs-string">"TCPConnectWrap"</span>, cwt);
</code></pre>
<p>以上 C++ 代码给 JS 暴露了一个 TCPConnectWrap 函数，类似 C++ 层暴露的 TCP 函数 一样，但是在 JS 层执行 new TCPConnectWrap 时不会关联到 C++ 层的某一个对象，接下来看看如何使用。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TCPConnectWrap</span>();
req.<span class="hljs-property">oncomplete</span> = afterConnect;
req.<span class="hljs-property">address</span> = address;
req.<span class="hljs-property">port</span> = port;
req.<span class="hljs-property">localAddress</span> = localAddress;
req.<span class="hljs-property">localPort</span> = localPort;
<span class="hljs-comment">// _handle 为 new TCP 返回的对象</span>
self.<span class="hljs-property">_handle</span>.<span class="hljs-title function_">connect</span>(req, address, port);
<span class="hljs-comment">// 执行完后 JS 层将失去对 TCPConnectWrap 的引用</span>
</code></pre>
<p>当发起一个 TCP 连接时，就会创建一个 TCPConnectWrap 表示一次连接请求，接着看 C++ 层 connect 的逻辑。</p>
<pre><code class="hljs language-c++">ConnectWrap* req_wrap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConnectWrap</span>(env, req_wrap_obj, ...);
</code></pre>
<p>C++ 层首先创建了一个 ConnectWrap 对象，ConnectWrap 继承 ReqWrap，ReqWrap 继承 AsyncWrap，AsyncWrap 继承 BaseObject。所以 new ConnectWrap 就是把 JS 层传进来的 TCPConnectWrap 和 C++ 层的 ConnectWrap 关联起来，另外 ReqWrap 构造函数中有一个非常关键的操作。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> T>
ReqWrap&#x3C;T>::<span class="hljs-built_in">ReqWrap</span>(Environment* env,
                    v8::Local&#x3C;v8::Object> object,
                    ...)
    : <span class="hljs-built_in">AsyncWrap</span>(env, object, provider),
      <span class="hljs-built_in">ReqWrapBase</span>(env) {
  <span class="hljs-built_in">MakeWeak</span>();
}
</code></pre>
<p>MakeWeak 用于给持久引用设置弱引用回调。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseObject::MakeWeak</span><span class="hljs-params">()</span> </span>{
  persistent_handle_.<span class="hljs-built_in">SetWeak</span>(
      <span class="hljs-keyword">this</span>,
      [](<span class="hljs-type">const</span> WeakCallbackInfo&#x3C;BaseObject>&#x26; data) {
        <span class="hljs-comment">//</span>
      },
      WeakCallbackType::kParameter);
}
</code></pre>
<p>回调的逻辑我们在后面再具体分析。创建完 ConnectWrap 后，接着执行了 req_wrap->Dispatch。</p>
<pre><code class="hljs language-c++">err = req_wrap-><span class="hljs-built_in">Dispatch</span>(uv_tcp_connect,
                         &#x26;wrap->handle_,
                         <span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">const</span> sockaddr*>(&#x26;addr),
                         AfterConnect);
  <span class="hljs-comment">// err &#x3C; 0</span>
  <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-keyword">delete</span> req_wrap;
</code></pre>
<p>如果 Dispatch 调用 Libuv 的 uv_tcp_connect 失败则直接删除 req_wrap， 即释放 ConnectWrap 对象的内存。ConnectWrap 析构的时候，父类 BaseObject 的 persistent_handle_ 也会析构，从而 JS 层的对象 TCPConnectWrap 将失去唯一的引用，最后被 GC。接下来再看看 Libuv 操作成功的逻辑。</p>
<pre><code class="hljs language-c++"><span class="hljs-type">int</span> ReqWrap&#x3C;T>::<span class="hljs-built_in">Dispatch</span>(LibuvFunction fn, Args... args) {
  <span class="hljs-type">int</span> err = CallLibuvFunction&#x3C;T, LibuvFunction>::<span class="hljs-built_in">Call</span>(
      fn,
      <span class="hljs-built_in">env</span>()-><span class="hljs-built_in">event_loop</span>(),
      <span class="hljs-built_in">req</span>(),
      MakeLibuvRequestCallback&#x3C;T, Args>::<span class="hljs-built_in">For</span>(<span class="hljs-keyword">this</span>, args)...);
  <span class="hljs-comment">// 操作成功</span>
  <span class="hljs-keyword">if</span> (err >= <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">ClearWeak</span>();
    <span class="hljs-built_in">env</span>()-><span class="hljs-built_in">IncreaseWaitingRequestCounter</span>();
  }
  <span class="hljs-keyword">return</span> err;
}
</code></pre>
<p>这里有两个关键的操作，第一个 ClearWeak，ClearWeak 是删除 ReqWrap 构造函数中设置的弱引用回调，使得 JS 层 TCPConnectWrap 对象被 ConnectWrap 的持久句柄 persistent_handle_ 引用，所以不会被 GC，否则因为连接是一个异步操作，在等待连接结果的过程中 JS 对象被 GC 会导致进程 Crash。另一个关键操作是 For 函数。</p>
<pre><code class="hljs language-c++">  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Wrapper</span><span class="hljs-params">(ReqT* req, Args... args)</span> </span>{
    <span class="hljs-comment">// BaseObjectPtr 构造函数导致 C++ 对象的引用数加一</span>
    BaseObjectPtr&#x3C;ReqWrap&#x3C;ReqT>> req_wrap{ReqWrap&#x3C;ReqT>::<span class="hljs-built_in">from_req</span>(req)};
    req_wrap-><span class="hljs-built_in">Detach</span>();
    req_wrap-><span class="hljs-built_in">env</span>()-><span class="hljs-built_in">DecreaseWaitingRequestCounter</span>();
    F original_callback = <span class="hljs-built_in">reinterpret_cast</span>&#x3C;F>(req_wrap->original_callback_);
    <span class="hljs-built_in">original_callback</span>(req, args...);
  }
  
  <span class="hljs-function"><span class="hljs-type">static</span> F <span class="hljs-title">For</span><span class="hljs-params">(ReqWrap&#x3C;ReqT>* req_wrap, F v)</span> </span>{
    <span class="hljs-comment">// 保存原始回调函数</span>
    req_wrap->original_callback_ = <span class="hljs-keyword">reinterpret_cast</span>&#x3C;<span class="hljs-keyword">typename</span> ReqWrap&#x3C;ReqT>::<span class="hljs-type">callback_t</span>>(v);
    <span class="hljs-keyword">return</span> Wrapper;
  }
</code></pre>
<p>For 函数保存了原始回调，然后返回一个 Wrapper 函数，当 Libuv 回调时就会执行 Wrapper，Wrapper 中通过拿到的 C++ 对象 ReqWrap（ConnectWrap 是 ReqWrap 的子类） 定义了一个智能指针 BaseObjectPtr（ConnectWrap 引用数加一），然后调用 Detach，前面讲过 Detach 会设置一个 detach 标记，调完 Detach 后就执行真正的回调函数 original_callback，这里是 AfterConnect。</p>
<pre><code class="hljs language-c++"><span class="hljs-type">void</span> ConnectionWrap&#x3C;WrapType, UVType>::<span class="hljs-built_in">AfterConnect</span>(<span class="hljs-type">uv_connect_t</span>* req,
                                                    <span class="hljs-type">int</span> status) {
  BaseObjectPtr&#x3C;ConnectWrap> req_wrap{<span class="hljs-built_in">static_cast</span>&#x3C;ConnectWrap*>(req->data)};
  <span class="hljs-comment">// 执行 JS 回调</span>
 }
</code></pre>
<p>AfterConnect 中也定义了一个 BaseObjectPtr，所以这时候 C++ 对象 ConnectWrap 引用数又加 1 变成 2，接着执行了 JS 层回调函数，执行完之后，Wrapper 和 AfterConnect 函数中的 BaseObjectPtr 会析构，从而 ConnectWrap 对象被析构，最终 BaseObject 的持久句柄会被析构，JS 对象失去最后一个引用而被 GC（如果该对象返回给 JS 层使用，则在 JS 层失去引用后再被 GC）。下面看一个例子。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">gc</span>();
}, <span class="hljs-number">2000</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-comment">// 随便连接一个端口</span>
    net.<span class="hljs-title function_">connect</span>(<span class="hljs-number">8888</span>, <span class="hljs-string">'127.0.0.1'</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">() =></span> {});
}, <span class="hljs-number">1000</span>);
</code></pre>
<p>下图为 AfterConnect 中 BaseObjectPtr 对象析构时的调用栈。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4a65152160d41cca9d9adea064a8822~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这时候 BaseObject 的引用数为 2，减去 1 为 1。下图为 Wrapper 函数中 BaseObjectPtr 对象析构时的调用栈。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6774e5bf7a9432093c241d1fbc1104f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>Wrapper 中的 BaseObjectPtr 析构后，BaseObject 的引用数为 0，所以会释放 BaseObject 的内存，从而持久句柄 persistent_handle_ 被析构，最后 JS 对象 TCPConnectWrap 被 GC。这种方式对用户是无感知的，完全由 Node.js 控制内存的使用和释放。</p>
<ol start="3">
<li>关联底层资源的 JS 对象的内存管理机制</li>
</ol>
<p>正常来说，JS 对象失去引用后会直接被 V8 GC 回收，我们不需要额外关注，但是如果这个 JS 对象关联了底层的资源，比如 C++ 对象，那情况就会变得不一样了。这里以 trace_events 模块为例，我们可以通过 trace_events 的 createTracing 创建一个收集 trace event 数据的对象。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createTracing</span>(<span class="hljs-params">options</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tracing</span>(options.<span class="hljs-property">categories</span>);
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tracing</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">categories</span>) {
    <span class="hljs-variable language_">this</span>[kHandle] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CategorySet</span>(categories);
  }
}
</code></pre>
<p>createTracing 中创建了一个 Tracing 对象，Tracing 对象中又创建了一个 CategorySet 对象，CategorySet 是 C++ 层导出的函数。</p>
<pre><code class="hljs language-c++">  Local&#x3C;FunctionTemplate> category_set = <span class="hljs-built_in">NewFunctionTemplate</span>(isolate, NodeCategorySet::New);
  category_set-><span class="hljs-built_in">InstanceTemplate</span>()-><span class="hljs-built_in">SetInternalFieldCount</span>(NodeCategorySet::kInternalFieldCount);
  category_set-><span class="hljs-built_in">Inherit</span>(BaseObject::<span class="hljs-built_in">GetConstructorTemplate</span>(env));
  <span class="hljs-built_in">SetConstructorFunction</span>(context, target, <span class="hljs-string">"CategorySet"</span>, category_set);
</code></pre>
<p>JS 执行 new CategorySet 时会执行 C++ 的 NodeCategorySet::New。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NodeCategorySet::New</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
  Environment* env = Environment::<span class="hljs-built_in">GetCurrent</span>(args);
  <span class="hljs-comment">// 忽略其他代码</span>
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">NodeCategorySet</span>(env, args.<span class="hljs-built_in">This</span>(), std::<span class="hljs-built_in">move</span>(categories));
}
</code></pre>
<p>最终创建了一个 NodeCategorySet 对象，NodeCategorySet 继承 BaseObject。</p>
<pre><code class="hljs language-c++">  <span class="hljs-built_in">NodeCategorySet</span>(Environment* env,
                  Local&#x3C;Object> wrap,
                  std::set&#x3C;std::string>&#x26;&#x26; categories) :
        <span class="hljs-built_in">BaseObject</span>(env, wrap), <span class="hljs-built_in">categories_</span>(std::<span class="hljs-built_in">move</span>(categories)) {
    <span class="hljs-built_in">MakeWeak</span>();
  }
</code></pre>
<p>NodeCategorySet 默认调用了 MakeWeak，所以如果 JS 层没有变量引用 new CategorySet 返回的对象，则它会被 GC。下面看一个例子。</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">gc</span>();
}, <span class="hljs-number">1000</span>);

<span class="hljs-keyword">const</span> trace_events = <span class="hljs-built_in">require</span>(<span class="hljs-string">'trace_events'</span>);
trace_events.<span class="hljs-title function_">createTracing</span>({<span class="hljs-attr">categories</span>: [<span class="hljs-string">'node.perf'</span>, <span class="hljs-string">'node.async_hooks'</span>]});
</code></pre>
<p>因为 trace_events.createTracing 返回的对象没有被任何变量引用，导致 Tracing 对象中的 CategorySet 也没有被引用，从而被 GC，下面是调用栈。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a1caccf02444bc59e86fc8eb51f3817~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如果我们把 createTracing 返回的对象赋值给 global.demo，则不会被 GC。下面再来看一个例子。</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">gc</span>();
}, <span class="hljs-number">1000</span>);

<span class="hljs-keyword">const</span> trace_events = <span class="hljs-built_in">require</span>(<span class="hljs-string">'trace_events'</span>);
<span class="hljs-keyword">const</span> events = trace_events.<span class="hljs-title function_">createTracing</span>({<span class="hljs-attr">categories</span>: [<span class="hljs-string">'node.perf'</span>, <span class="hljs-string">'node.async_hooks'</span>]});
events.<span class="hljs-title function_">enable</span>();
</code></pre>
<p>执行 enable 后也不会被 GC，为什么呢？看看 enable 的实现。</p>
<pre><code class="hljs language-js">  <span class="hljs-keyword">const</span> enabledTracingObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeSet</span>();

  <span class="hljs-title function_">enable</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 忽略其他代码</span>
    enabledTracingObjects.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>);
  }
</code></pre>
<p>enable 会把 this 加入到了 enabledTracingObjects 变量，而 enabledTracingObjects 是一直存在的，所以 Tracing 不会被 GC。从 trace_events 的内存管理机制中可以看到，对于关联了 C++ 对象的 JS 对象，需要设置弱引用回调，这样当 JS 对象失去引用而被 GC 时，它关联的 C++ 对象才可以被释放，否则就会造成内存泄露。</p>
<ol start="4">
<li>基于引用数的对象的内存管理机制</li>
</ol>
<p>刚才 trace_events 的例子中，关联了 C++ 对象的 JS 对象是直接暴露给用户的，所以只需要设置弱引用回调，然后在 JS 对象被 GC 时释放关联的 C++ 对象即可。但是如果这个 JS 对象是由 Node.js 内核管理，然后通过其他 API 来操作这个对象的话，情况又变得不一样了。接下来再以 diagnostics_channel 的代码为例看看另一种使用方式。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> channels = <span class="hljs-title class_">ObjectCreate</span>(<span class="hljs-literal">null</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">channel</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Channel</span>(name);
  channels[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>(channel);
  <span class="hljs-keyword">return</span> channel;
}
</code></pre>
<p>我们可以通过 diagnostics_channel 的 channel 函数创建一个 Channel 对象，然后以此作为订阅发布机制。当 Node.js 创建一个 Channel 对象时，它会以该 Channel 对象为参数创建一个 WeakReference 对象，然后把 WeakReference 对象保存到 channels 中，结构图如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27fce077af2c4195bc95e9a6466a4823~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>WeakReference 是 C++ 提供的对象。</p>
<pre><code class="hljs language-c++">  Local&#x3C;FunctionTemplate> weak_ref = <span class="hljs-built_in">NewFunctionTemplate</span>(isolate, WeakReference::New);
  weak_ref-><span class="hljs-built_in">InstanceTemplate</span>()-><span class="hljs-built_in">SetInternalFieldCount</span>(WeakReference::kInternalFieldCount);
  weak_ref-><span class="hljs-built_in">Inherit</span>(BaseObject::<span class="hljs-built_in">GetConstructorTemplate</span>(env));
  <span class="hljs-built_in">SetProtoMethod</span>(isolate, weak_ref, <span class="hljs-string">"get"</span>, WeakReference::Get);
  <span class="hljs-built_in">SetProtoMethod</span>(isolate, weak_ref, <span class="hljs-string">"incRef"</span>, WeakReference::IncRef);
  <span class="hljs-built_in">SetProtoMethod</span>(isolate, weak_ref, <span class="hljs-string">"decRef"</span>, WeakReference::DecRef);
  <span class="hljs-built_in">SetConstructorFunction</span>(context, target, <span class="hljs-string">"WeakReference"</span>, weak_ref);
</code></pre>
<p>当在 JS 层执行 new WeakReference 时，就会执行 C++ 的 WeakReference::New。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WeakReference::New</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
  Environment* env = Environment::<span class="hljs-built_in">GetCurrent</span>(args);
  <span class="hljs-comment">// args.This() 为 JS 执行 new WeakReference 返回的对象，</span>
  <span class="hljs-comment">// args[0] 为 JS 层传入的第一个参数</span>
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakReference</span>(env, args.<span class="hljs-built_in">This</span>(), args[<span class="hljs-number">0</span>].<span class="hljs-built_in">As</span>&#x3C;Object>());
}
</code></pre>
<p>接着看 WeakReference 构造函数。</p>
<pre><code class="hljs language-c++">WeakReference::<span class="hljs-built_in">WeakReference</span>(Environment* env,
                             Local&#x3C;Object> object,
                             Local&#x3C;Object> target)
    : <span class="hljs-built_in">WeakReference</span>(env, object, target, <span class="hljs-number">0</span>) {}
    
WeakReference::<span class="hljs-built_in">WeakReference</span>(Environment* env,
                             Local&#x3C;Object> object,
                             Local&#x3C;Object> target,
                             <span class="hljs-type">uint64_t</span> reference_count)
    : <span class="hljs-built_in">SnapshotableObject</span>(env, object, type_int), <span class="hljs-comment">// </span>
    <span class="hljs-built_in">reference_count_</span>(reference_count) {
  <span class="hljs-comment">// 如果 JS 层没有变量引用 new WeakReference 返回的对象，则释放 C++ 的 WeakReference 对象的内存</span>
  <span class="hljs-built_in">MakeWeak</span>();
  <span class="hljs-keyword">if</span> (!target.<span class="hljs-built_in">IsEmpty</span>()) {
    <span class="hljs-comment">// target_ 是持久句柄，保存对传入的 JS 对象（Channel）的引用</span>
    target_.<span class="hljs-built_in">Reset</span>(env-><span class="hljs-built_in">isolate</span>(), target);
    <span class="hljs-keyword">if</span> (reference_count_ == <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// 如果只有 target_ 引用传入的 JS 对象，则该 JS 对象可以被 GC</span>
      target_.<span class="hljs-built_in">SetWeak</span>();
    }
  }
}
</code></pre>
<p>WeakReference 通过 reference_count_ 字段记录了 target （JS 层传入的 Channel 对象）有多少个引用。SnapshotableObject 继承 BaseObject，用于关联 JS 的 WeakReference 和 C++ 的 WeakReference 对象。接着通过 WeakReference 的 target_ 引用 JS 层传入的对象，因为 reference_count_ 是 0，所以执行 SetWeak，表示如果只有持久句柄 target_ 引用传入的 JS 对象，则该 JS 对象可以被 GC。回到 JS 层。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">channel</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Channel</span>(name);
  channels[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>(channel);
  <span class="hljs-keyword">return</span> channel;
}
</code></pre>
<p>可以看到通过 channel 获取的 Channel 对象直接返回给用户，WeakReference 会被 channels 引用，但是存在一个问题是，如果用户没有变量引用该返回的 Channel 对象，则会导致 Channel 被 GC，例如<a href="https://github.com/nodejs/node/issues/42170" target="_blank" rel="nofollow noopener noreferrer">如下情况</a>。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { channel } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'diagnostics_channel'</span>)
<span class="hljs-keyword">const</span> strongRef = <span class="hljs-title function_">channel</span>(<span class="hljs-string">'strong'</span>)

strongRef.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">message</span> =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message) <span class="hljs-comment">// outputs because the subscriber is still available</span>
})

<span class="hljs-title function_">channel</span>(<span class="hljs-string">'weak'</span>).<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">message</span> =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message) <span class="hljs-comment">// no output because the subscriber was garbage collected</span>
})

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-title function_">channel</span>(<span class="hljs-string">'weak'</span>).<span class="hljs-title function_">publish</span>(<span class="hljs-string">'weak output'</span>)
  strongRef.<span class="hljs-title function_">publish</span>(<span class="hljs-string">'strong output'</span>)
})

<span class="hljs-title function_">gc</span>()
</code></pre>
<p>channel('weak') 创建了一个 Channel 对象，但是 JS 里没有地方引用返回的 Channel 对象，从而 Channel 对象被 GC，当 setTimeout 中执行 channel('weak').publish 时会重新创建一个新的 Channel，导致 pubilsh 不符合预期。这个是 Node.js 中的一个 bug，后面被修复了，修复代码如下。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name, subscription</span>) {
  <span class="hljs-keyword">const</span> chan = <span class="hljs-title function_">channel</span>(name);
  channels[name].<span class="hljs-title function_">incRef</span>();
  chan.<span class="hljs-title function_">subscribe</span>(subscription);
}
</code></pre>
<p>修复后，需要通过 subscribe 进行订阅，subscribe 会调用 channel 函数创建一个 Channel 对象，然后执行 incRef。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WeakReference::IncRef</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
  WeakReference* weak_ref = <span class="hljs-built_in">Unwrap</span>&#x3C;WeakReference>(args.<span class="hljs-built_in">Holder</span>());
  weak_ref->reference_count_++;
  <span class="hljs-keyword">if</span> (weak_ref->target_.<span class="hljs-built_in">IsEmpty</span>()) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">if</span> (weak_ref->reference_count_ == <span class="hljs-number">1</span>) weak_ref->target_.<span class="hljs-built_in">ClearWeak</span>();
}
</code></pre>
<p>IncRef 的逻辑很简单，就是 Channel 对象的引用数加一，并且清除弱引用设置，这样保证即使 JS 层没有变量引用该 Channel 对象，也不会被 GC。同理，当显式调用 unsubscribe 时才会导致 Channel 对象被 GC。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">name, subscription</span>) {
  <span class="hljs-keyword">const</span> chan = <span class="hljs-title function_">channel</span>(name);
  <span class="hljs-keyword">if</span> (!chan.<span class="hljs-title function_">unsubscribe</span>(subscription)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  channels[name].<span class="hljs-title function_">decRef</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p>看一下 C++ 层的 decRef。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WeakReference::DecRef</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
  WeakReference* weak_ref = <span class="hljs-built_in">Unwrap</span>&#x3C;WeakReference>(args.<span class="hljs-built_in">Holder</span>());
  weak_ref->reference_count_--;
  <span class="hljs-keyword">if</span> (weak_ref->target_.<span class="hljs-built_in">IsEmpty</span>()) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">if</span> (weak_ref->reference_count_ == <span class="hljs-number">0</span>) weak_ref->target_.<span class="hljs-built_in">SetWeak</span>();
}
</code></pre>
<p>decRef 中判断了如果 reference_count_ 为 0，则设置 Channel 的弱引用回调，所以最终被 GC，除非用户再次调用 subscribe。这种就是基于引用计数来对对象进行内存管理的方式。</p>
<p>不知道大家有没有发现另一个问题，就是 WeakReference 对象什么时候被 GC？纵观 diagnostics_channel 的代码我们只看到给 channels 对象新增属性的代码，没有删除属性的代码，通过代码测试一下。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { subscribe, unsubscribe } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'diagnostics_channel'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">noop</span>(<span class="hljs-params"></span>) {}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-title function_">memoryUsage</span>().<span class="hljs-property">heapUsed</span>);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">1000000</span>; i++) {
    <span class="hljs-title function_">subscribe</span>(<span class="hljs-title class_">String</span>(i), noop);
    <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-title class_">String</span>(i), noop);
}

<span class="hljs-title function_">gc</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-title function_">memoryUsage</span>().<span class="hljs-property">heapUsed</span>);
</code></pre>
<p>在 Node.js V18.9.0 中输出如下。</p>
<pre><code class="hljs">4949688
46934032
</code></pre>
<p>可以发现尽管调用了 unsubscribe，内存还是新增了非常多，这里的确存在了一个内存泄露的问题，我最近提交 <a href="https://github.com/nodejs/node/pull/45633" target="_blank" rel="nofollow noopener noreferrer">PR</a> 修复了该问题，修复方式如下。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">name, subscription</span>) {
  <span class="hljs-keyword">const</span> chan = <span class="hljs-title function_">channel</span>(name);
  <span class="hljs-keyword">if</span> (!chan.<span class="hljs-title function_">unsubscribe</span>(subscription)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  channels[name].<span class="hljs-title function_">decRef</span>();
  <span class="hljs-comment">// 引用数为 0 时删除该 key</span>
  <span class="hljs-keyword">if</span> (channels[name].<span class="hljs-title function_">getRef</span>() === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">delete</span> channels[name];
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<h2>如何使用 Node.js 的内存管理机制</h2>
<p>那么对于我们来说，这种机制有什么用处呢？Node.js 除了提供 BaseObject 管理内部对象的内存，也通过 ObjectWrap 导出了这个功能。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectWrap</span> {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">ObjectWrap</span>() {
    refs_ = <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>>
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> T* <span class="hljs-title">Unwrap</span><span class="hljs-params">(v8::Local&#x3C;v8::Object> handle)</span> </span>{
    <span class="hljs-type">void</span>* ptr = handle-><span class="hljs-built_in">GetAlignedPointerFromInternalField</span>(<span class="hljs-number">0</span>);
    ObjectWrap* wrap = <span class="hljs-built_in">static_cast</span>&#x3C;ObjectWrap*>(ptr);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&#x3C;T*>(wrap);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> v8::Local&#x3C;v8::Object> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">handle</span>(v8::Isolate::<span class="hljs-built_in">GetCurrent</span>());
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> v8::Local&#x3C;v8::Object> <span class="hljs-title">handle</span><span class="hljs-params">(v8::Isolate* isolate)</span> </span>{
    <span class="hljs-keyword">return</span> v8::Local&#x3C;v8::Object>::<span class="hljs-built_in">New</span>(isolate, <span class="hljs-built_in">persistent</span>());
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> v8::Persistent&#x3C;v8::Object>&#x26; <span class="hljs-title">persistent</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> handle_;
  }

 <span class="hljs-keyword">protected</span>:
  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Wrap</span><span class="hljs-params">(v8::Local&#x3C;v8::Object> handle)</span> </span>{
    <span class="hljs-comment">// 关联 JS 和 C++ 对象</span>
    handle-><span class="hljs-built_in">SetAlignedPointerInInternalField</span>(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);
    <span class="hljs-built_in">persistent</span>().<span class="hljs-built_in">Reset</span>(v8::Isolate::<span class="hljs-built_in">GetCurrent</span>(), handle);
    <span class="hljs-comment">// 默认设置了弱引用，如果 JS 对象没有被其他变量引用则会被 GC</span>
    <span class="hljs-built_in">MakeWeak</span>();
  }
  <span class="hljs-comment">// 设置弱引用回调</span>
  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">MakeWeak</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">persistent</span>().<span class="hljs-built_in">SetWeak</span>(<span class="hljs-keyword">this</span>, WeakCallback, v8::WeakCallbackType::kParameter);
  }
  <span class="hljs-comment">// 引用数加 1，清除弱引用回调</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Ref</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">persistent</span>().<span class="hljs-built_in">ClearWeak</span>();
    refs_++;
  }
  <span class="hljs-comment">// 和 Ref 相反</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Unref</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (--refs_ == <span class="hljs-number">0</span>)
      <span class="hljs-built_in">MakeWeak</span>();
  }

  <span class="hljs-type">int</span> refs_;  <span class="hljs-comment">// ro</span>

 <span class="hljs-keyword">private</span>:
  <span class="hljs-comment">// 弱引用回调</span>
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">WeakCallback</span><span class="hljs-params">(
      <span class="hljs-type">const</span> v8::WeakCallbackInfo&#x3C;ObjectWrap>&#x26; data)</span> </span>{
    ObjectWrap* wrap = data.<span class="hljs-built_in">GetParameter</span>();
    <span class="hljs-comment">// 解除引用 JS 对象</span>
    wrap->handle_.<span class="hljs-built_in">Reset</span>();
    <span class="hljs-comment">// 释放内存</span>
    <span class="hljs-keyword">delete</span> wrap;
  }

  <span class="hljs-comment">// 通过持久引用保存 JS 对象，避免被 GC</span>
  v8::Persistent&#x3C;v8::Object> handle_;
};
</code></pre>
<p>ObjectWrap 为开发者提供了 JS 和 C++ 对象的生命周期管理，开发者可以继承该类，但是需要注意的是 ObjectWrap 默认设置了弱引用，如果管理的 JS 对象没有被其他变量引用则会被 GC，如果想改变这个行为，则可以主动调 Ref，有兴趣的同学可以参考<a href="https://github.com/theanarkh/nodejs-book/tree/main/src/ObjectWrapper" target="_blank" rel="nofollow noopener noreferrer">这个例子</a>。</p>
<p>除此之外，我们还可以利用这种机制追踪 JS 对象是否被 GC。
js</p>
<pre><code class="hljs language-ini">const { createHook, AsyncResource } = require('async_hooks')<span class="hljs-comment">;</span>
const <span class="hljs-attr">weakMap</span> = new WeakMap()<span class="hljs-comment">;</span>
// 存储被监控对象和 GC 回调的映射
const <span class="hljs-attr">gcCallbackContext</span> = {}<span class="hljs-comment">;</span>

let hooks<span class="hljs-comment">;</span>

function trackGC(obj, gcCallback) {
  if (!hooks) {
    <span class="hljs-attr">hooks</span> = createHook({
      destroy(id) {
        if (gcCallbackContext<span class="hljs-section">[id]</span>) {
          gcCallbackContext<span class="hljs-section">[id]</span>()<span class="hljs-comment">;</span>
          delete gcCallbackContext<span class="hljs-section">[id]</span><span class="hljs-comment">;</span>
        }
      }
    }).enable()<span class="hljs-comment">;</span>
  }
  const <span class="hljs-attr">gcTracker</span> = new AsyncResource(<span class="hljs-string">'none'</span>)<span class="hljs-comment">;</span>
  // 通过 asyncId 记录被追踪对象和 GC 回调的映射
  gcCallbackContext<span class="hljs-section">[gcTracker.asyncId()]</span> = gcCallback<span class="hljs-comment">;</span>
  weakMap.set(obj, gcTracker)<span class="hljs-comment">;</span>
}
</code></pre>
<p>WeakMap 的存储的是键值对，键只能是对象且 WeakMap 对该对象是弱引用，也就是说如果没有其他变量引用该对象则该对象会被 GC，并且值也会被 GC。当我们想追踪一个 JS 对象是否被 GC 时，就可以把该对象作为键保存在 WeakMap 中，再利用一个特殊的值，这个值的特殊之处在于当键被 GC 时，值也会被 GC，再通过给值设置弱引用回调得到通知，那就是说当回调被执行时，说明值被 GC 了，也就说明键被 GC 了。这个值的类型是 AsyncResource，AsyncResource 帮我们处理好了底层的事件，我们只需要通过 async_hooks 的 destroy 钩子就可以知道哪个 AsyncResource 被 GC了，从而知道哪个键被 GC了，最后执行一个回调。来看一下是如何知道 AsyncResource 对象被 GC 的。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncResource</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">type, opts = kEmptyObject</span>) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-title function_">registerDestroyHook</span>(<span class="hljs-variable language_">this</span>, ...);
  }

}
</code></pre>
<p>当创建一个 AsyncResource 对象时，默认会执行 registerDestroyHook。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DestroyParam</span> {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-type">double</span> asyncId;
  Environment* env;
  Global&#x3C;Object> target;
  Global&#x3C;Object> propBag;
};

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">RegisterDestroyHook</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();
  DestroyParam* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DestroyParam</span>();
  p->asyncId = args[<span class="hljs-number">1</span>].<span class="hljs-built_in">As</span>&#x3C;Number>()-><span class="hljs-built_in">Value</span>();
  p->env = Environment::<span class="hljs-built_in">GetCurrent</span>(args);
  <span class="hljs-comment">// args[0] 为 JS 层的 AsyncResource 对象</span>
  p->target.<span class="hljs-built_in">Reset</span>(isolate, args[<span class="hljs-number">0</span>].<span class="hljs-built_in">As</span>&#x3C;Object>());
  <span class="hljs-comment">// 设置弱引用回调，p 为回调时传入的参数</span>
  p->target.<span class="hljs-built_in">SetWeak</span>(p, AsyncWrap::WeakCallback, WeakCallbackType::kParameter);
}
</code></pre>
<p>RegisterDestroyHook 中创建了一个 DestroyParam 对象保存上下文，然后调用 SetWeak 设置了 JS 对象的弱引用回调，当 AsyncResource 没有被其他变量引用时就会被 GC，从而执行 AsyncWrap::WeakCallback。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AsyncWrap::WeakCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> WeakCallbackInfo&#x3C;DestroyParam>&#x26; info)</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(info.GetIsolate())</span></span>;
  <span class="hljs-comment">// 智能指针，执行完 WeakCallback 后释放堆对象 DestroyParam 内存</span>
  std::unique_ptr&#x3C;DestroyParam> p{info.<span class="hljs-built_in">GetParameter</span>()};
  Local&#x3C;Object> prop_bag = PersistentToLocal::<span class="hljs-built_in">Default</span>(info.<span class="hljs-built_in">GetIsolate</span>(),
                                                      p->propBag);
  Local&#x3C;Value> val;
  <span class="hljs-comment">// 触发 async_hooks 的 destroy 钩子函数</span>
  <span class="hljs-keyword">if</span> (val.<span class="hljs-built_in">IsEmpty</span>() || val-><span class="hljs-built_in">IsFalse</span>()) {
    AsyncWrap::<span class="hljs-built_in">EmitDestroy</span>(p->env, p->asyncId);
  }
}
</code></pre>
<p>WeakCallback 中触发了 async_hooks 的 destroy 钩子，从而通过 destroy 钩子的 asyncId 就可以知道哪个 AsyncResource 对象被 GC 了，从而根据 WeakMap 的映射关系知道哪个被追踪的 JS 对象被 GC 了。我们看一个例子。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">memory</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> ~~(process.<span class="hljs-title function_">memoryUsage</span>().<span class="hljs-property">heapUsed</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>);
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`before new Array: <span class="hljs-subst">${memory()}</span> MB`</span>);

<span class="hljs-keyword">let</span> key = {
  <span class="hljs-attr">a</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>)
};

<span class="hljs-keyword">let</span> key2 = {
  <span class="hljs-attr">a</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>)
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`after new Array: <span class="hljs-subst">${memory()}</span> MB`</span>);

<span class="hljs-title function_">trackGC</span>(key, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"key gc"</span>);
});

<span class="hljs-title function_">trackGC</span>(key2, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"key2 gc"</span>);
});

<span class="hljs-variable language_">global</span>.<span class="hljs-title function_">gc</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`after gc 1: <span class="hljs-subst">${memory()}</span> MB`</span>);

key = <span class="hljs-literal">null</span>;

key2 = <span class="hljs-literal">null</span>;

<span class="hljs-variable language_">global</span>.<span class="hljs-title function_">gc</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`after gc 2: <span class="hljs-subst">${memory()}</span> MB`</span>);
</code></pre>
<p>执行上面代码，输出如下。</p>
<pre><code class="hljs language-javascript">before <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>: <span class="hljs-number">2</span> <span class="hljs-variable constant_">MB</span>
after <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>: <span class="hljs-number">162</span> <span class="hljs-variable constant_">MB</span>
after gc <span class="hljs-number">1</span>: <span class="hljs-number">161</span> <span class="hljs-variable constant_">MB</span>
after gc <span class="hljs-number">2</span>: <span class="hljs-number">1</span> <span class="hljs-variable constant_">MB</span>
key gc
key2 gc
</code></pre>
<p>从输出中可以看到 key 和 key2 变量被 GC 了，内存也得到了释放。</p>
<h2>总结</h2>
<p>内存管理是应用非常核心的部分，哪怕语言自带 GC，也不意味着我们就不需要关心内存的管理问题。本节课以 HandleWrap、ReqWrap、trace_events、diagnostics_channel 为例介绍了 Node.js 内核中多种内存管理的机制。</p>
<ol>
<li>HandleWrap 是对 Libuv handle 的封装，所以当不再使用时，需要显式调用 close 关闭 handle，才能释放内存。</li>
</ol>

<ol start="2">
<li>ReqWrap 是对请求的封装，是一次性的操作，发起操作到结束操作整个过程的内存管理都是由 Node.js 负责的。</li>
</ol>

<ol start="3">
<li>trace_events 是关联了底层资源的 JS 对象，通过弱引用机制进行 JS 对象和底层资源的内存管理。</li>
</ol>

<ol start="4">
<li>diagnostics_channel 是基于引用计数进行内存管理，底层也是使用了弱引用机。</li>
</ol>
<p>除此之外，还介绍了 Node.js 提供的内存管理机制，包括通过 ObjectWrap 管理 JS 和 C++ 对象的生命周期和通过 AsyncResource 追踪 JS 对象是否被 GC，我们可以把他们应用到项目中。理解这些原理不仅可以加深我们对 V8 和 Node.js 的理解，同时我们在使用 V8 和 Node.js 时，也就知道如何去管理自己的内存，避免出现内存泄露或应用 Crash的问题。</p></div>
</body></html>