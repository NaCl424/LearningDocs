<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>进程和进程间通信的实现</h1>
<p>这节课我们来讲解一下 Node.js 中的进程模块。在 Node.js 中，进程模块用于创建子进程，这样我们就可以拥有多个 Node.js 进程。多进程有几个好处。</p>
<ol>
<li>
<p>因为 Node.js 是单进程的，但有很多事情可能不适合在主进程里处理，比如一些 CPU 耗时的任务，我们就可以创建子进程来处理这些额外的任务。</p>
</li>
<li>
<p>多进程可以更好地利用多核。因为多核的机器中，多个进程可以保证每个核心上都在执行代码。</p>
</li>
<li>
<p>进程间相互独立，一个进程出问题不会影响其他进程。</p>
</li>
</ol>
<p>这节课，我们就先从操作系统的角度一起聊聊进程，再接着讲解 Node.js 中进程模块的实现以及进程间通信的实现，最后聊聊如何在进程间传递文件描述符，传递文件描述符也是操作系统中非常重要的技术。</p>
<h1>进程是什么？</h1>
<p>进程是操作系统中非常核心的概念，它本质上是程序运行时的实体，也是操作系统资源分配（内存、文件）的单位。另外，进程也是线程的基础，线程执行的代码、使用的内存和打开的文件都来自于进程。在操作系统中，进程是使用 task_struct 结构体表示的，如果用 JS 来理解，每个进程就是一个对象。task_struct 结构体里保存了一个进程所需要的一些信息，包括进程 ID、执行状态，执行上下文、打开的文件、根目录、工作目录、收到的信号、信号处理函数、代码段、数据段的位置、执行时间、退出码等等。</p>
<p>那么如何创建一个进程呢？<strong>进程的创建类似于人类的出生</strong>，操作系统在初始化时就创建了一些进程，后面所有的进程都是由系统的某个进程创建出来的。<strong>创建一个进程本质上就是创建一个 task_struct 结构体</strong>，再从父进程中复制一些信息过来，把子进程插入进程队列等待调度。</p>
<p>我们可以使用系统调用 fork 来创建一个进程，看一个例子。</p>
<pre><code class="hljs language-arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;unistd.h></span>  </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span>  </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/types.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/wait.h></span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span>{  
    <span class="hljs-type">pid_t</span> pid = fork();  
    <span class="hljs-keyword">if</span> (pid &#x3C; <span class="hljs-number">0</span>) {  
        <span class="hljs-comment">// 错误  </span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) {  
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"worker process\n"</span>);
    } <span class="hljs-keyword">else</span> {  
        <span class="hljs-comment">// 等待子进程先执行完</span>
        <span class="hljs-built_in">waitpid</span>(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"main process\n"</span>);
    }
}  
</code></pre>
<p>上面的代码通过 fork 创建了一个子进程，fork 函数有一个非常有意思的特点，那就是执行一次返回两次。在我们的常识里，一个函数只会返回一次，那 fork 是如何做到返回两次的呢？因为调用 fork 的时候，操作系统会复制一个新的 task_struct 实例出来，也就变成了两个进程，并且父进程的执行上下文也会直接复制到子进程中，然后两个进程就独立执行了。</p>
<p>fork 返回两次的意思其实是在两个进程分别返回一次，执行的都是 fork 后面的一行代码。而操作系统根据当前进程是主进程还是子进程，给 fork 函数设置了不同的返回值，所以不同的进程中 fork 返回值不一样。也就是说，我们可以通过 fork 函数的返回值判断当前是主进程还是子进程，就是上面代码中 if else 的判断。</p>
<p>另外，在创建子进程后，我们可以调用 waitpid 或类似的函数等待子进程退出。因为创建子进程后，哪个进程先执行是不确定的，取决于操作系统的进程调度机制。如果主进程先执行完毕，子进程不会自动退出，从而变成孤儿进程。系统进程会自动接管孤儿进程，成为它的父进程。直到孤儿进程退出后，系统进程才会自动做清理工作。但是，如果父进程没有退出也没有执行 waitpid 处理子进程的退出，子进程退出后就会变成僵尸进程，导致内存泄露。</p>
<p>fork 只是复制主进程的内容，而它创建的子进程的代码段和父进程是一样的。我们可以通过 fork 返回值来判断接下来要执行哪段代码，比如上面例子中的 if 和 else。但是，如果我们想执行另外一个程序怎么办呢？比如我们想在 Node.js 进程里执行 ls 命令。这时候就需要用到 exec* 系列函数，该系列函数会覆盖旧进程（task_struct）的信息，重新加载新的程序，看一个例子。</p>
<pre><code class="hljs language-arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;unistd.h></span>  </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span>  </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/types.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/wait.h></span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span>{  
    <span class="hljs-type">pid_t</span> pid = fork();  
    <span class="hljs-keyword">if</span> (pid &#x3C; <span class="hljs-number">0</span>) {  
        <span class="hljs-comment">// 错误  </span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) {  
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"worker process\n"</span>);
        <span class="hljs-type">char</span>* args[] = {<span class="hljs-string">"ls"</span>, <span class="hljs-string">"-l"</span>, <span class="hljs-literal">NULL</span>};
        <span class="hljs-built_in">execvp</span>(<span class="hljs-string">"ls"</span>, args);
    } <span class="hljs-keyword">else</span> {  
        <span class="hljs-built_in">waitpid</span>(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"main process\n"</span>);
    }
}  
</code></pre>
<p>上面的代码中，我们在子进程里通过 execvp 执行了另一个新的程序 ls。</p>
<h1>创建子进程</h1>
<p>了解了操作系统中进程的基础概念后，接下来看看 Node.js 中进程模块的实现。Node.js 提供了几个创建进程的 API，但是总结起来只有两种，一种是同步，另一种是异步。并且，它们的底层实现都一样，区别主要是同步方式会等待子进程执行完毕，父进程才能继续执行，异步方式则是父子进程的执行是独立的。下面，我们分别来看看这两种创建子进程的方式。</p>
<h2>异步创建进程</h2>
<p>首先来看一下异步创建方式，我们从 child_process 模块的 fork 函数开始看一下整个流程。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fork</span>(<span class="hljs-params">modulePath <span class="hljs-comment">/* , args, options */</span></span>) {  
  <span class="hljs-comment">// 一系列参数处理  </span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">spawn</span>(options.<span class="hljs-property">execPath</span>, args, options);  
}  

<span class="hljs-keyword">function</span> <span class="hljs-title function_">spawn</span>(<span class="hljs-params"><span class="hljs-comment">/*file, args, options*/</span></span>) {  
  <span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildProcess</span>();  
  child.<span class="hljs-title function_">spawn</span>(...);  
  <span class="hljs-keyword">return</span> child;  
};  
</code></pre>
<p>fork 调用了 spawn，spawn 调用了 ChildProcess 的 spawn 函数，看看 ChildProcess 和它的 spawn 函数。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildProcess</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-comment">// C++层定义  </span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_handle</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Process</span>();  
  <span class="hljs-comment">// 子进程退出时执行的回调</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_handle</span>.<span class="hljs-property">onexit</span> = <span class="hljs-function">(<span class="hljs-params">exitCode, signalCode</span>) =></span> {};
}  

<span class="hljs-title class_">ChildProcess</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">spawn</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) {  
  <span class="hljs-comment">// 创建进程  </span>
  <span class="hljs-keyword">const</span> err = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_handle</span>.<span class="hljs-title function_">spawn</span>(options);  
}  
</code></pre>
<p>ChildProcess 是对 C++ 层 Process 的封装，ChildProcess 的 spawn 执行了 Process 的 Spawn。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">static</span> void <span class="hljs-title function_ invoke__">Spawn</span>(<span class="hljs-keyword">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args) {
    uv_process_options_t options;
    <span class="hljs-comment">// 设置子进程退出的回调</span>
    options.exit_cb = OnExit;
    <span class="hljs-comment">// 忽略一系列参数的处理</span>
    int err = <span class="hljs-title function_ invoke__">uv_spawn</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">event_loop</span>(), &#x26;wrap<span class="hljs-punctuation">-></span>process_, &#x26;options);
    <span class="hljs-comment">// 设置进程 id 到 JS 层的对象</span>
    wrap<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">object</span>()<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">Set</span>(context, env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">pid_string</span>(),
                          Integer::<span class="hljs-title function_ invoke__">New</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">isolate</span>(),
                                       wrap<span class="hljs-punctuation">-></span>process_.pid)).<span class="hljs-title function_ invoke__">Check</span>();
}
</code></pre>
<p>Spawn 做了参数处理后，直接调用了 Libuv 的 uv_spawn。</p>
<pre><code class="hljs language-ini">int uv_spawn(uv_loop_t* loop,  
             uv_process_t* process, // 表示一个子进程
             const uv_process_options_t* options) {  
  int <span class="hljs-attr">exec_errorno</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
  uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS)<span class="hljs-comment">;  </span>
  QUEUE_INIT(&#x26;process->queue)<span class="hljs-comment">;  </span>
  // 创建一个管道用于创建子进程期间父子进程的通信
  <span class="hljs-attr">err</span> = uv__make_pipe(signal_pipe, <span class="hljs-number">0</span>)<span class="hljs-comment">;  </span>
  // 注册子进程退出信号的处理函数  
  uv_signal_start(&#x26;loop->child_watcher, uv__chld, SIGCHLD)<span class="hljs-comment">;  </span>
  // 创建子进程  
  <span class="hljs-attr">pid</span> = fork()<span class="hljs-comment">;  </span>
  // 子进程  
  if (<span class="hljs-attr">pid</span> == <span class="hljs-number">0</span>) {  
    uv__process_child_init(options, 
                              stdio_count, 
                              pipes, 
                              signal_pipe<span class="hljs-section">[1]</span>)<span class="hljs-comment">;  </span>
    abort()<span class="hljs-comment">;  </span>
  }  
  // 父进程  
  // 关闭管道写端，等待子进程写  
  uv__close(signal_pipe<span class="hljs-section">[1]</span>)<span class="hljs-comment">;  </span>

  process-><span class="hljs-attr">status</span> = <span class="hljs-number">0</span><span class="hljs-comment">;  </span>
  // 等待并判断子进程是否执行成功  
  do  
    <span class="hljs-attr">r</span> = read(signal_pipe[<span class="hljs-number">0</span>],&#x26;exec_error<span class="hljs-literal">no</span>,sizeof(exec_error<span class="hljs-literal">no</span>))<span class="hljs-comment">;</span>
  while (<span class="hljs-attr">r</span> == -<span class="hljs-number">1</span> &#x26;&#x26; err<span class="hljs-literal">no</span> == EINTR)<span class="hljs-comment">;  </span>
  // 子进程启动成功
  if (<span class="hljs-attr">r</span> == <span class="hljs-number">0</span>)
    <span class="hljs-comment">;</span>
  else if (<span class="hljs-attr">r</span> == sizeof(exec_error<span class="hljs-literal">no</span>)) {
    // 子进程启动失败
    do
      <span class="hljs-attr">err</span> = waitpid(pid, &#x26;status, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    while (<span class="hljs-attr">err</span> == -<span class="hljs-number">1</span> &#x26;&#x26; err<span class="hljs-literal">no</span> == EINTR)<span class="hljs-comment">;</span>
  } else {
      // ...
  }
  
  // 关闭管道读端
  uv__close_nocheckstdio(signal_pipe<span class="hljs-section">[0]</span>)<span class="hljs-comment">;</span>
  // 创建子进程成功，把 uv_process_t 插入 loop->process_handles 队列
  if (<span class="hljs-attr">exec_errorno</span> == <span class="hljs-number">0</span>) {  
    QUEUE_INSERT_TAIL(&#x26;loop->process_handles, &#x26;process->queue)<span class="hljs-comment">; </span>
    uv__handle_start(process)<span class="hljs-comment">;  </span>
  }  
  // 记录 pid 和子进程退出时执行的回调，见 uv__chld
  process-><span class="hljs-attr">pid</span> = pid<span class="hljs-comment">;  </span>
  process-><span class="hljs-attr">exit_cb</span> = options->exit_cb<span class="hljs-comment">;  </span>

  return exec_errorno<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>uv_spawn 的逻辑大致分为下面 3 个。</p>
<ol>
<li>创建父子进程临时通信管道，用于判断子进程是否启动成功。</li>
<li>创建子进程。</li>
<li>注册子进程退出处理函数，子进程退出时操作系统会给父进程发送信号。</li>
</ol>
<p>下面我们逐个分析。</p>
<h3><strong>创建父子进程临时通信管道</strong></h3>
<p>创建子进程的过程中，Libuv 会创建一个临时的管道，用于父进程判断子进程是否启动成功，创建管道的函数是 uv__make_pipe。</p>
<pre><code class="hljs language-scss">int <span class="hljs-built_in">uv__make_pipe</span>(int fds[<span class="hljs-number">2</span>], int flags) {
  <span class="hljs-comment">// 创建一个通信管道，拿到两个 fd，一个进程读，一个进程写</span>
  <span class="hljs-built_in">pipe</span>(fds);
  <span class="hljs-comment">// 设置 UV__O_CLOEXEC 标记</span>
  <span class="hljs-built_in">uv__cloexec</span>(fds[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);
  <span class="hljs-built_in">uv__cloexec</span>(fds[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);
  return <span class="hljs-number">0</span>;
}
</code></pre>
<p>pipe 系统调用用于创建一个匿名管道，通常用于父子进程间通信（子进程会继承父进程打开的这两个 fd），原理如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88123b0582634159ad52ebbe053a50f0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>要注意，匿名管道的底层是一块内存，这块内存有一个生产者和消费者指针，虽然初始化时有多个 fd 指向管道，但是通常是一个进程读（关闭写 fd），一个进程写（关闭读 fd），比如 Libuv 中是子进程写，父进程读。</p>
<p>另一个需要注意的点是，通过 uv__cloexec 函数设置的 UV__O_CLOEXEC 标记，会导致子进程中执行 exec* 函数时自动关闭子进程从父进程继承过来的 fd。当父进程发现管道的写端关闭了，就知道子进程启动成功了，具体参考下面创建子进程的逻辑。</p>
<h3>子进程的初始化</h3>
<p>创建子进程后，在子进程中执行 uv__process_child_init 函数。</p>
<pre><code class="hljs language-scss">staticvoid <span class="hljs-built_in">uv__process_child_init</span>(const uv_process_options_t* options,
                                     int stdio_count,  
                   int (*pipes)<span class="hljs-selector-attr">[2]</span>,  
                   int error_fd) {  
  <span class="hljs-comment">// 设置环境变量  </span>
  if (options->env != NULL) {  
    environ = options->env;  
  }                 
  <span class="hljs-comment">// 执行一系列设置，如果失败则执行 uv__write_int 通知父进程</span>
  if ((options->flags &#x26; UV_PROCESS_SETGID) &#x26;&#x26; <span class="hljs-built_in">setgid</span>(options->gid)) {
    <span class="hljs-built_in">uv__write_int</span>(error_fd, UV__ERR(errno));
    <span class="hljs-built_in">_exit</span>(<span class="hljs-number">127</span>);
  }

  if ((options->flags &#x26; UV_PROCESS_SETUID) &#x26;&#x26; <span class="hljs-built_in">setuid</span>(options->uid)) {
    <span class="hljs-built_in">uv__write_int</span>(error_fd, UV__ERR(errno));
    <span class="hljs-built_in">_exit</span>(<span class="hljs-number">127</span>);
  }
  <span class="hljs-comment">// 加载新的执行文件，操作系统自动关闭父子进程通信的管道  </span>
  <span class="hljs-built_in">execvp</span>(options->file, options->args);  
  <span class="hljs-comment">// 加载成功则不会走到这，走到这说明加载执行文件失败  </span>
  <span class="hljs-built_in">uv__write_int</span>(error_fd, UV__ERR(errno));  
  <span class="hljs-built_in">_exit</span>(<span class="hljs-number">127</span>);  
}  
</code></pre>
<p>子进程的逻辑主要是处理文件描述符、信号、设置环境变量等，然后加载新的执行文件。因为主进程和子进程通信的管道对应的文件描述符设置了 cloexec 标记，所以当子进程加载新的执行文件时，就会关闭用于和主进程通信的管道文件描述符，从而导致主进程读取管道读端的时候返回 0，这样主进程就知道子进程成功执行了。</p>
<h3>处理子进程退出</h3>
<p>父进程在创建子进程之前，会注册 SIGCHLD 信号，对应的处理函数是 uv__chld。当子进程退出的时候。操作系统给父进程发送 SIGCHLD 信号，让父进程执行 uv__chld。</p>
<pre><code class="hljs language-ini">static void uv__chld(uv_signal_t* handle, int signum) {  
  uv_process_t* process<span class="hljs-comment">;  </span>
  uv_loop_t* loop<span class="hljs-comment">;  </span>
  int exit_status<span class="hljs-comment">;  </span>
  int term_signal<span class="hljs-comment">;  </span>
  int status<span class="hljs-comment">;  </span>
  pid_t pid<span class="hljs-comment">;  </span>
  QUEUE pending<span class="hljs-comment">;  </span>
  QUEUE* q<span class="hljs-comment">;  </span>
  QUEUE* h<span class="hljs-comment">;  </span>
  // 保存进程（已退出的状态）的队列  
  QUEUE_INIT(&#x26;pending)<span class="hljs-comment">;  </span>
  <span class="hljs-attr">loop</span> = handle->loop<span class="hljs-comment">;  </span>
  // 子进程队列
  <span class="hljs-attr">h</span> = &#x26;loop->process_handles<span class="hljs-comment">;  </span>
  <span class="hljs-attr">q</span> = QUEUE_HEAD(h)<span class="hljs-comment">;  </span>
  //  收集已退出的进程  
  while (q != h) {  
    <span class="hljs-attr">process</span> = QUEUE_DATA(q, uv_process_t, queue)<span class="hljs-comment">;  </span>
    <span class="hljs-attr">q</span> = QUEUE_NEXT(q)<span class="hljs-comment">;  </span>
    do  
      /*
          WNOHANG 表示非阻塞等待子进程退出，如果没有 pid 对应的子进程没有退出则返回，而不是阻塞
      */   
      <span class="hljs-attr">pid</span> = waitpid(process->pid, &#x26;status, WNOHANG)<span class="hljs-comment">;  </span>
    while (<span class="hljs-attr">pid</span> == -<span class="hljs-number">1</span> &#x26;&#x26; err<span class="hljs-literal">no</span> == EINTR)<span class="hljs-comment">;  </span>

    if (<span class="hljs-attr">pid</span> == <span class="hljs-number">0</span>)  
      continue<span class="hljs-comment">;  </span>
    /*
      进程退出了，保存退出状态，移出队列，
      插入 pending 队列，等待处理  
    */
    process-><span class="hljs-attr">status</span> = status<span class="hljs-comment">;  </span>
    QUEUE_REMOVE(&#x26;process->queue)<span class="hljs-comment">;  </span>
    QUEUE_INSERT_TAIL(&#x26;pending, &#x26;process->queue)<span class="hljs-comment">;  </span>
  }  

  <span class="hljs-attr">h</span> = &#x26;pending<span class="hljs-comment">;  </span>
  <span class="hljs-attr">q</span> = QUEUE_HEAD(h)<span class="hljs-comment">;  </span>
  // 处理已经退出的进程
  while (q != h) {  
    <span class="hljs-attr">process</span> = QUEUE_DATA(q, uv_process_t, queue)<span class="hljs-comment">;  </span>
    <span class="hljs-attr">q</span> = QUEUE_NEXT(q)<span class="hljs-comment">;  </span>
    QUEUE_REMOVE(&#x26;process->queue)<span class="hljs-comment">;  </span>
    QUEUE_INIT(&#x26;process->queue)<span class="hljs-comment">;  </span>
    uv__handle_stop(process)<span class="hljs-comment">;  </span>
    <span class="hljs-attr">exit_status</span> = <span class="hljs-number">0</span><span class="hljs-comment">;  </span>
    // 获取退出信息
    if (WIFEXITED(process->status))  
      <span class="hljs-attr">exit_status</span> = WEXITSTATUS(process->status)<span class="hljs-comment">;  </span>
    // 是否因为信号而退出
    <span class="hljs-attr">term_signal</span> = <span class="hljs-number">0</span><span class="hljs-comment">;  </span>
    if (WIFSIGNALED(process->status))  
      <span class="hljs-attr">term_signal</span> = WTERMSIG(process->status)<span class="hljs-comment">;  </span>
    // 执行上传回调  
    process->exit_cb(process, exit_status, term_signal)<span class="hljs-comment">;  </span>
  }  
}  
</code></pre>
<p>当子进程退出时，虽然父进程会收到 SIGCHLD 信号，但无法知道是哪个子进程退出了，因为 Libuv 本身维护了子进程队列，它会遍历这个队列，判断每个节点对应的进程是否已经退出（更多内容可以参考 <a href="https://man7.org/linux/man-pages/man3/waitpid.3p.html" target="_blank" rel="nofollow noopener noreferrer">waitpid</a> 系统调用）。父进程主要负责收集子进程退出状态和原因等信息，并把子进程对应的 uv_process_t 结构体移出队列，然后执行 C++ 层回调 OnExit 函数。</p>
<pre><code class="hljs language-scss">static void <span class="hljs-built_in">OnExit</span>(uv_process_t* handle,
                     int64_t exit_status,
                     int term_signal) {
    ProcessWrap* wrap = static_cast&#x3C;ProcessWrap*>(handle->data);
    Environment* env = wrap-><span class="hljs-built_in">env</span>();

    Local&#x3C;Value> argv<span class="hljs-selector-attr">[]</span> = {
      Number::New(env->isolate(), static_cast&#x3C;double>(exit_status)),
      OneByteString(env->isolate(), signo_string(term_signal))
    };
    <span class="hljs-comment">// 执行 JS 的 onexit 函数</span>
    wrap-><span class="hljs-built_in">MakeCallback</span>(env->onexit_string(), <span class="hljs-built_in">arraysize</span>(argv), argv);
  }
};
</code></pre>
<p>最终回调 JS 层触发 exit 事件，表示一个子进程退出了。</p>
<h2>同步创建进程</h2>
<p>了解了异步创建进程的方式后，我们再来看一下同步方式的实现。JS 层入口函数是 spawnSync，它对应的是 C++ spawn_sync 模块的 spawn 函数。</p>
<pre><code class="hljs language-ini">void SyncProcessRunner::Spawn(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {  
  Environment* <span class="hljs-attr">env</span> = Environment::GetCurrent(args)<span class="hljs-comment">;  </span>
  SyncProcessRunner p(env)<span class="hljs-comment">;  </span>
  Local&#x3C;Value> result<span class="hljs-comment">;  </span>
  if (!p.Run(args<span class="hljs-section">[0]</span>).ToLocal(&#x26;result)) return<span class="hljs-comment">;  </span>
  args.GetReturnValue().Set(result)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>Spawn 中主要是新建了一个 SyncProcessRunner 对象并且执行 Run 方法，我们来看一下SyncProcessRunner的Run 做了什么。</p>
<pre><code class="hljs language-ini">MaybeLocal&#x3C;Object> SyncProcessRunner::Run(Local&#x3C;Value> options) {  
  ETryInitializeAndRunLoop(options)<span class="hljs-comment">; </span>
  // 收集子进程执行结果
  Local&#x3C;Object> <span class="hljs-attr">result</span> = BuildResultObject()<span class="hljs-comment">;</span>
  return scope.Escape(result)<span class="hljs-comment">;</span>
}  

Maybe&#x3C;bool> SyncProcessRunner::TryInitializeAndRunLoop(Local&#x3C;Value> options) {
  int r<span class="hljs-comment">;  </span>
  // 新建一个事件循环
  <span class="hljs-attr">uv_loop_</span> = new uv_loop_t<span class="hljs-comment">;  </span>
  // 解析参数
  if (!ParseOptions(options).To(&#x26;r)) return Nothing&#x3C;bool>()<span class="hljs-comment">;  </span>
  // 设置子进程执行的超时时间，防止父进程一直被堵着  
  if (timeout_ > 0) {  
    <span class="hljs-attr">r</span> = uv_timer_init(uv_loop_, &#x26;uv_timer_)<span class="hljs-comment">;</span>
    uv_unref(reinterpret_cast&#x3C;uv_handle_t*>(&#x26;uv_timer_))<span class="hljs-comment">;</span>
    <span class="hljs-attr">uv_timer_.data</span> = this<span class="hljs-comment">;  </span>
    // 开启一个定时器，超时执行 KillTimerCallback
    <span class="hljs-attr">r</span> = uv_timer_start(&#x26;uv_timer_, 
                       KillTimerCallback, 
                       timeout_, 
                       0)<span class="hljs-comment">;  </span>
  }  
  // 子进程退出时执行的回调
  <span class="hljs-attr">uv_process_options_.exit_cb</span> = ExitCallback<span class="hljs-comment">;</span>
  // 传进去新的 loop 而不是主进程本身的 loop，然后创建一个新的进程  
  <span class="hljs-attr">r</span> = uv_spawn(uv_loop_, &#x26;uv_process_, &#x26;uv_process_options_)<span class="hljs-comment">;  </span>
  <span class="hljs-attr">uv_process_.data</span> = this<span class="hljs-comment">;  </span>
  // 执行新的事件循环，等待子进程退出
  uv_run(uv_loop_, UV_RUN_DEFAULT)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>从上面的代码中可以看到，同步创建进程时，Node.js 会开启一个新的事件循环，然后调用 uv_spawn 新建一个子进程（异步方式中已经分析，不再分析），并且把表示子进程结构体的 handle 插入到新创建的事件循环中，接着 Libuv 一直处于事件循环中，因为一直有一个 uv_process_t（handle），所以新创建的 uv_run 会一直在执行。</p>
<p>这时候，Node.js 主进程会“阻塞”在该 uv_run 函数中。当子进程退出时，主进程会收到信号，然后删除新创建的事件循环中的 uv_process_t 结构体并执行回调 ExitCallback，接着事件循环退出，再次回到 Node.js 原来的事件循环。整个流程如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11007f3e29e44570aeca6a88ddd0ce4f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>接下来分析两个地方，分别是执行超时时间和子进程退出的处理。</p>
<h3>执行超时时间</h3>
<p>因为同步方式创建子进程会导致 Node.js 主进程阻塞，为了避免子进程一直不退出，影响主进程的执行，Node.js 支持配置子进程的最长执行时间。Node.js 会在新的事件循环中开启一个定时器，如果子进程没有在超时时间内推出，定时器就会超时，执行回调 KillTimerCallback。</p>
<pre><code class="hljs language-scss">void SyncProcessRunner::KillTimerCallback(uv_timer_t* handle) {  
  SyncProcessRunner* self = reinterpret_cast&#x3C;SyncProcessRunner*>(handle->data);  
  self-><span class="hljs-built_in">OnKillTimerTimeout</span>();  
}  
  
void SyncProcessRunner::OnKillTimerTimeout() {   
  <span class="hljs-built_in">Kill</span>();  
}  
  
void SyncProcessRunner::Kill() {  
  <span class="hljs-comment">// kill_signal_ 为用户自定义的发送给子进程的信号，默认为 SIGTERM</span>
  <span class="hljs-built_in">uv_process_kill</span>(&#x26;uv_process_, kill_signal_);   
  <span class="hljs-comment">// 清除定时器  </span>
  <span class="hljs-built_in">CloseKillTimer</span>();  
}  
</code></pre>
<p>当执行时间到达设置的阈值，Node.js 主进程会给子进程发送一个信号，默认是发送 SIGTERM 信号，该信号默认会杀死子进程，用户也可以自定义。</p>
<h3>处理子进程退出</h3>
<p>子进程退出时，父进程会执行 ExitCallback 回调，ExitCallback 主要是记录子进程退出时的错误码和被哪个信号杀死的（如果有的话）。</p>
<pre><code class="hljs language-arduino"><span class="hljs-comment">// 子进程退出时父进程执行 ExitCallback 回调</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SyncProcessRunner::ExitCallback</span><span class="hljs-params">(<span class="hljs-type">uv_process_t</span>* handle,  
                        <span class="hljs-type">int64_t</span> exit_status,  
                        <span class="hljs-type">int</span> term_signal)</span> </span>{  
  SyncProcessRunner* self = <span class="hljs-built_in">reinterpret_cast</span>&#x3C;SyncProcessRunner*>(handle->data);  
  <span class="hljs-built_in">uv_close</span>(<span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">uv_handle_t</span>*>(handle), <span class="hljs-literal">nullptr</span>);  
  self-><span class="hljs-built_in">OnExit</span>(exit_status, term_signal);  
}  
  
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SyncProcessRunner::OnExit</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> exit_status, <span class="hljs-type">int</span> term_signal)</span> </span>{  
  <span class="hljs-keyword">if</span> (exit_status &#x3C; <span class="hljs-number">0</span>)  
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">SetError</span>(<span class="hljs-built_in">static_cast</span>&#x3C;<span class="hljs-type">int</span>>(exit_status));  
  <span class="hljs-comment">// 记录退出码和是否因为信号退出</span>
  exit_status_ = exit_status;  
  term_signal_ = term_signal;  
}  
</code></pre>
<p>ExitCallback 只需要记录这些信息，不需要执行 JS 回调，因为同步方式中，子进程退出后会回到父进程的代码中继续执行，然后父进程会收集子进程的执行结果。</p>
<pre><code class="hljs language-scss">Local&#x3C;<span class="hljs-selector-tag">Object</span>> SyncProcessRunner::BuildResultObject() {
  EscapableHandleScope <span class="hljs-built_in">scope</span>(env()-><span class="hljs-built_in">isolate</span>());
  Local&#x3C;Context> context = <span class="hljs-built_in">env</span>()-><span class="hljs-built_in">context</span>();

  Local&#x3C;<span class="hljs-selector-tag">Object</span>> js_result = <span class="hljs-selector-tag">Object</span>::New(env()->isolate());

  if (exit_status_ >= <span class="hljs-number">0</span>) {
    if (term_signal_ > <span class="hljs-number">0</span>) {
      js_result-><span class="hljs-built_in">Set</span>(context, env()-><span class="hljs-built_in">status_string</span>(),
                     <span class="hljs-built_in">Null</span>(env()-><span class="hljs-built_in">isolate</span>()))<span class="hljs-selector-class">.Check</span>();
    } else {
      js_result-><span class="hljs-built_in">Set</span>(context, env()-><span class="hljs-built_in">status_string</span>(),
                     Number::New(env()->isolate(),
                                 static_cast&#x3C;double>(exit_status_))).Check();
    }
  } else {
    <span class="hljs-comment">// If exit_status_ &#x3C; 0 the process was never started because of some error.</span>
    js_result-><span class="hljs-built_in">Set</span>(context, env()-><span class="hljs-built_in">status_string</span>(),
                   <span class="hljs-built_in">Null</span>(env()-><span class="hljs-built_in">isolate</span>()))<span class="hljs-selector-class">.Check</span>();
  }
  <span class="hljs-comment">// 忽略其他处理</span>

  return scope<span class="hljs-selector-class">.Escape</span>(js_result);
}
</code></pre>
<p>BuildResultObject 会收集子进程的退出信息返回给 JS。到这里，一个同步创建的子进程就完成了它的一生。</p>
<h1>父子进程对进程间通信的处理</h1>
<p>进程间通信是多进程系统中非常重要的功能，<strong>没有进程间通信，进程就像孤岛一样不能交流信息</strong>。这是因为，进程间的内存是隔离的，如果进程间想通信，就需要一个公共的地方让多个进程可以互相访问，完成信息的传递。</p>
<p>在 Linux 中，同主机的进程间通信方式有很多，但基本都是先使用独立于进程的额外内存作为信息承载的地方，再通过某种方式让多个进程都可以访问到这块公共内存，比如管道、共享内存、Unix 域、消息队列等等。</p>
<p>不过，还有另外一种进程间通信的方式不属于以上情况，那就是信号。信号作为一种简单的进程间通信方式，操作系统提供了接口让进程可以直接修改另一个进程的数据，以此达到通信目的。Node.js 进程模块内置了进程间通信，使用的是 Unix 域方式。因为 Unix 域是唯一一种支持文件描述符传递的进程间通信方式。下面介绍 Node.js 中进程间通信的原理和实现。</p>
<h2>创建通信通道</h2>
<p>我们从 fork 函数开始分析 Node.js 中进程间通信的逻辑。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fork</span>(<span class="hljs-params">modulePath</span>) {  
 <span class="hljs-comment">// options.stdio 为字符串数组，比如 ['inherit','inherit','inherit']</span>
 <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options.<span class="hljs-property">stdio</span> === <span class="hljs-string">'string'</span>) {  
    options.<span class="hljs-property">stdio</span> = <span class="hljs-title function_">stdioStringToArray</span>(options.<span class="hljs-property">stdio</span>, <span class="hljs-string">'ipc'</span>);  
  } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 其他格式</span>
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">spawn</span>(options.<span class="hljs-property">execPath</span>, args, options);  
}  

<span class="hljs-keyword">function</span> <span class="hljs-title function_">stdioStringToArray</span>(<span class="hljs-params">stdio, channel</span>) {  
  <span class="hljs-keyword">const</span> options = [];  
  
  <span class="hljs-keyword">switch</span> (stdio) {  
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ignore'</span>:  
    <span class="hljs-keyword">case</span> <span class="hljs-string">'pipe'</span>: options.<span class="hljs-title function_">push</span>(stdio, stdio, stdio); <span class="hljs-keyword">break</span>;  
    <span class="hljs-keyword">case</span> <span class="hljs-string">'inherit'</span>: options.<span class="hljs-title function_">push</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-keyword">break</span>;  
  }  
  
  <span class="hljs-keyword">if</span> (channel) options.<span class="hljs-title function_">push</span>(channel);  
  
  <span class="hljs-keyword">return</span> options;  
}  
</code></pre>
<p>fork 中调用 stdioStringToArray 处理了数据的格式，并返回一个字符串数组，比如['pipe', 'pipe', 'pipe', 'ipc']或[0, 1, 2, 'ipc']，ipc 代表需要创建一个进程间通信的通道。处理完参数后，fork 函数调用了 spawn，接着看一下 spawn 函数的实现。</p>
<pre><code class="hljs language-ini">function getValidStdio(stdio, sync) {  
  let ipc<span class="hljs-comment">;  </span>
  let ipcFd<span class="hljs-comment">;  </span>
  
  <span class="hljs-attr">stdio</span> = stdio.reduce((acc, stdio, i) => {  
    if (<span class="hljs-attr">stdio</span> === <span class="hljs-string">'ipc'</span>) {  
      <span class="hljs-attr">ipc</span> = new Pipe(PipeConstants.IPC)<span class="hljs-comment">;  </span>
      <span class="hljs-attr">ipcFd</span> = i<span class="hljs-comment">;  </span>
      acc.push({  
        type: 'pipe',  
        handle: ipc,  
        ipc: true  
      })<span class="hljs-comment">;  </span>
    } else {  
      // 其它类型的处理  
    }  
    return acc<span class="hljs-comment">;  </span>
  }, <span class="hljs-section">[]</span>)<span class="hljs-comment">;  </span>
  // stdio 为对象数组， ipc 为 new Pipe，ipcFd 为子进程中的文件描述符
  return { stdio, ipc, ipcFd }<span class="hljs-comment">;  </span>
}  

<span class="hljs-attr">ChildProcess.prototype.spawn</span> = function(options) {  
  let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">;  </span>
  // 预处理进程间通信的数据结构  
  <span class="hljs-attr">stdio</span> = getValidStdio(stdio, <span class="hljs-literal">false</span>)<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">ipc</span> = stdio.ipc<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">ipcFd</span> = stdio.ipcFd<span class="hljs-comment">;  </span>
  <span class="hljs-attr">stdio</span> = options.stdio = stdio.stdio<span class="hljs-comment">;  </span>
  // 通过环境变量告诉子进程 IPC 文件描述符和数据处理模式  
  if (ipc !== undefined) {  
    options.envPairs.push(`<span class="hljs-attr">NODE_CHANNEL_FD</span>=<span class="hljs-variable">${ipcFd}</span>`)<span class="hljs-comment">;  </span>
    options.envPairs.push(`<span class="hljs-attr">NODE_CHANNEL_SERIALIZATION_MODE</span>=<span class="hljs-variable">${serialization}</span>`)<span class="hljs-comment">;  </span>
  } 
  // 创建子进程
  const <span class="hljs-attr">err</span> = this._handle.spawn(options)<span class="hljs-comment">;</span>
  // 处理主进程的 IPC 通信  
  if (ipc !== undefined) setupChannel(this, ipc, serialization)<span class="hljs-comment">;  </span>
  return err<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>spawn 中会首先执行 getValidStdio 预处理进程间通信的数据结构，这里我们只需要关注 ipc 的。可以看到，Node.js 会执行 new Pipe(PipeConstants.IPC) 创建一个 Unix 域用于进程间通信，但是这里只是定义了一个 C++ 对象，还没有可用的文件描述符。处理完进程间通信的数据结构后，父进程通过环境变量 NODE_CHANNEL_FD 告诉子进程IPC 通信的文件描述符是哪个，以及数据处理方式是什么（进程间通信的数据需要序列化和反序列化处理，比如按照 JSON 格式处理）。</p>
<p>接着执行 C++ 层的 Spawn 创建子进程，我们只关注关于进程间通信的处理。C++ 层首先也是需要处理参数。</p>
<pre><code class="hljs language-scss">static void <span class="hljs-built_in">ParseStdioOptions</span>(Environment* env,  
                                Local&#x3C;Object> js_options,  
                                uv_process_options_t* options) {  
    Local&#x3C;Context> context = env-><span class="hljs-built_in">context</span>();  
    Local&#x3C;String> stdio_key = env-><span class="hljs-built_in">stdio_string</span>();  
    <span class="hljs-comment">// 拿到 JS 层 stdio 的值  </span>
    Local&#x3C;Array> stdios = js_options-><span class="hljs-built_in">Get</span>(context, stdio_key)<span class="hljs-selector-class">.ToLocalChecked</span>()<span class="hljs-selector-class">.As</span>&#x3C;Array>();  
  
    uint32_t len = stdios-><span class="hljs-built_in">Length</span>();  
    <span class="hljs-comment">// 传递给 Libuv uv_spawn 的数据结构</span>
    options->stdio = new uv_stdio_container_t<span class="hljs-selector-attr">[len]</span>;  
    options->stdio_count = len;  
    <span class="hljs-comment">// 遍历 stdio，stdio 是一个对象数组  </span>
    for (uint32_t i = <span class="hljs-number">0</span>; i &#x3C; len; i++) {  
      <span class="hljs-comment">// 拿到数组的元素，是个对象</span>
      Local&#x3C;<span class="hljs-selector-tag">Object</span>> stdio = stdios-><span class="hljs-built_in">Get</span>(context, i)<span class="hljs-selector-class">.ToLocalChecked</span>()<span class="hljs-selector-class">.As</span>&#x3C;<span class="hljs-selector-tag">Object</span>>();  
      <span class="hljs-comment">// 拿到 stdio 的类型  </span>
      Local&#x3C;Value> type = stdio-><span class="hljs-built_in">Get</span>(context, env->type_string())<span class="hljs-selector-class">.ToLocalChecked</span>();  
      <span class="hljs-comment">// type 字段是 pipe 字符串，则表示创建 IPC 通道  </span>
      if (type->StrictEquals(env->pipe_string())) {  
        <span class="hljs-comment">// 设置标记和流结构体，UV_CREATE_PIPE 标记要创建一个 IPC 通道</span>
        options->stdio<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.flags</span> = static_cast&#x3C;uv_stdio_flags>(  
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);  
        <span class="hljs-comment">// 拿到对应的 Libuv stream 结构体  </span>
        options->stdio<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.stream</span> = <span class="hljs-built_in">StreamForWrap</span>(env, stdio);  
      }  
    }  
  }  
</code></pre>
<p>ParseStdioOptions 会把 StreamForWrap 的结果保存到 stream 中，我们看看 StreamForWrap 的逻辑。</p>
<pre><code class="hljs language-vbnet"><span class="hljs-keyword">static</span> uv_stream_t* StreamForWrap(Environment* env, Local&#x3C;<span class="hljs-type">Object</span>> stdio) {  
  Local&#x3C;<span class="hljs-type">String</span>> handle_key = env->handle_string();  
  /*
    获取对象中的 <span class="hljs-keyword">key</span> 为 handle 的值，对应刚才 JS 层 getValidStdio 的以下代码
    <span class="hljs-keyword">const</span> ipc = <span class="hljs-built_in">new</span> Pipe(SOCKET.IPC);
    acc.push({  
        type: <span class="hljs-comment">'pipe',  </span>
        handle: ipc,  
        ipc: <span class="hljs-literal">true</span>  
    });
  */  
  Local&#x3C;<span class="hljs-type">Object</span>> handle = stdio-><span class="hljs-keyword">Get</span>(env->context(), handle_key).ToLocalChecked().<span class="hljs-keyword">As</span>&#x3C;<span class="hljs-type">Object</span>>();  
  // 获取 JS 层对象所对应的 C++ 对象中的 stream  
  uv_stream_t* stream = LibuvStreamWrap::<span class="hljs-keyword">From</span>(env, handle)->stream();  
  <span class="hljs-keyword">return</span> stream;  
}  
      
// 从 JS 层使用的 <span class="hljs-type">object</span> 中获取关联的 C++ 对象  
LibuvStreamWrap* LibuvStreamWrap::<span class="hljs-keyword">From</span>(Environment* env, Local&#x3C;<span class="hljs-type">Object</span>> <span class="hljs-type">object</span>) {  
     <span class="hljs-keyword">return</span> Unwrap&#x3C;LibuvStreamWrap>(<span class="hljs-type">object</span>);  
}
</code></pre>
<p>前面课程讲过 JS 和 C++ 关联的内容，刚才 JS 层执行 new Pipe(SOCKET.IPC) 时创建了一个关联了 C++ 对象的 JS 对象。上面的代码是通过 JS handle 对象获取关联的 C++ 对象，再从 C++ 对象中获取它的 Libuv 数据结构 uv_stream_t，然后 Libuv 中会把文件描述符保存到该 stream 中。</p>
<p>参数处理完后，接着看 C++ 层调用 Libuv 的 uv_spawn。</p>
<pre><code class="hljs language-ini">int uv_spawn(uv_loop_t* loop,  
             uv_process_t* process,  
             const uv_process_options_t* options) {  
  
  int (*pipes)<span class="hljs-section">[2]</span><span class="hljs-comment">;  </span>
  // 创建进程间通信的文件描述符  
  for (<span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; options->stdio_count; i++) {  </span>
    <span class="hljs-attr">err</span> = uv__process_init_stdio(options->stdio + i, pipes[i])<span class="hljs-comment">; </span>
    if (err)  
      goto error<span class="hljs-comment">;  </span>
  }  
    
  // 设置进程间通信文件描述符到对应的数据结构
  for (<span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; options->stdio_count; i++) {  </span>
    uv__process_open_stream(options->stdio + i, pipes<span class="hljs-section">[i]</span>)<span class="hljs-comment">;  </span>
      
  }  
}  
</code></pre>
<p>uv_spawn 中执行 uv__process_init_stdio 创建 IPC 通道。</p>
<pre><code class="hljs language-arduino">
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">uv__make_socketpair</span><span class="hljs-params">(<span class="hljs-type">int</span> fds[<span class="hljs-number">2</span>])</span> </span>{
  <span class="hljs-comment">// 创建一个 Unix 域 IPC 通道，两个通信 fd 保存到 fds 中，一个用于父进程，一个用于子进程</span>
  <span class="hljs-built_in">socketpair</span>(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, fds)
  <span class="hljs-built_in">uv__cloexec</span>(fds[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">uv__process_init_stdio</span><span class="hljs-params">(<span class="hljs-type">uv_stdio_container_t</span>* container, <span class="hljs-type">int</span> fds[<span class="hljs-number">2</span>])</span> </span>{
  <span class="hljs-type">int</span> mask;
  <span class="hljs-type">int</span> fd;

  mask = UV_IGNORE | UV_CREATE_PIPE | UV_INHERIT_FD | UV_INHERIT_STREAM;

  <span class="hljs-keyword">switch</span> (container->flags &#x26; mask) {
      <span class="hljs-keyword">case</span> UV_CREATE_PIPE:
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">uv__make_socketpair</span>(fds);
  }
}
</code></pre>
<p>uv__process_init_stdio 中会创建用于进程间通信的文件描述符，接着通过 uv__process_open_stream 保存到对应的数据结构中。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">uv__process_open_stream</span><span class="hljs-params">(<span class="hljs-type">uv_stdio_container_t</span>* container,  
                                   <span class="hljs-type">int</span> pipefds[<span class="hljs-number">2</span>])</span> </span>{  
  <span class="hljs-type">int</span> flags;  
  <span class="hljs-type">int</span> err;  
  
  <span class="hljs-keyword">if</span> (!(container->flags &#x26; UV_CREATE_PIPE) || pipefds[<span class="hljs-number">0</span>] &#x3C; <span class="hljs-number">0</span>)  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
  <span class="hljs-comment">// 把 fd 保存到 IPC 对应的 stream 中</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">uv__stream_open</span>(container->data.stream, pipefds[<span class="hljs-number">0</span>], flags);  
}  
</code></pre>
<p>执行完 uv__process_open_stream，用于 IPC 的文件描述符就保存到 new Pipe(SOCKET.IPC) 所关联的 C++ 对象中。有了 IPC 通道的文件描述符，进程还需要进一步处理。我们看到 JS 层执行完 spawn 后，父子进程中都分别做了处理。</p>
<h2>主进程处理通信通道</h2>
<p>主进程创建完子进程后，会执行 setupChannel 处理数据发送和接收的逻辑。首先看一下接收数据的实现。</p>
<pre><code class="hljs language-ini">// target 为 ChildProcess 对象， channel 是 new Pipe(PipeConstants.IPC)<span class="hljs-comment">;  </span>
function setupChannel(target, channel, serializationMode) { 
  const <span class="hljs-attr">control</span> = new Control(channel)<span class="hljs-comment">;    </span>
  <span class="hljs-attr">target.channel</span> = control<span class="hljs-comment">;      </span>
  // 注册处理数据的函数    
  <span class="hljs-attr">channel.onread</span> = function(arrayBuffer) {      
    if (arrayBuffer) {      
      const <span class="hljs-attr">nread</span> = streamBaseState[kReadBytesOrError]<span class="hljs-comment">;</span>
      const <span class="hljs-attr">offset</span> = streamBaseState[kArrayBuffer<span class="hljs-literal">Off</span>set]<span class="hljs-comment">;</span>
      const <span class="hljs-attr">pool</span> = new Uint8Array(arrayBuffer, <span class="hljs-literal">off</span>set, nread)<span class="hljs-comment">;</span>
      // 解析收到的消息    
      for (const message of parseChannelMessages(channel, pool))   {    
        // 处理数据   
      }    
    }  
  }<span class="hljs-comment">;    </span>
  // 注册可读事件    
  channel.readStart()<span class="hljs-comment">;    </span>
  return control<span class="hljs-comment">;    </span>
}    
</code></pre>
<p>主进程注册了读事件，对应的处理函数是 onread，下面会详细分析。接着看一下发送数据的实现，代码也是在 setupChannel 函数中。</p>
<pre><code class="hljs language-ini">// target 是 process 对象
<span class="hljs-attr">target.send</span> = function(message, handle, options, callback) {
  return this._send(message, handle, options, callback)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

<span class="hljs-attr">target._send</span> = function(message, handle, options, callback) {  
   let obj<span class="hljs-comment">;  </span>
   const <span class="hljs-attr">req</span> = new WriteWrap()<span class="hljs-comment">;  </span>
   // 发送给对端  
   const <span class="hljs-attr">err</span> = writeChannelMessage(channel, req, message, handle)<span class="hljs-comment">;</span>
 }  
</code></pre>
<p>send 函数最终调用了 writeChannelMessage 发送数据。</p>
<pre><code class="hljs language-ini">writeChannelMessage(channel, req,message, handle) {  
  const <span class="hljs-attr">ser</span> = new ChildProcessSerializer()<span class="hljs-comment">;  </span>
  ser.writeHeader()<span class="hljs-comment">;  </span>
  ser.writeValue(message)<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">serializedMessage</span> = ser.releaseBuffer()<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">sizeBuffer</span> = Buffer.allocUnsafe(<span class="hljs-number">4</span>)<span class="hljs-comment">;  </span>
  sizeBuffer.writeUInt32BE(serializedMessage.length)<span class="hljs-comment">;  </span>
  // channel 是封装了 Unix 域的对象
  return channel.writeBuffer(req, Buffer.concat(<span class="hljs-section">[  
    sizeBuffer,  
    serializedMessage  
  ]</span>), handle)<span class="hljs-comment">;  </span>
}
</code></pre>
<p>channel.writeBuffer 通过刚才创建的 IPC 通道完成数据的发送。</p>
<h2>子进程处理通信通道</h2>
<p>接着看看子进程的逻辑。在创建子进程的时候，Node.js 中的主进程会通过环境变量 NODE_CHANNEL_FD 告诉子进程 Unix 域通信对应的文件描述符。在执行子进程的时候，它会处理这个文件描述符。具体实现在 setupChildProcessIpcChannel 函数中。</p>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">setupChildProcessIpcChannel</span>() {  
  <span class="hljs-comment">// 主进程通过环境变量设置该值</span>
  if (process.env.NODE_CHANNEL_FD) {  
    const fd = <span class="hljs-built_in">parseInt</span>(process.env.NODE_CHANNEL_FD, <span class="hljs-number">10</span>);  
    delete process<span class="hljs-selector-class">.env</span><span class="hljs-selector-class">.NODE_CHANNEL_FD</span>;   
    <span class="hljs-built_in">require</span>('child_process')<span class="hljs-selector-class">._forkChild</span>(fd, serializationMode);  
  }  
}  

function <span class="hljs-built_in">_forkChild</span>(fd, serializationMode) {  
  const <span class="hljs-selector-tag">p</span> = new <span class="hljs-built_in">Pipe</span>(PipeConstants.IPC);  
  <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.open</span>(fd);  
  const control = <span class="hljs-built_in">setupChannel</span>(process, p, serializationMode);  
} 
</code></pre>
<p>_forkChild 函数创建一个 Pipe 对象，然后把主进程传过来的 fd 保存到该 Pipe 对象中。对该 Pipe 对象的读写，就是对该 fd 进行读写，最后执行 setupChannel。setupChannel 主要是完成了 Unix 域通信的封装，包括处理接收的消息、发送消息、处理文件描述符传递等。刚才已经分析过，我们就不再具体分析了。</p>
<h1>进程间通信和文件描述符传递的实现</h1>
<p>那我们刚才分析了主进程和子进程是如何处理进程间通信的，下面再来分析下进程间通信中数据发送、数据接收和文件描述符传递的具体实现。</p>
<h2>发送</h2>
<p>首先来看一下进程间通信中，发送端实现的具体函数是 send，代码如下所示。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">process.send</span> = function(message, handle, options, callback) {  
    return this._send(message, handle, options, callback)<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
      
<span class="hljs-attr">process._send</span> = function(message, handle, options, callback) {  
  let obj<span class="hljs-comment">;  </span>
  // 发送文件描述符，handle 是文件描述符的封装  
  if (handle) {  
    // 消息类型是 NODE_HANDLE
    <span class="hljs-attr">message</span> = {  
      cmd: 'NODE_HANDLE',  
      type: null,  
      msg: message  
    }<span class="hljs-comment">;  </span>
    // handle 的 类型  
    if (handle instanceof net.Socket) {  
      <span class="hljs-attr">message.type</span> = <span class="hljs-string">'net.Socket'</span><span class="hljs-comment">;  </span>
    } else if (handle instanceof net.Server) {  
      <span class="hljs-attr">message.type</span> = <span class="hljs-string">'net.Server'</span><span class="hljs-comment">;  </span>
    } else if (handle instanceof TCP || handle instanceof Pipe) {  
      <span class="hljs-attr">message.type</span> = <span class="hljs-string">'net.Native'</span><span class="hljs-comment">;  </span>
    } else if (handle instanceof dgram.Socket) {  
      <span class="hljs-attr">message.type</span> = <span class="hljs-string">'dgram.Socket'</span><span class="hljs-comment">;  </span>
    } else if (handle instanceof UDP) {  
      <span class="hljs-attr">message.type</span> = <span class="hljs-string">'dgram.Native'</span><span class="hljs-comment">;  </span>
    }
    // 把 JS 层使用的对象转成 C++ 层对象  
    <span class="hljs-attr">handle</span> = handleConversion[message.type].send.call(target, 
                                                    message,
                                                    handle, 
                                                    options)<span class="hljs-comment">;  </span>
  }  
  // 发送  
  const <span class="hljs-attr">req</span> = new WriteWrap()<span class="hljs-comment">;  </span>
  // 发送给对端  
  const <span class="hljs-attr">err</span> = writeChannelMessage(channel, req, message, handle)<span class="hljs-comment">;  </span>
    
}  
</code></pre>
<p>如果发送的是一般数据，那发送格式如下。</p>
<pre><code class="hljs language-css">{ hello: <span class="hljs-string">"world"</span> } ｜  { cmd: <span class="hljs-string">'NODE_CLUSTER'</span>, ...message, seq }
</code></pre>
<p>NODE_CLUSTER 为 Node.js Cluster 模块发送的数据格式，后面 Cluster 课程会详细讲解。如果发送一般数据且发送文件描述符，那发送格式如下。</p>
<pre><code class="hljs language-css">{  
  cmd: <span class="hljs-string">'NODE_HANDLE'</span>,  
  type: xxx,  
  msg: { hello: <span class="hljs-string">"world"</span> } ｜ { cmd: <span class="hljs-string">'NODE_CLUSTER'</span>, ...message, seq } 
}
</code></pre>
<p>这里以最长路径来分析。Node.js 在发送一个封装了文件描述符的对象之前，首先会把 JS 层使用的对象转成 C++ 层使用的对象，如 TCP Server。</p>
<pre><code class="hljs language-javascript"><span class="hljs-title function_">send</span>(<span class="hljs-params">message, server, options</span>) {  
    <span class="hljs-keyword">return</span> server.<span class="hljs-property">_handle</span>;  
} 
</code></pre>
<p>server 是 net 模块的 createServer 创建的实例，server._handle 则表示 server 关联的 C++ 层创建的对象，接着看 writeChannelMessage 函数。</p>
<pre><code class="hljs language-ini">// channel 是 new Pipe(PipeConstants.IPC)<span class="hljs-comment">;  </span>
writeChannelMessage(channel, req, message, handle) {
    const <span class="hljs-attr">ser</span> = new ChildProcessSerializer()<span class="hljs-comment">;</span>
    ser.writeHeader()<span class="hljs-comment">;</span>
    ser.writeValue(message)<span class="hljs-comment">;</span>
    const <span class="hljs-attr">serializedMessage</span> = ser.releaseBuffer()<span class="hljs-comment">;</span>
    const <span class="hljs-attr">sizeBuffer</span> = Buffer.allocUnsafe(<span class="hljs-number">4</span>)<span class="hljs-comment">;</span>
    sizeBuffer.writeUInt32BE(serializedMessage.length)<span class="hljs-comment">;</span>
    return channel.writeBuffer(req, Buffer.concat(<span class="hljs-section">[
      sizeBuffer,
      serializedMessage
    ]</span>), handle)<span class="hljs-comment">;</span>
  },
</code></pre>
<p>writeChannelMessage 进行了数据序列化，接着调用 WriteBuffer 函数。</p>
<pre><code class="hljs language-ini">int StreamBase::WriteBuffer(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {
  Environment* <span class="hljs-attr">env</span> = Environment::GetCurrent(args)<span class="hljs-comment">;</span>
  // 请求上下文对象
  Local&#x3C;Object> <span class="hljs-attr">req_wrap_obj</span> = args[<span class="hljs-number">0</span>].As&#x3C;Object>()<span class="hljs-comment">;</span>
  uv_buf_t buf<span class="hljs-comment">;</span>
  // 一般数据部分
  <span class="hljs-attr">buf.base</span> = Buffer::Data(args[<span class="hljs-number">1</span>])<span class="hljs-comment">;</span>
  <span class="hljs-attr">buf.len</span> = Buffer::Length(args[<span class="hljs-number">1</span>])<span class="hljs-comment">;</span>

  uv_stream_t* <span class="hljs-attr">send_handle</span> = nullptr<span class="hljs-comment">;</span>
  // 是对象则说明是一个文件描述符的 wapper，如果流是 IPC 通道则支持发送文件描述符
  if (args<span class="hljs-section">[2]</span>->IsObject() &#x26;&#x26; IsIPCPipe()) {
    Local&#x3C;Object> <span class="hljs-attr">send_handle_obj</span> = args[<span class="hljs-number">2</span>].As&#x3C;Object>()<span class="hljs-comment">;</span>
    /* 
        send_handle_obj 是由 C++ 层创建在 JS 层使用的对象，
        解包出真正在 C++ 层使用的对象  
    */
    HandleWrap* wrap<span class="hljs-comment">;</span>
    ASSIGN_OR_RETURN_UNWRAP(&#x26;wrap, send_handle_obj, UV_EINVAL)<span class="hljs-comment">;</span>
    // 拿到 Libuv 层的 handle 结构体
    <span class="hljs-attr">send_handle</span> = reinterpret_cast&#x3C;uv_stream_t*>(wrap->GetHandle())<span class="hljs-comment">;</span>
    //设置到请求上下文中
    req_wrap_obj->Set(env->context(),
                      env->handle_string(),
                      send_handle_obj).Check()<span class="hljs-comment">;</span>
  }

  StreamWriteResult <span class="hljs-attr">res</span> = Write(&#x26;buf, <span class="hljs-number">1</span>, send_handle, req_wrap_obj)<span class="hljs-comment">;</span>
  SetWriteResult(res)<span class="hljs-comment">;</span>

  return res.err<span class="hljs-comment">;</span>
}
</code></pre>
<p>Write 会调用 Libuv 发送数据，如果传递了文件描述符，Libuv 会把 handle 中的 fd 取出来，使用 sendmsg 传递到其它进程（在 uv__write 函数中），文件描述符的整个发送的过程本质是从 JS 层到 Libuv 层，层层揭开要发送的对象，拿到一个文件描述符，然后通过操作系统提供的 API 把文件描述符传递给另一个进程，最终在另一个进程中把 fd 封装成对应的对象。如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93bbf14c62fb4784a45b0bd815fb358c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>接收</h2>
<p>分析完发送数据的逻辑，再看一下接收的逻辑。当收到数据时会执行 C++ 层的 OnUvRead 函数。</p>
<pre><code class="hljs language-scss">static MaybeLocal&#x3C;<span class="hljs-selector-tag">Object</span>> <span class="hljs-built_in">AcceptHandle</span>(Environment* env,
                                       LibuvStreamWrap* parent) {
  EscapableHandleScope <span class="hljs-built_in">scope</span>(env->isolate());
  Local&#x3C;<span class="hljs-selector-tag">Object</span>> wrap_obj;
  <span class="hljs-comment">// 创建一个新的 C++ 对象，比如 TCPWrap，可参考 TCPWrap::Instantiate</span>
  if (!WrapType::Instantiate(env, parent, WrapType::SOCKET)<span class="hljs-selector-class">.ToLocal</span>(&#x26;wrap_obj))
    return Local&#x3C;<span class="hljs-selector-tag">Object</span>>();
  <span class="hljs-comment">// 拿到 TCPWrap 对象</span>
  HandleWrap* wrap = Unwrap&#x3C;HandleWrap>(wrap_obj);
  <span class="hljs-comment">// 拿到 TCPWrap 中的 Libuv 结构体</span>
  uv_stream_t* stream = reinterpret_cast&#x3C;uv_stream_t*>(wrap->GetHandle());
  <span class="hljs-comment">// 把 fd 保存到 C++ 对象里的 stream 结构体中</span>
  <span class="hljs-built_in">uv_accept</span>(parent->stream(), stream);

  return scope<span class="hljs-selector-class">.Escape</span>(wrap_obj);
}

<span class="hljs-comment">// 有数据时的回调，buf 为普通数据</span>
void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) {  
  uv_handle_type type = UV_UNKNOWN_HANDLE;  
  <span class="hljs-comment">// 是否支持传递文件描述符并且有待处理的文件描述符，则判断文件描述符类型  </span>
  if (is_named_pipe_ipc() &#x26;&#x26;  
      <span class="hljs-built_in">uv_pipe_pending_count</span>(reinterpret_cast&#x3C;uv_pipe_t*>(stream())) > <span class="hljs-number">0</span>) {  
    type = <span class="hljs-built_in">uv_pipe_pending_type</span>(reinterpret_cast&#x3C;uv_pipe_t*>(stream()));  
  }  
  
  <span class="hljs-comment">// 读取成功  </span>
  if (nread > <span class="hljs-number">0</span>) {  
    MaybeLocal&#x3C;<span class="hljs-selector-tag">Object</span>> pending_obj;  
    <span class="hljs-comment">// 根据类型创建一个新的 C++ 对象表示客户端，并且从服务器中摘下一个传递过来的 fd 保存到客户端  </span>
    if (type == UV_TCP) {  
      pending_obj = AcceptHandle&#x3C;TCPWrap>(env(), this);  
    } else if (type == UV_NAMED_PIPE) {  
      pending_obj = AcceptHandle&#x3C;PipeWrap>(env(), this);  
    } else if (type == UV_UDP) {  
      pending_obj = AcceptHandle&#x3C;UDPWrap>(env(), this);  
    }
    <span class="hljs-comment">// 保存到 JS 层使用的对象中，键是 pendingHandle  </span>
    if (!pending_obj.IsEmpty()) {  
      <span class="hljs-selector-tag">object</span>()  
          -><span class="hljs-built_in">Set</span>(env()-><span class="hljs-built_in">context</span>(),  
                <span class="hljs-built_in">env</span>()-><span class="hljs-built_in">pending_handle_string</span>(),  
                pending_obj<span class="hljs-selector-class">.ToLocalChecked</span>())  
          <span class="hljs-selector-class">.Check</span>();  
    }  
  }  
  <span class="hljs-comment">// 通知 JS</span>
  <span class="hljs-built_in">EmitRead</span>(nread, *buf);  
}  
</code></pre>
<p>OnUvRead 函数中，buf 保存了一般数据，然后通过 Libuv 的函数判断是否有文件描述符需要处理。有就创建一个 C++ 层对象，并把 fd 保存到 C++ 对象的 Libuv handle 中，最后把数据保存到 pendingHandle 属性等待 JS 层处理。接下来，我们看看 JS 层的处理。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">channel.onread</span> = function(arrayBuffer) {  
  // 收到的文件描述符  
  const <span class="hljs-attr">recvHandle</span> = channel.pendingHandle<span class="hljs-comment">;  </span>
  <span class="hljs-attr">channel.pendingHandle</span> = null<span class="hljs-comment">;  </span>
  if (arrayBuffer) {  
    const <span class="hljs-attr">nread</span> = streamBaseState[kReadBytesOrError]<span class="hljs-comment">;  </span>
    const <span class="hljs-attr">offset</span> = streamBaseState[kArrayBuffer<span class="hljs-literal">Off</span>set]<span class="hljs-comment">;  </span>
    const <span class="hljs-attr">pool</span> = new Uint8Array(arrayBuffer, <span class="hljs-literal">off</span>set, nread)<span class="hljs-comment">;  </span>
    if (recvHandle)  
      <span class="hljs-attr">pendingHandle</span> = recvHandle<span class="hljs-comment">;  </span>
    // 解析收到的消息  
    for (const message of parseChannelMessages(channel, pool)) {       
      // 是否是内部通信事件，cmd 是 NODE_ 开头的，比如 NODE_HANDLE、NODE_CLUSTER  
      if (isInternal(message)) {  
        // 收到了文件描述符
        if (<span class="hljs-attr">message.cmd</span> === <span class="hljs-string">'NODE_HANDLE'</span>) {  
          handleMessage(message, pendingHandle, true)<span class="hljs-comment">;  </span>
          <span class="hljs-attr">pendingHandle</span> = null<span class="hljs-comment">;  </span>
        } else {  
          // cluster 模块的消息，cmd 为 NODE_CLUSTER
          handleMessage(message, undefined, true)<span class="hljs-comment">;  </span>
        }  
      } else {  // 一般数据
        handleMessage(message, undefined, false)<span class="hljs-comment">;  </span>
      }  
    }  
  }  
}<span class="hljs-comment">;  </span>
</code></pre>
<p>收到一个数据时，接收端首先根据消息的 cmd 字段判断数据的类型。cmd 如果是 NODE_ 开头的，就表示是内部数据，比如 NODE_HANDLE、NODE_CLUSTER，否则就是一般数据。handleMessage 会根据消息进一步处理。</p>
<pre><code class="hljs language-csharp"><span class="hljs-function">function <span class="hljs-title">handleMessage</span>(<span class="hljs-params">message, handle, <span class="hljs-keyword">internal</span></span>)</span> {
  <span class="hljs-keyword">const</span> eventName = (<span class="hljs-keyword">internal</span> ? <span class="hljs-string">'internalMessage'</span> : <span class="hljs-string">'message'</span>);
  process.nextTick(emit, eventName, message, handle);
}
</code></pre>
<p>如果是一般数据，则直接触发 message 事件，否则触发 internalMessage 事件。在Node.js 中，有两个主要的地方监听了这个事件，第一个是用于处理文件描述符传递的地方。</p>
<pre><code class="hljs language-javascript">target.<span class="hljs-title function_">on</span>(<span class="hljs-string">'internalMessage'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">message, handle</span>) {  
  <span class="hljs-comment">// 只处理 NODE_HANDLE 消息，即文件描述符传递</span>
  <span class="hljs-keyword">if</span> (message.<span class="hljs-property">cmd</span> !== <span class="hljs-string">'NODE_HANDLE'</span>) <span class="hljs-keyword">return</span>;  
  
  <span class="hljs-comment">// 成功收到，发送 ACK  </span>
  target.<span class="hljs-title function_">_send</span>({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'NODE_HANDLE_ACK'</span> }, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);  
    
  <span class="hljs-keyword">const</span> obj = handleConversion[message.<span class="hljs-property">type</span>];  
  
  <span class="hljs-comment">/*
    C++ 对象转成 JS 层使用的对象。转完之后再根据里层的字段
    message.msg 进一步处理  
  */</span>
  obj.<span class="hljs-property">got</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, message, handle, <span class="hljs-function">(<span class="hljs-params">handle</span>) =></span> {   
    <span class="hljs-comment">// 再次判断数据的类型，然后进一步分发，也有可能还是内部类型，比如 NODE_CLUSTER</span>
    <span class="hljs-title function_">handleMessage</span>(message.<span class="hljs-property">msg</span>, handle, <span class="hljs-title function_">isInternal</span>(message.<span class="hljs-property">msg</span>));   
  });  
})  
</code></pre>
<p>上面代码有几个重要的逻辑。</p>
<ol>
<li>收到一个 handle 后，返回 ACK 给发送端。这非常重要，因为当发送端收到一个连接时，同时也会拿到一个 fd，它会把这个 fd 发送给接收端，接收端也会拿到一个新的 fd，那么这时候就会有两个 fd。因此，当接收端拿到新的 fd 时，需要告诉发送端已经成功收到 fd，这时发送端就会关闭自己没有用的 fd。</li>
<li>把 C++ 层的 handle 对象转成 JS 层的对象。比如 TCP Server。</li>
</ol>
<pre><code class="hljs language-scss"><span class="hljs-built_in">got</span>(message, handle, emit) {  
    const server = new net<span class="hljs-selector-class">.Server</span>();  
    server<span class="hljs-selector-class">.listen</span>(handle, () => {  
      <span class="hljs-built_in">emit</span>(server);  
    });  
}  
</code></pre>
<p>这就是文件描述符传递的处理流程，处理完文件描述符传递后，会继续对数据部分（message.msg）进行处理，继续根据 cmd 字段判断触发 internalMessage 还是 message 事件。</p>
<p>接着看另一个 internalMessage 的处理，该 internalMessage 用于 cluster 模块。</p>
<pre><code class="hljs language-ini">worker.process.on('internalMessage', onInternalMessage(message, handle) => {
    if (message.cmd !== 'NODE_CLUSTER')
      return<span class="hljs-comment">;</span>
    // onmessage 见下面分析
    let <span class="hljs-attr">fn</span> = <span class="hljs-literal">on</span>message<span class="hljs-comment">;</span>
    // 有 ack 说明是请求对应的响应，找到对应的 callback，否则是收到一个请求
    if (message.ack !== undefined) {
      const <span class="hljs-attr">callback</span> = callbacks.get(message.ack)<span class="hljs-comment">;</span>

      if (callback !== undefined) {
        <span class="hljs-attr">fn</span> = callback<span class="hljs-comment">;</span>
        callbacks.delete(message.ack)<span class="hljs-comment">;</span>
      }
    }

    fn.apply(worker, arguments)<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;);</span>
</code></pre>
<p>cluster 模块的 internalMessage 事件用于处理服务器之间的数据通信。父进程和子进程对于 onmessage 的实现不同。</p>
<pre><code class="hljs language-ini">// 父进程
function onmessage(message, handle) {
  const <span class="hljs-attr">worker</span> = this<span class="hljs-comment">;</span>

  if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'online'</span>)
    online(worker)<span class="hljs-comment">;</span>
  else if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'queryServer'</span>)
    queryServer(worker, message)<span class="hljs-comment">;</span>
  else if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'listening'</span>)
    listening(worker, message)<span class="hljs-comment">;</span>
  else if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'exitedAfterDisconnect'</span>)
    exitedAfterDisconnect(worker, message)<span class="hljs-comment">;</span>
  else if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'close'</span>)
    close(worker, message)<span class="hljs-comment">;</span>
}

// 子进程
function onmessage(message, handle) {
  if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'newconn'</span>)
    onconnection(message, handle)<span class="hljs-comment">;</span>
  else if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'disconnect'</span>)
    _disconnect.call(worker, true)<span class="hljs-comment">;</span>
}
</code></pre>
<p>具体逻辑等我们讲 Cluster 的时候再分析。进程间通信的整体流程我们可以看下面这张图。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5333a168bfcc400880d63df8ff625cda~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h1>总结</h1>
<p>不管在操作系统中，还是 Node.js 里，进程都是一个非常重要的概念，进程是程序在操作系统中的运行实体，是操作系统资源分配的单位，它可以更好地利用多核，也一定程度上提高了应用的安全和稳定性。这节课我们详细讲解了 Node.js 进程模块的内容，希望你能记住以下几点。</p>
<ol>
<li><strong>在操作系统中，进程是程序执行的实体，也是系统资源分配的基本单位</strong> <strong>。</strong> 我们可以通过系统调用 fork 创建一个子进程，这个子进程继承了父进程的代码段。因此通过 fork 的返回值，我们可以在父进程和子进程中分别执行不同的代码逻辑。另外，我们还可以通过 exec 系列函数加载执行另一个程序。</li>
<li>异步和同步创建子进程的方式。异步方式直接通过 fork 创建子进程，这样两个进程就能独立运行了。同步方式则是通过新开一个事件循环，并基于它创建一个子进程，然后父进程会一直等待，直到子进程退出，新的事件循环结束，就可以继续执行了。</li>
<li>进程间通信的原理。父子进程通过 Unix 域实现了进程间通信，Node.js 之所以选择 Unix 域是因为 Unix 域是唯一一种支持文件描述符传递的进程间通信方式。在 Unix 域的基础上，Node.js 主进程和子进程分别做了处理，使得 JS 层可以发送和接收数据。</li>
<li>进程间通信的实现和文件描述符传递的实现。文件描述符传递是操作系统中非常重要的技术，也是 Node.js 中 Cluster 模块的基础，它本质上复制一个进程中的 fd 和资源映射关系到另一个进程。基于文件描述符传递技术，Node.js 上层也封装了很多逻辑，可以通过 JS 使用这种技术。</li>
</ol></div>
</body></html>