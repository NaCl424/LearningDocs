<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Libuv 的流机制</h1>
<p>上节课我们讲了线程的基础知识，以及 Libuv 中的线程池和线程间通信的实现。此外，Libuv 中还有另一个非常重要的概念：流机制，它在 Libuv 的很多模块中都有应用，比如 TCP、Pipe、TTY 等等。</p>
<p>本节课主要讲流的数据结构和围绕着这个数据结构的各种操作（如读写），从中可以看到流是如何基于事件驱动模块工作的。</p>
<h2>流是什么？</h2>
<p>我们先来说说流是什么。流是一种数据处理的机制，主要用来解决生产者 / 消费者之间不同步的问题。比如说，如果进程想往一个目的地写入数据但无法写入，进程就会被阻塞，后面的事件也就都无法继续进行。同样地，如果一个进程想读取数据，但数据还没有准备好，进程就需要一直等待而不能做其他事情。面对这些不合理的情况，流机制借助事件驱动模块的能力，封装了数据处理的具体逻辑，简化了上层调用者的成本。我们除了需要了解流的概念和作用，还需要深入了解和理解其工作原理。</p>
<p>在 Libuv 中流是围绕着文件描述符进行工作的，当我们想对文件描述符执行读写等操作时，我们不会直接操作这个文件描述符，而是由流机制进行管理，因为当我们进行读写操作时，当前并不一定满足条件。也就是说，当我们想从文件描述符中读取数据时，当前可能没有数据可以读，写入数据时同理。这时候，Libuv 会先在流中记录相关的操作和数据，然后 Libuv 会往事件驱动模块注册相应的事件，等到事件触发时才进行真正的读写，并通过回调来通知用户事件的发生。</p>
<p>那么，流具体是如何实现的呢？在流的实现中，最核心的数据结构是 IO 观察者（封装了文件描述符、感兴趣的事情和回调），其余的字段和流的操作相关，比如读一个流，写一个流，关闭一个流，在流中都有对应的字段去支持。</p>
<ol>
<li>读一个流时，注册 IO 观察者中文件描述符的可读事件，可读事件触发时执行用户的读回调。</li>
</ol>

<ol start="2">
<li>写一个流，先把数据写到流队列中，然后等到 IO 观察者中文件描述符的可写事件触发时，执行写入，并执行用户的写完成回调，但是如果当前待写队列为空，则会先尝试执行一次写入，因为文件描述符是非阻塞的，所以写入失败也没关系，可写事件触发时再写就行。</li>
</ol>

<ol start="3">
<li>关闭一个流，就是 IO 观察者中文件描述符的可写事件触发时，如果待写的数据已经写完，然后执行关闭流操作。</li>
</ol>
<p>流通过 IO 观察者，并结合事件驱动模块，很好地解决了生产者和消费者同步的问题。下面具体讲一下流在 Libuv 中的实现，首先看一下流的初始化。</p>
<h2>初始化流</h2>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv__stream_init</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv_stream_t</span>* stream, uv_handle_type type)</span> {
    <span class="hljs-type">int</span> err;
    <span class="hljs-comment">// 初始化 handle</span>
    uv__handle_init(loop, (<span class="hljs-type">uv_handle_t</span>*)stream, type);
    <span class="hljs-comment">// 各种操作的回调</span>
    stream->read_cb = <span class="hljs-literal">NULL</span>;
    stream->alloc_cb = <span class="hljs-literal">NULL</span>;
    stream->close_cb = <span class="hljs-literal">NULL</span>;
    stream->connection_cb = <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">// 各种操作对应的上下文结构体</span>
    stream->connect_req = <span class="hljs-literal">NULL</span>;
    stream->shutdown_req = <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">// 接收的 TCP 连接或者传递过来的文件描述符</span>
    stream->accepted_fd = <span class="hljs-number">-1</span>;
    stream->queued_fds = <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">// 操作对应的错误码</span>
    stream->delayed_error = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 写操作相关的数据结构</span>
    QUEUE_INIT(&#x26;stream->write_queue);
    QUEUE_INIT(&#x26;stream->write_completed_queue);
    stream->write_queue_size = <span class="hljs-number">0</span>;
    <span class="hljs-comment">/*
        初始化 IO 观察者，把文件描述符（这里还没有，所以是 -1）和
        回调 uv__stream_io 记录在 io_watcher 上
    */</span>
    uv__io_init(&#x26;stream->io_watcher, uv__stream_io, <span class="hljs-number">-1</span>);
}
</code></pre>
<p>流的初始化主要是初始化了一些字段，来记录流操作的一些上下文，例如。</p>
<ol>
<li>TCP 服务器（流）发起 listen 时会传入一个回调并记录到 connection_cb 中，当连接到来时会执行 connection_cb。</li>
</ol>

<ol start="2">
<li>TCP 客户端（流）发起连接时的上下文就会记录到 connect_req，当连接结束后执行 connect_req 的回调。</li>
</ol>

<ol start="3">
<li>往流写入数据时，数据会先被记录到 write_queue 队列中等待写入。</li>
</ol>
<p>可以看到，针对流的操作几乎都是异步的，即<strong>发起操作和执行真正的操作是分开进行的</strong>。因此，流就需要额外的字段来记录这些操作上下文，这样当满足操作条件时，流才能根据保存的上下文进行操作。另外我们还可以看到，流的所有操作对应的回调都是 uv__stream_io，在uv__stream_io 会针对触发的事件进行不同的处理。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__stream_io</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv__io_t</span>* w, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> events)</span> {
  <span class="hljs-type">uv_stream_t</span>* stream;

  stream = container_of(w, <span class="hljs-type">uv_stream_t</span>, io_watcher);
  <span class="hljs-comment">// 连接操作</span>
  <span class="hljs-keyword">if</span> (stream->connect_req) {
    uv__stream_connect(stream);
    <span class="hljs-keyword">return</span>;
  }
  
  <span class="hljs-comment">// 触发了可读事件，执行读操作</span>
  <span class="hljs-keyword">if</span> (events &#x26; (POLLIN | POLLERR | POLLHUP))
    uv__read(stream);
    
  <span class="hljs-comment">// 读回调关闭了流</span>
  <span class="hljs-keyword">if</span> (uv__stream_fd(stream) == <span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span>;
    
  <span class="hljs-comment">// 对端关闭了</span>
  <span class="hljs-keyword">if</span> ((events &#x26; POLLHUP) &#x26;&#x26;
      (stream->flags &#x26; UV_HANDLE_READING) &#x26;&#x26;
      (stream->flags &#x26; UV_HANDLE_READ_PARTIAL) &#x26;&#x26;
      !(stream->flags &#x26; UV_HANDLE_READ_EOF)) {
    <span class="hljs-type">uv_buf_t</span> buf = { <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span> };
    uv__stream_eof(stream, &#x26;buf);
  }
  <span class="hljs-comment">// 流关闭了</span>
  <span class="hljs-keyword">if</span> (uv__stream_fd(stream) == <span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span>;  <span class="hljs-comment">/* read_cb closed stream. */</span>
    
  <span class="hljs-comment">// 可写事件触发</span>
  <span class="hljs-keyword">if</span> (events &#x26; (POLLOUT | POLLERR | POLLHUP)) {
    uv__write(stream);
    uv__write_callbacks(stream);

    <span class="hljs-comment">// 待写队列为空</span>
    <span class="hljs-keyword">if</span> (QUEUE_EMPTY(&#x26;stream->write_queue))
      uv__drain(stream);
  }
}
</code></pre>
<p>因为这里面涉及所有流的操作逻辑，所以暂时不深入讲解，在下面的内容中会具体分析每一个操作的实现。</p>
<p>前面讲到，流是围绕着文件描述符进行工作的，但我们发现初始化时，还没有文件描述符。文件描述符通常是在真正使用流的时候才会实时创建，比如当我们通过 Node.js 创建一个 TCP 服务器时，只有在调用 listen 的时候，Node.js 才会通过 Libuv 创建对应的文件描述符（具体是在 bind 操作时）。有了文件描述符之后，就可以通过 uv__stream_open 设置到流中。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv__stream_open</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> flags)</span> {
    <span class="hljs-comment">// 设置流的标记</span>
    stream->flags |= flags;
    <span class="hljs-comment">// 针对 TCP 流的处理</span>
    <span class="hljs-keyword">if</span> (stream->type == UV_TCP) {
        <span class="hljs-comment">// 关闭 nagle 算法</span>
        <span class="hljs-keyword">if</span> ((stream->flags &#x26; UV_HANDLE_TCP_NODELAY) &#x26;&#x26; uv__tcp_nodelay(fd,<span class="hljs-number">1</span>))
            <span class="hljs-keyword">return</span> UV__ERR(errno);
        
        <span class="hljs-comment">// 开启 TCP KEEPALIVE</span>
        <span class="hljs-keyword">if</span> ((stream->flags &#x26; UV_HANDLE_TCP_KEEPALIVE) &#x26;&#x26; uv__tcp_keepalive(fd, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>)) {
            <span class="hljs-keyword">return</span> UV__ERR(errno);
        }
    }
    <span class="hljs-comment">// 保存文件描述符到 IO 观察者中</span>
    stream->io_watcher.fd = fd;
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv__stream_open 主要是记录文件描述符和标记到流的结构体中，有了文件描述符，后续就可以操作这个流了。下面我们一起看看具体的操作。</p>
<h2>对流发起一个连接</h2>
<p>连接操作是针对面向连接的流，如 TCP、Unix 域。因为 TCP 和 Unix 域的实现类似，所以这里以 TCP 连接为例。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv__tcp_connect</span><span class="hljs-params">(<span class="hljs-type">uv_connect_t</span>* req,
                    <span class="hljs-type">uv_tcp_t</span>* handle,
                    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr,
                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addrlen,
                    uv_connect_cb cb)</span> {
  <span class="hljs-type">int</span> err;
  <span class="hljs-type">int</span> r;

  <span class="hljs-comment">// 创建一个用于通信的 socket，把 socket 对应的 fd 保存到 handle 中</span>
  maybe_new_socket(handle,
                   addr->sa_family,
                   UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);

  <span class="hljs-keyword">do</span> {
    errno = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 发起对 addr 的连接</span>
    r = connect(uv__stream_fd(handle), addr, addrlen);
  } <span class="hljs-keyword">while</span> (r == <span class="hljs-number">-1</span> &#x26;&#x26; errno == EINTR);
  <span class="hljs-comment">// 连接还没有成功或者直接失败了</span>
  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">-1</span> &#x26;&#x26; errno != <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span> (errno == EINPROGRESS) <span class="hljs-comment">// 连接中，正常状态</span>
      ; <span class="hljs-comment">/* not an error */</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (errno == ECONNREFUSED) <span class="hljs-comment">// 直接返回连接失败，比如 Unix 域</span>
      handle->delayed_error = UV__ERR(errno);
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">return</span> UV__ERR(errno);
  }
  <span class="hljs-comment">// 初始化一个连接请求</span>
  uv__req_init(handle->loop, req, UV_CONNECT);
  req->cb = cb;
  req->handle = (<span class="hljs-type">uv_stream_t</span>*) handle;
  QUEUE_INIT(&#x26;req-><span class="hljs-built_in">queue</span>);
  handle->connect_req = req;
  <span class="hljs-comment">// 注册可写事件</span>
  uv__io_start(handle->loop, &#x26;handle->io_watcher, POLLOUT);
  <span class="hljs-comment">// 连接出错，插入pending队列，而不是直接执行上层回调</span>
  <span class="hljs-keyword">if</span> (handle->delayed_error)
    uv__io_feed(handle->loop, &#x26;handle->io_watcher);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>连接操作首先会直接调用系统函数 connect 发起一个连接，因为文件描述符是非阻塞的，所以不会导致进程阻塞。对于 TCP 连接，这时候就会发起三次握手，然后返回错误码 EINPROGRESS。接着 Libuv 就会把连接请求的上下文保存到 connect_req，等待三次握手结束时进行下一步处理。接着，我们来看连接结束后的逻辑。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__stream_connect</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream)</span> {
  <span class="hljs-type">int</span> error;
  <span class="hljs-type">uv_connect_t</span>* req = stream->connect_req;
  <span class="hljs-type">socklen_t</span> errorsize = <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>);
  <span class="hljs-comment">// 处理在 uv__tcp_connect 中发起连接时的出错</span>
  <span class="hljs-keyword">if</span> (stream->delayed_error) {
    error = stream->delayed_error;
    stream->delayed_error = <span class="hljs-number">0</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 到这里说明 uv__tcp_connect 中没有出错，然后从内核获取三次握手的结果</span>
    getsockopt(uv__stream_fd(stream),
               SOL_SOCKET,
               SO_ERROR,
               &#x26;error,
               &#x26;errorsize);
    error = UV__ERR(error);
  }
  <span class="hljs-comment">// 还在连接中，则忽略，等待下次回调</span>
  <span class="hljs-keyword">if</span> (error == UV__ERR(EINPROGRESS))
    <span class="hljs-keyword">return</span>;

  stream->connect_req = <span class="hljs-literal">NULL</span>;
  uv__req_unregister(stream->loop, req);
  
  <span class="hljs-comment">// 如果连接错误，或者没有数据等待写入则注销可写事件</span>
  <span class="hljs-keyword">if</span> (error &#x3C; <span class="hljs-number">0</span> || QUEUE_EMPTY(&#x26;stream->write_queue)) {
    uv__io_stop(stream->loop, &#x26;stream->io_watcher, POLLOUT);
  }
  <span class="hljs-comment">// 执行发起连接的回调</span>
  <span class="hljs-keyword">if</span> (req->cb)
    req->cb(req, error);

  <span class="hljs-keyword">if</span> (uv__stream_fd(stream) == <span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span>;
  <span class="hljs-comment">// 如果有数据等待发送，则执行写回调</span>
  <span class="hljs-keyword">if</span> (error &#x3C; <span class="hljs-number">0</span>) {
    uv__stream_flush_write_queue(stream, UV_ECANCELED);
    uv__write_callbacks(stream);
  }
}
</code></pre>
<p>发起连接的逻辑大致分为两种情况。第一种是调用 connect 时就失败了，这时候 Libuv 会把错误码记录到 delayed_error 中，往 pending 阶段插入一个任务，最后在 pending 阶段时执行上层回调把错误码告诉上层。第二种情况是成功发起了连接，在异步地等待连接结果，比如三次握手的结果，等到有结果后，就会在 Poll IO 阶段处理连接结果。这时候需要通过 getsockopt 从内核中拿到连接的结果，并把结果通过回调告诉上层。</p>
<p>除此之外，连接过程中 Libuv 允许写入数据，因为 Libuv 会缓存，等到连接成功后再执行写入，如果连接失败了 Libuv 会清除写事件并且执行写回调告诉上层。</p>
<h2>读取流中的数据</h2>
<p>当想从流中读取数据时，我们可以执行 uv_read_start。uv_read_start 会注册可读事件，这样流的数据（如果有的话）就会源源不断地流向调用方。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_read_start</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream,
                  uv_alloc_cb alloc_cb,
                  uv_read_cb read_cb)</span> {
    <span class="hljs-comment">// 标记正在读</span>
    stream->flags |= UV_HANDLE_READING;
    <span class="hljs-comment">// 保存回调，当有数据到来时，操作系统会通知 Libuv，然后 Libuv 最终执行这个回调通知上层</span>
    stream->read_cb = read_cb;
    <span class="hljs-comment">// 设置分配内存的函数，保存数据所需要的内存由上层负责管理</span>
    stream->alloc_cb = alloc_cb;
    <span class="hljs-comment">// 注册读事件</span>
    uv__io_start(stream->loop, &#x26;stream->io_watcher, POLLIN);
    uv__handle_start(stream);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_read_start 没有尝试发起读操作，而是记录读操作相关的回调，然后把流对应的文件描述符和感兴趣的事情注册到事件驱动模块中，当可读事件触发时，读回调就会被执行。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__read</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream)</span> {
  <span class="hljs-type">uv_buf_t</span> buf;
  <span class="hljs-type">ssize_t</span> nread;
  <span class="hljs-type">int</span> count;
  <span class="hljs-type">int</span> err;
  <span class="hljs-type">int</span> is_ipc;

  <span class="hljs-comment">// 有数据时，会连续执行读操作，但是为了避免让其他事件也可以执行，所以不会一直执行读</span>
  count = <span class="hljs-number">32</span>;
  <span class="hljs-comment">// is_ipc，用于 Unix 域，后续分析</span>
  is_ipc = stream->type == UV_NAMED_PIPE &#x26;&#x26; ((<span class="hljs-type">uv_pipe_t</span>*) stream)->ipc;

  <span class="hljs-keyword">while</span> (stream->read_cb
      &#x26;&#x26; (stream->flags &#x26; UV_HANDLE_READING)
      &#x26;&#x26; (count-- > <span class="hljs-number">0</span>)) {
      
    buf = uv_buf_init(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
    <span class="hljs-comment">// 分配内存，地址保存在 buf 中，alloc_cb 由上层实现</span>
    stream->alloc_cb((<span class="hljs-type">uv_handle_t</span>*)stream, <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>, &#x26;buf);
    
    <span class="hljs-comment">// 单纯的数据读取</span>
    <span class="hljs-keyword">if</span> (!is_ipc) {
      <span class="hljs-keyword">do</span> {
        nread = read(uv__stream_fd(stream), buf.base, buf.len);
      }
      <span class="hljs-keyword">while</span> (nread &#x3C; <span class="hljs-number">0</span> &#x26;&#x26; errno == EINTR);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 传递了文件描述符，在讲 Unix 域时单独分析</span>
    }
    <span class="hljs-comment">// 读出错</span>
    <span class="hljs-keyword">if</span> (nread &#x3C; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// </span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// 读到底了</span>
      uv__stream_eof(stream, &#x26;buf);
      <span class="hljs-keyword">return</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 读成功</span>
      <span class="hljs-type">ssize_t</span> buflen = buf.len;
      <span class="hljs-comment">// 执行上层回调</span>
      stream->read_cb(stream, nread, &#x26;buf);
      <span class="hljs-comment">// 读取的数据大小比buf的小，因为每次最多读 64 * 1024 字节</span>
      <span class="hljs-keyword">if</span> (nread &#x3C; buflen) {
        stream->flags |= UV_HANDLE_READ_PARTIAL;
        <span class="hljs-keyword">return</span>;
      }
    }
  }
}
</code></pre>
<p>读操作首先会调用 alloc_cb 分配 64 * 1024 字节的内存，然后调用 read 函数进行数据的读取，接着执行 read_cb 通知上层，如果读到的字节数是 0 则说明读对端关闭了写端，这时候执行 uv__stream_eof 进行处理。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__stream_eof</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream, <span class="hljs-type">const</span> <span class="hljs-type">uv_buf_t</span>* buf)</span> {
  <span class="hljs-comment">// 标记读完了</span>
  stream->flags |= UV_HANDLE_READ_EOF;
  <span class="hljs-comment">// 撤销等待可读事件</span>
  uv__io_stop(stream->loop, &#x26;stream->io_watcher, POLLIN);
  <span class="hljs-comment">// 如果也没有注册等待可写事件，则停掉 handle</span>
  <span class="hljs-keyword">if</span> (!uv__io_active(&#x26;stream->io_watcher, POLLOUT))
    uv__handle_stop(stream);
  uv__stream_osx_interrupt_select(stream);
  <span class="hljs-comment">// 触发回调</span>
  stream->read_cb(stream, UV_EOF, buf);
  stream->flags &#x26;= ~UV_HANDLE_READING;
}
</code></pre>
<p>uv__stream_eof 同样调用 read_cb 通知上层，并传入 UV_EOF 表示读结束了。有注册读操作，就会有停止读操作，对应的函数是 uv_read_stop。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_read_stop</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream)</span> {
    <span class="hljs-comment">// 清除正在读取的标记</span>
    stream->flags &#x26;= ~UV_HANDLE_READING;
    <span class="hljs-comment">// 撤销等待读事件</span>
    uv__io_stop(stream->loop, &#x26;stream->io_watcher, POLLIN);
    
    <span class="hljs-comment">// 如果对写事件也不感兴趣，则停掉 handle，允许事件循环退出</span>
    <span class="hljs-keyword">if</span> (!uv__io_active(&#x26;stream->io_watcher, POLLOUT))
        uv__handle_stop(stream);
    
    stream->read_cb = <span class="hljs-literal">NULL</span>;
    stream->alloc_cb = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>和 start 相反，start 是注册等待可读事件和打上正在读取这个标记，stop 则是撤销等待可读事件和清除这个标记。这些操作本质上是对事件驱动模块的操作。</p>
<h2>写入数据到流中</h2>
<p>我们可以通过 uv_write 往流中写入数据，但是数据不一定会被马上写入，而是会先缓存在流中，等待可写时，再把写入流对应的文件描述符中。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_write</span><span class="hljs-params">(<span class="hljs-type">uv_write_t</span>* req, <span class="hljs-comment">// 记录本次写请求的上下文</span>
             <span class="hljs-type">uv_stream_t</span>* handle, <span class="hljs-comment">// 往哪个流写</span>
             <span class="hljs-type">const</span> <span class="hljs-type">uv_buf_t</span> bufs[], <span class="hljs-comment">// 需要写入的数据</span>
             <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nbufs,<span class="hljs-comment">// buf个数</span>
             uv_write_cb cb <span class="hljs-comment">// 写完后执行的回调</span>
)</span> {
        <span class="hljs-keyword">return</span> uv_write2(req, handle, bufs, nbufs, <span class="hljs-literal">NULL</span>, cb);
}
</code></pre>
<p>uv_write 直接调用 uv_write2。其中第四个参数是 NULL，代表写一般的数据，比如 hello 字符串，不传递文件描述符。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_write2</span><span class="hljs-params">(<span class="hljs-type">uv_write_t</span>* req,
              <span class="hljs-type">uv_stream_t</span>* stream,
              <span class="hljs-type">const</span> <span class="hljs-type">uv_buf_t</span> bufs[],
              <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nbufs,
              <span class="hljs-comment">// 需要传递的文件描述符所在的流，这里是 NULL</span>
              <span class="hljs-type">uv_stream_t</span>* send_handle,
              uv_write_cb cb
)</span>
{
        <span class="hljs-type">int</span> empty_queue;
        <span class="hljs-comment">// write_queue_size 为 0 代表当前没有等待写入的数据，则可以尝试直接写入</span>
        empty_queue = (stream->write_queue_size == <span class="hljs-number">0</span>);
        <span class="hljs-comment">// 初始化一个写请求</span>
        uv__req_init(stream->loop, req, UV_WRITE);
        <span class="hljs-comment">// 写完后执行的回调</span>
        req->cb = cb;
        <span class="hljs-comment">// 记录所操作的流</span>
        req->handle = stream;
        <span class="hljs-comment">// 操作错误码</span>
        req->error = <span class="hljs-number">0</span>;
        QUEUE_INIT(&#x26;req-><span class="hljs-built_in">queue</span>);
        <span class="hljs-comment">// 存储数据元信息的 bufs</span>
        req->bufs = req->bufsml;
        <span class="hljs-comment">// 不够则扩容</span>
        <span class="hljs-keyword">if</span> (nbufs > ARRAY_SIZE(req->bufsml))
            req->bufs = uv__malloc(nbufs * <span class="hljs-keyword">sizeof</span>(bufs[<span class="hljs-number">0</span>]));
        <span class="hljs-comment">// 把需要写入的数据填充到 req->bufs 中</span>
        <span class="hljs-built_in">memcpy</span>(req->bufs, bufs, nbufs * <span class="hljs-keyword">sizeof</span>(bufs[<span class="hljs-number">0</span>]));
        <span class="hljs-comment">// 需要写入的 buf 个数</span>
        req->nbufs = nbufs;
        <span class="hljs-comment">// 目前写入的 buf 个数，初始化是 0</span>
        req->write_index = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 更新流中待写数据的总长度，就是每个 buf 的数据大小加起来</span>
        stream->write_queue_size += uv__count_bufs(bufs, nbufs);
        <span class="hljs-comment">// 插入待写队列</span>
        QUEUE_INSERT_TAIL(&#x26;stream->write_queue, &#x26;req-><span class="hljs-built_in">queue</span>);
        <span class="hljs-comment">/*
            stream->connect_req 非空说明流作为客户端，并且正在建立连接，
            则不能执行写入，建立连接成功会置 connect_req 为 NULL 并触发可写事件。
        */</span>
        <span class="hljs-keyword">if</span> (stream->connect_req) {
            <span class="hljs-comment">/* Still connecting, do nothing. */</span>
        }
        <span class="hljs-comment">//  待写数据队列为空，说明没有数据等待写入，则这次的写操作可以直接发起</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (empty_queue) {
            uv__write(stream);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">/*
                队列非空，说明还有数据等待被写入，先注册等待可写事件，
                事件触发的时候，再执行写入
            */</span>
            uv__io_start(stream->loop, &#x26;stream->io_watcher, POLLOUT);
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_write2 首先封装一个写请求并插入到流的待写队列，然后根据当前流状态进行下一步操作。</p>
<ol>
<li>如果正在发起连接，则不需要执行写操作，因为连接成功后会触发可写事件。</li>
</ol>

<ol start="2">
<li>如果待写队列为空，则直接进行写操作，因为文件描述符是非阻塞的，所以就算写失败了也不会阻塞进程，</li>
</ol>

<ol start="3">
<li>如果队列非空则注册可写事件，等待可写时再写入。</li>
</ol>
<p>结构图如下</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/618a7c014c854529a8356fb1d61976dd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>从上图中可以看到，Libuv 只是保存了指向待写数据的指针，而不是进行数据的复制。数据所占内存的管理由调用方管理，如果数据保存在堆内存，则需要在写回调中释放对应的内存。如下是当可写事件触发时，真正的写操作逻辑。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__write</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream)</span> {

    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>* <span class="hljs-title">iov</span>;</span>
    QUEUE* q;
    <span class="hljs-type">uv_write_t</span>* req;
    <span class="hljs-type">int</span> iovmax;
    <span class="hljs-type">int</span> iovcnt;
    <span class="hljs-type">ssize_t</span> n;
    <span class="hljs-type">int</span> err;
        
start:
    <span class="hljs-comment">// 待写队列为空，没数据需要写</span>
    <span class="hljs-keyword">if</span> (QUEUE_EMPTY(&#x26;stream->write_queue))
        <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 取出一个写请求</span>
    q = QUEUE_HEAD(&#x26;stream->write_queue);
    req = QUEUE_DATA(q, <span class="hljs-type">uv_write_t</span>, <span class="hljs-built_in">queue</span>);
    <span class="hljs-comment">/*
        struct iovec {
            ptr_t iov_base; // 数据首地址
            size_t iov_len; // 数据长度
        };
        iovec 和 bufs 结构体的定义一样
    */</span>
    <span class="hljs-comment">/*
        req->write_index 表示当前待写 buf 的索引，
        一个请求里可以有多个 buf，转成 iovec 格式发送
    */</span>
    iov = (<span class="hljs-keyword">struct</span> iovec*) &#x26;(req->bufs[req->write_index]);
    <span class="hljs-comment">// 待写的 buf 个数，nbufs 是总数，write_index 是当前已写的个数</span>
    iovcnt = req->nbufs - req->write_index;
    <span class="hljs-comment">// 最多能写几个</span>
    iovmax = uv__getiovmax();
    
    <span class="hljs-comment">// 取最小值</span>
    <span class="hljs-keyword">if</span> (iovcnt > iovmax)
        iovcnt = iovmax;
    
    <span class="hljs-comment">// 需要传递的描述符</span>
    <span class="hljs-keyword">if</span> (req->send_handle) {
        <span class="hljs-comment">// 需要传递文件描述符的逻辑，分析 Unix 域的时候再分析</span>
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 单纯发送数据，则直接写</span>
        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">if</span> (iovcnt == <span class="hljs-number">1</span>) {
                n = write(uv__stream_fd(stream), iov[<span class="hljs-number">0</span>].iov_base, iov[<span class="hljs-number">0</span>].iov_len);
            } <span class="hljs-keyword">else</span> {
                n = writev(uv__stream_fd(stream), iov, iovcnt);
            }
        } <span class="hljs-keyword">while</span> (n == <span class="hljs-number">-1</span> &#x26;&#x26; errno == EINTR);
    }
    <span class="hljs-comment">// 写失败</span>
    <span class="hljs-keyword">if</span> (n &#x3C; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 发送失败的逻辑，我们不具体分析</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 写成功，n 是写成功的字节数</span>
        <span class="hljs-keyword">while</span> (n >= <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 当前 buf</span>
            <span class="hljs-type">uv_buf_t</span>* buf = &#x26;(req->bufs[req->write_index]);
            <span class="hljs-comment">// buf 的数据长度</span>
            <span class="hljs-type">size_t</span> len = buf->len;
            <span class="hljs-comment">/*
                len 代表需要写入的，n 表示已经写入的
                len 如果大于 n 说明该 buf 的数据还没有完全被写入
            */</span>
            <span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>)n &#x3C; len) {
                <span class="hljs-comment">// 更新指针，指向下次待发送的数据首地址</span>
                buf->base += n;
                <span class="hljs-comment">// 记录 buf 中还有多少数据等待发送</span>
                buf->len -= n;
                <span class="hljs-comment">// 更新待写数据的总长度</span>
                stream->write_queue_size -= n;
                n = <span class="hljs-number">0</span>;
                <span class="hljs-comment">// 设置了一直写标记，则跳到 start 标签继续写</span>
                <span class="hljs-keyword">if</span> (stream->flags &#x26; UV_HANDLE_BLOCKING_WRITES) {
                    <span class="hljs-keyword">goto</span> start;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 否则等待可写事件触发的时候再写</span>
                    <span class="hljs-keyword">break</span>;
                }
            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// n >= len 说明成功写入了一个或多个 buf 的数据</span>
                <span class="hljs-comment">// 该 buf 的数据全部写入成功，更新索引到下一个 buf 的位置</span>
                req->write_index++;
                n -= len;
                <span class="hljs-comment">// 更新待写数据总长度</span>
                stream->write_queue_size -= len;
                <span class="hljs-comment">// 是否全部数据都写入完毕</span>
                <span class="hljs-keyword">if</span> (req->write_index == req->nbufs) {
                    <span class="hljs-comment">// 写完了本请求的数据，做后续处理</span>
                    uv__write_req_finish(req);
                    <span class="hljs-keyword">return</span>;
                }
            }
        }
    }
    <span class="hljs-comment">// 到这说明数据还没有完全被写入，保证注册了等待可写事件，等待继续写</span>
    uv__io_start(stream->loop, &#x26;stream->io_watcher, POLLOUT);
}
</code></pre>
<p>写完一个请求的数据后 Libuv 是如何处理的呢？从上面的代码中可以看到，写完一个请求的数据后，会调用 uv__write_req_finish 函数。</p>
<pre><code class="hljs language-c"><span class="hljs-comment">// 把 buf 的数据写入完成或写出错后触发回调</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__write_req_finish</span><span class="hljs-params">(<span class="hljs-type">uv_write_t</span>* req)</span> {
    <span class="hljs-type">uv_stream_t</span>* stream = req->handle;
    <span class="hljs-comment">// 移出队列</span>
    QUEUE_REMOVE(&#x26;req-><span class="hljs-built_in">queue</span>);
    <span class="hljs-comment">// 插入写完成队列</span>
    QUEUE_INSERT_TAIL(&#x26;stream->write_completed_queue, &#x26;req-><span class="hljs-built_in">queue</span>);
    <span class="hljs-comment">// 插入 pending 队列，在 pending 阶段执行业务回调</span>
    uv__io_feed(stream->loop, &#x26;stream->io_watcher);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">uv__io_feed</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv__io_t</span>* w)</span> {
  <span class="hljs-keyword">if</span> (QUEUE_EMPTY(&#x26;w->pending_queue))
    QUEUE_INSERT_TAIL(&#x26;loop->pending_queue, &#x26;w->pending_queue);
}
</code></pre>
<p>uv__write_req_finish 的逻辑比较简单，就是把节点从待写队列中移除，然后插入写完成队列，结构如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a7bf1af16e446b3a4bce43ec4241524~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>最后把 IO 观察者插入 pending 队列。在 pending 阶段会执行 IO 观察者的回调 uv__stream_io。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__stream_io</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv__io_t</span>* w, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> events)</span> {
  <span class="hljs-type">uv_stream_t</span>* stream;

  stream = container_of(w, <span class="hljs-type">uv_stream_t</span>, io_watcher);
  <span class="hljs-keyword">if</span> (events &#x26; (POLLOUT | POLLERR | POLLHUP)) {
    <span class="hljs-comment">// 如果有数据等话，继续写，如果写完了就返回 </span>
    uv__write(stream);
    <span class="hljs-comment">// 执行业务回调</span>
    uv__write_callbacks(stream);
  }
}
</code></pre>
<p>uv__stream_io 中首先执行 uv__write 判断是否还有数据需要写，有就继续写，没有就直接返回，然后通过 uv__write_callbacks 执行业务回调。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__write_callbacks</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream)</span> {
  <span class="hljs-type">uv_write_t</span>* req;
  QUEUE* q;
  QUEUE pq;
  <span class="hljs-comment">// 写完成队列为空，不需要处理</span>
  <span class="hljs-keyword">if</span> (QUEUE_EMPTY(&#x26;stream->write_completed_queue))
    <span class="hljs-keyword">return</span>;

  QUEUE_MOVE(&#x26;stream->write_completed_queue, &#x26;pq);
  <span class="hljs-comment">// 清空写完成队列，并执行业务回调</span>
  <span class="hljs-keyword">while</span> (!QUEUE_EMPTY(&#x26;pq)) {
    q = QUEUE_HEAD(&#x26;pq);
    req = QUEUE_DATA(q, <span class="hljs-type">uv_write_t</span>, <span class="hljs-built_in">queue</span>);
    QUEUE_REMOVE(q);
    <span class="hljs-comment">// 请求结束，请求个数减一</span>
    uv__req_unregister(stream->loop, req);

    <span class="hljs-comment">// 执行上层回调</span>
    <span class="hljs-keyword">if</span> (req->cb)
      req->cb(req, req->error);
  }
}
</code></pre>
<p>写操作流程图如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9934e7e9825a40f3a491f01716e07b8c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>关闭流的写端</h2>
<p>面向连接的流是全双工的，每一端都可以同时进行数据的读写，所以关闭时，某一端可以选择关闭读或者写。Libuv 没有关闭读端的功能，我们可以通过关闭流或者不订阅可读事件来实现，想要关闭写端，可以通过 uv_shutdown 函数来操作。</p>
<pre><code class="hljs language-c"><span class="hljs-comment">// 关闭流的写端</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">uv_shutdown</span><span class="hljs-params">(<span class="hljs-type">uv_shutdown_t</span>* req, <span class="hljs-type">uv_stream_t</span>* stream, uv_shutdown_cb cb)</span>
{
    uv__req_init(stream->loop, req, UV_SHUTDOWN);
    req->handle = stream;
    <span class="hljs-comment">// 关闭操作完成后执行的上层回调</span>
    req->cb = cb;
    stream->shutdown_req = req;
    <span class="hljs-comment">// 设置正在操作的标记</span>
    stream->flags |= UV_HANDLE_SHUTTING;
    
    <span class="hljs-comment">// 注册可写事件</span>
    uv__io_start(stream->loop, &#x26;stream->io_watcher, POLLOUT);
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_shutdown 只是把请求上下文保存到 stream 中，接着注册可写事件，等到可写事件触发时 Libuv 会执行 uv__stream_io 关闭流的写端。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__stream_io</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv__io_t</span>* w, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> events)</span> {
  <span class="hljs-type">uv_stream_t</span>* stream;

  stream = container_of(w, <span class="hljs-type">uv_stream_t</span>, io_watcher);

  <span class="hljs-comment">// 可写事件触发</span>
  <span class="hljs-keyword">if</span> (events &#x26; (POLLOUT | POLLERR | POLLHUP)) {
    uv__write(stream);
    uv__write_callbacks(stream);

    <span class="hljs-comment">// 待写队列为空才关闭流</span>
    <span class="hljs-keyword">if</span> (QUEUE_EMPTY(&#x26;stream->write_queue))
      uv__drain(stream);
  }
}
</code></pre>
<p>可以看到，如果流中还有数据则不能关闭流，需要等到数据写入完毕，当写入完毕后，执行 uv__drain 关闭。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__drain</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream)</span> {
  <span class="hljs-type">uv_shutdown_t</span>* req;
  <span class="hljs-type">int</span> err;
  
  <span class="hljs-comment">// 撤销等待可写事件，因为没有数据需要写入了</span>
  uv__io_stop(stream->loop, &#x26;stream->io_watcher, POLLOUT);
  <span class="hljs-comment">// 流还没有关闭并且设置了关闭标记，则关闭写端</span>
  <span class="hljs-keyword">if</span> ((stream->flags &#x26; UV_HANDLE_SHUTTING) &#x26;&#x26;
      !(stream->flags &#x26; UV_HANDLE_CLOSING) &#x26;&#x26;
      !(stream->flags &#x26; UV_HANDLE_SHUT)) {

    req = stream->shutdown_req;
    stream->shutdown_req = <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">// 清除标记</span>
    stream->flags &#x26;= ~UV_HANDLE_SHUTTING;
    uv__req_unregister(stream->loop, req);

    err = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 关闭写端</span>
    <span class="hljs-keyword">if</span> (shutdown(uv__stream_fd(stream), SHUT_WR))
      err = UV__ERR(errno);
    <span class="hljs-comment">// 标记已关闭写端</span>
    <span class="hljs-keyword">if</span> (err == <span class="hljs-number">0</span>)
      stream->flags |= UV_HANDLE_SHUT;
    <span class="hljs-comment">// 执行回调</span>
    <span class="hljs-keyword">if</span> (req->cb != <span class="hljs-literal">NULL</span>)
      req->cb(req, err);
  }
}
</code></pre>
<p>最终调用系统函数 shutdown 关闭流的写端，但是读端还没有关闭，还可以读数据 。</p>
<h2>关闭流</h2>
<p>当我们不再使用一个流的时候，可以通过 uv_close 关闭它，uv_close 最终会执行 uv__stream_close 关闭流。</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv__stream_close</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* handle)</span> {
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i;
    <span class="hljs-type">uv__stream_queued_fds_t</span>* queued_fds;
    <span class="hljs-comment">// 关闭 IO 观察者，对 fd 的事件不再感兴趣</span>
    uv__io_close(handle->loop, &#x26;handle->io_watcher);
    uv_read_stop(handle);
    <span class="hljs-comment">// 关闭 handle</span>
    uv__handle_stop(handle);
    <span class="hljs-comment">// 不再读写</span>
    handle->flags &#x26;= ~(UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);
    
    <span class="hljs-comment">// 关闭文件描述符，除了标准输入，输出，错误流</span>
    <span class="hljs-keyword">if</span> (handle->io_watcher.fd != <span class="hljs-number">-1</span>) {
        <span class="hljs-comment">/* Don't close stdio file descriptors. Nothing good comes from it. */</span>
        <span class="hljs-keyword">if</span> (handle->io_watcher.fd > STDERR_FILENO)
            <span class="hljs-comment">// 关闭文件描述符</span>
            uv__close(handle->io_watcher.fd);
            handle->io_watcher.fd = <span class="hljs-number">-1</span>;
    }
    <span class="hljs-comment">// 关闭已经接收但是还没有处理的 fd，比如 TCP 连接</span>
    <span class="hljs-keyword">if</span> (handle->accepted_fd != <span class="hljs-number">-1</span>) {
        uv__close(handle->accepted_fd);
        handle->accepted_fd = <span class="hljs-number">-1</span>;
    }
    
    <span class="hljs-comment">// 关闭传递过来但还没有被处理的 fd，用于 Unix 域 IPC 时</span>
    <span class="hljs-keyword">if</span> (handle->queued_fds != <span class="hljs-literal">NULL</span>) {
        queued_fds = handle->queued_fds;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &#x3C; queued_fds->offset; i++)
        uv__close(queued_fds->fds[i]);
        uv__free(handle->queued_fds);
        handle->queued_fds = <span class="hljs-literal">NULL</span>;
    }
}
</code></pre>
<p>关闭流就是清除流中的状态和资源，不同类型的流对应不同的操作，比如 Unix 域用于 IPC 时才有 handle->queued_fds。关闭了流之后，在 close 阶段时会销毁流。</p>
<pre><code class="hljs language-c"><span class="hljs-comment">// 执行 close 阶段的回调</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__finish_close</span><span class="hljs-params">(<span class="hljs-type">uv_handle_t</span>* handle)</span> {
  <span class="hljs-keyword">switch</span> (handle->type) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">case</span> UV_NAMED_PIPE:
    <span class="hljs-keyword">case</span> UV_TCP:
    <span class="hljs-keyword">case</span> UV_TTY:
      uv__stream_destroy((<span class="hljs-type">uv_stream_t</span>*)handle);
      <span class="hljs-keyword">break</span>;

  }
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>销毁流的函数是 uv__stream_destroy。</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uv__stream_destroy</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream)</span> {
      <span class="hljs-comment">// 正在发起连接则执行回调</span>
      <span class="hljs-keyword">if</span> (stream->connect_req) {
        <span class="hljs-comment">// 销毁一个request</span>
        uv__req_unregister(stream->loop, stream->connect_req);
        <span class="hljs-comment">// 执行上层回调</span>
        stream->connect_req->cb(stream->connect_req, UV_ECANCELED);
        stream->connect_req = <span class="hljs-literal">NULL</span>;
      }
      <span class="hljs-comment">// 清空待写队列</span>
      uv__stream_flush_write_queue(stream, UV_ECANCELED);
      <span class="hljs-comment">// 执行写回调</span>
      uv__write_callbacks(stream);
      <span class="hljs-comment">// 正在发起关闭写端操作则执行回调</span>
      <span class="hljs-keyword">if</span> (stream->shutdown_req) {
        uv__req_unregister(stream->loop, stream->shutdown_req);
        <span class="hljs-comment">// 调用回调</span>
        stream->shutdown_req->cb(stream->shutdown_req, UV_ECANCELED);
        stream->shutdown_req = <span class="hljs-literal">NULL</span>;
      }
}
</code></pre>
<p>uv__stream_destroy 一共三个逻辑，分别是对发起连接、关闭写端和写入数据的处理，具体的处理就是执行上层的回调。</p>
<h2>总结</h2>
<p>本节课介绍了 Libuv 流的概念、工作机制以及围绕着流的各种操作的实现。流本质是对文件描述符的封装，依赖事件驱动模块进行工作，当我们操作一个文件描述符时，通常不是直接发起操作，而是注册相关的事件，等待事件完成后，事件驱动就会通知 Libuv，接着再发起真正的操作，比如数据读写。了解这些之后，我们再学习后面的 TCP、Unix 域的时候就会轻松很多，因为它们都是基于流机制进行工作的。</p></div>
</body></html>