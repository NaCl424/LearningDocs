<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Libuv 的功能是如何引入 JS 的</h1>
<p>在《Node.js 基础架构》这节课我们讲过，Node.js 是由 V8、Libuv 和 C++ 胶水层组成的。那么 C++ 胶水层是如何把 Libuv 的功能引入 JS 的呢？这节课我们就来好好聊一聊。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7b86cd00b30426b9c183e500e83badc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h1>V8 基础知识</h1>
<p>我们知道，JS 的拓展能力是由 V8 提供的。也就是说，在 Libuv 实现了网络、文件、进程等功能后，还需要借助 V8 提供的拓展能力引入 JS 中，才能在 JS 里使用相关的功能。因此，我们需要先了解 V8 的一些基础数据结构和提供的拓展机制。</p>
<p>V8 的数据结构非常多，但是常用的是下面的几个，我们需要了解下面的数据结构才能更好地了解和使用 V8。</p>
<ul>
<li>Isolate：Isolate 代表一个 V8 的实例，它相当于这一个容器。通常一个线程里面会有一个这样的实例。比如说在 Node.js 主线程里面就会有一个 Isolate 实例，子线程里也会有一个 Isolate 实例。</li>
</ul>

<ul>
<li>Context：Context 是代表代码执行的上下文，起到隔离的作用，即我们改变一个 Context 的内容不会影响另一个 Context，它主要是保存 Object、Function 这些我们平时经常会用到的内置类型。如果我们想拓展 JS 功能，就可以通过这个对象实现。另外一个 Isolate 中，可以存在多个 Context。</li>
</ul>

<ul>
<li>ObjectTemplate：ObjectTemplate 是用于定义对象的模板。我们可以基于这个模板去创建对象。</li>
</ul>

<ul>
<li>FunctionTemplate：FunctionTemplate 和 ObjectTemplate 是类似的，它主要是用于定义一个函数的模板。我们可以基于这个函数模板去创建一个函数。</li>
</ul>

<ul>
<li>FunctionCallbackInfo： 用于实现 JS 和 C++ 通信的对象。当我们通过 JS 调用 C++ 代码时，就会通过该类的对象获取 JS 层传入的参数。</li>
</ul>

<ul>
<li>Handle：Handle 用于 V8 的内存管理，它保存了 V8 堆对象的地址信息。我们平时定义的对象和数组，就是用 Handle 来管理的。比如在 C++ 层创建一个 JS 对象。</li>
</ul>
<pre><code class="hljs language-c++"><span class="hljs-comment">// Local 是 Handle 的一种，Object::New 用于在 V8 堆分配内存</span>
Local&#x3C;Value> object = Object::<span class="hljs-built_in">New</span>(isolate);
</code></pre>
<ul>
<li>HandleScope：HandleScope 是一个 Handle 容器，方便管理大量 Handle 的创建和销毁。它主要是利用 C++ 的析构函数机制管理多个 Handle 的生命周期。</li>
</ul>
<pre><code class="hljs language-c++">{
    <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(env->isolate())</span></span>;
    <span class="hljs-comment">// 创建两个 Handle 对象，指向两个对象</span>
    Local&#x3C;Value> object1 = Object::<span class="hljs-built_in">New</span>(isolate);
    Local&#x3C;Value> object2 = Object::<span class="hljs-built_in">New</span>(isolate);
} <span class="hljs-comment">// 执行到这后 object1 和 object2 的内存被释放，Object 被 GC</span>
</code></pre>
<p>接下来我们详细介绍一下 FunctionTemplate 和 ObjectTemplate 这两个非常核心的类，它们是我们拓展 JS 能力时经常会使用到的。就像建房子会根据设计图施工一样，我们可以在 V8 中通过定义某种模板创建出对应的实例，那我们该如何定义一个函数模版呢，具体代码可参考<a href="https://github.com/theanarkh/nodejs-book/tree/main/src/V8/FunctionTemplate" target="_blank" rel="nofollow noopener noreferrer">这里</a>。</p>
<pre><code class="hljs language-c++"><span class="hljs-function">Local&#x3C;String> <span class="hljs-title">newString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * name)</span> </span>{
  <span class="hljs-keyword">return</span> String::<span class="hljs-built_in">NewFromUtf8</span>(Isolate::<span class="hljs-built_in">GetCurrent</span>(), name, v8::NewStringType::kNormal).<span class="hljs-built_in">ToLocalChecked</span>();
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProtoMethod</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
    std::cout&#x3C;&#x3C;<span class="hljs-string">"call ProtoMethod"</span>&#x3C;&#x3C;std::endl;
}

<span class="hljs-comment">// 定义一个加法函数</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InstanceMethod</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
    std::cout&#x3C;&#x3C;<span class="hljs-string">"call InstanceMethod"</span>&#x3C;&#x3C;std::endl;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(
  Local&#x3C;Object> exports,
  Local&#x3C;Value> <span class="hljs-keyword">module</span>,
  Local&#x3C;Context> context
)</span> </span>{
        Isolate* isolate = context-><span class="hljs-built_in">GetIsolate</span>();
        <span class="hljs-comment">// 新建一个函数模版</span>
        Local&#x3C;FunctionTemplate> parentFunc = FunctionTemplate::<span class="hljs-built_in">New</span>(isolate);
        <span class="hljs-comment">// 新建一个字符串表示函数名</span>
        Local&#x3C;String> parentName = String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, <span class="hljs-string">"Parent"</span>, v8::NewStringType::kNormal).<span class="hljs-built_in">ToLocalChecked</span>();
        <span class="hljs-comment">// 设置函数名</span>
        parentFunc-><span class="hljs-built_in">SetClassName</span>(parentName);
        <span class="hljs-comment">// 设置原型属性</span>
        parentFunc-><span class="hljs-built_in">PrototypeTemplate</span>()-><span class="hljs-built_in">Set</span>(isolate, <span class="hljs-string">"protoField"</span>, Number::<span class="hljs-built_in">New</span>(isolate, <span class="hljs-number">1</span>));
        <span class="hljs-comment">// 设置原型函数，JS 调 protoMethod 时就会调 ProtoMethod 函数</span>
        parentFunc-><span class="hljs-built_in">PrototypeTemplate</span>()-><span class="hljs-built_in">Set</span>(isolate, <span class="hljs-string">"protoMethod"</span>, FunctionTemplate::<span class="hljs-built_in">New</span>(isolate, ProtoMethod));
        <span class="hljs-comment">// 设置对象属性</span>
        parentFunc-><span class="hljs-built_in">InstanceTemplate</span>()-><span class="hljs-built_in">Set</span>(isolate, <span class="hljs-string">"instanceField"</span>, Number::<span class="hljs-built_in">New</span>(isolate, <span class="hljs-number">2</span>));
        parentFunc-><span class="hljs-built_in">InstanceTemplate</span>()-><span class="hljs-built_in">Set</span>(isolate, <span class="hljs-string">"instanceMethod"</span>, FunctionTemplate::<span class="hljs-built_in">New</span>(isolate, InstanceMethod));
        <span class="hljs-comment">// 根据模块创建函数实例</span>
        Local&#x3C;Function> parentInstance = parentFunc-><span class="hljs-built_in">GetFunction</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();
        <span class="hljs-comment">// 导出到 JS 层</span>
        exports-><span class="hljs-built_in">Set</span>(context, parentName, parentInstance).<span class="hljs-built_in">Check</span>();
}

<span class="hljs-comment">// addon 定义</span>
<span class="hljs-built_in">NODE_MODULE_CONTEXT_AWARE</span>(NODE_GYP_MODULE_NAME, Initialize)
</code></pre>
<p>下面来详细解释上面的代码。</p>
<ol>
<li>通过 FunctionTemplate::New(isolate) 创建一个函数模板，函数模板是定义了当通过这个函数模板创建一个函数时函数的内容，比如函数名，函数的原型对象里有什么属性等，对应 JS 的函数。</li>
</ol>

<ol start="2">
<li>通过 SetClassName 定义了当通过这个函数模板创建一个函数时，这个函数的名字。</li>
</ol>

<ol start="3">
<li>通过设置 PrototypeTemplate 的属性定义了当通过这个函数模板创建一个函数时，这个函数的原型对象，就是 JS 里的 function.prototype。</li>
</ol>

<ol start="4">
<li>通过设置 InstanceTemplate 的属性定义了当通过这个函数模板创建一个函数并且通过 new 执行这个函数时，生成的对象里有哪些内容。</li>
</ol>
<p>翻译成 JS 如下。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instanceField</span> = <span class="hljs-number">2</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instanceMethod</span> = <span class="hljs-function">() =></span> { ... };
}

<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">protoField</span> = <span class="hljs-number">1</span>;
<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">protoMethod</span> = <span class="hljs-function">() =></span> { ... };
</code></pre>
<p>下面通过使用这个 Addon 来体验下效果。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Parent</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/test.node'</span>);

<span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Parent.prototype: '</span>, <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'parent.protoField: '</span>, parent.<span class="hljs-property">protoField</span>);
parent.<span class="hljs-title function_">protoMethod</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'parent.instanceField: '</span>, parent.<span class="hljs-property">instanceField</span>);
parent.<span class="hljs-title function_">instanceMethod</span>();
</code></pre>
<p>输出如下：</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">Parent.prototype:</span>  <span class="hljs-string">Parent</span> { <span class="hljs-attr">protoField:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">protoMethod:</span> [<span class="hljs-attr">Function:</span> <span class="hljs-string">protoMethod</span>] } 
<span class="hljs-attr">parent.protoField:</span>  <span class="hljs-number">1</span> 
<span class="hljs-string">call</span> <span class="hljs-string">ProtoMethod</span>
<span class="hljs-attr">parent.instanceField:</span>  <span class="hljs-number">2</span> 
<span class="hljs-string">call</span> <span class="hljs-string">InstanceMethod</span>
</code></pre>
<p>可以看到，通过 Parent 创建出来的对象具备了 PrototypeTemplate 和 InstanceTemplate 里的属性，结构图如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/034c3e28dbec4cb0b5e0ffe5cd6782d5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>了解了基础使用后，接着看一下高级点的用法：继承，V8 提供了类似 JS 里的原型链继承的功能，具体代码可参考<a href="https://github.com/theanarkh/nodejs-book/tree/main/src/V8/Inherit" target="_blank" rel="nofollow noopener noreferrer">这里</a>。</p>
<pre><code class="hljs language-c++">Local&#x3C;FunctionTemplate> childFunc = FunctionTemplate::<span class="hljs-built_in">New</span>(isolate);
Local&#x3C;String> childName = String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, <span class="hljs-string">"Child"</span>, v8::NewStringType::kNormal).<span class="hljs-built_in">ToLocalChecked</span>();
childFunc-><span class="hljs-built_in">SetClassName</span>(childName);
<span class="hljs-comment">// 定义自己的原型属性</span>
childFunc-><span class="hljs-built_in">PrototypeTemplate</span>()-><span class="hljs-built_in">Set</span>(isolate, <span class="hljs-string">"childProtoField"</span>, Number::<span class="hljs-built_in">New</span>(isolate, <span class="hljs-number">1</span>));
<span class="hljs-comment">// 定义自己的实例属性</span>
childFunc-><span class="hljs-built_in">InstanceTemplate</span>()-><span class="hljs-built_in">Set</span>(isolate, <span class="hljs-string">"childInstanceField"</span>, Number::<span class="hljs-built_in">New</span>(isolate, <span class="hljs-number">2</span>));
<span class="hljs-comment">// 继承 parentFunc 函数模版</span>
childFunc-><span class="hljs-built_in">Inherit</span>(parentFunc);

Local&#x3C;Function> parentInstance = parentFunc-><span class="hljs-built_in">GetFunction</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();
Local&#x3C;Function> childInstance = childFunc-><span class="hljs-built_in">GetFunction</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();
exports-><span class="hljs-built_in">Set</span>(context, parentName, parentInstance).<span class="hljs-built_in">Check</span>();
exports-><span class="hljs-built_in">Set</span>(context, childName, childInstance).<span class="hljs-built_in">Check</span>();
</code></pre>
<p>这里和刚才的区别是多了个继承的设置，这样 child 就可以直接使用 parent 的一些内容了。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Parent</span>, <span class="hljs-title class_">Child</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/test.node'</span>);
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Child.prototype: '</span>, <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Parent.prototype === Child.prototype: '</span>, <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'child.protoField: '</span>, child.<span class="hljs-property">protoField</span>);
child.<span class="hljs-title function_">protoMethod</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'child.instanceField: '</span>, child.<span class="hljs-property">instanceField</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'child.instanceMethod: '</span>, child.<span class="hljs-property">instanceMethod</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'child.childProtoField: '</span>, child.<span class="hljs-property">childProtoField</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'child.childInstanceField: '</span>, child.<span class="hljs-property">childInstanceField</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'child instanceof Parent: '</span>, child <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Parent</span>);
</code></pre>
<p>我们看看输出：</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">Child.prototype:</span>  <span class="hljs-string">Parent</span> { <span class="hljs-attr">childProtoField:</span> <span class="hljs-number">1</span> }
<span class="hljs-string">Parent.prototype</span> <span class="hljs-string">===</span> <span class="hljs-attr">Child.prototype:</span>  <span class="hljs-literal">false</span>
<span class="hljs-attr">child.protoField:</span>  <span class="hljs-number">1</span>
<span class="hljs-string">call</span> <span class="hljs-string">ProtoMethod</span>
<span class="hljs-attr">child.instanceField:</span>  <span class="hljs-string">undefined</span>
<span class="hljs-attr">child.instanceMethod:</span>  <span class="hljs-string">undefined</span>
<span class="hljs-attr">child.childProtoField:</span>  <span class="hljs-number">1</span>
<span class="hljs-attr">child.childInstanceField:</span>  <span class="hljs-number">2</span>
<span class="hljs-attr">child instanceof Parent:</span>  <span class="hljs-literal">true</span>
</code></pre>
<p>可以看到，child 继承了 parent PrototypeTemplate 中的内容，但是没有继承 InstanceTemplate 的内容。结构图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09fd8d25e14c459e988852cf0815932f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下面再看一下另一个高级的用法：JS 和 C++ 对象绑定，也是 Node.js 中非常核心的部分，具体代码可参考<a href="https://github.com/theanarkh/nodejs-book/tree/main/src/V8/WrapperObject" target="_blank" rel="nofollow noopener noreferrer">这里</a>。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dummy</span> {
  <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Dummy</span>(Local&#x3C;Object> object): <span class="hljs-built_in">jsObject</span>(Isolate::<span class="hljs-built_in">GetCurrent</span>(), object) {
      <span class="hljs-comment">// 设置 JS 对象关联的 C++ 对象</span>
      object-><span class="hljs-built_in">SetAlignedPointerInInternalField</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">static_cast</span>&#x3C;<span class="hljs-type">void</span>*>(<span class="hljs-keyword">this</span>));
      <span class="hljs-comment">// 给 JS 对象设置一个属性</span>
      Local&#x3C;Context> context = Isolate::<span class="hljs-built_in">GetCurrent</span>()-><span class="hljs-built_in">GetCurrentContext</span>();
      (<span class="hljs-type">void</span>)object-><span class="hljs-built_in">Set</span>(context, <span class="hljs-built_in">newString</span>(<span class="hljs-string">"hello"</span>), <span class="hljs-built_in">newString</span>(<span class="hljs-string">"world"</span>));
    };
    <span class="hljs-comment">// C++ 对象关联的 JS 对象</span>
    Global&#x3C;Object> jsObject;
    <span class="hljs-type">int</span> dummy_field = <span class="hljs-number">1</span>;
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">New</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dummy</span>(args.<span class="hljs-built_in">This</span>());
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Method</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
    Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();
    Local&#x3C;Context> context = isolate-><span class="hljs-built_in">GetCurrentContext</span>();
    <span class="hljs-comment">// 获取 JS 对象的属性</span>
    Local&#x3C;String> hello = <span class="hljs-built_in">newString</span>(<span class="hljs-string">"hello"</span>);
    <span class="hljs-comment">// 获取 hello 属性等值</span>
    Local&#x3C;String> helloValue = args.<span class="hljs-built_in">Holder</span>()-><span class="hljs-built_in">Get</span>(context, hello).<span class="hljs-built_in">ToLocalChecked</span>().<span class="hljs-built_in">As</span>&#x3C;String>();
    <span class="hljs-comment">// 获取 JS 对象关联的 C++ 对象</span>
    Dummy* dummy = <span class="hljs-built_in">static_cast</span>&#x3C;Dummy*>(args.<span class="hljs-built_in">Holder</span>()-><span class="hljs-built_in">GetAlignedPointerFromInternalField</span>(<span class="hljs-number">0</span>));
    Local&#x3C;Object> obj = Object::<span class="hljs-built_in">New</span>(isolate);
    <span class="hljs-comment">// 把 JS 和 C++ 对象的属性返回给 JS 层</span>
    (<span class="hljs-type">void</span>)obj-><span class="hljs-built_in">Set</span>(context, hello, helloValue);
    (<span class="hljs-type">void</span>)obj-><span class="hljs-built_in">Set</span>(context, <span class="hljs-built_in">newString</span>(<span class="hljs-string">"dummy_field"</span>), Number::<span class="hljs-built_in">New</span>(isolate, dummy->dummy_field));
    args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(obj);
}

<span class="hljs-comment">// 新建一个函数模版</span>
Local&#x3C;FunctionTemplate> funcWithCallback = FunctionTemplate::<span class="hljs-built_in">New</span>(isolate, New);
<span class="hljs-comment">// 设置 JS 对象可以关联的 C++ 对象个数</span>
funcWithCallback-><span class="hljs-built_in">InstanceTemplate</span>()-><span class="hljs-built_in">SetInternalFieldCount</span>(<span class="hljs-number">1</span>);
funcWithCallback-><span class="hljs-built_in">PrototypeTemplate</span>()-><span class="hljs-built_in">Set</span>(isolate, <span class="hljs-string">"method"</span>, FunctionTemplate::<span class="hljs-built_in">New</span>(isolate, Method));
<span class="hljs-comment">// 新建一个字符串表示函数名</span>
Local&#x3C;String> funcWithCallbackName = String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, <span class="hljs-string">"FuncWithCallback"</span>, v8::NewStringType::kNormal).<span class="hljs-built_in">ToLocalChecked</span>();
<span class="hljs-comment">// 设置函数名</span>
funcWithCallback-><span class="hljs-built_in">SetClassName</span>(funcWithCallbackName);
Local&#x3C;Function> funcWithCallbackInstance = funcWithCallback-><span class="hljs-built_in">GetFunction</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();
</code></pre>
<p>接下来看一下效果：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Parent</span>, <span class="hljs-title class_">Child</span>, <span class="hljs-title class_">FuncWithCallback</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/test.node'</span>);

<span class="hljs-keyword">const</span> instace = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FuncWithCallback</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instace.<span class="hljs-title function_">method</span>());
</code></pre>
<p>输出如下：</p>
<pre><code class="hljs language-css">{ hello: <span class="hljs-string">'world'</span>, dummy_field: <span class="hljs-number">1</span> }
</code></pre>
<p>以上代码用到的技术几乎是 Node.js 每个 C++ 模块都会用到的，下面来详细分析一下上面的代码，看看它的工作原理。</p>
<ol>
<li>创建一个函数模块，和之前不一样的是，这里会设置一个回调函数是 New，并执行 InstanceTemplate()->SetInternalFieldCount(1)，因为我们需要在 JS 对象中关联一个 C++ 对象，所以需要设置为 1，类似预留一个 slot。</li>
</ol>

<ol start="2">
<li>当 JS 执行 new FuncWithCallback 时，C++ 层首先会创建一个 JS 对象，然后调用 New 函数，在 New 函数中可以通过 args.This() 拿到这个 JS 对象。</li>
</ol>

<ol start="3">
<li>接着创建一个 Dummy 对象，把这个 JS 对象传入 Dummy 的构造函数中。Dummy 构造函数在 jsObject 字段中保存了 JS 对象，然后在 JS 对象中保存了 Dummy 对象，最后往 JS 对象新增了一个hello 属性，结构图如下：</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56540ec6802a4b20806042a0689b8b51~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<ol start="4">
<li>JS 层 new 执行完毕拿到了一个 JS 对象 instance，接着执行 instace.method() 时就会调用 C++ 的 Method。Method 函数中可以通过 args.Holder() 或 args.This()（通常是一样的）获得函数调用的上下文，类似 JS 函数调用时的 this。</li>
</ol>

<ol start="5">
<li>接着通过 GetAlignedPointerFromInternalField(0) 获得之前关联的 C++ 对象。从而取得相应的内容。</li>
</ol>
<p>结构图如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a5e492c2e864a7d993227537b841440~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h1>C++ 层核心数据结构</h1>
<p>有了 V8 的拓展机制后，理论上就可以把 Libuv 引入 JS 里了，但 Node.js 在 C++ 层还设计了一些通用的数据结构，很多 C++ 模块中都会用到它们，所以我们先来了解下这些数据结构。</p>
<p><strong>BaseObject</strong></p>
<p>BaseObject 是 Node.js 中非常重要的数据结构，是 C++ 层大多数类的基类，用于管理 JS 和所关联 C++ 对象的生命周期，这里只介绍常用的部分。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseObject</span> : <span class="hljs-keyword">public</span> MemoryRetainer {  
 <span class="hljs-keyword">private</span>:  
  <span class="hljs-comment">// 持久句柄，指向 JS 对象  </span>
  v8::Global&#x3C;v8::Object> persistent_handle_;  
  Environment* env_;  
};  
</code></pre>
<p>BaseObject 中最重要的字段是 persistent_handle_，persistent_handle_ 是一个持久句柄，用于保存 JS 层的对象，并且通过弱引用机制管理 JS 和 C++ 对象的生命周期。</p>
<ol>
<li><strong>构造函数</strong></li>
</ol>
<pre><code class="hljs language-c++">    <span class="hljs-comment">// 把 JS 对象存储到 persistent_handle_ 中，需要的时候通过 object() 函数取出来  </span>
    BaseObject::<span class="hljs-built_in">BaseObject</span>(Environment* env, 
                           v8::Local&#x3C;v8::Object> object) 
    : <span class="hljs-built_in">persistent_handle_</span>(env-><span class="hljs-built_in">isolate</span>(), object), 
      <span class="hljs-built_in">env_</span>(env) {  
      <span class="hljs-comment">// 把 this 存到 JS 对象 object 中  </span>
      object-><span class="hljs-built_in">SetAlignedPointerInInternalField</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">static_cast</span>&#x3C;<span class="hljs-type">void</span>*>(<span class="hljs-keyword">this</span>));  
    }  
</code></pre>
<p>构造函数用于关联 JS 对象和 C++ 对象，下图中的对象即我们平时在 JS 层使用的由 C++ 模块创建的对象，比如 new TCP() 和 TCPWrap 对象的关系，后面我们可以看到用处。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44a715306fd4e7e9aeb58d0b98ee624~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<ol start="2">
<li><strong>获取</strong> <strong>JS</strong> <strong>对象</strong></li>
</ol>
<pre><code class="hljs language-c++"><span class="hljs-function">v8::Local&#x3C;v8::Object> <span class="hljs-title">BaseObject::object</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{  
  <span class="hljs-keyword">return</span> PersistentToLocal::<span class="hljs-built_in">Default</span>(<span class="hljs-built_in">env</span>()-><span class="hljs-built_in">isolate</span>(), persistent_handle_);  
}  
</code></pre>
<p>object 函数用于返回 JS 层使用的对象。</p>
<ol start="3">
<li><strong>获取 BaseObject 对象</strong></li>
</ol>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 通过 obj 取出里面保存的 BaseObject 对象  </span>
<span class="hljs-function">BaseObject* <span class="hljs-title">BaseObject::FromJSObject</span><span class="hljs-params">(v8::Local&#x3C;v8::Object> obj)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&#x3C;BaseObject*>(obj-><span class="hljs-built_in">GetAlignedPointerFromInternalField</span>(<span class="hljs-number">0</span>));  
}  
<span class="hljs-comment">// T 为 BaseObject 子类</span>
<span class="hljs-function">T* <span class="hljs-title">BaseObject::FromJSObject</span><span class="hljs-params">(v8::Local&#x3C;v8::Object> object)</span> </span>{  
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&#x3C;T*>(<span class="hljs-built_in">FromJSObject</span>(object));  
}  
</code></pre>
<p>FromJSObject 用于通过 JS 对象获取对应的 C++ 对象，因为它们互相关联，所以很自然可以获取到。</p>
<ol start="4">
<li><strong>Unwrap</strong></li>
</ol>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 从 obj 中取出对应的 BaseObject 对象  </span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> T* <span class="hljs-title">Unwrap</span><span class="hljs-params">(v8::Local&#x3C;v8::Object> obj)</span> </span>{  
  <span class="hljs-keyword">return</span> BaseObject::<span class="hljs-built_in">FromJSObject</span>&#x3C;T>(obj);  
}  
  
<span class="hljs-comment">// 从 obj 中获取对应的 BaseObject 对象，如果为空则返回第三个参数的值（默认值）  </span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ASSIGN_OR_RETURN_UNWRAP(ptr, obj, ...) \  </span>
  <span class="hljs-keyword">do</span> {       \  
    *ptr = <span class="hljs-keyword">static_cast</span>&#x3C;<span class="hljs-keyword">typename</span> std::remove_reference&#x3C;<span class="hljs-keyword">decltype</span>(*ptr)>::type>( \  
        BaseObject::<span class="hljs-built_in">FromJSObject</span>(obj));   \  
    <span class="hljs-keyword">if</span> (*ptr == <span class="hljs-literal">nullptr</span>)  \  
      <span class="hljs-keyword">return</span> __VA_ARGS__; \  
  } <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)  
</code></pre>
<p>Unwrap 是非常重要的逻辑，基本每次从 JS 层到 C++ 层都用到了这个函数，它用于从 JS 对象中获取对应的 C++ 对象，比如 JS 层调 setNoDelay 时会执行 C++ 层 SetNoDelay。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPWrap::SetNoDelay</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
  TCPWrap* wrap;
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap,
                          <span class="hljs-comment">// JS 层使用的对象，比如 _handle = new TCP()</span>
                          args.<span class="hljs-built_in">Holder</span>(),
                          args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(UV_EBADF));
 <span class="hljs-comment">// ...</span>
}
</code></pre>
<ol start="5">
<li><strong>MakeWeak</strong></li>
</ol>
<p>BaseObject 中通过 persistent_handle_ 持有了一个 JS 对象，MakeWeak 利用了 V8 提供的机制，在 JS 对象只有 persistent_handle_ 引用时可以被 GC，从而释放关联的 C++ 对象的内存。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseObject::MakeWeak</span><span class="hljs-params">()</span> </span>{
  persistent_handle_.<span class="hljs-built_in">SetWeak</span>(
      <span class="hljs-keyword">this</span>,
      [](<span class="hljs-type">const</span> v8::WeakCallbackInfo&#x3C;BaseObject>&#x26; data) {
        BaseObject* obj = data.<span class="hljs-built_in">GetParameter</span>();
        <span class="hljs-comment">// 不再引用 JS 对象</span>
        obj->persistent_handle_.<span class="hljs-built_in">Reset</span>();
        <span class="hljs-comment">// 执行 GC 逻辑，默认释放 BaseObject 对象内存</span>
        obj-><span class="hljs-built_in">OnGCCollect</span>();
      }, v8::WeakCallbackType::kParameter);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseObject::OnGCCollect</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;
}
</code></pre>
<p>但是 BaseObject 默认不会调用 MakeWeak，这个是子类控制的。另外值得一提的是 SetWeak 也可以不传入如何参数，这种方式会在只有持久句柄引用 JS 对象时，该 JS 对象可以被 GC，并且会重置持久句柄，使得它不再引用该 JS 对象。</p>
<p><strong>AsyncWrap</strong></p>
<p>AsyncWrap 是 BaseObject 的子类，实现了 async_hook 模块的功能，同时实现了异步操作的功能，这里我们只关注异步操作中回调 JS 的功能。当 C++ 层回调 JS 层时会调用 AsyncWrap 的 MakeCallback 函数。</p>
<ol>
<li><strong>回调</strong> <strong>JS</strong></li>
</ol>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> v8::MaybeLocal&#x3C;v8::Value> <span class="hljs-title">AsyncWrap::MakeCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> v8::Local&#x3C;v8::Name> symbol,  
                                                                                                             <span class="hljs-type">int</span> argc,                                                                                                             v8::Local&#x3C;v8::Value>* argv)</span> </span>{  
  v8::Local&#x3C;v8::Value> cb_v;  
  <span class="hljs-comment">// 从对象中取出该 symbol 属性对应的值，值是个函数</span>
  <span class="hljs-comment">// symbol 的值通常在 JS 层设置，比如 onread = xxx，oncomplete = xxx  </span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">object</span>()-><span class="hljs-built_in">Get</span>(<span class="hljs-built_in">env</span>()-><span class="hljs-built_in">context</span>(), symbol).<span class="hljs-built_in">ToLocal</span>(&#x26;cb_v))  
    <span class="hljs-keyword">return</span> v8::<span class="hljs-built_in">MaybeLocal</span>&#x3C;v8::Value>();  
  <span class="hljs-comment">// 需要是个函数  </span>
  <span class="hljs-keyword">if</span> (!cb_v-><span class="hljs-built_in">IsFunction</span>()) {  
    <span class="hljs-keyword">return</span> v8::<span class="hljs-built_in">MaybeLocal</span>&#x3C;v8::Value>();  
  }  
  <span class="hljs-comment">// 回调，见 async_wrap.cc  </span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">MakeCallback</span>(cb_v.<span class="hljs-built_in">As</span>&#x3C;v8::Function>(), argc, argv);  
}  
</code></pre>
<p>以上只是入口函数，看看真正的实现。</p>
<pre><code class="hljs language-c++"><span class="hljs-function">MaybeLocal&#x3C;Value> <span class="hljs-title">AsyncWrap::MakeCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> Local&#x3C;Function> cb,  
                                          <span class="hljs-type">int</span> argc,  
                                          Local&#x3C;Value>* argv)</span> </span>{  
  
  MaybeLocal&#x3C;Value> ret = <span class="hljs-built_in">InternalMakeCallback</span>(<span class="hljs-built_in">env</span>(), <span class="hljs-built_in">object</span>(), cb, argc, argv, context);  
  <span class="hljs-keyword">return</span> ret;  
}  
</code></pre>
<p>接着看一下 InternalMakeCallback</p>
<pre><code class="hljs language-c++"><span class="hljs-function">MaybeLocal&#x3C;Value> <span class="hljs-title">InternalMakeCallback</span><span class="hljs-params">(Environment* env,  
                                       Local&#x3C;Object> recv,  
                                       <span class="hljs-type">const</span> Local&#x3C;Function> callback,  
                                       <span class="hljs-type">int</span> argc,  
                                       Local&#x3C;Value> argv[],  
                                       async_context asyncContext)</span> </span>{  
  <span class="hljs-comment">// …省略其他代码</span>
  <span class="hljs-comment">// 执行 JS 层回调  </span>
  callback-><span class="hljs-built_in">Call</span>(env-><span class="hljs-built_in">context</span>(), recv, argc, argv);}  
</code></pre>
<p>最终通过 V8 Function 的 Call 执行该 JS 函数。</p>
<p><strong>HandleWrap</strong></p>
<p>HandleWrap 是对 Libuv uv_handle_t 结构体和操作的封装，也是很多 C++ 类的基类，比如 TCP、UDP。结构图如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00b382eba34b4aac8d3faa60862829d9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleWrap</span> : <span class="hljs-keyword">public</span> AsyncWrap {  
 <span class="hljs-keyword">public</span>:  
  <span class="hljs-comment">// 操作和判断 handle 状态函数，对 Libuv 的封装  </span>
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">(...)</span></span>;  
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Ref</span><span class="hljs-params">(...)</span></span>;  
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Unref</span><span class="hljs-params">(...)</span></span>;  
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HasRef</span><span class="hljs-params">(...)</span></span>;  
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">IsAlive</span><span class="hljs-params">(<span class="hljs-type">const</span> HandleWrap* wrap)</span> </span>{  
    <span class="hljs-keyword">return</span> wrap != <span class="hljs-literal">nullptr</span> &#x26;&#x26; wrap->state_ != kClosed;  
  }  
  
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">HasRef</span><span class="hljs-params">(<span class="hljs-type">const</span> HandleWrap* wrap)</span> </span>{  
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">IsAlive</span>(wrap) &#x26;&#x26; <span class="hljs-built_in">uv_has_ref</span>(wrap-><span class="hljs-built_in">GetHandle</span>());  
  }  
  <span class="hljs-comment">// 获取封装的 handle  </span>
  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uv_handle_t</span>* <span class="hljs-title">GetHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> handle_; }  
  <span class="hljs-comment">// 关闭 handle，如果传入回调则在 close 阶段被执行  </span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">(v8::Local&#x3C;v8::Value> close_callback = v8::Local&#x3C;v8::Value>())</span></span>;  
  
 <span class="hljs-keyword">protected</span>:  
  <span class="hljs-comment">// 子类可实现</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">()</span> </span>{}  
  <span class="hljs-comment">// handle 状态  </span>
  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">IsHandleClosing</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{  
    <span class="hljs-keyword">return</span> state_ == kClosing || state_ == kClosed;  
  }  
  
 <span class="hljs-keyword">private</span>:   
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(<span class="hljs-type">uv_handle_t</span>* handle)</span></span>;  
  
  <span class="hljs-comment">// handle 队列  </span>
  ListNode&#x3C;HandleWrap> handle_wrap_queue_;  
  <span class="hljs-comment">// handle 的状态  </span>
  <span class="hljs-keyword">enum</span> { kInitialized, kClosing, kClosed } state_;  
  <span class="hljs-comment">// 所有 handle 的基类  </span>
  <span class="hljs-type">uv_handle_t</span>* <span class="hljs-type">const</span> handle_;  
};  
</code></pre>
<p>HandleWrap 有个 handle_ 成员，它指向子类的 handle 类结构体，比如 TCP 模块的 uv_tcp_t，然后剩下的功能就是对 handle 管理的逻辑，比如 Ref 和 Unref 用于控制该 handle 是否影响事件循环的退出。</p>
<ol>
<li><strong>构造函数</strong></li>
</ol>
<pre><code class="hljs language-c++"><span class="hljs-comment">/* 
  object 为 JS 层对象 
  handle 为子类具体的 handle 类型，不同模块不一样 
*/</span>  
HandleWrap::<span class="hljs-built_in">HandleWrap</span>(Environment* env,  
                       Local&#x3C;Object> object,  
                       <span class="hljs-type">uv_handle_t</span>* handle,  
                       AsyncWrap::ProviderType provider)  
    : <span class="hljs-built_in">AsyncWrap</span>(env, object, provider),  
      <span class="hljs-built_in">state_</span>(kInitialized),  
      <span class="hljs-built_in">handle_</span>(handle) {  
  <span class="hljs-comment">// 保存 Libuv handle 和 C++ 对象的关系，Libuv 执行 C++ 回调时使用</span>
  handle_->data = <span class="hljs-keyword">this</span>;  
}  
</code></pre>
<ol start="2">
<li><strong>判断和操作 handle 状态</strong></li>
</ol>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 修改 handle 为活跃状态  </span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrap::Ref</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{  
  HandleWrap* wrap;  
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap, args.<span class="hljs-built_in">Holder</span>());  
  
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsAlive</span>(wrap))  
    <span class="hljs-built_in">uv_ref</span>(wrap-><span class="hljs-built_in">GetHandle</span>());  
}  
  
<span class="hljs-comment">// 修改 hande 为不活跃状态  </span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrap::Unref</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{  
  HandleWrap* wrap;  
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap, args.<span class="hljs-built_in">Holder</span>());  
  
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsAlive</span>(wrap))  
    <span class="hljs-built_in">uv_unref</span>(wrap-><span class="hljs-built_in">GetHandle</span>());  
}  
  
<span class="hljs-comment">// 判断 handle 是否处于活跃状态  </span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrap::HasRef</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{  
  HandleWrap* wrap;  
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap, args.<span class="hljs-built_in">Holder</span>());  
  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(<span class="hljs-built_in">HasRef</span>(wrap));  
}  

<span class="hljs-comment">// 关闭 handle（JS 层调用） </span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrap::Close</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{  
  HandleWrap* wrap;  
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap, args.<span class="hljs-built_in">Holder</span>());  
  <span class="hljs-comment">// 传入回调  </span>
  wrap-><span class="hljs-built_in">Close</span>(args[<span class="hljs-number">0</span>]);  
}  

<span class="hljs-comment">// 真正关闭 handle 的函数  </span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrap::Close</span><span class="hljs-params">(Local&#x3C;Value> close_callback)</span> </span>{  
  <span class="hljs-comment">// 正在关闭或已经关闭  </span>
  <span class="hljs-keyword">if</span> (state_ != kInitialized)  
    <span class="hljs-keyword">return</span>;  
  <span class="hljs-comment">// 调用 Libuv 函数  </span>
  <span class="hljs-built_in">uv_close</span>(handle_, OnClose);  
  <span class="hljs-comment">// 关闭中  </span>
  state_ = kClosing;  
  <span class="hljs-comment">// 传了 onclose 回调则保存起来，在 close 阶段后调用  </span>
  <span class="hljs-keyword">if</span> (!close_callback.<span class="hljs-built_in">IsEmpty</span>() &#x26;&#x26; 
       close_callback-><span class="hljs-built_in">IsFunction</span>() &#x26;&#x26;  
      !<span class="hljs-built_in">persistent</span>().<span class="hljs-built_in">IsEmpty</span>()) {  
    <span class="hljs-built_in">object</span>()-><span class="hljs-built_in">Set</span>(<span class="hljs-built_in">env</span>()-><span class="hljs-built_in">context</span>(),  
                  <span class="hljs-built_in">env</span>()-><span class="hljs-built_in">handle_onclose_symbol</span>(),  
                  close_callback).<span class="hljs-built_in">Check</span>();  
  }  
}  
  
<span class="hljs-comment">// 关闭 handle 成功后回调，Libuv 层执行  </span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrap::OnClose</span><span class="hljs-params">(<span class="hljs-type">uv_handle_t</span>* handle)</span> </span>{  
  Environment* env = wrap-><span class="hljs-built_in">env</span>();  
  wrap->state_ = kClosed;  
  <span class="hljs-comment">// 执行子类的 onClose，如果没有则是空操作</span>
  wrap-><span class="hljs-built_in">OnClose</span>();  
  <span class="hljs-comment">// 有 JS 层 onclose 回调则执行  </span>
  <span class="hljs-keyword">if</span> (!wrap-><span class="hljs-built_in">persistent</span>().<span class="hljs-built_in">IsEmpty</span>() &#x26;&#x26;  
      wrap-><span class="hljs-built_in">object</span>()-><span class="hljs-built_in">Has</span>(env-><span class="hljs-built_in">context</span>(), env-><span class="hljs-built_in">handle_onclose_symbol</span>())  
      .<span class="hljs-built_in">FromMaybe</span>(<span class="hljs-literal">false</span>)) {  
    wrap-><span class="hljs-built_in">MakeCallback</span>(env-><span class="hljs-built_in">handle_onclose_symbol</span>(), 
                       <span class="hljs-number">0</span>,
                       <span class="hljs-literal">nullptr</span>);  
  }  
}  
</code></pre>
<p><strong>ReqWrap</strong></p>
<p>ReqWrap 表示通过 Libuv 对 handle 的一次请求，比如读取文件。ReqWrap 是请求操作的基类，可以实现不同的子类。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> T>  
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReqWrap</span> : <span class="hljs-keyword">public</span> AsyncWrap, <span class="hljs-keyword">public</span> ReqWrapBase { 
 <span class="hljs-keyword">protected</span>:  
  <span class="hljs-comment">// Libuv 请求结构体，类型由子类决定</span>
  T req_;  
};   
</code></pre>
<p>看一下实现</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> T>  
ReqWrap&#x3C;T>::<span class="hljs-built_in">ReqWrap</span>(Environment* env,  
                    v8::Local&#x3C;v8::Object> object,  
                    AsyncWrap::ProviderType provider)  
    : <span class="hljs-built_in">AsyncWrap</span>(env, object, provider),  
      <span class="hljs-built_in">ReqWrapBase</span>(env) {
  <span class="hljs-comment">// 初始化状态  </span>
  <span class="hljs-built_in">Reset</span>();  
}   
  
<span class="hljs-comment">// 重置字段  </span>
<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> T>  
<span class="hljs-type">void</span> ReqWrap&#x3C;T>::<span class="hljs-built_in">Reset</span>() {  
  <span class="hljs-comment">// 由 Libuv 调用的 C++ 层回调</span>
  original_callback_ = <span class="hljs-literal">nullptr</span>;  
  req_.data = <span class="hljs-literal">nullptr</span>;  
}  
</code></pre>
<p>构造函数没有太多逻辑，只是做了一些初始化的事情。接着看发起请求时的逻辑。</p>
<pre><code class="hljs language-c++">
<span class="hljs-comment">// 获取 Libuv 请求结构体</span>
<span class="hljs-function">T* <span class="hljs-title">req</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> &#x26;req_; }  

<span class="hljs-comment">// 保存 Libuv 数据结构和 ReqWrap 实例的关系，发起请求时调用  </span>
<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> T>  
<span class="hljs-type">void</span> ReqWrap&#x3C;T>::<span class="hljs-built_in">Dispatched</span>() {  
  req_.data = <span class="hljs-keyword">this</span>;  
} 

<span class="hljs-comment">// 调用 Libuv 函数  </span>
<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> T>
<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> LibuvFunction, <span class="hljs-keyword">typename</span>... Args>
<span class="hljs-type">int</span> ReqWrap&#x3C;T>::<span class="hljs-built_in">Dispatch</span>(LibuvFunction fn, Args... args) {
  <span class="hljs-comment">// 关联 Libuv 结构体和 C++ 请求对象</span>
  <span class="hljs-built_in">Dispatched</span>();
  CallLibuvFunction&#x3C;T, LibuvFunction>::<span class="hljs-built_in">Call</span>(
      <span class="hljs-comment">// 执行 Libuv 函数</span>
      fn,
      <span class="hljs-built_in">env</span>()-><span class="hljs-built_in">event_loop</span>(),
      <span class="hljs-built_in">req</span>(),
      <span class="hljs-comment">// 由 Libuv 执行的回调，args 通常 handle，参数，回调</span>
      MakeLibuvRequestCallback&#x3C;T, Args>::<span class="hljs-built_in">For</span>(<span class="hljs-keyword">this</span>, args)...);
}
</code></pre>
<p>当 Node.js 需求发起一个请求时，会先创建一个 ReqWrap 的子类对象，然后调 Dispatch 发起真正的请求，Dispatch 通过 CallLibuvFunction&#x3C;T, LibuvFunction>::Call 调用 Libuv 的函数。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// Detect `int uv_foo(uv_loop_t* loop, uv_req_t* request, ...);`.</span>
<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> ReqT, <span class="hljs-keyword">typename</span>... Args>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">CallLibuvFunction</span>&#x3C;ReqT, <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">uv_loop_t</span>*, ReqT*, Args...)> {
  <span class="hljs-keyword">using</span> T = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">uv_loop_t</span>*, ReqT*, Args...);
  <span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span>... PassedArgs>
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">Call</span><span class="hljs-params">(T fn, <span class="hljs-type">uv_loop_t</span>* loop, ReqT* req, PassedArgs... args)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fn</span>(loop, req, args...);
  }
};

<span class="hljs-comment">// Detect `int uv_foo(uv_req_t* request, ...);`.</span>
<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> ReqT, <span class="hljs-keyword">typename</span>... Args>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">CallLibuvFunction</span>&#x3C;ReqT, <span class="hljs-built_in">int</span>(*)(ReqT*, Args...)> {
  <span class="hljs-keyword">using</span> T = <span class="hljs-built_in">int</span>(*)(ReqT*, Args...);
  <span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span>... PassedArgs>
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">Call</span><span class="hljs-params">(T fn, <span class="hljs-type">uv_loop_t</span>* loop, ReqT* req, PassedArgs... args)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fn</span>(req, args...);
  }
};

<span class="hljs-comment">// Detect `void uv_foo(uv_req_t* request, ...);`.</span>
<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> ReqT, <span class="hljs-keyword">typename</span>... Args>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">CallLibuvFunction</span>&#x3C;ReqT, <span class="hljs-built_in">void</span>(*)(ReqT*, Args...)> {
  <span class="hljs-keyword">using</span> T = <span class="hljs-built_in">void</span>(*)(ReqT*, Args...);
  <span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span>... PassedArgs>
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">Call</span><span class="hljs-params">(T fn, <span class="hljs-type">uv_loop_t</span>* loop, ReqT* req, PassedArgs... args)</span> </span>{
    <span class="hljs-built_in">fn</span>(req, args...);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
};
</code></pre>
<p>Node.js 针对不了的 Libuv 函数签名格式编写了不同的模版函数，不过我们不用过于纠结细节，只需要知道它最终会调用 Libuv 的某个函数，并传入了一系列参数，其中一个为 MakeLibuvRequestCallback&#x3C;T, Args>::For(this, args)...。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 通过 req 成员找所属对象的地址</span>
<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> T>
ReqWrap&#x3C;T>* ReqWrap&#x3C;T>::<span class="hljs-built_in">from_req</span>(T* req) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ContainerOf</span>(&#x26;ReqWrap&#x3C;T>::req_, req);
}

<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> ReqT, <span class="hljs-keyword">typename</span> T>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MakeLibuvRequestCallback</span> {
  <span class="hljs-comment">// 匹配第二个参数为非函数</span>
  <span class="hljs-function"><span class="hljs-type">static</span> T <span class="hljs-title">For</span><span class="hljs-params">(ReqWrap&#x3C;ReqT>* req_wrap, T v)</span> </span>{
    <span class="hljs-keyword">return</span> v;
  }
};

<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> ReqT, <span class="hljs-keyword">typename</span>... Args>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MakeLibuvRequestCallback</span>&#x3C;ReqT, <span class="hljs-built_in">void</span>(*)(ReqT*, Args...)> {
  <span class="hljs-keyword">using</span> F = <span class="hljs-built_in">void</span>(*)(ReqT* req, Args... args);
  <span class="hljs-comment">// Libuv 回调</span>
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Wrapper</span><span class="hljs-params">(ReqT* req, Args... args)</span> </span>{
    <span class="hljs-comment">// 通过 Libuv 结构体拿到对应的 C++ 对象</span>
    ReqWrap&#x3C;ReqT>* req_wrap = ReqWrap&#x3C;ReqT>::<span class="hljs-built_in">from_req</span>(req);
    <span class="hljs-comment">// 拿到原始的回调执行</span>
    F original_callback = <span class="hljs-built_in">reinterpret_cast</span>&#x3C;F>(req_wrap->original_callback_);
    <span class="hljs-built_in">original_callback</span>(req, args...);
  }
  <span class="hljs-comment">// 匹配第二个参数为函数</span>
  <span class="hljs-function"><span class="hljs-type">static</span> F <span class="hljs-title">For</span><span class="hljs-params">(ReqWrap&#x3C;ReqT>* req_wrap, F v)</span> </span>{
    <span class="hljs-comment">// 保存原来的函数</span>
    req_wrap->original_callback_ = <span class="hljs-keyword">reinterpret_cast</span>&#x3C;<span class="hljs-keyword">typename</span> ReqWrap&#x3C;ReqT>::<span class="hljs-type">callback_t</span>>(v);
    <span class="hljs-comment">// 返回包裹函数</span>
    <span class="hljs-keyword">return</span> Wrapper;
  }
};
</code></pre>
<p>MakeLibuvRequestCallback::For 用于适配不同的 Dispatch 调用格式，例如 TCP 连接和 DNS 解析。</p>
<pre><code class="hljs language-c++"> <span class="hljs-comment">// TCP 连接</span>
 req_wrap-><span class="hljs-built_in">Dispatch</span>(uv_tcp_connect,
                    &#x26;wrap->handle_,
                    <span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">const</span> sockaddr*>(&#x26;addr),
                    AfterConnect); <span class="hljs-comment">// 回调</span>
 <span class="hljs-comment">// DNS 解析</span>
 req_wrap-><span class="hljs-built_in">Dispatch</span>(uv_getaddrinfo,
                    AfterGetAddrInfo, <span class="hljs-comment">// 回调</span>
                    *hostname,
                    <span class="hljs-literal">nullptr</span>,
                    &#x26;hints);
</code></pre>
<p>MakeLibuvRequestCallback::For 会遍历传入的参数，如果是非函数参数，则透传给 Libuv，如果是函数参数时会执行第二个 For 函数，第二个 For 函数封装了原始的回调，然后把一个 Wrapper 函数传入 Libuv，等到 Libuv 回调时，再执行真正的回调，通过这种劫持的方式，C++ 层可以做一些额外的事情。执行 Dispatch 后的结构图如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17e317f669064e3189758c93e84373b4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>总的来说，ReqWrap 抽象了请求 Libuv 的过程，具体数据结构和操作由子类实现，看一下某个子类的实现。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 请求 Libuv 时，数据结构是 uv_connect_t，表示一次连接请求  </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectWrap</span> : <span class="hljs-keyword">public</span> ReqWrap&#x3C;<span class="hljs-type">uv_connect_t</span>> {  
 <span class="hljs-keyword">public</span>:  
  <span class="hljs-built_in">ConnectWrap</span>(...);  
};  
</code></pre>
<p>当发起一个 TCP 连接时，使用方式如下，后面的课程会详细介绍。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// req_wrap_obj JS 层传来的 req 对象</span>
ConnectWrap* req_wrap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConnectWrap</span>(env, req_wrap_obj, ...);
<span class="hljs-comment">// 发起请求，回调为 AfterConnect</span>
req_wrap-><span class="hljs-built_in">Dispatch</span>(uv_tcp_connect,
                   &#x26;wrap->handle_,
                   <span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">const</span> sockaddr*>(&#x26;addr),
                   AfterConnect);
</code></pre>
<h1>JS 和 C、C++ 层通信</h1>
<p>接下来我们看一下 JS 和 C、C++ 层的通信，Node.js 很多功能都是由 C、C++ 实现，然后暴露到 JS 层使用的，所以当我们调用 JS 代码时，就会进入 C++ 层，接着 C++ 层会进入 Libuv 的 C 层，等到 Libuv 完成操作后就会回调 C++ 代码，最终 C++ 代码再回调 JS 层。</p>
<h2><strong>JS</strong> <strong>调用 C++</strong> <strong>？</strong></h2>
<p>前面讲过，JS 本身是没有网络、文件和进程这些功能的，在 Node.js 里，这些功能需要通过底层的 C、C++ 实现，最终通过 JS API 提供给用户使用。那么当我们调用一个 JS API 时，底层发生了什么呢？我们以 TCP 模块为例，下面的代码摘自 Node.js 的 net 模块。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">TCP</span> }= process.<span class="hljs-title function_">binding</span>(<span class="hljs-string">'tcp_wrap'</span>);    
<span class="hljs-keyword">const</span> tcp = <span class="hljs-keyword">new</span> <span class="hljs-title function_">TCP</span>(...);   
</code></pre>
<p>在 Node.js 中，C++ 模块（类）一般只会定义对应的 Libuv 结构体和一系列函数，然后创建一个函数模版，并传入一个回调，接着把这些函数挂载到函数模板中，最后通过函数模板返回一个函数 F 给 JS 层使用。我们从 C++ 的层面先分析执行 new TCP() 的逻辑，再分析 bind 的逻辑，这两个逻辑涉及的机制是其它 C++ 模块也会使用到的。首先看看 TCP 在 C++ 层的实现。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPWrap::Initialize</span><span class="hljs-params">(Local&#x3C;Object> target,
                         Local&#x3C;Value> unused,
                         Local&#x3C;Context> context,
                         <span class="hljs-type">void</span>* priv)</span> </span>{
  Environment* env = Environment::<span class="hljs-built_in">GetCurrent</span>(context);
  <span class="hljs-comment">// 创建一个函数模版</span>
  Local&#x3C;FunctionTemplate> t = env-><span class="hljs-built_in">NewFunctionTemplate</span>(New);
  <span class="hljs-comment">// 函数名</span>
  Local&#x3C;String> tcpString = <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(env-><span class="hljs-built_in">isolate</span>(), <span class="hljs-string">"TCP"</span>);
  t-><span class="hljs-built_in">SetClassName</span>(tcpString);
  <span class="hljs-comment">// 可关联的 C++ 对象个数</span>
  t-><span class="hljs-built_in">InstanceTemplate</span>()-><span class="hljs-built_in">SetInternalFieldCount</span>(StreamBase::kInternalFieldCount);
  <span class="hljs-comment">// 设置原型方法</span>
  env-><span class="hljs-built_in">SetProtoMethod</span>(t, <span class="hljs-string">"open"</span>, Open);
  env-><span class="hljs-built_in">SetProtoMethod</span>(t, <span class="hljs-string">"bind"</span>, Bind);
  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// 根据函数模块导出一个函数到 JS 层</span>
  target-><span class="hljs-built_in">Set</span>(env-><span class="hljs-built_in">context</span>(),
              tcpString,
              t-><span class="hljs-built_in">GetFunction</span>(env-><span class="hljs-built_in">context</span>()).<span class="hljs-built_in">ToLocalChecked</span>()).<span class="hljs-built_in">Check</span>();
</code></pre>
<p>当 JS 层执行 new TCP 时，C++ 层就会创建一个对象（ JS 层拿到的对象），然后把这个对象和 JS 层传入的参数传给 TCPWrap::New 函数。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPWrap::New</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{  
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">TCPWrap</span>(env, args.<span class="hljs-built_in">This</span>(), ...);  
}  
</code></pre>
<p>TCPWrap 继承了 HandleWrap。</p>
<pre><code class="hljs language-c++">HandleWrap::<span class="hljs-built_in">HandleWrap</span>(Environment* env,  
                       Local&#x3C;Object> object,  
                       <span class="hljs-type">uv_handle_t</span>* handle,  
                       AsyncWrap::ProviderType provider)  
    : <span class="hljs-built_in">AsyncWrap</span>(env, object, provider),  
      <span class="hljs-built_in">state_</span>(kInitialized),  
      <span class="hljs-built_in">handle_</span>(handle) {  
  <span class="hljs-comment">// 保存 Libuv handle 和 C++ 对象的关系  </span>
  handle_->data = <span class="hljs-keyword">this</span>;  
}  
</code></pre>
<p>HandleWrap 保存了 Libuv 结构体和 C++ 对象的关系，这样我们从 Libuv 回调时就可以知道 handle 对应的 C++ 对象。HandleWrap 继承了 BaseObject。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 把对象存储到 persistent_handle_ 中，需要的时候通过 object() 取出来  </span>
BaseObject::<span class="hljs-built_in">BaseObject</span>(Environment* env, v8::Local&#x3C;v8::Object> object)  
    : <span class="hljs-built_in">persistent_handle_</span>(env-><span class="hljs-built_in">isolate</span>(), object), <span class="hljs-built_in">env_</span>(env) {  
  <span class="hljs-comment">// 把 this 存到 object中，BaseObject::kSlot 为 0  </span>
  object-><span class="hljs-built_in">SetAlignedPointerInInternalField</span>(BaseObject::kSlot, <span class="hljs-built_in">static_cast</span>&#x3C;<span class="hljs-type">void</span>*>(<span class="hljs-keyword">this</span>));    
}  
</code></pre>
<p>前面讲过，SetAlignedPointerInInternalField 函数做的事情就是把一个值（TCPWrap对象）保存到 JS 对象 object 里。如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22bb7e0733df440c8f06202aa324638e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这时候 new TCP 就执行完毕了，下面我们会看到这些关联起来的对象有什么作用，接着看在 JS 层执行tcp.connect(...) 函数的逻辑。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TCPConnectWrap</span>();
req.<span class="hljs-property">oncomplete</span> = afterConnect;
req.<span class="hljs-property">address</span> = address;
req.<span class="hljs-property">port</span> = port;
req.<span class="hljs-property">localAddress</span> = localAddress;
req.<span class="hljs-property">localPort</span> = localPort;
self.<span class="hljs-property">_handle</span>.<span class="hljs-title function_">connect</span>(req, address, port);
</code></pre>
<p>接着看 C++ 层 connect 函数。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> T>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPWrap::Connect</span><span class="hljs-params">(...)</span> </span>{
  TCPWrap* wrap;
  <span class="hljs-comment">// 从 JS 对象拿到关联的 C++ 对象</span>
  <span class="hljs-comment">/*
        wrap = args.Holder()->GetAlignedPointerFromInternalField(BaseObject::kSlot));
  */</span>
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap,
                          args.<span class="hljs-built_in">Holder</span>(),
                          args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(UV_EBADF));
  <span class="hljs-comment">// 从 C++ 对象 TCPWrap 中获得 Libuv 的 handle 结构体</span>
  <span class="hljs-built_in">uv_tcp_connect</span>(&#x26;wrap->handle_, ...);
}
</code></pre>
<p>我们只需看一下 ASSIGN_OR_RETURN_UNWRAP 宏的逻辑，主要是从 args.Holder() 中获取对应的 C++ 对象（TCPWrap），然后就可以使用 TCPWrap 对象的 handle 去请求 Libuv 了。</p>
<h2>C++ 调用 Libuv</h2>
<p>那么 C++ 调用 Libuv 又是如何串起来的呢？来详细看一下 connect 函数的代码。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPWrap::Connect</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args,  
    std::function&#x3C;<span class="hljs-type">int</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip_address, T* addr)> uv_ip_addr)</span> </span>{  
  Environment* env = Environment::<span class="hljs-built_in">GetCurrent</span>(args);  
  
  TCPWrap* wrap;  
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap,  
                          args.<span class="hljs-built_in">Holder</span>(),  
                          args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(UV_EBADF));  
  
  <span class="hljs-comment">// 第一个参数是 TCPConnectWrap 对象</span>
  Local&#x3C;Object> req_wrap_obj = args[<span class="hljs-number">0</span>].<span class="hljs-built_in">As</span>&#x3C;Object>();  
  <span class="hljs-comment">// 忽略其他参数处理</span>
  <span class="hljs-comment">// 创建一个对象请求 Libuv</span>
  ConnectWrap* req_wrap =  <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConnectWrap</span>(env,  req_wrap_obj, ...);  
  req_wrap-><span class="hljs-built_in">Dispatch</span>(uv_tcp_connect,  
                     &#x26;wrap->handle_,  
                     <span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">const</span> sockaddr*>(&#x26;addr),  
                     AfterConnect);  
}  
</code></pre>
<p>ConnectWrap 是 C++ 类，继承了 BaseObject，req_wrap_obj 是 JS 对象，它们会互相关联，和之前分析的一样。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed9b548b614453b9daae6774d9a4a3f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>另外，ConnectWrap 还继承了 ReqWrap，ReqWrap 是用于管理 Libuv 请求的。接着看一下 Dispatch。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 调用 Libuv 函数  </span>
<span class="hljs-type">int</span> ReqWrap&#x3C;T>::<span class="hljs-built_in">Dispatch</span>(LibuvFunction fn, Args... args) {  
  <span class="hljs-comment">// 保存 Libuv 结构体和 C++ 层对象 ConnectWrap 的关系    </span>
  req_.data = <span class="hljs-keyword">this</span>;    
  CallLibuvFunction&#x3C;T, LibuvFunction>::<span class="hljs-built_in">Call</span>(  
      fn,  
      <span class="hljs-built_in">env</span>()-><span class="hljs-built_in">event_loop</span>(),  
      <span class="hljs-built_in">req</span>(),  
      MakeLibuvRequestCallback&#x3C;T, Args>::<span class="hljs-built_in">For</span>(<span class="hljs-keyword">this</span>, args)...);   
}  
</code></pre>
<p>调用 Libuv 之前的结构如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/041e1c250c7e4b4782c9ebb9d9e8cc91~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>接下来分析调用 Libuv 的具体过程：</p>
<pre><code class="hljs language-c++"><span class="hljs-built_in">uv_tcp_connect</span>(  
  <span class="hljs-built_in">req</span>(),  
  &#x26;wrap->handle_,  
  <span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">const</span> sockaddr*>(&#x26;addr),  
  AfterConnect
);  
</code></pre>
<p>然后，我们再看看uv_tcp_connect做了什么。</p>
<pre><code class="hljs language-c">    <span class="hljs-type">int</span> <span class="hljs-title function_">uv_tcp_connect</span><span class="hljs-params">(<span class="hljs-type">uv_connect_t</span>* req,  
                       <span class="hljs-type">uv_tcp_t</span>* handle,  
                       <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr,  
                       uv_connect_cb cb)</span> {  
      <span class="hljs-comment">// ...  </span>
      <span class="hljs-keyword">return</span> uv__tcp_connect(req, handle, addr, addrlen, cb);  
    }  
      
    <span class="hljs-type">int</span> <span class="hljs-title function_">uv__tcp_connect</span><span class="hljs-params">(<span class="hljs-type">uv_connect_t</span>* req,  
                        <span class="hljs-type">uv_tcp_t</span>* handle,  
                        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr,  
                        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addrlen,  
                        uv_connect_cb cb)</span> {  
      <span class="hljs-type">int</span> err;  
      <span class="hljs-type">int</span> r;  
      
      <span class="hljs-comment">// 非阻塞发起连接</span>
      connect(uv__stream_fd(handle), addr, addrlen);
      <span class="hljs-comment">// 保存回调 AfterConnect</span>
      req->cb = cb;
      <span class="hljs-comment">// 关联起来  </span>
      req->handle = (<span class="hljs-type">uv_stream_t</span>*) handle;  
      <span class="hljs-comment">// 注册事件，连接结束后触发，然后执行回调</span>
      uv__io_start(handle->loop, &#x26;handle->io_watcher, POLLOUT);
      <span class="hljs-comment">// ...  </span>
    }  
</code></pre>
<p>Libuv 中保存了请求上下文，比如回调，并把 req 和 handle 做了关联，在执行回调时会使用，如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64a3646c100e4044844a8b0b4accab57~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2><strong>Libuv 回调 C++</strong></h2>
<p>分析完 C++ 调用 Libuv 后，我们看看 Libuv 回调 C++ 的。当连接结束后，比如完成了三次握手，操作系统会通知 Libuv，Libuv 会执行 uv__stream_connect 处理连接结果 。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uv__stream_connect</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream)</span> {
  <span class="hljs-type">int</span> error;
  <span class="hljs-type">uv_connect_t</span>* req = stream->connect_req;
  <span class="hljs-type">socklen_t</span> errorsize = <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>);
  <span class="hljs-comment">// 获取连接结果</span>
  getsockopt(uv__stream_fd(stream),
             SOL_SOCKET,
             SO_ERROR,
             &#x26;error,
             &#x26;errorsize);
    error = UV__ERR(error);
  <span class="hljs-comment">// 执行回调</span>
  <span class="hljs-keyword">if</span> (req->cb)
    req->cb(req, error);
}
</code></pre>
<p>uv__stream_connect 从操作系统获取连接结果，然后执行 C++ 层回调，从前面的分析中可以知道回调函数是 AfterConnect。</p>
<pre><code class="hljs language-c++">
<span class="hljs-type">void</span> ConnectionWrap&#x3C;WrapType, UVType>::<span class="hljs-built_in">AfterConnect</span>(<span class="hljs-type">uv_connect_t</span>* req,  
                                                    <span class="hljs-type">int</span> status) {  
  <span class="hljs-comment">// 从 Libuv 结构体拿到 C++ 层的请求对象  </span>
  <span class="hljs-function">std::unique_ptr&#x3C;ConnectWrap> <span class="hljs-title">req_wrap</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&#x3C;ConnectWrap*>(req->data))</span></span>;  
  <span class="hljs-comment">// 从 C++ 层请求对象拿到对应的 handle 结构体（Libuv 里关联起来的），</span>
  <span class="hljs-comment">// 再通过 handle 拿到对应的C++层 TCPWrap 对象（HandleWrap 关联的）  </span>
  WrapType* wrap = <span class="hljs-built_in">static_cast</span>&#x3C;WrapType*>(req->handle->data);  
  Environment* env = wrap-><span class="hljs-built_in">env</span>();  
  ...  
  Local&#x3C;Value> argv[<span class="hljs-number">5</span>] = {  
    Integer::<span class="hljs-built_in">New</span>(env-><span class="hljs-built_in">isolate</span>(), status),  
    wrap-><span class="hljs-built_in">object</span>(),  
    req_wrap-><span class="hljs-built_in">object</span>(),  
    Boolean::<span class="hljs-built_in">New</span>(env-><span class="hljs-built_in">isolate</span>(), readable),  
    Boolean::<span class="hljs-built_in">New</span>(env-><span class="hljs-built_in">isolate</span>(), writable)  
  };  
  <span class="hljs-comment">// 回调 JS 层 oncomplete  </span>
  req_wrap-><span class="hljs-built_in">MakeCallback</span>(env-><span class="hljs-built_in">oncomplete_string</span>(), 
                         <span class="hljs-built_in">arraysize</span>(argv), 
                         argv);  
}    
</code></pre>
<p>AfterConnect 通过之前的关联关系拿到 TCPWrap 对象，最后再通过 req_wrap 对象（ConnectWrap）的 MakeCallback 执行 JS 回调。</p>
<h2>C++ 回调 JS</h2>
<p>接着看 MakeCallback 是如何回调 JS 的。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> v8::MaybeLocal&#x3C;v8::Value> <span class="hljs-title">AsyncWrap::MakeCallback</span><span class="hljs-params">(
    <span class="hljs-type">const</span> v8::Local&#x3C;v8::String> symbol,
    <span class="hljs-type">int</span> argc,
    v8::Local&#x3C;v8::Value>* argv)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">MakeCallback</span>(symbol.<span class="hljs-built_in">As</span>&#x3C;v8::Name>(), argc, argv);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> v8::MaybeLocal&#x3C;v8::Value> <span class="hljs-title">AsyncWrap::MakeCallback</span><span class="hljs-params">(
    <span class="hljs-type">const</span> v8::Local&#x3C;v8::Name> symbol,
    <span class="hljs-type">int</span> argc,
    v8::Local&#x3C;v8::Value>* argv)</span> </span>{
    
  v8::Local&#x3C;v8::Value> cb_v;
  <span class="hljs-comment">// 通过 ConnectWrap 的 object() 获取关联的 JS 对象并获取 oncomplete 属性的值</span>
  <span class="hljs-built_in">object</span>()-><span class="hljs-built_in">Get</span>(<span class="hljs-built_in">env</span>()-><span class="hljs-built_in">context</span>(), symbol).<span class="hljs-built_in">ToLocal</span>(&#x26;cb_v)
    
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">MakeCallback</span>(cb_v.<span class="hljs-built_in">As</span>&#x3C;v8::Function>(), argc, argv);
}
</code></pre>
<p>MakeCallback 中通过 ConnectWrap 的 object() 函数获取关联的 JS 对象，也就是 JS 创建的 TCPConnectWrap。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TCPConnectWrap</span>();
req.<span class="hljs-property">oncomplete</span> = afterConnect;
</code></pre>
<p>接着获取 TCPConnectWrap 对象的 oncomplete 属性的值，值是一个函数，接着调 MakeCallback。</p>
<pre><code class="hljs language-c++"><span class="hljs-function">MaybeLocal&#x3C;Value> <span class="hljs-title">AsyncWrap::MakeCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> Local&#x3C;Function> cb,
                                          <span class="hljs-type">int</span> argc,
                                          Local&#x3C;Value>* argv)</span> </span>{

  <span class="hljs-built_in">InternalMakeCallback</span>(<span class="hljs-built_in">env</span>(), <span class="hljs-built_in">GetResource</span>(), <span class="hljs-built_in">object</span>(), cb, argc, argv, context);
}

<span class="hljs-function">MaybeLocal&#x3C;Value> <span class="hljs-title">InternalMakeCallback</span><span class="hljs-params">(Environment* env,
                                       Local&#x3C;Object> resource,
                                       Local&#x3C;Object> recv,
                                       <span class="hljs-type">const</span> Local&#x3C;Function> callback,
                                       <span class="hljs-type">int</span> argc,
                                       Local&#x3C;Value> argv[],
                                       async_context asyncContext)</span> </span>{
     callback-><span class="hljs-built_in">Call</span>(env-><span class="hljs-built_in">context</span>(), recv, argc, argv);
 }
</code></pre>
<p>这样就完成了回调 JS 层。整个过程翻译成 JS 大致如下：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 操作系统</span>
<span class="hljs-keyword">let</span> fd = <span class="hljs-number">0</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">socket</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> ++fd;
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">fd, addr, port, req</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> {
        <span class="hljs-comment">// 模拟</span>
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
            <span class="hljs-title function_">resolve</span>(<span class="hljs-number">0</span>);
        }, <span class="hljs-number">1000</span>);
    })
}

<span class="hljs-comment">//Libuv  </span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">uv_tcp_connect</span>(<span class="hljs-params">req, handle, addr, port, cb</span>) { 
    handle.<span class="hljs-property">fd</span> = <span class="hljs-title function_">socket</span>();
    req.<span class="hljs-property">handle</span> = handle;
    req.<span class="hljs-property">cb</span> = cb;
    <span class="hljs-keyword">const</span> status = <span class="hljs-keyword">await</span> <span class="hljs-title function_">connect</span>(handle.<span class="hljs-property">fd</span>, addr, port);
    req.<span class="hljs-title function_">cb</span>(req, status);
 }    
      
<span class="hljs-comment">// C++  </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectWrap</span> {
    uv_connect_t = {};
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">object</span>) {
        object[<span class="hljs-number">0</span>] = <span class="hljs-variable language_">this</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">object</span> = object;
    }
    <span class="hljs-title class_">Dispatch</span>(fn, ...args) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">uv_connect_t</span>.<span class="hljs-property">data</span> = <span class="hljs-variable language_">this</span>;
        <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uv_connect_t</span>, ...args);
    }
    <span class="hljs-title class_">MakeCallback</span>(key, ...args) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">object</span>[key](...args);
    }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPWrap</span> {    
  uv_tcp_t = {};    
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">uv_tcp_t</span>.<span class="hljs-property">data</span> = <span class="hljs-variable language_">this</span>;
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title class_">Connect</span>(req, addr, port) {    
    <span class="hljs-keyword">const</span> tcpWrap = <span class="hljs-variable language_">this</span>[<span class="hljs-number">0</span>];    
    <span class="hljs-keyword">const</span> connectWrap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectWrap</span>(req);
    connectWrap.<span class="hljs-title class_">Dispatch</span>(
        uv_tcp_connect, 
        tcpWrap.<span class="hljs-property">uv_tcp_t</span>,  
        addr,  
        port,
        <span class="hljs-function">(<span class="hljs-params">req, status</span>) =></span> { 
          <span class="hljs-keyword">const</span> connectWrap = req.<span class="hljs-property">data</span>;
          <span class="hljs-keyword">const</span> tcpWrap = req.<span class="hljs-property">handle</span>.<span class="hljs-property">data</span>;
          connectWrap.<span class="hljs-title class_">MakeCallback</span>(<span class="hljs-string">'oncomplete'</span>, tcpWrap, connectWrap, status);
        }
    );    
 }    
  
}    
  
<span class="hljs-keyword">function</span> <span class="hljs-title function_">FunctionTemplate</span>(<span class="hljs-params">cb</span>) {    
   <span class="hljs-keyword">function</span> <span class="hljs-title function_">Tmp</span>(<span class="hljs-params"></span>) {  
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-variable language_">this</span>, map);  
    cb &#x26;&#x26; <span class="hljs-title function_">cb</span>(<span class="hljs-variable language_">this</span>);  
   }  
   <span class="hljs-keyword">const</span> map = {};  
   <span class="hljs-keyword">return</span> {  
    <span class="hljs-title class_">PrototypeTemplate</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {  
        <span class="hljs-keyword">return</span> {  
            <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">k, v</span>) {  
                <span class="hljs-title class_">Tmp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[k] = v;  
            }  
        }  
    },  
    <span class="hljs-title class_">InstanceTemplate</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {  
        <span class="hljs-keyword">return</span> {  
            <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">k, v</span>) {  
                map[k] = v;  
            }  
        }  
    },  
    <span class="hljs-title class_">GetFunction</span>() {  
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Tmp</span>;  
    }  
   }   
  
}    
  
<span class="hljs-keyword">const</span> <span class="hljs-title class_">TCPFunctionTemplate</span> = <span class="hljs-title class_">FunctionTemplate</span>(<span class="hljs-function">(<span class="hljs-params">target</span>) =></span> { target[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TCPWrap</span>(); })    
  
<span class="hljs-title class_">TCPFunctionTemplate</span>.<span class="hljs-title class_">PrototypeTemplate</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">'connect'</span>, <span class="hljs-title class_">TCPWrap</span>.<span class="hljs-property">Connect</span>);  
<span class="hljs-title class_">TCPFunctionTemplate</span>.<span class="hljs-title class_">InstanceTemplate</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">'name'</span>, <span class="hljs-string">'hi'</span>);  
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TCP</span> = <span class="hljs-title class_">TCPFunctionTemplate</span>.<span class="hljs-title class_">GetFunction</span>();  

<span class="hljs-keyword">const</span> <span class="hljs-title class_">TCPConnectWrapFunctionTemplate</span> = <span class="hljs-title class_">FunctionTemplate</span>();    
<span class="hljs-keyword">const</span> <span class="hljs-title class_">TCPConnectWrap</span> = <span class="hljs-title class_">TCPConnectWrapFunctionTemplate</span>.<span class="hljs-title class_">GetFunction</span>(); 

<span class="hljs-comment">// JS  </span>
<span class="hljs-keyword">const</span> tcp = <span class="hljs-keyword">new</span> <span class="hljs-title function_">TCP</span>();  
<span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TCPConnectWrap</span>();
<span class="hljs-keyword">const</span> address = <span class="hljs-string">'127.0.0.1'</span>;
<span class="hljs-keyword">const</span> port = <span class="hljs-number">80</span>;
req.<span class="hljs-property">oncomplete</span> = <span class="hljs-function">() =></span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'connect 成功'</span>); };
req.<span class="hljs-property">address</span> = address;
req.<span class="hljs-property">port</span> = port;
tcp.<span class="hljs-title function_">connect</span>(req, address, port);
</code></pre>
<h1>总结</h1>
<p>这节课我们围绕 C++ 层是如何把 Libuv 的功能引入 JS 的，详细讲解了 C++ 层核心内容。</p>
<ol>
<li>Node.js 通过 V8 提供的函数模版和对象模版来拓展 JS 的功能。</li>
</ol>

<ol start="2">
<li>C++ 层的核心数据结构大多数是 C++ 类的基类，它们封装了很多通用的逻辑。BaseObject 用于 JS 和 C++ 对象的管理，AsyncWrap 用于异步回调 JS，HandleWrap 和 ReqWrap 是对 Libuv handle 和 request 的封装，这是我们必须理解的核心数据结构，后面的课程中会大量引用。</li>
</ol>

<ol start="3">
<li>我们沿着 JS 到 C++ 再到 Libuv，然后从 Libuv 到 C++，再到 JS 的路线进行了详细的分析，在这个过程中，我们需要捋清楚 JS、C++ 和 Libuv 三层之间，数据结构的关联关系，否则就会陷入迷雾中。</li>
</ol>
<p>了解了这些内容后，后面学习 TCP、UDP 等模块都会容易很多，同时也为我们自己写 JS 运行时打下了坚实的基础。</p></div>
</body></html>