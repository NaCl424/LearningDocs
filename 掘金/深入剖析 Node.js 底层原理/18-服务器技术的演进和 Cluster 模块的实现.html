<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>服务器技术的演进和 Cluster 模块的实现</h1>
<p>上节课我们讲了 Node.js 的进程模块，进程模块使得 Node.js 具备了创建子进程的能力，而 Cluster 模块在进程模块的基础上使得多个进程可以监听同一个端口，实现服务器的多进程架构。</p>
<p>Cluster 模块使用到的技术不是 Node.js 中独有的，而是现代服务器软件通用的技术。而要了解 Cluster 模块的基础，我们就要从服务器架构的演进开始讲起。这之后，我们会深入 Node.js Cluster 模块的实现，并且实现出自己的 Cluster 模块。</p>
<h1>服务器的架构演进</h1>
<p>服务器是现代软件中非常重要的一个组成，它的底层技术和架构也一直在演变。其中，如何高效地处理连接一直是操作系统和服务器软件都在研究的问题，高效处理连接才能满足互联网日益增长的流量，也为用户节省更多资源，提升整体使用体验。下面，我们就一起看看服务器处理连接的架构演进。</p>
<p>一个基于 TCP 协议的服务器，创建流程如下（伪代码）。</p>
<pre><code class="hljs language-scss">int server_fd = <span class="hljs-built_in">socket</span>();
<span class="hljs-built_in">bind</span>(server_fd);
<span class="hljs-built_in">listen</span>(server_fd);
</code></pre>
<p>执行完以上步骤，一个服务器正式启动。基于上面的模型，接下来分析各种处理连接的架构。</p>
<h2>串行模式</h2>
<p>串行模式就是服务器逐个处理连接，处理完前面的连接后才能继续处理后面的连接，逻辑如下。</p>
<pre><code class="hljs language-scss"><span class="hljs-built_in">while</span>(<span class="hljs-number">1</span>) {
    int client_fd  = <span class="hljs-built_in">accept</span>(server_fd);
    <span class="hljs-built_in">read</span>(client_fd);
    <span class="hljs-built_in">write</span>(client_fd);
}
</code></pre>
<p>上面是服务器处理连接方式中最朴素的模型，如果没有连接，则服务器处于阻塞状态，如果有连接服务器就会不断地调用 accept 摘下完成三次握手的连接并处理。我们看看这种模式的处理过程。假设此时有 n 个请求到来，进程会从accept 中被唤醒，然后拿到一个新的 socket 用于通信，结构图如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efe63a79e2244312ad1ab00d7155b037~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这种处理模式下，如果处理的过程中调用了阻塞 API，比如文件 IO，就会影响后面请求的处理，可想而知，效率是非常低的，而且，并发量比较大的时候，监听 socket 对应的队列很快就会被占满（已完成连接队列有一个最大长度），导致后面的连接无法完成。这是最简单的模式，虽然服务器的设计中肯定不会使用这种模式，但是它让我们了解了一个服务器处理请求的整体过程。</p>
<p>上面的过程不仅涉及连接处理，还涉及连接的建立，即三次握手，很多同学都了解三次握手是什么，但可能很少会深入思考它是如何实现的，这样碰到连接相关的问题时就无法解决，比如为什么发起连接时会收到 RST 包，又比如遇到面试题：服务器通过操作系统监听一个端口后，收到连接时如何处理 ？一个服务器最多可以接收多少个连接呢？</p>
<p>众所周知，一个服务器启动的时候会监听一个端口，其实就是新建了一个 socket。如果有一个连接到来的时候，我们通过 accept 就能拿到这个新连接对应的 socket，那这个 socket 和监听的 socket 是不是同一个呢？</p>
<p>其实 socket 分为监听型和通信型。表面上，服务器用一个端口实现了多个连接，但是这个端口是用于监听的，底层用于和客户端通信的其实是另一个 socket。每当一个连接到来的时候，操作系统会根据请求包的目的地址信息找到对应的监听 socket，如果找不到就会回复 RST 包，如果找到就会生成一个新的 socket 与之通信（accept 的时候返回的那个）。监听 socket 里保存了监听的 IP 和端口，通信 socket 首先从监听 socket 中复制 IP 和端口，然后把客户端的 IP 和端口也记录下来。这样一来，下次再收到一个数据包，操作系统就会根据四元组从 socket 池子里找到该 socket，完成数据的处理。因此理论上，一个服务器能接受多少连接取决于服务器的硬件配置，比如内存大小。</p>
<h2>多进程模式</h2>
<p>串行模式中，所有请求都在一个进程中排队被处理，效率非常低下。为了提高效率，我们可以把请求分给多个进程处理。因为在串行处理的模式中，如果有文件 IO 操作就会阻塞进程，继而阻塞后续请求的处理。在多进程的模式中，即使一个请求阻塞了进程，操作系统还可以调度其它进程继续执行新的任务。多进程模式分为几种，下面我们一一讲解。</p>
<h3><strong>fork 模式</strong></h3>
<p>fork 模式是主进程监听端口，有连接到来时，主进程执行 accept 摘取连接，然后通过 fork 创建子进程处理连接，逻辑如下。</p>
<pre><code class="hljs language-perl"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {  
    <span class="hljs-keyword">int</span> client_fd = <span class="hljs-keyword">accept</span>(<span class="hljs-keyword">socket</span>); 
    <span class="hljs-regexp">//</span> 忽略出错处理 
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">fork</span>() > <span class="hljs-number">0</span>) {  
        <span class="hljs-keyword">continue</span>;
        <span class="hljs-regexp">//</span> 父进程负责 <span class="hljs-keyword">accept</span>  
    } <span class="hljs-keyword">else</span> {  
        <span class="hljs-regexp">//</span> 子进程  
        handle(client_fd); 
        <span class="hljs-keyword">exit</span>(); 
    }  
} 
</code></pre>
<p>这种模式下，每次来一个请求，就会新建一个进程去处理。这种模式比串行模式稍微好了一点，每个请求都被独立处理。假设 a 请求阻塞在文件 IO，不会影响 b 请求的处理，尽可能地做到了并发。它的瓶颈就是系统的进程数有限，如果有大量的请求，系统扛不住，而且进程的开销会很大，对于系统来说是一个沉重的负担。</p>
<h3><strong>pre-fork 模式 + 主进程 accept</strong></h3>
<p>pre-fork 模式就是服务器启动的时候，预先创建一定数量的进程，但是这些进程是 worker 进程，不负责接收连接，只负责处理请求。处理过程为主进程负责接收连接，然后把接收到的连接交给 worker 进程处理，流程如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5792e61fe9d24ab8bcf9cda602ef43e8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>逻辑如下：</p>
<pre><code class="hljs language-ini">let <span class="hljs-attr">fds</span> = [[], [], [], …进程个数]<span class="hljs-comment">;  </span>
let <span class="hljs-attr">process</span> = []<span class="hljs-comment">;  </span>
for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span> <span class="hljs-comment">; i &#x3C; 进程个数; i++) {  </span>
    // 创建管道用于传递文件描述符  
    socketpair(fds<span class="hljs-section">[i]</span>)<span class="hljs-comment">;  </span>
    let pid<span class="hljs-comment">;  </span>
    if (<span class="hljs-attr">pid</span> = fork() > <span class="hljs-number">0</span>) {  
        // 父进程  
        process.push({pid, 其它字段})<span class="hljs-comment">;  </span>
    } else {  
        const <span class="hljs-attr">index</span> = i<span class="hljs-comment">;  </span>
        // 子进程处理请求  
        while(1) {  
            // 从管道中读取文件描述符  
            var <span class="hljs-attr">client_fd</span> = read(fd[index][<span class="hljs-number">1</span>])<span class="hljs-comment">;  </span>
            // 处理请求  
            handle(client_fd)<span class="hljs-comment">;  </span>
        }  
    }  
}  
// 主进程 accept
for (<span class="hljs-comment">;;) {  </span>
    const <span class="hljs-attr">clientFd</span> = accept(socket)<span class="hljs-comment">;  </span>
    // 找出处理该请求的子进程  
    const <span class="hljs-attr">i</span> = findProcess()<span class="hljs-comment">;  </span>
    // 传递文件描述符  
    write(fds<span class="hljs-section">[i]</span><span class="hljs-section">[0]</span>, clientFd)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>和 fork 模式相比，pre-fork 模式相对比较复杂，因为在前一种模式中，主进程收到一个请求就会实时 fork 一个子进程，这个子进程会继承主进程中新请求对应的 fd，可以直接处理该 fd 对应的请求。但是在进程池的模式中，子进程是预先创建的，当主进程收到一个请求的时候，子进程中无法拿得到该请求对应的 fd 。这时候就需要主进程使用传递文件描述符的技术，把这个请求对应的 fd 传给子进程。</p>
<h3><strong>pre-fork 模式 + 子进程 accept</strong></h3>
<p>前面介绍的两种模式中，都是主进程接收连接，然后传递给子进程处理，这样主进程就会成为系统的瓶颈，它可能来不及接收和分发请求给子进程，而子进程却很空闲。子进程 accept 这种模式不是等到请求来的时候再创建进程，而是在服务器启动的时候，就会创建多个进程，然后多个子进程分别调用 accept，逻辑如下。</p>
<pre><code class="hljs language-scss">int server_fd = <span class="hljs-built_in">socket</span>();
<span class="hljs-built_in">bind</span>(server_fd);
for (let i = <span class="hljs-number">0</span> ; i &#x3C; 进程个数; i++) {  
    if (fork() > <span class="hljs-number">0</span>) {  
        <span class="hljs-comment">// 父进程负责监控子进程  </span>
    } else {  
        <span class="hljs-comment">// 子进程处理请求  </span>
        <span class="hljs-built_in">listen</span>(server_fd);
        <span class="hljs-built_in">while</span>(<span class="hljs-number">1</span>) {  
            int client_fd = <span class="hljs-built_in">accept</span>(socket);  
            <span class="hljs-built_in">handle</span>(client_fd);  
        }  
    }  
}  
</code></pre>
<p>这种模式下多个子进程都阻塞在 accept，如果这时候有一个请求到来，那么所有的子进程都会被唤醒，但是先被调度的子进程会摘下这个请求节点，后续的进程被唤醒后可能会遇到已经没有请求可以处理，而又进入睡眠，这种进程被无效唤醒的现象就是著名的惊群现象。这种模式的处理流程如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e46cecf81f845d0946604ba0b3d3245~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>Nginx 中解决了惊群这个问题，它的处理方式是在 accpet 之前先加锁，拿到锁的进程才进行 accept，这样就保证了只有一个进程会阻塞在 accept，不会引起惊群问题，但是新版操作系统已经在内核层面解决了这个问题，每次只会唤醒一个进程。</p>
<h2>多线程模式</h2>
<p>除了使用多进程外，也可以使用多线程技术处理连接，多线程模式和多进程模式类似，也分为 3 种： 1. 主线程 accept，创建子线程处理 2. 线程池 3. 子线程 accept 1、3 和多进程模式中的一样，第 2 种比较特别，所以我们重点来介绍。在子进程模式时，每个子进程都有自己的 task_struct，这就意味着在 fork 之后，每个进程负责维护自己的数据、资源。线程则不一样，线程共享进程的数据和资源，主线程从 accept 中拿到一个 fd 传给线程之后，线程就可以直接操作它，所以线程池模式的架构如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86b362383c2d4148be7f7c61d336a318~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>通过上图我们可以知道，主线程负责 accept 请求，然后通过互斥的方式插入一个任务到共享队列中，线程池中的子线程同样是通过互斥的方式，从共享队列中摘取节点进行处理。有兴趣的同学可以参考这个<a href="https://github.com/theanarkh/multi-thread-server" target="_blank" rel="nofollow noopener noreferrer">仓库</a>。</p>
<h2>事件驱动</h2>
<p>从之前的处理模式中我们知道，为了应对大量的请求，服务器需要大量的进程 / 线程，这是个非常大的开销。现在很多服务器（Nginx、Nodejs、Redis）都开始使用单进程 + 事件驱动模式去设计，这种模式可以在单个进程中轻松处理成千上万的请求。</p>
<p>但也正因为单进程模式下，再多的请求也只在一个进程里处理，这样一个任务会一直在占据 CPU，后续的任务就无法执行了。因此，事件驱动模式不适合 CPU 密集型的场景，更适合 IO 密集的场景（一般都会提供线程 / 线程池，负责处理 CPU 或者阻塞型的任务）。</p>
<p>大部分操作系统都提供了事件驱动的 API，但是事件驱动在不同系统中实现不一样，所以一般都会有一层抽象层抹平这个差异。这里以 Linux 的 epoll 为例子。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 创建一个 epoll 实例</span>
int epoll_fd = <span class="hljs-built_in">epoll_create</span>();  
<span class="hljs-comment">/* 
    在 epoll 给某个文件描述符注册感兴趣的事件，这里是监听的 socket，注册可读事件，即连接到来 
    event = { 
        event: 可读 
        fd： 监听 socket 
        // 一些上下文 
    } 
*/</span>  
<span class="hljs-built_in">epoll_ctl</span>(epoll_fd , EPOLL_CTL_ADD , socket, event);  
<span class="hljs-built_in">while</span>(<span class="hljs-number">1</span>) {  
    <span class="hljs-comment">// 阻塞等待事件就绪，events 保存就绪事件的信息，total 是个数  </span>
    int total= <span class="hljs-built_in">epoll_wait</span>(epoll_fd , 保存就绪事件的结构events, 事件个数, timeout);  
    for (let i = <span class="hljs-number">0</span>; i &#x3C; total; i++) {  
        if (events[fd] === 监听 socket) {  
            int client_fd = <span class="hljs-built_in">accpet</span>(socket);  
            <span class="hljs-comment">// 把新的 socket 也注册到 epoll，等待可读，即可读取客户端数据  </span>
            <span class="hljs-built_in">epoll_ctl</span>(epoll_fd , EPOLL_CTL_ADD , client_fd, event);  
        } else {  
            <span class="hljs-comment">//  从events[i] 中拿到一些上下文，执行相应的回调  </span>
        }  
    }  
}  
</code></pre>
<p>事件驱动模式的处理流程为服务器注册文件描述符和事件到 epoll 中，然后 epoll 开始阻塞，当有事件触发时 epoll 就会返回哪些 fd 的哪些事件触发了，接着服务器遍历就绪事件并执行对应的回调，在回调里可以再次注册 / 删除事件，就这样不断驱动着进程的运行。</p>
<p>epoll 的原理其实也类似事件驱动，它底层维护用户注册的事件和文件描述符，本身也会在文件描述符对应的文件 / socket / 管道处注册一个回调，等被通知有事件发生的时候，就会把 fd 和事件返回给用户，大致原理如下。</p>
<pre><code class="hljs language-csharp"><span class="hljs-function">function <span class="hljs-title">epoll_wait</span>()</span> {  
    <span class="hljs-keyword">for</span> 事件个数  
        <span class="hljs-comment">// 调用文件系统的函数判断  </span>
        <span class="hljs-keyword">if</span> (事件 [i] 中对应的文件描述符中有某个用户感兴趣的事件发生 ？) {  
            插入就绪事件队列  
        } <span class="hljs-keyword">else</span> {  
            <span class="hljs-comment">/*
                在事件 [i] 中的文件描述符所对应的文件 / socke / 管道等资源中注册回调。
                感兴趣的事件触发后回调 epoll，回调 epoll 后，epoll 把该 event[i] 插入
                就绪事件队列返回给用户  
            */</span>
        }  
}  
</code></pre>
<h2>SO_REUSEPORT 端口复用</h2>
<p>前面我们主要介绍了 3 种连接处理方式：</p>
<ol>
<li>单进程串行处理；</li>
<li>主进程接收连接，分发给子进程处理；</li>
<li>主进程管理子进程，子进程共同处理连接。</li>
</ol>
<p>从串行处理到多进程 / 多线程模式，在处理连接上有了很大的改进，但依然存在一些问题。2 中的问题是，虽然有多个子进程处理请求，但只有一个进程接收请求，这远远不够。</p>
<p>3 中的问题是，多个子进程虽然可以同时 accept，但也会导致惊群问题。而且，被唤醒处理连接的进程应该处理多少个连接也是一个问题，比如有 10 个连接，进程 1 被唤醒后是全部处理，还是只处理一个然后把剩下的留给其它进程处理呢？即使新版的内核已经解决了惊群问题，但是被唤醒的进程应该处理多少个连接的问题依然存在，所以<strong>如何接收请求和分发请求</strong>是两个可以改进的地方。</p>
<p>新版 Linux 支持 SO_REUSEPORT 特性后，使得处理请求的模式有了很大的改善。 SO_REUSEPORT 之前，一个 socket 是无法绑定到同一个地址的，通常的做法是主进程 bind 后 fork 子进程，然后子进程 listen，但共享的是同一个 socket。SO_REUSEPORT 特性支持多个 socket 绑定到同一个地址，当连接到来时，操作系统会根据地址信息找到一组 socket，然后根据策略选择一个 socket 并唤醒阻塞在该 socket 的进程。这样之前多进程共享 socket 的模式下，被唤醒的进程应该处理多少个请求的问题也解决了，因为 SO_REUSEPORT 模式中，每个进程一个 socket，对应一个请求队列，内核会把请求负载均衡地分发到各个进程中，被 socket 唤醒的进程只处理自己的监听 socket 下的连接就行，架构如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2d9cc7cfc70414e8fcc324012f32524~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这种模式在底层解决了多进程请求分发的问题，提高了处理请求的效率同时实现了负载均衡。</p>
<p>以上是服务器处理请求的架构演变，服务器作为对性能要求极高的软件，在技术演变的过程中，不仅应用层做了很多改进，操作系统内核层面也做了很多改进，这些也是 Node.js Cluster 模块中使用到的技术。</p>
<h1>Node.js 中的连接处理</h1>
<p>接下来，我们就来看看 Node.js 是如何处理连接的。首先看一下 Cluster 模块的一个使用例子。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">cluster</span> = require(<span class="hljs-string">'cluster'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">http</span> = require(<span class="hljs-string">'http'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">numCPUs</span> = require(<span class="hljs-string">'os'</span>).cpus().length<span class="hljs-comment">;  </span>
  
if (cluster.isMaster) {  
  for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; numCPUs; i++) {  </span>
    cluster.fork()<span class="hljs-comment">;  </span>
  }  
} else {  
  http.createServer((req, res) => {  
    res.writeHead(200)<span class="hljs-comment">;  </span>
    res.end('hello world\n')<span class="hljs-comment">;  </span>
  }).listen(8888)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>以上代码在第一次执行的时候，cluster.isMaster 为 true，说明是主进程，然后通过 fork 调用创建一个子进程，在子进程里同样执行以上代码，但是 cluster.isMaster 为 false，从而执行了 else 的逻辑。我们看到每个子进程都会监听 8888 这个端口但是又不会引起 EADDRINUSE 错误，为什么呢？</p>
<h2>主进程初始化</h2>
<p>我们先看主进程 require('cluster') 的时候，Node.js 是怎么处理的。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">childOrMaster</span> = <span class="hljs-string">'NODE_UNIQUE_ID'</span> in process.env ? <span class="hljs-string">'child'</span> : <span class="hljs-string">'master'</span><span class="hljs-comment">;  </span>
<span class="hljs-attr">module.exports</span> = require(`internal/cluster/<span class="hljs-variable">${childOrMaster}</span>`)  
</code></pre>
<p>从代码中可以看到，Node.js 会根据环境变量 NODE_UNIQUE_ID 的值加载不同的模块。因为主进程中不存在 NODE_UNIQUE_ID，所以会加载 master 模块。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">cluster.isWorker</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;  </span>
<span class="hljs-attr">cluster.isMaster</span> = <span class="hljs-literal">true</span><span class="hljs-comment">; </span>
// 调度策略  
<span class="hljs-attr">cluster.SCHED_NONE</span> = SCHED_NONE<span class="hljs-comment">;    </span>
<span class="hljs-attr">cluster.SCHED_RR</span> = SCHED_RR<span class="hljs-comment">;     </span>
// 调度策略的选择   
let <span class="hljs-attr">schedulingPolicy</span> = {  
  'none': SCHED_NONE,  
  'rr': SCHED_RR  
}<span class="hljs-section">[process.env.NODE_CLUSTER_SCHED_POLICY]</span><span class="hljs-comment">;  </span>

<span class="hljs-attr">cluster.schedulingPolicy</span> = schedulingPolicy<span class="hljs-comment">;  </span>
// 创建子进程函数  
<span class="hljs-attr">cluster.fork</span> = function(env) {  
  // 参数处理
  cluster.setupMaster()<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">id</span> = ++ids<span class="hljs-comment">;  </span>
  // 设置环境变量 NODE_UNIQUE_ID 到子进程的环境变量中
  const <span class="hljs-attr">workerEnv</span> = { ...process.env, ...env, NODE_UNIQUE_ID: `<span class="hljs-variable">${id}</span>` }<span class="hljs-comment">;</span>
  // 调用 child_process 模块的 fork 创建子进程
  const <span class="hljs-attr">workerProcess</span> = fork(cluster.settings.exec, cluster.settings.args, {
    env: workerEnv,
    // ...
  })<span class="hljs-comment">;</span>
  // 一个 Worker 表示一个子进程
  const <span class="hljs-attr">worker</span> = new Worker({  
    id: id,  
    process: workerProcess  
  })<span class="hljs-comment">;  </span>
  // 接收子进程的消息
  worker.process.on('internalMessage', internal(worker, onmessage))<span class="hljs-comment">;  </span>
  process.nextTick(emitForkNT, worker)<span class="hljs-comment">;  </span>
  cluster.workers<span class="hljs-section">[worker.id]</span> = worker<span class="hljs-comment">;  </span>
  return worker<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;        </span>
</code></pre>
<p>主进程的逻辑如下。</p>
<ol>
<li>选择工作模式，Node.js 提供的工作模式有轮询和共享两种工作模式。</li>
<li>封装了一个 fork 函数，cluster.fork 是对 child_process 模块 fork 的封装，用户每次执行 cluster.fork 时，就会新建一个子进程，并且传递一个 NODE_UNIQUE_ID 环境变量给子进程，这样子进程加载 cluster 模块时就会加载到 child 模块。</li>
<li>监听 internalMessage 事件接收子进程的消息，这个消息包括子进程主动发送给父进程的，和父进程主动发送给子进程然后子进程回复的，来看看 internalMessage 事件处理函数和发送数据的逻辑。</li>
</ol>
<pre><code class="hljs language-ini">const <span class="hljs-attr">callbacks</span> = new Map()<span class="hljs-comment">;  </span>
let <span class="hljs-attr">seq</span> = <span class="hljs-number">0</span><span class="hljs-comment">;  </span>

// 发送消息给父/子进程
function sendHelper(proc, message, handle, cb) {
  <span class="hljs-attr">message</span> = { cmd: <span class="hljs-string">'NODE_CLUSTER'</span>, ...message, seq }<span class="hljs-comment">;</span>
  // 设置回调
  if (typeof <span class="hljs-attr">cb</span> === <span class="hljs-string">'function'</span>)
    callbacks.set(seq, cb)<span class="hljs-comment">;</span>

  seq += 1<span class="hljs-comment">;</span>
  return proc.send(message, handle)<span class="hljs-comment">;</span>
}

// 接收父/子进程的消息
// worker 表示子进程，即和哪个子进程通信，cb 是 onmessage
function internal(worker, cb) {  
  return function onInternalMessage(message, handle) {  
    // 只处理 NODE_CLUSTER 命令的消息
    if (message.cmd !== 'NODE_CLUSTER')  
      return<span class="hljs-comment">;  </span>
  
    let <span class="hljs-attr">fn</span> = cb<span class="hljs-comment">;  </span>
    // 有 ack 字段说明是父进程发送消息返回的 ack，比如发送连接给子进程，处理函数 ack 对应的 callback
    // 否则说明是子进程请求父进程，这时候处理函数为 onmessage
    if (message.ack !== undefined) {  
      const <span class="hljs-attr">callback</span> = callbacks.get(message.ack)<span class="hljs-comment">;  </span>
  
      if (callback !== undefined) {  
        <span class="hljs-attr">fn</span> = callback<span class="hljs-comment">;  </span>
        callbacks.delete(message.ack)<span class="hljs-comment">;  </span>
      }  
    }  
    
    fn.apply(worker, arguments)<span class="hljs-comment">;  </span>
  }<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>sendHelper 和 internal 函数是对异步消息通信做了一层封装，因为进程间通信是异步的，当我们发送多个消息后，如果收到一个回复，我们无法辨别出该回复是针对哪一个请求的，Node.js 通过 seq 的方式对每一个请求和响应做了一个编号，从而区分响应对应的请求。如果是子进程主动发送给父进程的请求，则不存在回调，这时候会执行 onmessage 处理，看一下 onmessage 的实现。</p>
<pre><code class="hljs language-ini">function onmessage(message, handle) {  
  const <span class="hljs-attr">worker</span> = this<span class="hljs-comment">;  </span>
  if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'online'</span>)  
    online(worker)<span class="hljs-comment">;  </span>
  else if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'queryServer'</span>)  
    queryServer(worker, message)<span class="hljs-comment">;  </span>
  else if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'listening'</span>)  
    listening(worker, message)<span class="hljs-comment">;  </span>
  else if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'exitedAfterDisconnect'</span>)  
    exitedAfterDisconnect(worker, message)<span class="hljs-comment">;  </span>
  else if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'close'</span>)  
    close(worker, message)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>onmessage 根据不同的消息类型进行相应的处理，后面我们再具体分析。至此，主进程的逻辑就分析完了。</p>
<h2>子进程初始化</h2>
<p>接着看一下子进程的逻辑。当子进程启动时，会在 initializeClusterIPC 中进行相关处理，逻辑如下。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function">function <span class="hljs-title">initializeClusterIPC</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (process.argv[<span class="hljs-number">1</span>] &#x26;&#x26; process.env.NODE_UNIQUE_ID) {
    <span class="hljs-type">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cluster'</span>);
    cluster._setupWorker();
    <span class="hljs-keyword">delete</span> process.env.NODE_UNIQUE_ID;
  }
}
</code></pre>
<p>initializeClusterIPC 中调用了 _setupWorker 初始化。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">cluster.isWorker</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;  </span>
<span class="hljs-attr">cluster.isMaster</span> = <span class="hljs-literal">false</span><span class="hljs-comment">; </span>
<span class="hljs-attr">cluster._setupWorker</span> = function() {  
  // worker 代表子进程自己
  const <span class="hljs-attr">worker</span> = new Worker({  
    id: +process.env.NODE_UNIQUE_ID | 0,  
    process: process,  
    state: 'online'  
  })<span class="hljs-comment">;  </span>
  
  <span class="hljs-attr">cluster.worker</span> = worker<span class="hljs-comment">;  </span>
  // 处理和父进程的通信
  process.on('internalMessage', internal(worker, onmessage))<span class="hljs-comment">;  </span>
  // 通知主进程子进程启动成功  
  send({ act: 'online' })<span class="hljs-comment">; </span>
   
  // 处理主进程发过来的消息
  function onmessage(message, handle) {  
    // 新连接到来
    if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'newconn'</span>)  
      onconnection(message, handle)<span class="hljs-comment">;  </span>
    else if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'disconnect'</span>)  
      _disconnect.call(worker, true)<span class="hljs-comment">;  </span>
  }  
}<span class="hljs-comment">;  </span>
</code></pre>
<p>_setupWorker 中和父进程一样，也监听了 internalMessage 事件，然后通知父进程自己启动成功了。</p>
<h2>net.createServer 的处理</h2>
<p>主进程和子进程执行完初始化代码后，子进程开始执行业务代码 http.createServer，http.createServer 最后会调用 net 模块的 listen，然后调用 listenIncluster。我们从该函数开始分析。</p>
<pre><code class="hljs language-ini">function listenIncluster(server, address, port, addressType,  
                         backlog, fd, exclusive, flags) {  
    
  const <span class="hljs-attr">serverQuery</span> = {  
    address: address,  
    port: port,  
    addressType: addressType,  
    fd: fd,  
    flags,  
  }<span class="hljs-comment">;  </span>
  
  cluster._getServer(server, serverQuery, listenOnMasterHandle)<span class="hljs-comment">;    </span>
  function listenOnMasterHandle(err, handle) {  
    <span class="hljs-attr">server._handle</span> = handle<span class="hljs-comment">;  </span>
    server._listen2(address,
                    port, 
                    addressType, 
                    backlog, 
                    fd, 
                    flags)<span class="hljs-comment">;  </span>
  }  
}  
</code></pre>
<p>listenIncluster 函数会调用子进程 cluster 模块的 _getServer 函数。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">cluster._getServer</span> = function(obj, options, cb) {  
  let <span class="hljs-attr">address</span> = options.address<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">message</span> = {  
    act: 'queryServer',  
    index,  
    data: null,  
    ...options  
  }<span class="hljs-comment">;  </span>
  
  <span class="hljs-attr">message.address</span> = address<span class="hljs-comment">;  </span>
  // 给主进程发送消息  
  send(message, (reply, handle) => {  
    // 根据不同模式做处理
    if (handle)  
      shared(reply, handle, indexesKey, cb)<span class="hljs-comment">;  </span>
    else  
      rr(reply, indexesKey, cb)<span class="hljs-comment">;             </span>
  })<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
</code></pre>
<p>从上面代码中可以看到，_getServer 函数会给主进程发送一个 queryServer 的请求并设置了一个回调函数。</p>
<p>看一下主进程是如何处理 queryServer 请求的。</p>
<pre><code class="hljs language-ini">function queryServer(worker, message) {  
  const <span class="hljs-attr">key</span> = `<span class="hljs-variable">${message.address}</span>:<span class="hljs-variable">${message.port}</span>:<span class="hljs-variable">${message.addressType}</span>:<span class="hljs-variable">${message.fd}</span>:<span class="hljs-variable">${message.index}</span>`<span class="hljs-comment">;  </span>
  let <span class="hljs-attr">handle</span> = handles.get(key)<span class="hljs-comment">;  </span>
  
  if (<span class="hljs-attr">handle</span> === undefined) {  
    let <span class="hljs-attr">address</span> = message.address<span class="hljs-comment">;  </span>
    let <span class="hljs-attr">constructor</span> = RoundRobinHandle<span class="hljs-comment">;  </span>
    // 根据策略选取不同的构造函数，UDP 只能使用共享模式，因为 UDP 不是基于连接的，没有连接可以分发  
    if (schedulingPolicy !== SCHED_RR ||  
        <span class="hljs-attr">message.addressType</span> === <span class="hljs-string">'udp4'</span> ||  
        <span class="hljs-attr">message.addressType</span> === <span class="hljs-string">'udp6'</span>) {  
      <span class="hljs-attr">constructor</span> = SharedHandle<span class="hljs-comment">;  </span>
    }  
  
    <span class="hljs-attr">handle</span> = new constructor(key,  
                             address,  
                             message.port,  
                             message.addressType,  
                             message.fd,  
                             message.flags)<span class="hljs-comment">;  </span>
    handles.set(key, handle)<span class="hljs-comment">;  </span>
  }  
  handle.add(worker, (errno, reply, handle) => {  
    const { data } = handles.get(key)<span class="hljs-comment">;  </span>
    // 返回结果给子进程
    send(worker, {  
      errno,  
      key,  
      ack: message.seq,  
      data,  
      ...reply  
    }, handle)<span class="hljs-comment">;  </span>
  })<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>queryServer 首先根据调度策略选择构造函数并创建一个对象，然后执行该对象的 add 方法并且传入一个回调。下面我们看看不同策略下的处理。</p>
<h3>共享模式</h3>
<p>首先看看共享模式的实现，共享模式对应前面分析的主进程管理子进程，多个子进程共同 accept 处理连接这种方式。</p>
<pre><code class="hljs language-ini">function SharedHandle(key, address, port, addressType, fd, flags) {  
  <span class="hljs-attr">this.key</span> = key<span class="hljs-comment">;  </span>
  <span class="hljs-attr">this.workers</span> = []<span class="hljs-comment">;  </span>
  <span class="hljs-attr">this.handle</span> = null<span class="hljs-comment">;  </span>
  <span class="hljs-attr">this.errno</span> = <span class="hljs-number">0</span><span class="hljs-comment">;  </span>
  
  let rval<span class="hljs-comment">;  </span>
  if (<span class="hljs-attr">addressType</span> === <span class="hljs-string">'udp4'</span> || addressType === <span class="hljs-string">'udp6'</span>)  
    <span class="hljs-attr">rval</span> = dgram._createSocketHandle(address, 
                                     port, 
                                     addressType, 
                                     fd, 
                                     flags)<span class="hljs-comment">;  </span>
  else  
    <span class="hljs-attr">rval</span> = net._createServerHandle(address,  
                                   port, 
                                   addressType, 
                                   fd, 
                                   flags)<span class="hljs-comment">;  </span>
  
  if (typeof <span class="hljs-attr">rval</span> === <span class="hljs-string">'number'</span>)  
    <span class="hljs-attr">this.errno</span> = rval<span class="hljs-comment">;  </span>
  else  
    <span class="hljs-attr">this.handle</span> = rval<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>SharedHandle 是共享模式，即主进程创建好 handle，交给子进程处理，接着看它的 add 函数。</p>
<pre><code class="hljs language-javascript"><span class="hljs-title class_">SharedHandle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">worker, send</span>) {  
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">workers</span>.<span class="hljs-title function_">push</span>(worker);  
  <span class="hljs-title function_">send</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">errno</span>, <span class="hljs-literal">null</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handle</span>);  
};  
</code></pre>
<p>SharedHandle 的 add 把 SharedHandle 中创建的 handle 返回给子进程。</p>
<p>接着看子进程拿到 handle 后的处理。</p>
<pre><code class="hljs language-ini">function shared(message, handle, indexesKey, cb) {  
  const <span class="hljs-attr">key</span> = message.key<span class="hljs-comment">;  </span>
    
  const <span class="hljs-attr">close</span> = handle.close<span class="hljs-comment">;  </span>
  
  <span class="hljs-attr">handle.close</span> = function() {  
    send({ act: 'close', key })<span class="hljs-comment">;  </span>
    handles.delete(key)<span class="hljs-comment">;  </span>
    indexes.delete(indexesKey)<span class="hljs-comment">;  </span>
    // 因为是共享的，可以直接 close 掉而不会影响其它子进程等
    return close.apply(handle, arguments)<span class="hljs-comment">;  </span>
  }<span class="hljs-comment">;  </span>
  handles.set(key, handle)<span class="hljs-comment">; </span>
  // 执行 net 模块的回调 
  cb(message.errno, handle)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>shared 函数把接收到的 handle 再回传到调用方，即 net 模块的 listenOnMasterHandle 函数，listenOnMasterHandle 会执行 listen 开始监听地址。</p>
<pre><code class="hljs language-kotlin">function setupListenHandle(address, port, addressType, backlog, fd, flags) {
  <span class="hljs-comment">// this._handle 即主进程返回的 handle</span>
  <span class="hljs-comment">// 连接到来时的回调</span>
  <span class="hljs-keyword">this</span>._handle.onconnection = onconnection;
  <span class="hljs-keyword">this</span>._handle[owner_symbol] = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">this</span>._handle.listen(backlog || <span class="hljs-number">511</span>);
}
</code></pre>
<p>这样多个子进程就成功启动了服务器，但是有连接到来时，系统只会有一个进程拿到该连接。所以所有子进程存在竞争关系导致负载不均衡，这取决于操作系统的实现。共享模式的核心逻辑是主进程在 _createServerHandle 创建 handle 时执行 bind 绑定了地址（但没有 listen），然后通过文件描述符传递的方式传给子进程，子进程执行 listen 的时候就不会报端口已经被监听的错误了，因为端口被监听的错误是执行 bind 的时候返回的。逻辑如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57d5feca53804d4397a7f0cfb077a002~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>看一个共享模式的使用例子。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">cluster</span> = require(<span class="hljs-string">'cluster'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">os</span> = require(<span class="hljs-string">'os'</span>)<span class="hljs-comment">;</span>
// 设置为共享模式
<span class="hljs-attr">cluster.schedulingPolicy</span> = cluster.SCHED_NONE<span class="hljs-comment">;</span>

// 主进程 fork 多个子进程
if (cluster.isMaster) {
  // 通常根据 CPU 核数创建多个进程 os.cpus().length
  for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; 3; i++) {</span>
    cluster.fork()<span class="hljs-comment">;</span>
  }
} else { // 子进程创建服务器
  const <span class="hljs-attr">net</span> = require(<span class="hljs-string">'net'</span>)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">server</span> = net.createServer((socket) => {
    socket.destroy()<span class="hljs-comment">;</span>
    console.log(`handled by process: ${process.pid}`)<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;</span>
  server.listen(8080)<span class="hljs-comment">;</span>
}
</code></pre>
<p>然后查看一下哪个进程监听了端口 8080（lsof -i:8080）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b34868540a6141f980e7776bd2c1bde0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>可以看到多个进程都监听了这个端口，然后发起多个请求看看处理情况。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d70e23340694b40934659d9550845ab~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>输出是不确定且无规律的，取决于哪个进程成功抢到了这个请求。</p>
<h3>轮询模式</h3>
<p>接着看轮询模式，轮询模式对应前面的主进程 accept，分发给多个子进程处理这种方式。</p>
<pre><code class="hljs language-kotlin">function RoundRobinHandle(key, address, port, addressType, fd, flags) {  
  <span class="hljs-keyword">this</span>.key = key;  
  <span class="hljs-keyword">this</span>.all = new Map();  
  <span class="hljs-keyword">this</span>.free = [];  
  <span class="hljs-keyword">this</span>.handles = [];  
  <span class="hljs-keyword">this</span>.handle = <span class="hljs-literal">null</span>;  
  <span class="hljs-keyword">this</span>.server = net.createServer(assert.fail);  
  
  <span class="hljs-keyword">if</span> (fd >= <span class="hljs-number">0</span>)  
    <span class="hljs-keyword">this</span>.server.listen({ fd });  
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (port >= <span class="hljs-number">0</span>) {  
    <span class="hljs-keyword">this</span>.server.listen({  
      port,  
      host: address,  
      ipv6Only: <span class="hljs-built_in">Boolean</span>(flags &#x26; constants.UV_TCP_IPV6ONLY),  
    });  
  } <span class="hljs-keyword">else</span>  
    <span class="hljs-keyword">this</span>.server.listen(address);  <span class="hljs-comment">// UNIX socket path.  </span>
  <span class="hljs-comment">// 监听成功后，注册 onconnection 回调，有连接到来时执行  </span>
  <span class="hljs-keyword">this</span>.server.once(<span class="hljs-string">'listening'</span>, () => {  
    <span class="hljs-keyword">this</span>.handle = <span class="hljs-keyword">this</span>.server._handle;  
    <span class="hljs-keyword">this</span>.handle.onconnection = (err, handle) => <span class="hljs-keyword">this</span>.distribute(err, handle);  
    <span class="hljs-keyword">this</span>.server._handle = <span class="hljs-literal">null</span>;  
    <span class="hljs-keyword">this</span>.server = <span class="hljs-literal">null</span>;  
  });  
}  
</code></pre>
<p>因为 RoundRobinHandle的 工作模式是主进程负责监听，收到连接后分发给子进程，所以 RoundRobinHandle 中直接启动了一个服务器，当收到连接时执行 this.distribute 进行分发。接着看一下RoundRobinHandle 的 add 函数。</p>
<pre><code class="hljs language-kotlin">RoundRobinHandle.prototype.add = function(worker, send) {  
   <span class="hljs-keyword">this</span>.all.<span class="hljs-keyword">set</span>(worker.id, worker);  
  
   <span class="hljs-keyword">const</span> done = () => {  
    <span class="hljs-comment">// send 的第三个参数是 null，说明没有 handle</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.handle.getsockname) {  
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">out</span> = {};  
      <span class="hljs-keyword">this</span>.handle.getsockname(<span class="hljs-keyword">out</span>);  
      send(<span class="hljs-literal">null</span>, { sockname: <span class="hljs-keyword">out</span> }, <span class="hljs-literal">null</span>);  
    } <span class="hljs-keyword">else</span> {  
      send(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);  <span class="hljs-comment">// UNIX socket.  </span>
    }  
  
    <span class="hljs-keyword">this</span>.handoff(worker);   
  };  
  <span class="hljs-comment">// 否则等待 listen 成功后执行回调  </span>
  <span class="hljs-keyword">this</span>.server.once(<span class="hljs-string">'listening'</span>, done);  
};  
</code></pre>
<p>RoundRobinHandle 会在 listen 成功后执行回调。我们回顾一下执行 add 函数时的回调。</p>
<pre><code class="hljs language-vbnet">handle.add(worker, (errno, reply, handle) => {  
  <span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">handles</span>.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">key</span>);  
  send(worker, {  
    errno,  
    <span class="hljs-keyword">key</span>,  
    ack: message.seq,  
    data,  
    ...reply  
  }, handle);  
});  
</code></pre>
<p>回调函数会把 handle 等信息返回给子进程。但是在 RoundRobinHandle 和 SharedHandle 中返回的 handle 是不一样的，分别是 null 和 net.createServer 实例，因为前者不需要启动一个服务器，它只需要接收来自父进程传递的连接就行。</p>
<p>接着我们回到子进程的上下文，看子进程是如何处理的，刚才我们讲过，不同的调度策略，返回的 handle 是不一样的，我们看轮询模式下的处理。</p>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">rr</span>(message, indexesKey, cb) { 
   let key = message<span class="hljs-selector-class">.key</span>;  
   <span class="hljs-comment">// 不需要 listen，空操作</span>
   function <span class="hljs-built_in">listen</span>(backlog) {  
       return <span class="hljs-number">0</span>;  
   }  
  
   function <span class="hljs-built_in">close</span>() {
       <span class="hljs-comment">// 因为 handle 是共享的，所以无法直接关闭，需要告诉父进程，引用数减一</span>
       if (key === undefined)
         return;
    
       <span class="hljs-built_in">send</span>({ act: 'close', key });
       handles<span class="hljs-selector-class">.delete</span>(key);
       indexes<span class="hljs-selector-class">.delete</span>(indexesKey);
       key = undefined;
  } 
  <span class="hljs-comment">// 构造假的 handle 给调用方</span>
  const handle = { close, listen, ref: noop, unref: noop };  
  
  handles<span class="hljs-selector-class">.set</span>(key, handle); 
  <span class="hljs-comment">// 执行 net 模块的回调 </span>
  <span class="hljs-built_in">cb</span>(<span class="hljs-number">0</span>, handle);  
}  
</code></pre>
<p>round-robin 模式下，Node.js 会构造一个假的 handle 返回给 net 模块，因为调用方会调用 handle 的这些函数。当有请求到来时，round-bobin 模块会执行 distribute 分发连接给子进程。</p>
<pre><code class="hljs language-kotlin">RoundRobinHandle.prototype.distribute = function(err, handle) {  
  <span class="hljs-comment">// 首先保存 handle 到队列  </span>
  <span class="hljs-keyword">this</span>.handles.push(handle);  
  <span class="hljs-comment">// 从空闲队列获取一个子进程  </span>
  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">this</span>.free.shift();  
  <span class="hljs-comment">// 分发  </span>
  <span class="hljs-keyword">if</span> (worker)  
    <span class="hljs-keyword">this</span>.handoff(worker);  
};  
  
RoundRobinHandle.prototype.handoff = function(worker) {  
  <span class="hljs-comment">// 拿到一个 handle  </span>
  <span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">this</span>.handles.shift();  
  <span class="hljs-comment">// 没有 handle，则子进程重新入队  </span>
  <span class="hljs-keyword">if</span> (handle === undefined) {  
    <span class="hljs-keyword">this</span>.free.push(worker);
    <span class="hljs-keyword">return</span>;  
  }  
  <span class="hljs-comment">// 通知子进程有新连接  </span>
  <span class="hljs-keyword">const</span> message = { act: <span class="hljs-string">'newconn'</span>, key: <span class="hljs-keyword">this</span>.key };  
  
  sendHelper(worker.process, message, handle, (reply) => {  
    <span class="hljs-comment">// 接收成功  </span>
    <span class="hljs-keyword">if</span> (reply.accepted)  
      handle.close();  
    <span class="hljs-keyword">else</span>  
      <span class="hljs-comment">// 结束失败，则重新分发  </span>
      <span class="hljs-keyword">this</span>.distribute(<span class="hljs-number">0</span>, handle);
    <span class="hljs-comment">// 继续分发</span>
    <span class="hljs-keyword">this</span>.handoff(worker);  
  });  
};  
</code></pre>
<p>可以看到 Node.js 没用按照严格的轮询，而是哪个进程接收连接快，就继续给它分发。接着看一下子进程是怎么处理该请求的。</p>
<pre><code class="hljs language-ini">function onmessage(message, handle) {  
    if (<span class="hljs-attr">message.act</span> === <span class="hljs-string">'newconn'</span>)  
      onconnection(message, handle)<span class="hljs-comment">;  </span>
}  
  
function onconnection(message, handle) {  
  const <span class="hljs-attr">key</span> = message.key<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">server</span> = handles.get(key)<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">accepted</span> = server !== undefined<span class="hljs-comment">;  </span>
  // 回复接收成功  
  send({ ack: message.seq, accepted })<span class="hljs-comment">;  </span>
    
  if (accepted)  
     // 在 net 模块设置
    server.onconnection(0, handle)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>最终执行 server.onconnection 进行连接的处理。逻辑如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adad220943fa43f78fd2d91a2f2fe19b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>看一下轮询模式的使用例子。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">cluster</span> = require(<span class="hljs-string">'cluster'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">os</span> = require(<span class="hljs-string">'os'</span>)<span class="hljs-comment">;</span>
// 设置为轮询模式
<span class="hljs-attr">cluster.schedulingPolicy</span> = cluster.SCHED_RR<span class="hljs-comment">;</span>

// 主进程 fork 多个子进程
if (cluster.isMaster) {
  // 通常根据 CPU 核数创建多个进程 os.cpus().length
  for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; 3; i++) {</span>
    cluster.fork()<span class="hljs-comment">;</span>
  }
} else { // 子进程创建服务器
  const <span class="hljs-attr">net</span> = require(<span class="hljs-string">'net'</span>)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">server</span> = net.createServer((socket) => {
    socket.destroy()<span class="hljs-comment">;</span>
    console.log(`handled by process: ${process.pid}`)<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;</span>
  server.listen(8080)<span class="hljs-comment">;</span>
}
</code></pre>
<p>执行后看一下哪个进程监听了 8080 端口。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89617f2c24254de9b8abffab81cea0f7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>可以看到只有一个进程监听了这个端口，那就是主进程，当主进程收到连接后会通过文件描述符的方式分发给子进程。下面是输出。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/956cdf7250bd46b698ddaca87734e165~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>Node.js 会尽可能快地进行轮询分发，而不是严格地轮询分发，所以输出不一定是有序的。</p>
<h1>实现自己的 Cluster 模块</h1>
<p>了解了Cluster 模块的原理后，我们自己来实现一个 Cluster 模块。</p>
<h2>轮询模式</h2>
<p>首先创建一个在 parent.js 文件，该文件在主进程中执行。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">constchildProcess</span> = require(<span class="hljs-string">'child_process'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">net</span> = require(<span class="hljs-string">'net'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">workers</span> = []<span class="hljs-comment">;  </span>
const <span class="hljs-attr">workerNum</span> = <span class="hljs-number">10</span><span class="hljs-comment">;  </span>
let <span class="hljs-attr">index</span> = <span class="hljs-number">0</span><span class="hljs-comment">;  </span>
for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; workerNum; i++) {  </span>
  workers.push(childProcess.fork('child.js', {env: {index: i}}))<span class="hljs-comment">;</span>
}  
  
const <span class="hljs-attr">server</span> = net.createServer((client) => {  
    workers<span class="hljs-section">[index]</span>.send(null, client)<span class="hljs-comment">;  </span>
    console.log('dispatch to', index)<span class="hljs-comment">;  </span>
    <span class="hljs-attr">index</span> = (index + <span class="hljs-number">1</span>) % workerNum<span class="hljs-comment">;  </span>
})<span class="hljs-comment">;  </span>
server.listen(11111)<span class="hljs-comment">;  </span>
</code></pre>
<p>主进程负责监听请求，主进程收到请求后，按照一定的算法把请求通过文件描述符的方式传给worker 进程。接着再创建一个 child.js 文件，该文件在 worker 进程中执行。</p>
<pre><code class="hljs language-javascript">process.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message, client</span>) =></span> {  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'receive connection from master'</span>);  
});  
</code></pre>
<p>worker 进程通过监听 message 事件接收来自父进程发送过来的连接，然后处理连接。这里没有实现子进程回复确认收到的逻辑，但这是必要的，因为当子进程接收连接成功后，主进程需要把本进程内连接对应的 fd 关闭，否则会造成 fd 泄露，这个关闭的时机就是子进程回复成功接收到连接时。</p>
<h2>共享模式</h2>
<p>首先创建一个在 parent.js 文件，该文件在主进程中执行。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">childProcess</span> = require(<span class="hljs-string">'child_process'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">net</span> = require(<span class="hljs-string">'net'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">workers</span> = []<span class="hljs-comment">;  </span>
const <span class="hljs-attr">workerNum</span> = <span class="hljs-number">10</span>    <span class="hljs-comment">;  </span>
const <span class="hljs-attr">handle</span> = net._createServerHandle(<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">11111</span>, <span class="hljs-number">4</span>)<span class="hljs-comment">;  </span>
  
for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; workerNum; i++) {  </span>
    const <span class="hljs-attr">worker</span> = childProcess.fork(<span class="hljs-string">'child.js'</span>, {env: {index: i}})<span class="hljs-comment">;  </span>
    workers.push(worker)<span class="hljs-comment">;  </span>
    worker.send(null ,handle)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>主进程负责绑定端口，把 handle 传给 worker 进程。接着再创建一个 child.js 文件，该文件在 worker 进程中执行。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);  
process.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message, handle</span>) =></span> {  
    net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">() =></span> {  
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">index</span>, <span class="hljs-string">'receive connection'</span>);  
    }).<span class="hljs-title function_">listen</span>({handle});  
});  
</code></pre>
<p>worker 进程各自执行 listen 监听 socket。当有连接到来时，操作系统会唤醒进程，先被调度的 worker 进程会处理该连接。</p>
<p><strong>实现共享模式的重点在于理解 EADDRINUSE 错误是怎么来的。</strong> 当一个进程执行 bind 的时候，如果其它进程也执行 bind 并且端口也一样，则操作系统会告诉我们端口已经被监听了（EADDRINUSE）。但是如果我们在子进程里不执行 bind 的话，就可以绕过这个限制。那么重点在于，<strong>如何在子进程中不执行bind，但是又可以绑定到同样的端口呢</strong>？实际上有 2 种方式。</p>
<p><strong>第</strong> <strong>1</strong> <strong>种是通过 fork。</strong> 我们知道 fork 的时候，子进程会继承主进程的文件描述符。所以首先在主进程中执行 bind 然后 fork 子进程，接着在子进程中执行 listen 就可以接收连接了。下面是使用 C 语言实现的例子。</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;unistd.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/types.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/socket.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;netinet/in.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;string.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/wait.h></span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>
{
    <span class="hljs-type">int</span> server_fd;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span>

    server_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);

    <span class="hljs-built_in">memset</span>(&#x26;server_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(<span class="hljs-number">1234</span>);

    bind(server_fd, (<span class="hljs-keyword">struct</span> sockaddr*)&#x26;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr));
    <span class="hljs-comment">// 创建多个子进程</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">3</span>; i++) {
        <span class="hljs-type">int</span> ret = fork();
        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 子进程</span>
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sub thread: %d\n"</span>, getpid());
            listen(server_fd, <span class="hljs-number">500</span>);
            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
                <span class="hljs-type">int</span> fd = accept(server_fd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d receive connection: %d\n"</span>, getpid(), fd);
                close(fd);
            }
            close(server_fd);
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"main thread: %d\n"</span>, getpid());
    waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
    close(server_fd);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>我们可以看到，编译执行后请求 1234 端口可以看到每次输出的 pid 是不一样的。</p>
<p><strong>第</strong> <strong>2</strong> <strong>种是通过文件描述符传递。</strong> 在这种方式中，我们首先可以创建一个 socket 并绑定到一个地址中，然后通过操作系统的文件描述符传递技术，把 socket 对应的 fd 发送到另一个进程中。通过这种方式，我们就绕过了 bind 同一个端口的问题。对于传递文件描述符，Node.js 中支持很多种方式。共享模式中的例子是创建了一个 socket 并通过 bind 绑定了地址，我们还可以执行 listen 使得主进程也可以处理连接。接下来我们看个例子。</p>
<p>首先在主进程中启动服务器，代码如下。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">childProcess</span> = require(<span class="hljs-string">'child_process'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">net</span> = require(<span class="hljs-string">'net'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">workers</span> = []<span class="hljs-comment">;  </span>
const <span class="hljs-attr">workerNum</span> = <span class="hljs-number">10</span><span class="hljs-comment">;  </span>
const <span class="hljs-attr">server</span> = net.createServer(() => {  
    console.log('master receive connection')<span class="hljs-comment">;  </span>
})  
server.listen(11111)<span class="hljs-comment">;  </span>
for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; workerNum; i++) {  </span>
    const <span class="hljs-attr">worker</span> = childProcess.fork(<span class="hljs-string">'child.js'</span>, {env: {index: i}})<span class="hljs-comment">;  </span>
    workers.push(worker)<span class="hljs-comment">;  </span>
    worker.send(null, server)<span class="hljs-comment">;  </span>
}  
     
</code></pre>
<p>主进程完成了 bind 和 listen，然后把 server 传递给子进程，子进程代码如下。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);  
process.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message, server</span>) =></span> {  
    server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-function">() =></span> {  
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">index</span>, <span class="hljs-string">'receive connection'</span>);  
    })  
});  
</code></pre>
<p>子进程通过监听 message 事件接收主进程传递过来的 server，然后监听该 server 的 connection 事件，这样子进程就可以接收连接了。在这种方式中，主进程和子进程都可以处理连接。</p>
<p>最后，我们写一个客户端测试，看一下请求是否可以被主进程和子进程同时处理。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">net</span> = require(<span class="hljs-string">'net'</span>)<span class="hljs-comment">;  </span>
for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; 50; i++) {  </span>
    net.connect({port: 11111})<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>执行上面的代码我们就可以看到主进程和子进程处理连接的情况。</p>
<h1>总结</h1>
<p>服务器知识并不是 Node.js 中独有的，而是现代服务器的通用技术，像是 Nginx、Redis 等优秀的服务器软件底层的基础也是基于这些技术发展而来的。</p>
<p>回顾服务器的发展，无论是服务器本身还是操作系统，在提升处理连接效率方面都做了非常多的努力和探索，在发展的过程中，经历了串行处理、多进程 / 多线程、事件驱动、端口复用等模式，还有现在 Go 语言的协程模式。目前大多数服务器软件使用的技术是事件驱动和端口复用，包括 Node.js、Nginx、Redis 等服务器软件。</p>
<p>有了这些基础，我们就可以很好地理解 Node.js 是如何基于服务器的基础技术实现自己的服务区架构的。Node.js 的服务器架构支持共享和轮询两种模式，前者是主进程负责管理子进程，子进程接收并处理连接，后者则是主进程接收连接再分发给子进程，前者的问题是惊群问题和负载不均衡，后者问题是父进程会成为整个系统的瓶颈，从中可以看出 Node.js 使用的是比较常用的模式，这个主要是因为底层的 Libuv 为了系统兼容性问题，没有支持 SO_REUSEPORT，所以 Node.js 中也没有支持 SO_REUSEPORT。</p>
<p>最后，我们也实现了一个自己的 Cluster 模块，并体验了一下文件描述符技术。希望经过这节课的学习，大家不仅知道 Node.js 服务器的原理，也会服务器技术本身有很多的了解和理解。</p></div>
</body></html>