<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Unix 域和文件描述符传递</h1>
<p>Unix 域是操作系统提供的一种IPC（进程间通信）方式，操作系统通常会提供很多种 IPC 方式，为什么我们要单独用一节课讲 Unix 域呢？因为相比其他 IPC 方式，Unix 域不仅支持传递普通的数据，还支持传递文件描述符，而传递文件描述符是操作系统提供的非常重要的技术。</p>
<p>在 Node.js 中，net、child_process 和 Cluster 模块都依赖 Unix 域的能力，所以这节课我们详细讲解 Unix 域相关的内容，包括操作系统中的 Unix 域、Libuv 中的 Unix 域和文件描述符传递技术。</p>
<h1>操作系统中的 Unix 域</h1>
<p>在操作系统中，Unix 域提供了 SOCK_STREAM、SOCK_DGRAM 和 SOCK_SEQPACKET 三种数据传输方式。</p>
<ul>
<li>SOCK_STREAM 表示是基于连接，按照字节流发送的。</li>
<li>SOCK_DGRAM 表示不是基于连接的，按照应用层传递的数据包直接发送。</li>
<li>SOCK_SEQPACKET 表示基于连接的，按照应用层传递的数据包直接发送（Node.js 只支持 SOCK_STREAM）。</li>
</ul>
<p>在使用上，Unix 域遵循网络编程的 API，但是和网络编程不一样，Unix 域没有端口和 IP 的概念，取而代之的是路径字符串，也就是说当我们选择通过连接的方式通信时，我们需要绑定 / 连接到一个路径中，并且需要对这个路径有一定的权限，下面我们看一个使用例子。</p>
<p>下面是创建一个 Unix 域服务器 unix_domain_server.c。</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/socket.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/types.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;string.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;unistd.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/un.h></span></span>

<span class="hljs-type">const</span> <span class="hljs-type">char</span>* SERVER_PATH = <span class="hljs-string">"server.sock"</span>;

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-comment">// 删除之前创建的 sock，如果有的话</span>
    unlink(SERVER_PATH);
    
    <span class="hljs-type">int</span> server_fd = socket(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>);
    
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">server_addr</span>;</span>
    server_addr.sun_family = AF_UNIX;
    <span class="hljs-built_in">memcpy</span>(server_addr.sun_path, SERVER_PATH, <span class="hljs-built_in">strlen</span>(SERVER_PATH));
    bind(server_fd, (<span class="hljs-keyword">struct</span> sockaddr *)&#x26;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr));
    listen(server_fd, <span class="hljs-number">512</span>);

    <span class="hljs-type">int</span> client_fd;
    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        client_fd = accept(server_fd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);
        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);
        read(client_fd, &#x26;buf, <span class="hljs-keyword">sizeof</span>(buf));
        close(client_fd);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"receive data: %s\n"</span>, buf);
    }
    close(server_fd);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>执行 gcc unix_domain_server.c -o server 编译代码并执行 ./server 启动服务器，然后再创建一个 Unix 域客户端 unix_domain_client.c。</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/socket.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/types.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;string.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;unistd.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/un.h></span></span>

<span class="hljs-type">const</span> <span class="hljs-type">char</span>* SERVER_PATH = <span class="hljs-string">"server.sock"</span>;

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-comment">// 申请 socket</span>
    <span class="hljs-type">int</span> sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>);
    
    <span class="hljs-comment">// 设置服务器地址</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">server_addr</span>;</span>
    server_addr.sun_family = AF_UNIX;
    <span class="hljs-built_in">memcpy</span>(server_addr.sun_path, SERVER_PATH, <span class="hljs-built_in">strlen</span>(SERVER_PATH));

    <span class="hljs-comment">// 连接到服务器</span>
    connect(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&#x26;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr));
    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* data = <span class="hljs-string">"hello"</span>;
    <span class="hljs-comment">// 发送数据</span>
    write(sockfd, data, <span class="hljs-built_in">strlen</span>(data));
    <span class="hljs-comment">// 关闭连接</span>
    close(sockfd);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}  
</code></pre>
<p>执行 gcc unix_domain_client.c -o client 编译并执行 ./client 启动客户端，这时候会看到服务器输出 receive data: hello。我们发现使用上和前面课程介绍的网络编程很像，这也是 Node.js net 模块的底层技术。</p>
<p>除了基于网络 API 外，Unix 还支持更简洁的使用方式，那就是通过 socketpair 同时创建一个 Unix 域客户端和服务器。</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;unistd.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;string.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/types.h></span>         </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/socket.h></span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> {
    <span class="hljs-type">int</span> pid;
    <span class="hljs-type">int</span> fds[<span class="hljs-number">2</span>];
    <span class="hljs-comment">// 创建一个 Unix 域客户端和服务器，fd 存在 fds 数组</span>
    socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, fds);
    <span class="hljs-comment">// 创建子进程</span>
    pid = fork();
    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) { 
        <span class="hljs-comment">// 关闭读端</span>
        close(fds[<span class="hljs-number">0</span>]);
        <span class="hljs-type">const</span> <span class="hljs-type">char</span> * data = <span class="hljs-string">"hello"</span>;
        <span class="hljs-comment">// 写入数据</span>
        write(fds[<span class="hljs-number">1</span>], data, <span class="hljs-built_in">strlen</span>(data));
        close(fds[<span class="hljs-number">1</span>]);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }<span class="hljs-keyword">else</span> {         
        <span class="hljs-comment">// 关闭写端</span>
        close(fds[<span class="hljs-number">1</span>]);  
        <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];
        <span class="hljs-comment">// 读取数据</span>
        read(fds[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, buf);
        close(fds[<span class="hljs-number">0</span>]);      
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>从代码中可以看到 socketpair 可以直接创建两个 fd 给父子进程进行通信，使用上简单很多，这也是 Node.js 进程间通信的底层技术。</p>
<p>除了了解 Unix 域的使用方式外，有几个知识我们也需要了解。</p>
<ol>
<li>基于连接模式时，Unix 域是使用字符串路径作为客户端和服务器连接的地址，它会在文件系统中创建一个文件，所以服务器要保证有写和执行权限才能启动成功，客户端保证有写权限才能连接到服务器。如果你发现服务器明明监听了这个路径，但是客户端连接却失败了，就可以这样去排查，这点和监听端口不一样，我之前也修复了一个 Node.js 中相关的问题，有兴趣可以参考这个 <a href="https://github.com/nodejs/node/pull/43634" target="_blank" rel="nofollow noopener noreferrer">PR</a>。</li>
<li>不基于连接模式时，客户端需要保证有写权限才能发送数据给服务器。</li>
<li>在基于连接模式的通信中，操作系统不会自动删除服务器创建的地址文件，需要应用自己删除，否则下次再使用会报地址已使用的错误（Libuv 会自动删除）。</li>
<li>在支持匿名路径的内核中。如果使用匿名路径，则不会创建路径文件，也不需要删除，内核会在 socket 引用数为 0 时自动删除相关的数据结构。</li>
</ol>
<h1>Libuv 中的 Unix 域</h1>
<p>了解了操作系统中的 Unix 域后，我们接着来看一下 Libuv 中是如何封装的。Libuv 提供的 API 和操作系统有点类似，首先使用前需要通过 uv_pipe_init 初始化 Unix 域相关的数据结构。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv_pipe_init</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv_pipe_t</span>* handle, <span class="hljs-type">int</span> ipc)</span> </span>{
    <span class="hljs-built_in">uv__stream_init</span>(loop, (<span class="hljs-type">uv_stream_t</span>*)handle, UV_NAMED_PIPE);
    <span class="hljs-comment">// 发起关闭的结构体</span>
    handle->shutdown_req = <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">// 发起连接的结构体</span>
    handle->connect_req = <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">// 路径地址</span>
    handle->pipe_fname = <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">// 是否用于 ipc</span>
    handle->ipc = ipc;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_pipe_init 逻辑很简单，就是初始化 uv_pipe_t 结构体，其中 ipc 是需要重点关注的字段，该字段表示该 handle 是否支持传递文件描述符，Node.js 中有两种使用场景，一种情况下，ipc 是 1（进程间通信），另一种是 0（通过 net 模块使用 Unix 域）。</p>
<p>初始化 handle 后，可以调用 uv_pipe_open 直接绑定 fd 到 handle。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv_pipe_open</span><span class="hljs-params">(<span class="hljs-type">uv_pipe_t</span>* handle, uv_file fd)</span> </span>{
  <span class="hljs-comment">// 设置非阻塞模式</span>
  <span class="hljs-built_in">uv__nonblock</span>(fd, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">uv__stream_open</span>((<span class="hljs-type">uv_stream_t</span>*)handle, fd, ...);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv__stream_open</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* stream, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> flags)</span> </span>{
  stream->flags |= flags;
  <span class="hljs-comment">// 记录 fd 到 handle</span>
  stream->io_watcher.fd = fd;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>通过 uv_pipe_open 绑定了 fd 后就可以直接对 handle 进行读写操作了。</p>
<p>另外，初始化 handle 后也可以调用 uv_pipe_bind 创建一个 fd，然后绑定地址到 fd 中，最后把 fd 保存到 handle 里。</p>
<pre><code class="hljs language-ini">int uv_pipe_bind(uv_pipe_t* handle, const char* name) {
    struct sockaddr_un saddr<span class="hljs-comment">;</span>
    const char* pipe_fname<span class="hljs-comment">;</span>
    int sockfd<span class="hljs-comment">;</span>
    int err<span class="hljs-comment">;</span>
    
    <span class="hljs-attr">pipe_fname</span> = NULL<span class="hljs-comment">;</span>
    
    <span class="hljs-attr">pipe_fname</span> = uv__strdup(name)<span class="hljs-comment">;</span>
    <span class="hljs-attr">name</span> = NULL<span class="hljs-comment">;</span>
    // Unix 域套接字
    <span class="hljs-attr">sockfd</span> = uv__socket(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    // 初始化监听的地址
    memset(&#x26;saddr, 0, sizeof saddr)<span class="hljs-comment">;</span>
    uv__strscpy(saddr.sun_path, pipe_fname, sizeof(saddr.sun_path))<span class="hljs-comment">;</span>
    <span class="hljs-attr">saddr.sun_family</span> = AF_UNIX<span class="hljs-comment">;</span>
    
    // 绑定路径地址
    bind(sockfd, (struct sockaddr*)&#x26;saddr, sizeof saddr)<span class="hljs-comment">;</span>
    // 记录路径字符串，后续需要删除它对应的文件和释放内存
    handle-><span class="hljs-attr">pipe_fname</span> = pipe_fname<span class="hljs-comment">;</span>
    // 保存socket fd，用于后面监听
    handle-><span class="hljs-attr">io_watcher.fd</span> = sockfd<span class="hljs-comment">;</span>
    return 0<span class="hljs-comment">;</span>
}
</code></pre>
<p>uv_pipe_bind 函数首先申请一个 socket 套接字并拿到一个 fd，然后把路径地址绑定 Unix 域路径到 socket 中，从中可以看到 Libuv 中，使用的 SOCK_STREAM 数据模式。</p>
<p>绑定了路径后，就可以调用 listen 函数开始监听。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv_pipe_listen</span><span class="hljs-params">(<span class="hljs-type">uv_pipe_t</span>* handle, <span class="hljs-type">int</span> backlog, uv_connection_cb cb)</span> </span>{
    <span class="hljs-comment">// 修改 socket 为监听状态</span>
    <span class="hljs-built_in">listen</span>(<span class="hljs-built_in">uv__stream_fd</span>(handle), backlog);
    <span class="hljs-comment">// 保存回调，有连接到来时由 uv__server_io 函数触发</span>
    handle->connection_cb = cb;
    <span class="hljs-comment">// IO 观察者的回调，有连接到来时在 Poll IO 阶段被执行</span>
    handle->io_watcher.cb = uv__server_io;
    <span class="hljs-comment">// 注册 IO 观察者到事件驱动模块，等待连接，即读事件到来</span>
    <span class="hljs-built_in">uv__io_start</span>(handle->loop, &#x26;handle->io_watcher, POLLIN);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_pipe_listen 执行 listen 函数使得 socket 成为监听状态，这样才能接收连接，然后把 socket 对应的文件描述符和回调封装成 IO 观察者，注册到事件驱动模块，等到有读事件到来（有连接到来），就会执行 uv__server_io 函数，uv__server_io 摘下对应的连接，最后执行 connection_cb 回调。</p>
<p>这时候就成功启动了一个服务，接着就是看客户端的逻辑。客户端首先也是需要调用 uv_pipe_init 初始化 Unix 域相关的 handle，然后调用 uv_pipe_connect 发起连接。</p>
<pre><code class="hljs language-ini">void uv_pipe_connect(uv_connect_t* req,
                     uv_pipe_t* handle,
                     const char* name,
                     uv_connect_cb cb) {
    struct sockaddr_un saddr<span class="hljs-comment">;</span>
    int new_sock<span class="hljs-comment">;</span>
    int err<span class="hljs-comment">;</span>
    int r<span class="hljs-comment">;</span>
    // 保存 socket 对应的文件描述符到 IO 观察者
    handle-><span class="hljs-attr">io_watcher.fd</span> = uv__socket(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    // 需要连接的服务器信息
    memset(&#x26;saddr, 0, sizeof saddr)<span class="hljs-comment">;</span>
    uv__strscpy(saddr.sun_path, name, sizeof(saddr.sun_path))<span class="hljs-comment">;</span>
    <span class="hljs-attr">saddr.sun_family</span> = AF_UNIX<span class="hljs-comment">;</span>
    
    // 连接服务器
    do {
        <span class="hljs-attr">r</span> = connect(uv__stream_fd(handle),(struct sockaddr*)&#x26;saddr, sizeof saddr)<span class="hljs-comment">;</span>
    }
    while (<span class="hljs-attr">r</span> == -<span class="hljs-number">1</span> &#x26;&#x26; err<span class="hljs-literal">no</span> == EINTR)<span class="hljs-comment">;</span>
    // 忽略错误处理逻辑
    // 注册可写事件，然后把 IO 观察者注册到事件驱动模块，等待连接结果执行 uv__stream_io
    uv__io_start(handle->loop, &#x26;handle->io_watcher, POLLOUT)<span class="hljs-comment">;</span>
    
out:
    // 记录请求上下文，连接结束后回调
    handle-><span class="hljs-attr">connect_req</span> = req<span class="hljs-comment">;</span>
    uv__req_init(handle->loop, req, UV_CONNECT)<span class="hljs-comment">;</span>
    req-><span class="hljs-attr">handle</span> = (uv_stream_t*)handle<span class="hljs-comment">;</span>
    req-><span class="hljs-attr">cb</span> = cb<span class="hljs-comment">;</span>
    QUEUE_INIT(&#x26;req->queue)<span class="hljs-comment">;</span>
}
</code></pre>
<p>执行 uv_pipe_connect 后，客户端就可以继续处理其他代码了，等到连接有结果后，就会调用 uv__stream_io 函数（uv_pipe_t 是 uv_stream_t 的子类），uv__stream_io 函数会继续调用 uv__stream_connect 函数处理连接结果。</p>
<pre><code class="hljs language-scss"> static void <span class="hljs-built_in">uv__stream_connect</span>(uv_stream_t* stream) {
  int error;
  uv_connect_t* req = stream->connect_req;
  socklen_t errorsize = <span class="hljs-built_in">sizeof</span>(int);
  <span class="hljs-comment">// 获取连接结果</span>
  <span class="hljs-built_in">getsockopt</span>(uv__stream_fd(stream),
             SOL_SOCKET,
             SO_ERROR,
             &#x26;error,
             &#x26;errorsize);
  error = <span class="hljs-built_in">UV__ERR</span>(error);
  <span class="hljs-comment">// 执行回调</span>
  if (req->cb)
    req-><span class="hljs-built_in">cb</span>(req, error);
}
</code></pre>
<p>uv__stream_connect 通过操作系统获取连接结果，然后执行调用，通知连接发起方连接结果。这样，一个连接流程就结束了。</p>
<p>剩下的服务器处理连接以及数据通信在 Libuv 流机制和 TCP 课程中已经讲过，它们是类似的，就不再详细讲解。</p>
<h1>文件描述符传递</h1>
<p>了解了 Unix 域的基础后，下面来看一下什么是文件描述符传递。假设有一个进程，我们称之为父进程，初始化时没有打开任何文件，然后父进程通过 fork 创建一个子进程，创建子进程后父进程打开了一个文件，如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a0a68e5f234892b65e65957b1b471e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如果父进程想把这个 fd 传到子进程那怎么办？把这个 fd 直接当作一般数据发送到子进程可以吗？答案是不可以的。因为每个进程都有自己的 fd 列表，父进程的 fd 可能在子进程中已经被使用了。另外，fd 只是个索引，只传递索引没有传递它关联的资源是没有意义的。这时候就需要使用文件描述符传递技术，它可以把一个进程中 fd 和资源的映射关系复制到另一个进程中。如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7e7f5d19cef466e82b6f3ec0399ab1f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>具体来说就是，父进程不仅要把 fd 传给子进程，还需要把 fd 对应的资源也传递过去，这个是指示操作系统去完成的，具体是通过 Unix 域来实现。下面，我们来看一下 Libuv 中对于文件描述符传递的处理。</p>
<p><strong>首先看发送端的处理</strong>，具体逻辑在 uv__write 函数中。</p>
<pre><code class="hljs language-ini">static void uv__write(uv_stream_t* stream) {
  struct iovec* iov<span class="hljs-comment">;</span>
  QUEUE* q<span class="hljs-comment">;</span>
  uv_write_t* req<span class="hljs-comment">;</span>
  int iovmax<span class="hljs-comment">;</span>
  int iovcnt<span class="hljs-comment">;</span>
  ssize_t n<span class="hljs-comment">;</span>
  int err<span class="hljs-comment">;</span>

  <span class="hljs-attr">q</span> = QUEUE_HEAD(&#x26;stream->write_queue)<span class="hljs-comment">;</span>
  <span class="hljs-attr">req</span> = QUEUE_DATA(q, uv_write_t, queue)<span class="hljs-comment">;</span>
  /*
    struct iovec {
        ptr_t iov_base<span class="hljs-comment">; // 数据首地址</span>
        size_t iov_len<span class="hljs-comment">; // 数据长度</span>
    }<span class="hljs-comment">;  </span>
    iovec 和 bufs 结构体的定义一样
  */
  // 待发送的数据
  <span class="hljs-attr">iov</span> = (struct iovec*) &#x26;(req->bufs[req->write_index])<span class="hljs-comment">;</span>
  <span class="hljs-attr">iovcnt</span> = req->nbufs - req->write_index<span class="hljs-comment">;</span>
  // 最多能写几个
  <span class="hljs-attr">iovmax</span> = uv__getiovmax()<span class="hljs-comment">;</span>

  // 取最小值
  if (iovcnt > iovmax)
    <span class="hljs-attr">iovcnt</span> = iovmax<span class="hljs-comment">;</span>

  // 有需要传递的描述符
  if (req->send_handle) {
    int fd_to_send<span class="hljs-comment">;</span>
    /*
      struct msghdr {
        void         *msg_name<span class="hljs-comment">;       // optional address </span>
        socklen_t     msg_namelen<span class="hljs-comment">;    // size of address </span>
        struct iovec *msg_iov<span class="hljs-comment">;        // scatter/gather array </span>
        size_t        msg_iovlen<span class="hljs-comment">;     // # elements in msg_iov </span>
        void         *msg_control<span class="hljs-comment">;    // ancillary data, see below </span>
        size_t        msg_controllen<span class="hljs-comment">; // ancillary data buffer len </span>
        int           msg_flags<span class="hljs-comment">;      // flags on received message </span>
      }<span class="hljs-comment">;  </span>
    */
    struct msghdr msg<span class="hljs-comment">;</span>
    /*
      struct cmsghdr  { 
         socklen_t cmsg_len <span class="hljs-comment">;  </span>
         int  cmsg_level <span class="hljs-comment">;   </span>
         int  cmsg_type <span class="hljs-comment">;  </span>
      } <span class="hljs-comment">; </span>
    */
    struct cmsghdr *cmsg<span class="hljs-comment">;</span>
    /*
            scratch是个联合体，data<span class="hljs-section">[64]</span> 是用于存储 cmsghdr 和紧跟后面的数据
    */
    union {
      char data<span class="hljs-section">[64]</span><span class="hljs-comment">;</span>
      struct cmsghdr alias<span class="hljs-comment">;</span>
    } scratch<span class="hljs-comment">;</span>
    
    // 需要发送的 fd
    <span class="hljs-attr">fd_to_send</span> = uv__handle_fd((uv_handle_t*) req->send_handle)<span class="hljs-comment">;</span>

    memset(&#x26;scratch, 0, sizeof(scratch))<span class="hljs-comment">;</span>

    // 下面两个字段用于udp
    <span class="hljs-attr">msg.msg_name</span> = NULL<span class="hljs-comment">;</span>
    <span class="hljs-attr">msg.msg_namelen</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    // 要发送的数据
    <span class="hljs-attr">msg.msg_iov</span> = iov<span class="hljs-comment">;</span>
    <span class="hljs-attr">msg.msg_iovlen</span> = iovcnt<span class="hljs-comment">;</span>
    <span class="hljs-attr">msg.msg_flags</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    // 指向一个cmsghdr
    <span class="hljs-attr">msg.msg_control</span> = &#x26;scratch.alias<span class="hljs-comment">;</span>
    // 要发送的 fd
    <span class="hljs-attr">msg.msg_controllen</span> = CMSG_SPACE(sizeof(fd_to_send))<span class="hljs-comment">;</span>
    <span class="hljs-attr">cmsg</span> = CMSG_FIRSTHDR(&#x26;msg)<span class="hljs-comment">;</span>
    cmsg-><span class="hljs-attr">cmsg_level</span> = SOL_SOCKET<span class="hljs-comment">;</span>
    cmsg-><span class="hljs-attr">cmsg_type</span> = SCM_RIGHTS<span class="hljs-comment">;</span>
    cmsg-><span class="hljs-attr">cmsg_len</span> = CMSG_LEN(sizeof(fd_to_send))<span class="hljs-comment">;</span>

    {
      void* <span class="hljs-attr">pv</span> = CMSG_DATA(cmsg)<span class="hljs-comment">;</span>
      int* <span class="hljs-attr">pi</span> = pv<span class="hljs-comment">;</span>
      // 写入需要传递的文件描述符
      *<span class="hljs-attr">pi</span> = fd_to_send<span class="hljs-comment">;</span>
    }

    do {
      // 发送数据和文件描述符
      <span class="hljs-attr">n</span> = sendmsg(uv__stream_fd(stream), &#x26;msg, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    } while (<span class="hljs-attr">n</span> == -<span class="hljs-number">1</span> &#x26;&#x26; err<span class="hljs-literal">no</span> == EINTR)<span class="hljs-comment">;</span>
  } 
}
</code></pre>
<p>当请求设置了需要发送文件描述符时，Libuv 会把数据和文件描述符打包到 struct msghdr 结构体中，然后调 sendmsg 发送，当这个数据到达接收方时，操作系统会帮我们处理好文件描述符传递的问题（有兴趣可以参考这个<a href="https://zhuanlan.zhihu.com/p/381683155" target="_blank" rel="nofollow noopener noreferrer">文章</a>）。</p>
<p>接着，<strong>我们再</strong> <strong>来看接收方的实现</strong>，具体逻辑在 uv__read 函数中。</p>
<pre><code class="hljs language-ini">static void uv__read(uv_stream_t* stream) {
     uv_buf_t buf<span class="hljs-comment">;</span>
     ssize_t nread<span class="hljs-comment">;</span>
     struct msghdr msg<span class="hljs-comment">;</span>
     char cmsg_space<span class="hljs-section">[CMSG_SPACE(UV__CMSG_FD_SIZE)]</span><span class="hljs-comment">;</span>
     int count<span class="hljs-comment">;</span>
     int err<span class="hljs-comment">;</span>
    
     <span class="hljs-attr">buf</span> = uv_buf_init(NULL, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
     // 分配内存，地址保存在buf中
     stream->alloc_cb((uv_handle_t*)stream, 64 * 1024, &#x26;buf)<span class="hljs-comment">;</span>
     // 传递了文件描述符
     <span class="hljs-attr">msg.msg_flags</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
     // 读取的数据存放到 buf
     <span class="hljs-attr">msg.msg_iov</span> = (struct iovec*) &#x26;buf<span class="hljs-comment">;</span>
     <span class="hljs-attr">msg.msg_iovlen</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
     <span class="hljs-attr">msg.msg_name</span> = NULL<span class="hljs-comment">;</span>
     <span class="hljs-attr">msg.msg_namelen</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
     <span class="hljs-attr">msg.msg_controllen</span> = sizeof(cmsg_space)<span class="hljs-comment">;</span>
     <span class="hljs-attr">msg.msg_control</span> = cmsg_space<span class="hljs-comment">;</span>
    // 读取数据和传递的文件描述符
    <span class="hljs-attr">nread</span> = uv__recvmsg(uv__stream_fd(stream), &#x26;msg, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    // 处理读取的文件描述符
    uv__stream_recv_cmsg(stream, &#x26;msg)<span class="hljs-comment">;</span>
    // 执行回调
    stream->read_cb(stream, nread, &#x26;buf)<span class="hljs-comment">;</span>
}
</code></pre>
<p>接收方除了接收一般的数据外还会接收传递过来的文件描述符 ，并调用 uv__stream_recv_cmsg 处理收到的文件描述符。</p>
<pre><code class="hljs language-ini">static int uv__stream_recv_cmsg(uv_stream_t* stream, struct msghdr* msg) {
  struct cmsghdr* cmsg<span class="hljs-comment">;</span>

  for (<span class="hljs-attr">cmsg</span> = CMSG_FIRSTHDR(msg)<span class="hljs-comment">; cmsg != NULL; cmsg = CMSG_NXTHDR(msg, cmsg)) {</span>
    char* start<span class="hljs-comment">;</span>
    char* end<span class="hljs-comment">;</span>
    int err<span class="hljs-comment">;</span>
    void* pv<span class="hljs-comment">;</span>
    int* pi<span class="hljs-comment">;</span>
    unsigned int i<span class="hljs-comment">;</span>
    unsigned int count<span class="hljs-comment">;</span>
    <span class="hljs-attr">pv</span> = CMSG_DATA(cmsg)<span class="hljs-comment">;</span>
    <span class="hljs-attr">pi</span> = pv<span class="hljs-comment">;</span>

    <span class="hljs-attr">start</span> = (char*) cmsg<span class="hljs-comment">;</span>
    <span class="hljs-attr">end</span> = (char*) cmsg + cmsg->cmsg_len<span class="hljs-comment">;</span>
    <span class="hljs-attr">count</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    // 多少个 fd
    while (start + CMSG_LEN(count * sizeof(*pi)) &#x3C; end)
      count++<span class="hljs-comment">;</span>
      
    // 保存收到的 fd，优先存储在 stream->accepted_fd，然后排队到 stream->queued_fds
    for (<span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; count; i++) {</span>
      if (stream->accepted_fd != -1) {
        <span class="hljs-attr">err</span> = uv__stream_queue_fd(stream, pi[i])<span class="hljs-comment">;</span>
      } else {
        stream-><span class="hljs-attr">accepted_fd</span> = pi[i]<span class="hljs-comment">;</span>
      }
    }
  }

  return 0<span class="hljs-comment">;</span>
}
</code></pre>
<p>uv__stream_recv_cmsg 的逻辑涉及到操作系统层面的一些知识可以不用过多理解，我们只需要知道 uv__stream_recv_cmsg 完成了 fd 的解析和保存。uv__stream_recv_cmsg 会把接收到的第一个 fd 保存到 accepted_fd 中，然后剩下的通过 uv__stream_queue_fd 进行排队。接下来，我们看看 uv__stream_queue_fd 是如何实现排队的。</p>
<pre><code class="hljs language-ini">static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {
  uv__stream_queued_fds_t* queued_fds<span class="hljs-comment">;</span>
  unsigned int queue_size<span class="hljs-comment">;</span>
  // fd 队列
  <span class="hljs-attr">queued_fds</span> = stream->queued_fds<span class="hljs-comment">;</span>
  if (<span class="hljs-attr">queued_fds</span> == NULL) {
    <span class="hljs-attr">queue_size</span> = <span class="hljs-number">8</span><span class="hljs-comment">;</span>
    // uv__stream_queued_fds_t 结构体的大小 + 数组的大小
    <span class="hljs-attr">queued_fds</span> = uv__malloc((queue_size - <span class="hljs-number">1</span>) * sizeof(*queued_fds->fds) + sizeof(*queued_fds))<span class="hljs-comment">;</span>
    queued_fds-><span class="hljs-attr">size</span> = queue_size<span class="hljs-comment">;</span>
    queued_fds-><span class="hljs-attr">offset</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    stream-><span class="hljs-attr">queued_fds</span> = queued_fds<span class="hljs-comment">;</span>
  }
  // 省略扩容逻辑
  queued_fds->fds<span class="hljs-section">[queued_fds->offset++]</span> = fd<span class="hljs-comment">;</span>
  return 0<span class="hljs-comment">;</span>
}
</code></pre>
<p>想要理解上面的代码，我们首先需要理解 uv__stream_queued_fds_t 结构体，uv__stream_queued_fds_t 结构体用于管理接收到的多个 fd，定义如下。</p>
<pre><code class="hljs language-arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">uv__stream_queued_fds_s</span> {
  <span class="hljs-comment">// 容量</span>
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;
  <span class="hljs-comment">// 当前空闲位置的索引</span>
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;
  <span class="hljs-comment">// 数组，内存是动态申请的</span>
  <span class="hljs-type">int</span> fds[<span class="hljs-number">1</span>];
};
</code></pre>
<p>下面看看结构图。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/932cc55e8d35479782a8215ae9e37212~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>刚才讲过 Libuv 会把接收到的第一个 fd 保存在 accepted_fd 字段，那么接收的额外 fd 就是存储在 fds 数组里 <strong>。</strong></p>
<p>把传递过来的 fd 保存起来后，接着就需要在读回调里消费这些 fd，示例代码如下。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 是否还有待处理的 fd</span>
while (uv_pipe_pending_count(server_stream) > <span class="hljs-number">0</span>) {
  uv_stream_t stream;
  <span class="hljs-comment">// 摘取收到的文件描述符到 stream</span>
  <span class="hljs-built_in">uv_accept</span>(server_stream, stream);
}
</code></pre>
<p>上面的 uv_pipe_pending_count 函数用于判断是否有还没被消费的 fd。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv_pipe_pending_count</span><span class="hljs-params">(<span class="hljs-type">uv_pipe_t</span>* handle)</span> </span>{
  <span class="hljs-type">uv__stream_queued_fds_t</span>* queued_fds;
  <span class="hljs-comment">// accepted_fd 记录第一个待消费的 fd，等于 -1 说明没有 fd 可被消费</span>
  <span class="hljs-keyword">if</span> (handle->accepted_fd == <span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-comment">// queued_fds 表示除了 accepted_fd 的 fd 外还有多少个 fd 等待消费</span>
  <span class="hljs-comment">// 等于 NULL 说明只有 accepted_fd 中的一个 fd 等待消费</span>
  <span class="hljs-keyword">if</span> (handle->queued_fds == <span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  <span class="hljs-comment">// 否则返回 queued_fds 中的 fd 个数 + accepted_fd 中的一个</span>
  queued_fds = handle->queued_fds;
  <span class="hljs-keyword">return</span> queued_fds->offset + <span class="hljs-number">1</span>;
}
</code></pre>
<p>uv_accept 用于消费收到的 fd。</p>
<pre><code class="hljs language-rust">int <span class="hljs-title function_ invoke__">uv_accept</span>(uv_stream_t* server, uv_stream_t* client) {
  int err;
  <span class="hljs-comment">// 保存 accepted_fd 到 client</span>
  <span class="hljs-title function_ invoke__">uv__stream_open</span>(client, server<span class="hljs-punctuation">-></span>accepted_fd, UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);

  <span class="hljs-comment">// 还有排队的</span>
  <span class="hljs-title function_ invoke__">if</span> (server<span class="hljs-punctuation">-></span>queued_fds != NULL) {
    uv__stream_queued_fds_t* queued_fds;
    queued_fds = server<span class="hljs-punctuation">-></span>queued_fds;
    <span class="hljs-comment">// 把队列中的第一个移到 accepted_fd</span>
    server<span class="hljs-punctuation">-></span>accepted_fd = queued_fds<span class="hljs-punctuation">-></span>fds[<span class="hljs-number">0</span>];
    <span class="hljs-comment">// offset 是当前空闲位置的索引，-- 后即最后一个 fd 的位置，如果是 0，说明没有需要处理的 fd 了，释放内存</span>
    <span class="hljs-title function_ invoke__">if</span> (--queued_fds<span class="hljs-punctuation">-></span>offset == <span class="hljs-number">0</span>) {
      <span class="hljs-title function_ invoke__">uv__free</span>(queued_fds);
      server<span class="hljs-punctuation">-></span>queued_fds = NULL;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 元素往前移</span>
      <span class="hljs-title function_ invoke__">memmove</span>(queued_fds<span class="hljs-punctuation">-></span>fds,
              queued_fds<span class="hljs-punctuation">-></span>fds + <span class="hljs-number">1</span>,
              queued_fds<span class="hljs-punctuation">-></span>offset * <span class="hljs-title function_ invoke__">sizeof</span>(*queued_fds<span class="hljs-punctuation">-></span>fds));
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 没有则重置 accepted_fd</span>
    server<span class="hljs-punctuation">-></span>accepted_fd = -<span class="hljs-number">1</span>;
    <span class="hljs-comment">// 继续注册可读事件</span>
    <span class="hljs-title function_ invoke__">uv__io_start</span>(server<span class="hljs-punctuation">-></span><span class="hljs-keyword">loop</span>, &#x26;server<span class="hljs-punctuation">-></span>io_watcher, POLLIN);
  }
  <span class="hljs-keyword">return</span> err;
}
</code></pre>
<p>每次调用 uv_accept 就会拿到一个 fd，并且 uv_accept 会自动更新相关的数据结构，并把下一个待消费的 fd 保存到 accepted_fd 中，直到处理完所有的 fd。这就是 Libuv 中关于文件描述符的处理逻辑，下节课讲进程间通信时会进一步讲解 Node.js 是如何处理文件描述符传递的。</p>
<h1>总结</h1>
<p>Unix 域作为一种操作系统提供的 IPC 技术，在很多软件中都少不了它的身影，Node.js 也不例外。在 Node.js，Unix 域的作用主要有两个：第一是作为进程间通信的方式，使得任意有权限的进程间都可以通信；第二是实现文件描述符传递。文件描述符传递在操作系统和 Node.js 中都是非常重要的技术，比如 Node.js 的服务器实现就依赖于文件描述符传递。</p>
<p>这节课首先介绍了操作系统中 Unix 域的两种使用方式，一种是基于网络编程 API 的，可用于任意进程间通信，一种是基于 socketpair 系统调用的，通常用于父子进程间通信。接着介绍了 Libuv 中对 Unix 域的封装和使用，Libuv 提供了类似网络编程的 API，使用上比较简单，最后介绍了非常重要的文件描述符技术，主要讲了文件描述符的发送 / 接收 / 消费过程。</p></div>
</body></html>