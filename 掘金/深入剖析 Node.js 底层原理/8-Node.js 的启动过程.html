<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Node.js 的启动过程</h1>
<p>前面的课程讲了一些基础的内容，本节课来讲解一下 Node.js 的启动过程 ，这是我们深入理解 Node.js 工作原理非常重要的一步，了解了启动过程，我们才能更好地了解后面的核心模块是如何在启动的进程中工作的。本节课先从宏观介绍 Node.js 的启动过程，然后再详细分析启动过程中各个核心部分的实现，从中我们可以看到启动过程中每一个核心的步骤以及它的作用。</p>
<p>开始讲解前，我们先来看一下 Node.js 启动时的核心流程，有了大致印象后，会更容易理解后面的内容，同时也可以通过这个流程图不断地加深对启动过程的理解。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfc449cb3a4c4fe5a3af71e602f1cb17~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>首先看一下整体的逻辑。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>{
  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-literal">nullptr</span>, _IONBF, <span class="hljs-number">0</span>);
  <span class="hljs-built_in">setvbuf</span>(stderr, <span class="hljs-literal">nullptr</span>, _IONBF, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> node::<span class="hljs-built_in">Start</span>(argc, argv);
}
</code></pre>
<p>main 函数的开头通过 setvbuf 设置了不缓冲标准输出流和标准错误流的数据，而是直接输出，因为当我们调用 C API 输出数据时，最终需要调用操作系统的 API 进行处理，C 库的 API 为了减少对系统调用的次数，会先对数据进行缓存，等到合适的时机再调用系统调用，比如遇到换行时。类似 TCP 协议通常是积累一定数据才会组包发送一样。setvbuf 和 _IONBF 用于禁止缓冲行为，实时输出。接着看 Start。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Start</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>{
  <span class="hljs-comment">// 注册 C++ 模块、解析命令行参数、初始化 V8</span>
  InitializationResult result = <span class="hljs-built_in">InitializeOncePerProcess</span>(argc, argv);

  <span class="hljs-function">NodeMainInstance <span class="hljs-title">main_instance</span><span class="hljs-params">(&#x26;params,
                                 uv_default_loop(),
                                 per_process::v8_platform.Platform(),
                                 result.args,
                                 result.exec_args,
                                 indexes)</span></span>;
  main_instance.<span class="hljs-built_in">Run</span>();

  <span class="hljs-keyword">return</span> result.exit_code;
}
</code></pre>
<p>Start 里主要两个逻辑，首先看 InitializeOncePerProcess。</p>
<pre><code class="hljs language-c++"><span class="hljs-function">InitializationResult <span class="hljs-title">InitializeOncePerProcess</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>{
  <span class="hljs-comment">// 注册 C++ 模块</span>
  binding::<span class="hljs-built_in">RegisterBuiltinModules</span>();
  <span class="hljs-comment">// 解析命令行参数</span>
  <span class="hljs-built_in">ProcessGlobalArgs</span>();
  <span class="hljs-comment">// 初始化 V8 Platform</span>
  per_process::v8_platform.<span class="hljs-built_in">Initialize</span>(per_process::cli_options->v8_thread_pool_size);
  <span class="hljs-comment">// 初始化 V8</span>
  V8::<span class="hljs-built_in">Initialize</span>();
}
</code></pre>
<p>InitializeOncePerProcess 初始化后，接着创建一个 NodeMainInstance 实例并执行它的 Run 函数。</p>
<pre><code class="hljs language-c++">NodeMainInstance::<span class="hljs-built_in">NodeMainInstance</span>(
    Isolate::CreateParams* params, <span class="hljs-comment">// 创建 isolate 的参数</span>
    <span class="hljs-type">uv_loop_t</span>* event_loop, <span class="hljs-comment">// 事件循环</span>
    MultiIsolatePlatform* platform, <span class="hljs-comment">// V8 Platform</span>
    <span class="hljs-type">const</span> std::vector&#x3C;std::string>&#x26; args, <span class="hljs-comment">// 启动参数</span>
    <span class="hljs-type">const</span> std::vector&#x3C;std::string>&#x26; exec_args,
    <span class="hljs-type">const</span> std::vector&#x3C;<span class="hljs-type">size_t</span>>* per_isolate_data_indexes)
    : <span class="hljs-built_in">args_</span>(args),
      <span class="hljs-built_in">exec_args_</span>(exec_args),
      <span class="hljs-comment">// ArrayBuffer（Buffer） 的内存分配器</span>
      <span class="hljs-built_in">array_buffer_allocator_</span>(ArrayBufferAllocator::<span class="hljs-built_in">Create</span>()),
      <span class="hljs-built_in">isolate_</span>(<span class="hljs-literal">nullptr</span>),
      <span class="hljs-built_in">platform_</span>(platform),
      <span class="hljs-built_in">isolate_data_</span>(<span class="hljs-literal">nullptr</span>),
      <span class="hljs-built_in">owns_isolate_</span>(<span class="hljs-literal">true</span>) {
      
  params->array_buffer_allocator = array_buffer_allocator_.<span class="hljs-built_in">get</span>();
  <span class="hljs-comment">// 创建 isolate</span>
  isolate_ = Isolate::<span class="hljs-built_in">Allocate</span>();
  platform-><span class="hljs-built_in">RegisterIsolate</span>(isolate_, event_loop);
  <span class="hljs-comment">// 初始化 isolate</span>
  Isolate::<span class="hljs-built_in">Initialize</span>(isolate_, *params);
  <span class="hljs-comment">// 把公共的数据封装到一起</span>
  isolate_data_ = std::<span class="hljs-built_in">make_unique</span>&#x3C;IsolateData>(isolate_,
                                                event_loop,
                                                platform,
                                                array_buffer_allocator_.<span class="hljs-built_in">get</span>(),
                                                per_isolate_data_indexes);
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NodeMainInstance::Run</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-type">int</span> exit_code = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 创建 Environment 对象</span>
  DeleteFnPtr&#x3C;Environment, FreeEnvironment> env = <span class="hljs-built_in">CreateMainEnvironment</span>(&#x26;exit_code);
  <span class="hljs-comment">// 加载 Environment</span>
  <span class="hljs-built_in">LoadEnvironment</span>(env.<span class="hljs-built_in">get</span>());
}
</code></pre>
<p>NodeMainInstance 构造函数主要做了一些初始化工作，接着 调用 Run，Run 调用了 CreateMainEnvironment 创建了 一个 Environment 对象。</p>
<pre><code class="hljs language-c++">NodeMainInstance::<span class="hljs-built_in">CreateMainEnvironment</span>(<span class="hljs-type">int</span>* exit_code) {
  <span class="hljs-comment">// 创建 V8 Context</span>
  Local&#x3C;Context> context = <span class="hljs-built_in">NewContext</span>(isolate_);
  <span class="hljs-comment">// 新建一个 Environment 对象，并记录到 context 中</span>
  std::unique_ptr&#x3C;Environment> env = std::<span class="hljs-built_in">make_unique</span>&#x3C;Environment>(
      isolate_data_.<span class="hljs-built_in">get</span>(),
      context,
      ...);
  <span class="hljs-comment">// 初始化 Libuv 相关的结构体                                   </span>
  env-><span class="hljs-built_in">InitializeLibuv</span>(per_process::v8_is_profiling);
  <span class="hljs-comment">// 初始化诊断相关的能力</span>
  env-><span class="hljs-built_in">InitializeDiagnostics</span>();
  <span class="hljs-comment">// 初始化 Inspector 相关</span>
  env-><span class="hljs-built_in">InitializeInspector</span>({});
  <span class="hljs-comment">// 初始化模块加载器(BootstrapInternalLoaders())和执行内部 JS 代码(BootstrapNode())</span>
  env-><span class="hljs-built_in">RunBootstrapping</span>();
  <span class="hljs-keyword">return</span> env;
}
</code></pre>
<p>创建完 Environment 后，继续执行 LoadEnvironment。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadEnvironment</span><span class="hljs-params">(Environment* env)</span> </span>{
  <span class="hljs-built_in">StartMainThreadExecution</span>(env);
}

<span class="hljs-function">MaybeLocal&#x3C;Value> <span class="hljs-title">StartMainThreadExecution</span><span class="hljs-params">(Environment* env)</span> </span>{
  <span class="hljs-comment">// 忽略执行其他 JS 代码的逻辑</span>
  <span class="hljs-comment">// run_main_module 中执行用户 JS 代码</span>
  <span class="hljs-keyword">if</span> (!first_argv.<span class="hljs-built_in">empty</span>() &#x26;&#x26; first_argv != <span class="hljs-string">"-"</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">StartExecution</span>(env, <span class="hljs-string">"internal/main/run_main_module"</span>);
  }
}
</code></pre>
<p>StartMainThreadExecution 中执行了用户的 JS 代码，执行用户 JS 通常会生产一些任务到 Libuv 中，最后开启事件循环。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 开启事件循环</span>
<span class="hljs-keyword">do</span> {
  <span class="hljs-built_in">uv_run</span>(env-><span class="hljs-built_in">event_loop</span>(), UV_RUN_DEFAULT);
  more = <span class="hljs-built_in">uv_loop_alive</span>(env-><span class="hljs-built_in">event_loop</span>());
} <span class="hljs-keyword">while</span> (more == <span class="hljs-literal">true</span> &#x26;&#x26; !env-><span class="hljs-built_in">is_stopping</span>());
</code></pre>
<p>了解了 Node.js 启动的大致流程后，我们按照 Node.js 初始化过程中的代码先后顺序对各个核心部分进行讲解。</p>
<h3>注册 C++ 模块</h3>
<p>RegisterBuiltinModules 函数的作用是注册 C++ 模块，C++ 模块用于给 JS 层提供各种底层的功能，是 Node.js 中非常核心的部分。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterBuiltinModules</span><span class="hljs-params">()</span> </span>{  
<span class="hljs-meta">#<span class="hljs-keyword">define</span> V(modname) _register_##modname();  </span>
  <span class="hljs-built_in">NODE_BUILTIN_MODULES</span>(V)  
<span class="hljs-meta">#<span class="hljs-keyword">undef</span> V  </span>
}  
</code></pre>
<p>NODE_BUILTIN_MODULES 是一个 C 语言宏，宏展开后如下（省略类似逻辑）</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterBuiltinModules</span><span class="hljs-params">()</span> </span>{  
<span class="hljs-meta">#<span class="hljs-keyword">define</span> V(modname) _register_##modname();  </span>
  <span class="hljs-built_in">V</span>(tcp_wrap)   
  <span class="hljs-built_in">V</span>(fs)  
  <span class="hljs-comment">// ...其它模块  </span>
<span class="hljs-meta">#<span class="hljs-keyword">undef</span> V  </span>
}  
</code></pre>
<p>再一步展开如下</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterBuiltinModules</span><span class="hljs-params">()</span> </span>{  
  _register_tcp_wrap();  
  _register_fs();  
}  
</code></pre>
<p>执行了一系列 _register 开头的函数，但是我们在 Node.js 源码里找不到这些函数，因为这些函数是在每个 C++ 模块定义的文件里（src/*.cc文件的最后一行）通过宏定义的。以 tcp_wrap 模块为例，看看它是怎么做的。文件 tcp_wrap.cc 的最后一句代码</p>
<pre><code class="hljs language-c++"><span class="hljs-built_in">NODE_MODULE_CONTEXT_AWARE_INTERNAL</span>(tcp_wrap, node::TCPWrap::Initialize) 
</code></pre>
<p>宏展开是</p>
<pre><code class="hljs language-c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_INTERNAL(modname, regfunc)  \  </span>
<span class="hljs-built_in">NODE_MODULE_CONTEXT_AWARE_CPP</span>(modname, regfunc, <span class="hljs-literal">nullptr</span>, NM_F_INTERNAL)  
</code></pre>
<p>继续展开</p>
<pre><code class="hljs language-c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags\  </span>
  <span class="hljs-type">static</span> node::node_module _module = {              \  
      NODE_MODULE_VERSION,                        \  
      flags,                        \  
      <span class="hljs-literal">nullptr</span>,                        \  
      __FILE__,                        \  
      <span class="hljs-literal">nullptr</span>,                        \  
      (node::addon_context_register_func)(regfunc),  \  
      <span class="hljs-built_in">NODE_STRINGIFY</span>(modname),                        \  
      priv,                        \  
      <span class="hljs-literal">nullptr</span>};                        \  
  <span class="hljs-type">void</span> _register_tcp_wrap() { <span class="hljs-built_in">node_module_register</span>(&#x26;_module); }  
</code></pre>
<p>首先定义了一个 node_module 结构体。node_module 是 Node.js 中表示 C++ 模块的数据结构，包括 一般的 C++ 模块和NAPI 模块等。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node_module</span> {  
  <span class="hljs-comment">// 版本、标记的元信息</span>
  <span class="hljs-type">int</span> nm_version;  
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nm_flags;  
  <span class="hljs-type">void</span>* nm_dso_handle;  
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* nm_filename;  
  <span class="hljs-comment">// 注册模块的钩子函数</span>
  node::addon_register_func nm_register_func;  
  node::addon_context_register_func nm_context_register_func; 
  <span class="hljs-comment">// 模块名 </span>
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* nm_modname;  
  <span class="hljs-type">void</span>* nm_priv;  
  <span class="hljs-comment">// 用于指向下一个节点</span>
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node_module</span>* nm_link;  
};  
</code></pre>
<p>定义 node_module 之后，接着定义了一个 _register 开头的函数，这里是 _register_tcp_wrap，这些函数就会在 Node.js 启动时，逐个被执行一遍，接着看这些函数都做了什么事情， _register_tcp_wrap 函数里调了 node_module_register ，并传入一个 node_module 数据结构，所以我们看一下 node_module_register 的实现</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">node_module_register</span><span class="hljs-params">(<span class="hljs-type">void</span>* m)</span> </span>{  
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node_module</span>* mp = <span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-keyword">struct</span> node_module*>(m);  
  <span class="hljs-keyword">if</span> (mp->nm_flags &#x26; NM_F_INTERNAL) {  
    mp->nm_link = modlist_internal;  
    modlist_internal = mp;  
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!node_is_initialized) { 
    mp->nm_flags = NM_F_LINKED;  
    mp->nm_link = modlist_linked;  
    modlist_linked = mp;  
  } <span class="hljs-keyword">else</span> {  
    thread_local_modpending = mp;  
  }  
}  
</code></pre>
<p>C++ 内置模块的 flag 是 NM_F_INTERNAL，所以会执行第一个 if 的逻辑，modlist_internal 类似一个头指针。if 里的逻辑就是头插法建立一个单链表。所以注册 C++ 模块就是把各个模块连成一个链表，在后面模块加载的课程中会看到这个链表的使用。</p>
<h3>V8 Platform 初始化</h3>
<p>注册完 C++ 模块后，接着会初始化 V8 Platform，V8 Platform 用于创建一些 worker 线程以及 trace agent。worker 线程可以用于协助处理一些任务，比如 GC 任务，trace agent 则是处理 trace event 数据的。</p>
<pre><code class="hljs language-c++">  <span class="hljs-comment">// 我们可以通过命令后参数指定 thread_pool_size 大小，从而指定线程池大小</span>
  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> thread_pool_size)</span> </span>{
    <span class="hljs-comment">// 创建并记录 trace agent</span>
    tracing_agent_ = std::<span class="hljs-built_in">make_unique</span>&#x3C;tracing::Agent>();
    node::tracing::TraceEventHelper::<span class="hljs-built_in">SetAgent</span>(tracing_agent_.<span class="hljs-built_in">get</span>());
    <span class="hljs-comment">// 如果命令行设置了 trace event category 则开启 trace agent</span>
    <span class="hljs-keyword">if</span> (!per_process::cli_options->trace_event_categories.<span class="hljs-built_in">empty</span>()) {
      <span class="hljs-built_in">StartTracingAgent</span>();
    }
    <span class="hljs-comment">// 创建 Platform 对象</span>
    platform_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NodePlatform</span>(thread_pool_size, controller);
    <span class="hljs-comment">// 保存到 V8，V8 会使用该 Platform</span>
    v8::V8::<span class="hljs-built_in">InitializePlatform</span>(platform_);
  }
</code></pre>
<p>trace events 用于收集 Node.js / V8 内核的一些数据，这里我们不关注，接下来看一下 NodePlatform 的构造函数。</p>
<pre><code class="hljs language-c++">NodePlatform::<span class="hljs-built_in">NodePlatform</span>(<span class="hljs-type">int</span> thread_pool_size,
                           TracingController* tracing_controller) {
   worker_thread_task_runner_ = std::<span class="hljs-built_in">make_shared</span>&#x3C;WorkerThreadsTaskRunner>(thread_pool_size);
}
</code></pre>
<p>NodePlatform 中创建了 WorkerThreadsTaskRunner 对象。</p>
<pre><code class="hljs language-c++">WorkerThreadsTaskRunner::<span class="hljs-built_in">WorkerThreadsTaskRunner</span>(<span class="hljs-type">int</span> thread_pool_size) {
  Mutex platform_workers_mutex;
  ConditionVariable platform_workers_ready;

  <span class="hljs-function">Mutex::ScopedLock <span class="hljs-title">lock</span><span class="hljs-params">(platform_workers_mutex)</span></span>;
  <span class="hljs-type">int</span> pending_platform_workers = thread_pool_size;
  <span class="hljs-comment">// 延迟任务处理线程，即该任务会在一定时间后被执行，pending_worker_tasks_ 为任务队列</span>
  delayed_task_scheduler_ = std::<span class="hljs-built_in">make_unique</span>&#x3C;DelayedTaskScheduler>(&#x26;pending_worker_tasks_);
  threads_.<span class="hljs-built_in">push_back</span>(delayed_task_scheduler_-><span class="hljs-built_in">Start</span>());
  <span class="hljs-comment">// 创建线程池</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &#x3C; thread_pool_size; i++) {
    <span class="hljs-comment">// pending_worker_tasks_ 为线程池的任务任务</span>
    PlatformWorkerData* worker_data = <span class="hljs-keyword">new</span> PlatformWorkerData{
      &#x26;pending_worker_tasks_, ...
    };
    std::unique_ptr&#x3C;<span class="hljs-type">uv_thread_t</span>> t { <span class="hljs-keyword">new</span> <span class="hljs-built_in">uv_thread_t</span>() };
    <span class="hljs-comment">// 创建子线程</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">uv_thread_create</span>(t.<span class="hljs-built_in">get</span>(), PlatformWorkerThread,
                         worker_data) != <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">break</span>;
    }
    threads_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(t));
  }

  <span class="hljs-comment">// 等待子线程启动成功</span>
  <span class="hljs-keyword">while</span> (pending_platform_workers > <span class="hljs-number">0</span>) {
    platform_workers_ready.<span class="hljs-built_in">Wait</span>(lock);
  }
}
</code></pre>
<p>WorkerThreadsTaskRunner 中创建了很多子线程，我们分开分析。首先看看 DelayedTaskScheduler 线程，DelayedTaskScheduler 用于管理延时任务，也就是说当一个任务插入 DelayedTaskScheduler 时，他不是被立即执行的，而是会延迟一段时间。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerThreadsTaskRunner</span>::DelayedTaskScheduler {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DelayedTaskScheduler</span><span class="hljs-params">(TaskQueue&#x3C;Task>* tasks)</span>
  <span class="hljs-comment">// 保存任务队列，延迟任务超时后把任务插入该任务队列</span>
    : pending_worker_tasks_(tasks) {</span>}
  <span class="hljs-comment">// 启动线程</span>
  <span class="hljs-function">std::unique_ptr&#x3C;<span class="hljs-type">uv_thread_t</span>> <span class="hljs-title">Start</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> start_thread = [](<span class="hljs-type">void</span>* data) {
      <span class="hljs-built_in">static_cast</span>&#x3C;DelayedTaskScheduler*>(data)-><span class="hljs-built_in">Run</span>();
    };
    <span class="hljs-comment">// 创建线程</span>
    std::unique_ptr&#x3C;<span class="hljs-type">uv_thread_t</span>> t { <span class="hljs-keyword">new</span> <span class="hljs-built_in">uv_thread_t</span>() };
    <span class="hljs-built_in">uv_sem_init</span>(&#x26;ready_, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">CHECK_EQ</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">uv_thread_create</span>(t.<span class="hljs-built_in">get</span>(), start_thread, <span class="hljs-keyword">this</span>));
    <span class="hljs-built_in">uv_sem_wait</span>(&#x26;ready_);
    <span class="hljs-built_in">uv_sem_destroy</span>(&#x26;ready_);
    <span class="hljs-keyword">return</span> t;
  }
  <span class="hljs-comment">// 提交延迟任务</span>
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostDelayedTask</span><span class="hljs-params">(std::unique_ptr&#x3C;Task> task, <span class="hljs-type">double</span> delay_in_seconds)</span> </span>{
    tasks_.<span class="hljs-built_in">Push</span>(std::<span class="hljs-built_in">make_unique</span>&#x3C;ScheduleTask>(<span class="hljs-keyword">this</span>, std::<span class="hljs-built_in">move</span>(task),
                                               delay_in_seconds));
    <span class="hljs-built_in">uv_async_send</span>(&#x26;flush_tasks_);
  }

 <span class="hljs-keyword">private</span>:
  <span class="hljs-comment">// 子线程里执行的函数</span>
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span> </span>{
    loop_.data = <span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// 初始化数据结构</span>
    <span class="hljs-built_in">CHECK_EQ</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">uv_loop_init</span>(&#x26;loop_));
    flush_tasks_.data = <span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// 初始化 async handle，用于其他线程插入任务时唤醒子线程</span>
    <span class="hljs-built_in">CHECK_EQ</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">uv_async_init</span>(&#x26;loop_, &#x26;flush_tasks_, FlushTasks));
    <span class="hljs-built_in">uv_sem_post</span>(&#x26;ready_);
    <span class="hljs-comment">// 执行单独的事件循环</span>
    <span class="hljs-built_in">uv_run</span>(&#x26;loop_, UV_RUN_DEFAULT);
    <span class="hljs-built_in">CheckedUvLoopClose</span>(&#x26;loop_);
  }
  <span class="hljs-comment">// 子线程处理任务函数，逐个执行任务</span>
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">FlushTasks</span><span class="hljs-params">(<span class="hljs-type">uv_async_t</span>* flush_tasks)</span> </span>{
    DelayedTaskScheduler* scheduler =
        <span class="hljs-built_in">ContainerOf</span>(&#x26;DelayedTaskScheduler::loop_, flush_tasks->loop);
    <span class="hljs-keyword">while</span> (std::unique_ptr&#x3C;Task> task = scheduler->tasks_.<span class="hljs-built_in">Pop</span>())
      task-><span class="hljs-built_in">Run</span>();
  }
</code></pre>
<p>主线程执行 Start 开启子线程，然后子线程执行 Run 进行初始化，接着就进入事件循环，其他线程可以通过 PostDelayedTask 提交一个 ScheduleTask 任务，PostDelayedTask 会唤醒 DelayedTaskScheduler 子线程处理任务，来看一下执行 ScheduleTask 任务时的逻辑。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduleTask</span> : <span class="hljs-keyword">public</span> Task {
   <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">ScheduleTask</span>(DelayedTaskScheduler* scheduler,
                 std::unique_ptr&#x3C;Task> task,
                 <span class="hljs-type">double</span> delay_in_seconds)
      : <span class="hljs-built_in">scheduler_</span>(scheduler),
        <span class="hljs-built_in">task_</span>(std::<span class="hljs-built_in">move</span>(task)),
        <span class="hljs-built_in">delay_in_seconds_</span>(delay_in_seconds) {}

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{
      <span class="hljs-type">uint64_t</span> delay_millis = <span class="hljs-built_in">llround</span>(delay_in_seconds_ * <span class="hljs-number">1000</span>);
      <span class="hljs-function">std::unique_ptr&#x3C;<span class="hljs-type">uv_timer_t</span>> <span class="hljs-title">timer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">uv_timer_t</span>())</span></span>;
      <span class="hljs-built_in">CHECK_EQ</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">uv_timer_init</span>(&#x26;scheduler_->loop_, timer.<span class="hljs-built_in">get</span>()));
      timer->data = task_.<span class="hljs-built_in">release</span>();
      <span class="hljs-comment">// 启动一个定时器，超时后执行 RunTask</span>
      <span class="hljs-built_in">CHECK_EQ</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">uv_timer_start</span>(timer.<span class="hljs-built_in">get</span>(), RunTask, delay_millis, <span class="hljs-number">0</span>));
      scheduler_->timers_.<span class="hljs-built_in">insert</span>(timer.<span class="hljs-built_in">release</span>());
    }

   <span class="hljs-keyword">private</span>:
    DelayedTaskScheduler* scheduler_;
    std::unique_ptr&#x3C;Task> task_;
    <span class="hljs-type">double</span> delay_in_seconds_;
  };
</code></pre>
<p>可以看到执行 ScheduleTask 任务时会先往 DelayedTaskScheduler 子线程的事件循环中插入一个定时器，等到定时器超时时执行 RunTask。</p>
<pre><code class="hljs language-c++">  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">RunTask</span><span class="hljs-params">(<span class="hljs-type">uv_timer_t</span>* timer)</span> </span>{
    DelayedTaskScheduler* scheduler =
        <span class="hljs-built_in">ContainerOf</span>(&#x26;DelayedTaskScheduler::loop_, timer->loop);
    scheduler->pending_worker_tasks_-><span class="hljs-built_in">Push</span>(scheduler-><span class="hljs-built_in">TakeTimerTask</span>(timer));
  }
</code></pre>
<p>RunTask 会把任务插入真正的任务队列。这个队列由 Platform 的线程池处理。下面看看 Platform 的线程池，工作函数是 PlatformWorkerThread。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">PlatformWorkerThread</span><span class="hljs-params">(<span class="hljs-type">void</span>* data)</span> </span>{
  <span class="hljs-function">std::unique_ptr&#x3C;PlatformWorkerData>
      <span class="hljs-title">worker_data</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&#x3C;PlatformWorkerData*>(data))</span></span>;

  TaskQueue&#x3C;Task>* pending_worker_tasks = worker_data->task_queue;
  <span class="hljs-comment">// 通知主线程，子线程启动成功 </span>
  {
    <span class="hljs-function">Mutex::ScopedLock <span class="hljs-title">lock</span><span class="hljs-params">(*worker_data->platform_workers_mutex)</span></span>;
    (*worker_data->pending_platform_workers)--;
    worker_data->platform_workers_ready-><span class="hljs-built_in">Signal</span>(lock);
  }
  <span class="hljs-comment">// 不断处理任务队列里的任务</span>
  <span class="hljs-keyword">while</span> (std::unique_ptr&#x3C;Task> task = pending_worker_tasks-><span class="hljs-built_in">BlockingPop</span>()) {
    task-><span class="hljs-built_in">Run</span>();
    pending_worker_tasks-><span class="hljs-built_in">NotifyOfCompletion</span>();
  }
}
</code></pre>
<p>子线程的逻辑很简单，就是遍历任务队列然后执行每个任务。接着看两个产生任务的函数。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 直接提交到线程池的任务队列</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NodePlatform::CallOnWorkerThread</span><span class="hljs-params">(std::unique_ptr&#x3C;Task> task)</span> </span>{
  worker_thread_task_runner_-><span class="hljs-built_in">PostTask</span>(std::<span class="hljs-built_in">move</span>(task));
}

<span class="hljs-comment">// 提交到延迟任务处理线程，超时后再提交到线程池的任务队列</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NodePlatform::CallDelayedOnWorkerThread</span><span class="hljs-params">(std::unique_ptr&#x3C;Task> task,
                                             <span class="hljs-type">double</span> delay_in_seconds)</span> </span>{
  worker_thread_task_runner_-><span class="hljs-built_in">PostDelayedTask</span>(std::<span class="hljs-built_in">move</span>(task),
                                              delay_in_seconds);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WorkerThreadsTaskRunner::PostTask</span><span class="hljs-params">(std::unique_ptr&#x3C;Task> task)</span> </span>{
  pending_worker_tasks_.<span class="hljs-built_in">Push</span>(std::<span class="hljs-built_in">move</span>(task));
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WorkerThreadsTaskRunner::PostDelayedTask</span><span class="hljs-params">(std::unique_ptr&#x3C;Task> task,
                                              <span class="hljs-type">double</span> delay_in_seconds)</span> </span>{
  delayed_task_scheduler_-><span class="hljs-built_in">PostDelayedTask</span>(std::<span class="hljs-built_in">move</span>(task), delay_in_seconds);
}
</code></pre>
<p>V8 GC 时会执行上面的函数提交任务，比如回收 ArrayBuffer 内存时。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ArrayBufferSweeper::RequestSweep</span><span class="hljs-params">(SweepingType type)</span> </span>{
   V8::<span class="hljs-built_in">GetCurrentPlatform</span>()-><span class="hljs-built_in">CallOnWorkerThread</span>(std::<span class="hljs-built_in">move</span>(task));
}
</code></pre>
<p>又或者新生代 GC 时。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95fb0fd34d6a49888743847c753d6283~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>Node.js 中，除了借助子线程处理任务外，还会借助主线程处理任务。具体在 Node.js 初始化时执行的 platform->RegisterIsolate(isolate_, event_loop)。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NodePlatform::RegisterIsolate</span><span class="hljs-params">(Isolate* isolate, <span class="hljs-type">uv_loop_t</span>* loop)</span> </span>{
  <span class="hljs-function">Mutex::ScopedLock <span class="hljs-title">lock</span><span class="hljs-params">(per_isolate_mutex_)</span></span>;
  <span class="hljs-keyword">auto</span> delegate = std::<span class="hljs-built_in">make_shared</span>&#x3C;PerIsolatePlatformData>(isolate, loop);
  IsolatePlatformDelegate* ptr = delegate.<span class="hljs-built_in">get</span>();
  <span class="hljs-keyword">auto</span> insertion = per_isolate_.<span class="hljs-built_in">emplace</span>(
    isolate,
    std::<span class="hljs-built_in">make_pair</span>(ptr, std::<span class="hljs-built_in">move</span>(delegate)));
}
</code></pre>
<p>RegisterIsolate 用于在 Platform 的 map 数据结构插入一个键对值。这里的核心数据结构是 PerIsolatePlatformData。PerIsolatePlatformData 负责管理由主线程处理的任务。</p>
<pre><code class="hljs language-c++">PerIsolatePlatformData::<span class="hljs-built_in">PerIsolatePlatformData</span>(
    Isolate* isolate, <span class="hljs-type">uv_loop_t</span>* loop)
  : <span class="hljs-built_in">isolate_</span>(isolate), <span class="hljs-built_in">loop_</span>(loop) {
  flush_tasks_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">uv_async_t</span>();
  <span class="hljs-built_in">CHECK_EQ</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">uv_async_init</span>(loop, flush_tasks_, FlushTasks));
  flush_tasks_->data = <span class="hljs-built_in">static_cast</span>&#x3C;<span class="hljs-type">void</span>*>(<span class="hljs-keyword">this</span>);
  <span class="hljs-built_in">uv_unref</span>(<span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">uv_handle_t</span>*>(flush_tasks_));
}
</code></pre>
<p>PerIsolatePlatformData 中初始化了一个 async handle，用于其他子线程提交任务时通知主线程处理。接着看一下如何提交任务。</p>
<pre><code class="hljs language-c++">platform-><span class="hljs-built_in">GetForegroundTaskRunner</span>(isolate)-><span class="hljs-built_in">PostTask</span>(std::<span class="hljs-built_in">move</span>(task));
</code></pre>
<p>GetForegroundTaskRunner 代码如下。</p>
<pre><code class="hljs language-c++"><span class="hljs-function">std::shared_ptr&#x3C;v8::TaskRunner> <span class="hljs-title">NodePlatform::GetForegroundTaskRunner</span><span class="hljs-params">(Isolate* isolate)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ForIsolate</span>(isolate)-><span class="hljs-built_in">GetForegroundTaskRunner</span>();
}

<span class="hljs-function">std::shared_ptr&#x3C;v8::TaskRunner> <span class="hljs-title">PerIsolatePlatformData::GetForegroundTaskRunner</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();
}
</code></pre>
<p>接着看 PerIsolatePlatformData 的 PostTask 和 PostDelayedTask。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PerIsolatePlatformData::PostTask</span><span class="hljs-params">(std::unique_ptr&#x3C;Task> task)</span> </span>{
  foreground_tasks_.<span class="hljs-built_in">Push</span>(std::<span class="hljs-built_in">move</span>(task));
  <span class="hljs-built_in">uv_async_send</span>(flush_tasks_);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PerIsolatePlatformData::PostDelayedTask</span><span class="hljs-params">(
    std::unique_ptr&#x3C;Task> task, <span class="hljs-type">double</span> delay_in_seconds)</span> </span>{
  <span class="hljs-function">std::unique_ptr&#x3C;DelayedTask> <span class="hljs-title">delayed</span><span class="hljs-params">(<span class="hljs-keyword">new</span> DelayedTask())</span></span>;
  delayed->task = std::<span class="hljs-built_in">move</span>(task);
  delayed->platform_data = <span class="hljs-built_in">shared_from_this</span>();
  delayed->timeout = delay_in_seconds;
  foreground_delayed_tasks_.<span class="hljs-built_in">Push</span>(std::<span class="hljs-built_in">move</span>(delayed));
  <span class="hljs-built_in">uv_async_send</span>(flush_tasks_);
}
</code></pre>
<p>这两个函数的逻辑比较简单。往相应的任务队列插入一个新的任务，然后通知主线程处理。接着看任务处理函数。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PerIsolatePlatformData::FlushTasks</span><span class="hljs-params">(<span class="hljs-type">uv_async_t</span>* handle)</span> </span>{
  <span class="hljs-keyword">auto</span> platform_data = <span class="hljs-built_in">static_cast</span>&#x3C;PerIsolatePlatformData*>(handle->data);
  platform_data-><span class="hljs-built_in">FlushForegroundTasksInternal</span>();
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PerIsolatePlatformData::FlushForegroundTasksInternal</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-type">bool</span> did_work = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">// 处理延时任务</span>
  <span class="hljs-keyword">while</span> (std::unique_ptr&#x3C;DelayedTask> delayed =
      foreground_delayed_tasks_.<span class="hljs-built_in">Pop</span>()) {
    did_work = <span class="hljs-literal">true</span>;
    <span class="hljs-type">uint64_t</span> delay_millis = <span class="hljs-built_in">llround</span>(delayed->timeout * <span class="hljs-number">1000</span>);

    delayed->timer.data = <span class="hljs-built_in">static_cast</span>&#x3C;<span class="hljs-type">void</span>*>(delayed.<span class="hljs-built_in">get</span>());
    <span class="hljs-built_in">uv_timer_init</span>(loop_, &#x26;delayed->timer);
    <span class="hljs-comment">// 启动定时器，超时后通过 RunForegroundTask 执行真正的任务</span>
    <span class="hljs-built_in">uv_timer_start</span>(&#x26;delayed->timer, RunForegroundTask, delay_millis, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">uv_unref</span>(<span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">uv_handle_t</span>*>(&#x26;delayed->timer));
    uv_handle_count_++;
  }
  <span class="hljs-comment">// 处理普通任务</span>
  std::queue&#x3C;std::unique_ptr&#x3C;Task>> tasks = foreground_tasks_.<span class="hljs-built_in">PopAll</span>();
  <span class="hljs-keyword">while</span> (!tasks.<span class="hljs-built_in">empty</span>()) {
    std::unique_ptr&#x3C;Task> task = std::<span class="hljs-built_in">move</span>(tasks.<span class="hljs-built_in">front</span>());
    tasks.<span class="hljs-built_in">pop</span>();
    did_work = <span class="hljs-literal">true</span>;
    <span class="hljs-built_in">RunForegroundTask</span>(std::<span class="hljs-built_in">move</span>(task));
  }
  <span class="hljs-keyword">return</span> did_work;
}
</code></pre>
<p>FlushTasks 的逻辑就是遍历两个任务队列，如果是普通任务队列则直接执行任务函数，如果是延迟队列则先启动一个定时器，等到定时器超时时再执行真正的任务函数。下面是一种使用的情况。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c232d43fe954d55a0e4127bb4f1fbd1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h3>创建 Environment 对象</h3>
<p>初始化完 V8 Platform 后，接着创建 Environment 对象。Node.js 中 Environment 类（env.h）是一个很重要的类，主要用于包括一些公共的数据结构和逻辑，每一个线程对应一个 Environment 对象。Environment 类非常庞大，看一下初始化的代码</p>
<pre><code class="hljs language-c++">Environment::<span class="hljs-built_in">Environment</span>(IsolateData* isolate_data,  
                         Local&#x3C;Context> context,  
                         <span class="hljs-type">const</span> std::vector&#x3C;std::string>&#x26; args,  
                         <span class="hljs-type">const</span> std::vector&#x3C;std::string>&#x26; exec_args,  
                         Flags flags,  
                         <span class="hljs-type">uint64_t</span> thread_id)  
    : <span class="hljs-built_in">isolate_</span>(context-><span class="hljs-built_in">GetIsolate</span>()),  
      <span class="hljs-built_in">isolate_data_</span>(isolate_data),
      <span class="hljs-comment">// ... </span>
      <span class="hljs-built_in">context_</span>(context-><span class="hljs-built_in">GetIsolate</span>(), context) { 
  <span class="hljs-comment">// 保存命令行参数</span>
  options_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">EnvironmentOptions</span>(*isolate_data-><span class="hljs-built_in">options</span>()->per_env));   
  <span class="hljs-comment">// inspector agent，用于调试诊断</span>
  inspector_agent_ = std::<span class="hljs-built_in">make_unique</span>&#x3C;inspector::Agent>(<span class="hljs-keyword">this</span>);
  <span class="hljs-comment">// 关联 context 和 env  </span>
  <span class="hljs-built_in">AssignToContext</span>(context, <span class="hljs-built_in">ContextInfo</span>(<span class="hljs-string">""</span>));  
  <span class="hljs-comment">// 创建其它对象  </span>
  <span class="hljs-built_in">CreateProperties</span>();  
}  
</code></pre>
<p>我们只看一下 AssignToContext 和 CreateProperties。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Environment::AssignToContext</span><span class="hljs-params">(v8::Local&#x3C;v8::Context> context,  
                                         <span class="hljs-type">const</span> ContextInfo&#x26; info)</span> </span>{  
  <span class="hljs-comment">// 在 context 中保存 env 对象                                           </span>
  context-><span class="hljs-built_in">SetAlignedPointerInEmbedderData</span>(ContextEmbedderIndex::kEnvironment, <span class="hljs-keyword">this</span>);  
}  
</code></pre>
<p>AssignToContext 用于保存 context 和 env 的关系，这个逻辑非常重要，因为后续执行代码时，我们会进入 V8 的领域，这时候，我们只知道 Isolate 和 context。如果不保存 context 和 env 的关系，我们就不知道当前所属的 env。我们看一下如何获取对应的 env。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> Environment* <span class="hljs-title">Environment::GetCurrent</span><span class="hljs-params">(v8::Isolate* isolate)</span> </span>{  
  <span class="hljs-function">v8::HandleScope <span class="hljs-title">handle_scope</span><span class="hljs-params">(isolate)</span></span>;  
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetCurrent</span>(isolate-><span class="hljs-built_in">GetCurrentContext</span>());  
}  
  
<span class="hljs-function"><span class="hljs-keyword">inline</span> Environment* <span class="hljs-title">Environment::GetCurrent</span><span class="hljs-params">(v8::Local&#x3C;v8::Context> context)</span> </span>{  
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&#x3C;Environment*>(  
      context-><span class="hljs-built_in">GetAlignedPointerFromEmbedderData</span>(ContextEmbedderIndex::kEnvironment));  
}  
</code></pre>
<p>接着看一下 CreateProperties 中创建 process 对象的逻辑。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Environment::CreateProperties</span><span class="hljs-params">()</span> </span>{
  Local&#x3C;Object> process_object = node::<span class="hljs-built_in">CreateProcessObject</span>(<span class="hljs-keyword">this</span>).<span class="hljs-built_in">FromMaybe</span>(<span class="hljs-built_in">Local</span>&#x3C;Object>());
  <span class="hljs-comment">// 保存到 Environment 对象中</span>
  <span class="hljs-built_in">set_process_object</span>(process_object);
}

<span class="hljs-comment">// node::CreateProcessObject</span>
<span class="hljs-function">MaybeLocal&#x3C;Object> <span class="hljs-title">CreateProcessObject</span><span class="hljs-params">(Environment* env)</span> </span>{
  Isolate* isolate = env-><span class="hljs-built_in">isolate</span>();
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(isolate)</span></span>;
  Local&#x3C;Context> context = env-><span class="hljs-built_in">context</span>();
  <span class="hljs-comment">// 创建一个函数模版</span>
  Local&#x3C;FunctionTemplate> process_template = FunctionTemplate::<span class="hljs-built_in">New</span>(isolate);
  process_template-><span class="hljs-built_in">SetClassName</span>(env-><span class="hljs-built_in">process_string</span>());
  Local&#x3C;Function> process_ctor;
  Local&#x3C;Object> process;
  <span class="hljs-comment">// 基于函数模版创建一个函数，并通过这个函数创建一个对象</span>
  <span class="hljs-keyword">if</span> (!process_template-><span class="hljs-built_in">GetFunction</span>(context).<span class="hljs-built_in">ToLocal</span>(&#x26;process_ctor) ||
      !process_ctor-><span class="hljs-built_in">NewInstance</span>(context).<span class="hljs-built_in">ToLocal</span>(&#x26;process)) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">MaybeLocal</span>&#x3C;Object>();
  }
  <span class="hljs-comment">// 给 process 对象设置属性，就是我们在 JS 层可以获取的那些字段</span>
  <span class="hljs-comment">// process.version</span>
  <span class="hljs-built_in">READONLY_PROPERTY</span>(process,
                    <span class="hljs-string">"version"</span>,
                    <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(env-><span class="hljs-built_in">isolate</span>(), NODE_VERSION));

  <span class="hljs-comment">// process.versions</span>
  Local&#x3C;Object> versions = Object::<span class="hljs-built_in">New</span>(env-><span class="hljs-built_in">isolate</span>());
  <span class="hljs-built_in">READONLY_PROPERTY</span>(process, <span class="hljs-string">"versions"</span>, versions);
}
</code></pre>
<p>CreateProperties 创建了 process 对象并设置了一些属性，process 对象就是我们在 JS 层用使用的 process 对象，除了在 C++ 层设置属性外，在后续的启动过程，JS 层也会设置很多属性。</p>
<h3>初始化 Libuv 任务</h3>
<p>创建完 Environment 对象后，接着执行 InitializeLibuv 初始化 Libuv 相关的数据结构以及往 Libuv 中提交任务。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Environment::InitializeLibuv</span><span class="hljs-params">(<span class="hljs-type">bool</span> start_profiler_idle_notifier)</span> </span>{  
  <span class="hljs-built_in">uv_unref</span>(<span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">uv_handle_t</span>*>(<span class="hljs-built_in">timer_handle</span>()));  
  <span class="hljs-built_in">uv_check_init</span>(<span class="hljs-built_in">event_loop</span>(), <span class="hljs-built_in">immediate_check_handle</span>());  
  <span class="hljs-built_in">uv_unref</span>(<span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">uv_handle_t</span>*>(<span class="hljs-built_in">immediate_check_handle</span>()));
  <span class="hljs-built_in">uv_idle_init</span>(<span class="hljs-built_in">event_loop</span>(), <span class="hljs-built_in">immediate_idle_handle</span>());  
  <span class="hljs-built_in">uv_check_start</span>(<span class="hljs-built_in">immediate_check_handle</span>(), CheckImmediate);  
  <span class="hljs-built_in">uv_prepare_init</span>(<span class="hljs-built_in">event_loop</span>(), &#x26;idle_prepare_handle_);  
  <span class="hljs-built_in">uv_check_init</span>(<span class="hljs-built_in">event_loop</span>(), &#x26;idle_check_handle_);  
  <span class="hljs-built_in">uv_async_init</span>(  
      <span class="hljs-built_in">event_loop</span>(),  
      &#x26;task_queues_async_,  
      [](<span class="hljs-type">uv_async_t</span>* async) {  
        <span class="hljs-comment">// ...</span>
      });  
  <span class="hljs-built_in">uv_unref</span>(<span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">uv_handle_t</span>*>(&#x26;idle_prepare_handle_));  
  <span class="hljs-built_in">uv_unref</span>(<span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">uv_handle_t</span>*>(&#x26;idle_check_handle_));  
  <span class="hljs-built_in">uv_unref</span>(<span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">uv_handle_t</span>*>(&#x26;task_queues_async_));  
  <span class="hljs-comment">// …</span>
}  
</code></pre>
<p>这些函数都是 Libuv 提供的，分别是往 Libuv 不同阶段插入任务节点，uv_unref 是修改状态为 inactived，避免影响事件循环的退出。</p>
<ol>
<li>timer_handle 是实现 Node.js 中定时器的数据结构，对应 Libuv 的 time 阶段。</li>
</ol>

<ol start="2">
<li>immediate_check_handle 是实现 Node.js 中 setImmediate 的数据结构，对应 Libuv 的check 阶段。</li>
</ol>

<ol start="3">
<li>immediate_idle_handle 也是实现 Node.js 中 setImmediate 的数据结构，对应 Libuv 的 idle 阶段。</li>
</ol>

<ol start="4">
<li>task_queues_async_ 用于子线程和主线程通信。</li>
</ol>
<p>这里主要讲一下 4，其他的后面的课程再详细讲解。task_queues_async_ 用于其他子线程往启动线程提交一些任务，比如以下情况。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> Fn>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Environment::SetImmediateThreadsafe</span><span class="hljs-params">(Fn&#x26;&#x26; cb)</span> </span>{
  <span class="hljs-keyword">auto</span> callback = std::make_unique&#x3C;NativeImmediateCallbackImpl&#x3C;Fn>>(
      std::<span class="hljs-built_in">move</span>(cb), <span class="hljs-literal">false</span>);
  {
    <span class="hljs-function">Mutex::ScopedLock <span class="hljs-title">lock</span><span class="hljs-params">(native_immediates_threadsafe_mutex_)</span></span>;
    native_immediates_threadsafe_.<span class="hljs-built_in">Push</span>(std::<span class="hljs-built_in">move</span>(callback));
  }
  <span class="hljs-built_in">uv_async_send</span>(&#x26;task_queues_async_);
}

<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> Fn>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Environment::RequestInterrupt</span><span class="hljs-params">(Fn&#x26;&#x26; cb)</span> </span>{
  <span class="hljs-keyword">auto</span> callback = std::make_unique&#x3C;NativeImmediateCallbackImpl&#x3C;Fn>>(
      std::<span class="hljs-built_in">move</span>(cb), <span class="hljs-literal">false</span>);
  {
    <span class="hljs-function">Mutex::ScopedLock <span class="hljs-title">lock</span><span class="hljs-params">(native_immediates_threadsafe_mutex_)</span></span>;
    native_immediates_interrupts_.<span class="hljs-built_in">Push</span>(std::<span class="hljs-built_in">move</span>(callback));
  }
  <span class="hljs-built_in">uv_async_send</span>(&#x26;task_queues_async_);
  <span class="hljs-built_in">RequestInterruptFromV8</span>();
}
</code></pre>
<p>可以看到两个不同的函数会往两个不同的任务队列里插入一个任务，然后调用 uv_async_send 通知启动线程有任务需要处理。</p>
<pre><code class="hljs language-c++">  <span class="hljs-built_in">uv_async_init</span>(
      <span class="hljs-built_in">event_loop</span>(),
      &#x26;task_queues_async_,
      [](<span class="hljs-type">uv_async_t</span>* async) {
        Environment* env = <span class="hljs-built_in">ContainerOf</span>(&#x26;Environment::task_queues_async_, async);
        <span class="hljs-comment">// 处理队列里的任务</span>
        env-><span class="hljs-built_in">RunAndClearNativeImmediates</span>();
  });
</code></pre>
<p>这个逻辑很简单，主要是利用了 Libuv 提供的线程间通信机制，不过值得注意的是 Environment::RequestInterrupt 函数。该函数里调用了 RequestInterruptFromV8 和 uv_async_send 两个函数通知启动线程，这是为什么呢？因为 uv_async_send 只是通知启动线程有任务处理，且如果启动线程正阻塞在事件驱动模块，则唤醒启动线程，但是如果启动线程正在繁忙地执行 JS，甚至陷入了 JS 死循环里了，那么插入的任务就无法被处理了，这正是 RequestInterruptFromV8 解决的问题，RequestInterruptFromV8 是对 isolate()->RequestInterrupt 的封装，它是线程安全的，用于往 V8 插入一个任务，这个任务哪怕在 JS 死循环时也会被执行。通过 V8 的 Libuv 两种机制的配合，就可以保证这个任务一定会被执行，利用这个能力，我们可以做很多有趣的事情，同时也可以解决 Node.js 单线程带来的一些限制。</p>
<h3>初始化 Loader</h3>
<p>初始化 Libuv 的数据结构后，接着执行 RunBootstrapping 初始化模块加载器和执行内部的 JS 代码，对应的函数分别是 BootstrapInternalLoaders 和 BootstrapNode 函数。BootstrapInternalLoaders 首先定义一个变量，该变量是一个字符串数组，用于定义函数的形参列表，一会我们会看到它的作用。</p>
<pre><code class="hljs language-c++">std::vector&#x3C;Local&#x3C;String>> loaders_params = {  
      <span class="hljs-built_in">process_string</span>(),  
      <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(isolate_, <span class="hljs-string">"getLinkedBinding"</span>),  
      <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(isolate_, <span class="hljs-string">"getInternalBinding"</span>),  
      <span class="hljs-built_in">primordials_string</span>()
};  
</code></pre>
<p>然后再定义一个变量，是一个对象数组，用作执行函数时的实参。</p>
<pre><code class="hljs language-c++">    std::vector&#x3C;Local&#x3C;Value>> loaders_args = {  
         <span class="hljs-comment">// 刚才创建的 process 对象</span>
         <span class="hljs-built_in">process_object</span>(),  
         <span class="hljs-built_in">NewFunctionTemplate</span>(binding::GetLinkedBinding)  
             -><span class="hljs-built_in">GetFunction</span>(<span class="hljs-built_in">context</span>())  
             .<span class="hljs-built_in">ToLocalChecked</span>(),  
         <span class="hljs-built_in">NewFunctionTemplate</span>(binding::GetInternalBinding)  
             -><span class="hljs-built_in">GetFunction</span>(<span class="hljs-built_in">context</span>())  
             .<span class="hljs-built_in">ToLocalChecked</span>(),  
         <span class="hljs-built_in">primordials</span>()};  
</code></pre>
<p>接着 Node.js 编译执行 internal/bootstrap/loaders.js。</p>
<pre><code class="hljs language-c++"><span class="hljs-built_in">ExecuteBootstrapper</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"internal/bootstrap/loaders"</span>, &#x26;loaders_params, &#x26;loaders_args);
</code></pre>
<p>这个过程链路非常长，最后到 V8 层，就不贴出具体的代码，具体的逻辑转成 JS 如下。</p>
<pre><code class="hljs language-js">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">process, 
                  getLinkedBinding, 
                  getInternalBinding, 
                  primordials</span>) {  
      <span class="hljs-comment">// internal/bootstrap/loaders.js 的代码  </span>
    }  
    <span class="hljs-keyword">const</span> process = {};  
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLinkedBinding</span>(<span class="hljs-params"></span>){}  
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getInternalBinding</span>(<span class="hljs-params"></span>) {}  
    <span class="hljs-keyword">const</span> primordials = {};  
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">export</span> = <span class="hljs-title function_">demo</span>(process, 
                        getLinkedBinding, 
                        getInternalBinding, 
                        primordials);  
</code></pre>
<p>V8 会把 internal/bootstrap/loaders.js 的代码用一个函数包裹起来，形参就是 loaders_params 变量对应的四个字符串。然后执行这个函数，并且传入 loaders_args 里的那四个对象。在看 internal/bootstrap/loaders.js 代码之前，我们先看一下 getLinkedBinding, getInternalBinding 这两个函数，Node.js 在 C++ 层对外暴露了AddLinkedBinding 方法注册模块，Node.js 针对这种类型的模块，维护了一个单独的链表。getLinkedBinding 就是根据模块名从这个链表中找到对应的模块，但是我们一般用不到这个，所以就不深入分析。前面我们看到对于 C++ 内置模块，Node.js 同样维护了一个链表，getInternalBinding 就是根据模块名从这个链表中找到对应的模块。现在我们可以具体看一下 internal/bootstrap/loaders.js 的代码了。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> internalBinding;  
{  
  <span class="hljs-keyword">const</span> bindingObj = <span class="hljs-title class_">ObjectCreate</span>(<span class="hljs-literal">null</span>);  
  internalBinding = <span class="hljs-keyword">function</span> <span class="hljs-title function_">internalBinding</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) {  
    <span class="hljs-keyword">let</span> mod = bindingObj[<span class="hljs-variable language_">module</span>];  
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> mod !== <span class="hljs-string">'object'</span>) {  
      <span class="hljs-comment">// C++ 层传进来的 C++ 模块加载器</span>
      mod = bindingObj[<span class="hljs-variable language_">module</span>] = <span class="hljs-title function_">getInternalBinding</span>(<span class="hljs-variable language_">module</span>);
      moduleLoadList.<span class="hljs-title function_">push</span>(<span class="hljs-string">`Internal Binding <span class="hljs-subst">${<span class="hljs-variable language_">module</span>}</span>`</span>);  
    }  
    <span class="hljs-keyword">return</span> mod;  
  };  
}  
</code></pre>
<p>Node.js 在 JS 中对 getInternalBinding 进行了一个封装，主要是加了缓存处理，在 JS 里就可以通过 internalBinding 加载 C++ 模块。接着看下面的代码。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> internalBindingWhitelist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeSet</span>([,  
  <span class="hljs-string">'tcp_wrap'</span>,  
  <span class="hljs-comment">// 一系列C++内置模块名  </span>
]);  
  
{  
  <span class="hljs-keyword">const</span> bindingObj = <span class="hljs-title class_">ObjectCreate</span>(<span class="hljs-literal">null</span>);  
  process.<span class="hljs-property">binding</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">binding</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) {  
    <span class="hljs-variable language_">module</span> = <span class="hljs-title class_">String</span>(<span class="hljs-variable language_">module</span>);  
    <span class="hljs-keyword">if</span> (internalBindingWhitelist.<span class="hljs-title function_">has</span>(<span class="hljs-variable language_">module</span>)) {  
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">internalBinding</span>(<span class="hljs-variable language_">module</span>);  
    }  
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`No such module: <span class="hljs-subst">${<span class="hljs-variable language_">module</span>}</span>`</span>);  
  };
}  
</code></pre>
<p>给 process 挂载里一个 binding 函数用于加载 C++ 模块，但是它只能加载白名单里的 C++ 模块。除了 C++ 模块外，我们知道 Node.js 中还有原生的 JS 模块，对于加载原生JS 模块的处理。Node.js 通过 nativeModuleRequire 加载，后面的模块加载器课程时我们再详细讲解。最后返回这两个模块加载器给C++层。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">return</span>{  
  internalBinding,  
  <span class="hljs-attr">require</span>: nativeModuleRequire  
};  
</code></pre>
<p>C++ 层保存其中两个函数，分别用于加载内置 C++ 模块和原生 JS 模块的函数。</p>
<pre><code class="hljs language-c++"><span class="hljs-built_in">set_internal_binding_loader</span>(internal_binding_loader.<span class="hljs-built_in">As</span>&#x3C;Function>());
<span class="hljs-built_in">set_native_module_require</span>(require.<span class="hljs-built_in">As</span>&#x3C;Function>());   
</code></pre>
<p>至此，internal/bootstrap/loaders.js 分析完了。</p>
<h3>执行内部 JS 代码</h3>
<p>初始化完模块加载器后，接着通过 BootstrapNode 执行内部的 JS 代码，代码如下</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 获取全局变量并设置 global 属性，就是我们在 JS 层使用的 global 对象</span>
Local&#x3C;Object> global = <span class="hljs-built_in">context</span>()-><span class="hljs-built_in">Global</span>();  
global-><span class="hljs-built_in">Set</span>(<span class="hljs-built_in">context</span>(), <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(isolate_, <span class="hljs-string">"global"</span>), global).<span class="hljs-built_in">Check</span>();  
<span class="hljs-comment">/*
  执行 internal/bootstrap/node.js 时的参数
  process, require, internalBinding, primordials
*/</span>
std::vector&#x3C;Local&#x3C;String>> node_params = {
    <span class="hljs-built_in">process_string</span>(),
    <span class="hljs-built_in">require_string</span>(),
    <span class="hljs-built_in">internal_binding_string</span>(),
    <span class="hljs-built_in">primordials_string</span>()};
std::vector&#x3C;Local&#x3C;Value>> node_args = {
    <span class="hljs-built_in">process_object</span>(),
    <span class="hljs-comment">// 原生模块加载器</span>
    <span class="hljs-built_in">native_module_require</span>(),
    <span class="hljs-comment">// C++ 模块加载器</span>
    <span class="hljs-built_in">internal_binding_loader</span>(),
    <span class="hljs-built_in">primordials</span>()};

<span class="hljs-built_in">ExecuteBootstrapper</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"internal/bootstrap/node"</span>, &#x26;node_params, &#x26;node_args);
<span class="hljs-built_in">ExecuteBootstrapper</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"internal/bootstrap/switches/is_main_thread"</span>, &#x26;node_params, &#x26;node_args);  
<span class="hljs-built_in">ExecuteBootstrapper</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"internal/bootstrap/switches/does_own_process_state"</span>, &#x26;node_params, &#x26;node_args); 
</code></pre>
<p>首先在全局对象上设置一个 global 属性，值是一个全局对象，这就是我们在 Node.js 中使用的 global 对象。接着传入刚才保存的模块加载器，执行三个 JS 文件的代码，这三个文件的代码主要是挂载属性和做一些初始化工作。</p>
<pre><code class="hljs language-js">process.<span class="hljs-property">cpuUsage</span>= wrapped.<span class="hljs-property">cpuUsage</span>;  
process.<span class="hljs-property">resourceUsage</span> = wrapped.<span class="hljs-property">resourceUsage</span>;  
process.<span class="hljs-property">memoryUsage</span> = wrapped.<span class="hljs-property">memoryUsage</span>;  
process.<span class="hljs-property">kill</span> = wrapped.<span class="hljs-property">kill</span>;  
process.<span class="hljs-property">exit</span> = wrapped.<span class="hljs-property">exit</span>;  
</code></pre>
<p>设置全局变量</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">defineOperation</span>(<span class="hljs-variable language_">global</span>, <span class="hljs-string">'clearInterval'</span>, timers.<span class="hljs-property">clearInterval</span>);  
<span class="hljs-title function_">defineOperation</span>(<span class="hljs-variable language_">global</span>, <span class="hljs-string">'clearTimeout'</span>, timers.<span class="hljs-property">clearTimeout</span>);  
<span class="hljs-title function_">defineOperation</span>(<span class="hljs-variable language_">global</span>, <span class="hljs-string">'setInterval'</span>, timers.<span class="hljs-property">setInterval</span>);  
<span class="hljs-title function_">defineOperation</span>(<span class="hljs-variable language_">global</span>, <span class="hljs-string">'setTimeout'</span>, timers.<span class="hljs-property">setTimeout</span>);  
<span class="hljs-title class_">ObjectDefineProperty</span>(<span class="hljs-variable language_">global</span>, <span class="hljs-string">'process'</span>, {  
  <span class="hljs-attr">value</span>: process,  
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,  
  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,  
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>  
});  
</code></pre>
<p>这里的细节比较多，就不具体展开，后续用到的时候再单独介绍。</p>
<h3>执行用户 JS 代码</h3>
<p>经过前面一系列的操作，完成了 C++ 层的初始化，也完成了 JS 层的初始化，最终通过 StartMainThreadExecution 执行用户 JS 代码（internal/main/run_main_module.js）。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> {
  prepareMainThreadExecution
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/bootstrap/pre_execution'</span>);

<span class="hljs-title function_">prepareMainThreadExecution</span>(<span class="hljs-literal">true</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/modules/cjs/loader'</span>).<span class="hljs-property">Module</span>.<span class="hljs-title function_">runMain</span>(process.<span class="hljs-property">argv</span>[<span class="hljs-number">1</span>]);
</code></pre>
<p>但是在执行用户 JS 之前还需要处理一下事情，比如 IPC 通道，具体逻辑在 prepareMainThreadExecution。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareMainThreadExecution</span>(<span class="hljs-params">expandArgv1 = <span class="hljs-literal">false</span></span>) {
  <span class="hljs-comment">// 只列出部分</span>
  <span class="hljs-comment">// 给 process 挂载属性</span>
  <span class="hljs-title function_">patchProcessObject</span>(expandArgv1);
  <span class="hljs-comment">// IPC 处理</span>
  <span class="hljs-title function_">setupChildProcessIpcChannel</span>();
  <span class="hljs-comment">// Cluster 模块的处理</span>
  <span class="hljs-title function_">initializeClusterIPC</span>();
  <span class="hljs-comment">// 挂载 runMain，为执行用户 JS 做准备</span>
  <span class="hljs-title function_">initializeCJSLoader</span>();
  <span class="hljs-comment">// 加载预加载模块</span>
  <span class="hljs-title function_">loadPreloadModules</span>();
}
</code></pre>
<p><strong>1 给process对象挂载属性</strong></p>
<p>执行 patchProcessObject 函数（在 node_process_methods.cc 中导出）给 process 对象挂载一些列属性，不一一列举。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// process.argv  </span>
process-><span class="hljs-built_in">Set</span>(context,
             <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(isolate, <span class="hljs-string">"argv"</span>),  
             <span class="hljs-built_in">ToV8Value</span>(context, env-><span class="hljs-built_in">argv</span>()).<span class="hljs-built_in">ToLocalChecked</span>()).<span class="hljs-built_in">Check</span>();  
  
<span class="hljs-built_in">READONLY_PROPERTY</span>(process, 
                  <span class="hljs-string">"pid"</span>,  
                  Integer::<span class="hljs-built_in">New</span>(isolate, <span class="hljs-built_in">uv_os_getpid</span>())); 
</code></pre>
<p>因为 Node.js 增加了对线程的支持，有些属性需要特殊处理，比如在线程里使用 process.exit 的时候，退出的是单个线程，而不是整个进程。</p>
<p><strong>2 处理</strong> <strong>进程间通信</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupChildProcessIpcChannel</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_CHANNEL_FD</span>) {  
    <span class="hljs-keyword">const</span> fd = <span class="hljs-built_in">parseInt</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_CHANNEL_FD</span>, <span class="hljs-number">10</span>);  
    <span class="hljs-keyword">delete</span> process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_CHANNEL_FD</span>;  
    <span class="hljs-keyword">const</span> serializationMode = 
process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_CHANNEL_SERIALIZATION_MODE</span> || <span class="hljs-string">'json'</span>;  
    <span class="hljs-keyword">delete</span> process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_CHANNEL_SERIALIZATION_MODE</span>;  
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">_forkChild</span>(fd, serializationMode);  
  }  
}  
</code></pre>
<p>环境变量 NODE_CHANNEL_FD 是在创建子进程的时候设置的，如果有说明当前启动的进程是子进程，则需要处理进程间通信。</p>
<p><strong>3 处理cluster模块的</strong> <strong>进程间通信</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initializeclusterIPC</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">argv</span>[<span class="hljs-number">1</span>] &#x26;&#x26; process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_UNIQUE_ID</span>) {  
    <span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cluster'</span>);  
    cluster.<span class="hljs-title function_">_setupWorker</span>(); 
    <span class="hljs-keyword">delete</span> process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_UNIQUE_ID</span>;  
  }  
}  
</code></pre>
<p><strong>4 挂载 runMain</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initializeCJSLoader</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">CJSLoader</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/modules/cjs/loader'</span>);
  <span class="hljs-title class_">CJSLoader</span>.<span class="hljs-property">Module</span>.<span class="hljs-property">runMain</span> =
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/modules/run_main'</span>).<span class="hljs-property">executeUserEntryPoint</span>;
}
</code></pre>
<p>runMain 用于执行用户 JS 代码。</p>
<p><strong>5 加载预加载模块</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadPreloadModules</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 获取需要预加载的模块</span>
  <span class="hljs-keyword">const</span> preloadModules = <span class="hljs-title function_">getOptionValue</span>(<span class="hljs-string">'--require'</span>);
  <span class="hljs-keyword">if</span> (preloadModules &#x26;&#x26; preloadModules.<span class="hljs-property">length</span> > <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> {
      <span class="hljs-title class_">Module</span>: {
        _preloadModules
      },
    } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/modules/cjs/loader'</span>);
    <span class="hljs-comment">// 加载</span>
    <span class="hljs-title function_">_preloadModules</span>(preloadModules);
  }
}
</code></pre>
<p>预加载模块会在用户 JS 代码之前被加载，所以我们可以在预加载模块里做一些 hack 的事情。</p>
<p><strong>5 执行用户</strong> <strong>JS</strong> <strong>代码</strong></p>
<pre><code class="hljs language-js"><span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/modules/cjs/loader'</span>).<span class="hljs-property">Module</span>.<span class="hljs-title function_">runMain</span>(process.<span class="hljs-property">argv</span>[<span class="hljs-number">1</span>]);  
</code></pre>
<p>这里的 require 就是 初始化 Loader 时保存到 C++ 层的原生 JS 模块加载器 nativeModuleRequire。internal/modules/cjs/loader.js 是负责加载用户 JS 的模块，runMain 做的事情是加载用户的 JS，然后执行，模块加载器课程中再详细讲解。</p>
<h3>进入Libuv事件循环</h3>
<p>执行完所有内置的初始化后，Node.js 执行了用户的 JS 代码，用户的 JS 代码通常会往事件循环中注册任务，比如创建一个服务器，最后 Node.js 进入 Libuv 的事件循环中，开始一轮又一轮的事件循环处理。如果没有需要处理的任务，Libuv 会退出，从而 Node.js 退出。</p>
<h3>总结</h3>
<p>本节课从宏观到微观的角度详细介绍了 Node.js 启动过程中所涉及的核心逻辑，包括注册 C++ 模块、Platform、Environment、Loader 的初始化、执行用户的 JS 代码和启动事件循环等。</p>
<ol>
<li>C++ 模块用于暴露底层的能力到 JS 层。</li>
</ol>

<ol start="2">
<li>Platform 用于管理多个子线程辅助 Node.js 的工作，比如 GC。</li>
</ol>

<ol start="3">
<li>Environment 用于管理 Node.js 中的公共数据结构和逻辑。</li>
</ol>

<ol start="4">
<li>Loader 用于初始化模块加载器，为后续执行代码做准备。</li>
</ol>

<ol start="5">
<li>执行用户的 JS 注册任务到事件循环。</li>
</ol>

<ol start="6">
<li>最后一个步骤是启动事件循环，这样 Node.js 就启动起来了。</li>
</ol>
<p>通过了解每一个步骤的实现以及意义，我们对 Node.js 的底层原理的理解又进了一步，同时也为我们实现简单的 JS 运行时打下了坚实的基础。</p></div>
</body></html>