<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>UDP 客户端 / 服务器的实现和特性</h1>
<p>前面两节课我们介绍了面向连接的 TCP 协议，这节课我们再介绍另一个协议：UDP。</p>
<p>UDP 是一种无连接、不可靠的传输层数据报协议，实现上不像 TCP 协议那么复杂。无连接的意思是不需要建立连接就可以往对端直接发送数据，减少了三次握手带来的时延，但是不可靠可能会导致数据丢失，所以比较适合要求时延低，少量丢包不影响整体功能的场景。</p>
<p>这节课我们就来聊一聊 UDP 的基础内容以及 Node.js 的 UDP 模块是怎么实现的。</p>
<h1>UDP 协议基础</h1>
<p>UDP 是无连接、不可靠的数据报协议。这里面有 3 个关键词：无连接、数据报和不可靠，我们一一来解释。</p>
<ol>
<li>无连接：指定目的地 IP 和端口，直接发送数据，不需要建立连接，而 TCP 通信前是需要先建立连接的，这样减少了三次握手带来的时延。</li>
<li>数据报：每次发送是一个单独的数据包，如果大小超过系统限制则报错，而 TCP 通常是把应用层的数据缓存下来，根据一定的算法组织数据发送的，并不是应用层每次调用发送函数，TCP 就会发送一个报文。</li>
<li>不可靠：UDP 只管发送，不管是否可以到达对端。发送失败的原因可能是网络问题、对端缓冲区已满或者对端没有监听对应的端口等，而 TCP 是有一套机制保证数据的可靠性，UDP 一般适合少量丢包不影响整体的场景，比如视频播放。</li>
</ol>
<h2>UDP 服务器</h2>
<p>接下来看一下在网络编程中，如何创建一个 UDP 服务器（伪代码）</p>
<pre><code class="hljs language-scss">    <span class="hljs-comment">// 申请一个socket    </span>
    int fd = <span class="hljs-built_in">socket</span>(...);    
    <span class="hljs-comment">// 绑定一个众所周知的地址，像TCP一样    </span>
    <span class="hljs-built_in">bind</span>(fd, ip， port);    
    <span class="hljs-comment">// 直接阻塞等待消息的到来，UDP不需要listen    </span>
    <span class="hljs-built_in">recvmsg</span>()；  
</code></pre>
<p>和 TCP 不同的是，UDP 只需要创建一个 socket 并绑定到某个地址，就可以接收来自任何客户端到数据，不需要建立连接。</p>
<h2>UDP 客户端</h2>
<p>接着看一下创建一个客户端的流程。客户端的流程有多种方式，原因在于源IP、端口和目的IP、端口可以有多种设置方式。不像服务器需要对外公布监听到地址，客户端可以显式绑定到某个地址，也可以由操作系统自行决定，下面我们看看各种使用方式。</p>
<h3>由操作系统决定源 IP 和端口</h3>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 申请一个socket  </span>
int fd = <span class="hljs-built_in">socket</span>(...);  
<span class="hljs-comment">// 给服务器发送数据  </span>
<span class="hljs-built_in">sendto</span>(fd, 服务器ip,服务器端口, data)  
</code></pre>
<p>客户端只需要申请一个 socket，然后调用 sendto 函数就可以直接发送数据了。其中发送方的地址由操作系统选择，对于 IP，如果是多宿主主机，每次调用 sendto 的时候，操作系统会动态选择源 IP。对于端口，操作系统会在第一次调用 sendto 的时候随机选择一个端口，并且不能修改，服务器的地址则在调用 sendto 函数时传入。因为 UDP 不是面向连接的，所以使用 UDP 时，不需要调用 connect 建立连接，只要我们知道服务器的地址，直接给服务器发送数据就行。另外，sendto 可以每次发送数据给不同的服务器。</p>
<h3>显式指定源 IP 和端口</h3>
<pre><code class="hljs language-scss">    <span class="hljs-comment">// 申请一个socket  </span>
    int fd = <span class="hljs-built_in">socket</span>(...);  
    <span class="hljs-comment">// 绑定一个客户端的地址  </span>
    <span class="hljs-built_in">bind</span>(fd, ip， port);  
    <span class="hljs-comment">// 给服务器发送数据  </span>
    <span class="hljs-built_in">sendto</span>(fd, 服务器ip,服务器端口, data);  
</code></pre>
<p>除了让操作系统选择发送方的地址，我们也可以使用 bind 函数来设置发送方的地址。</p>
<h3>显式绑定服务器地址</h3>
<p>除了在发送时传入服务器的地址，我们也可以提前绑定服务器地址。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 申请一个 socket  </span>
int fd = <span class="hljs-built_in">socket</span>(...);  
<span class="hljs-built_in">connect</span>(fd, 服务器 IP，服务器端口);  
<span class="hljs-comment">/*
  给服务器发送数据,或者 sendto(fd, null,null, data)，
  调用 sendto 则不需要再指定服务器 IP 和端口  
*/</span>
<span class="hljs-built_in">write</span>(fd, data);  
</code></pre>
<p>我们可以先调用 connect 绑定服务器 IP 和端口到 socket，这样后面调用发送函数时就不需要指定了，但是这个 socket 只能发送数据给绑定的服务器，除非再次调用 connect 重新绑定新的服务器地址。另外需要注意的是，如果我们调用 connect 绑定了地址后，尽量不要在发送函数中再传入地址，比如调用 sendto 时，这样可能会导致报错，例如 MacOS 下的错误信息是 Socket is already connected。</p>
<p>虽然使用方式很多，但是归根到底还是对四元组设置的管理。bind 是绑定源 IP 端口到 socket，connect 是绑定服务器 IP 端口到 socket，sendto 是动态指定服务器地址。对于源 IP 和端口，我们可以主动设置，也可以让操作系统随机选择。对于目的 IP 和端口，我们可以在发送数据前设置，也可以在发送数据时设置。</p>
<h2>发送 / 接收缓冲区</h2>
<p>前面 TCP 的课程中讲过，TCP 协议会把应用层的数据先缓存到 socket 的发送缓冲区中，然后根据算法进行发送。同样地，操作系统收到数据时，会先把数据缓存到 socket 的接收缓冲区，然后等待应用层读取。</p>
<p>UDP 也有发送和接收缓冲区的概念。但是和 TCP 不太一样，因为 UDP 是面向数据包的协议，所以发送数据时不需要缓存，而是直接发送。那么它的发送缓冲区有什么用呢？UDP 的发送缓冲区是用于控制应用层单次可以发送多少字节的数据，比如我们设置发送缓冲区大小为 1 字节，然后发送 2 字节则会报错。UDP 的接收缓冲区则和 TCP 的类似，因为操作系统收到数据时都是先缓存到 socket 的接收缓冲区，所以接收缓冲区就是控制可以累积多少还没被应用层读取的数据，如果超过这个值则会丢弃数据包，对于 TCP 协议来说，对端操作系统会主动需要重传，对于 UDP 则需要应用层进行处理，重传或忽略。</p>
<h1>Node.js 中 UDP 模块的实现</h1>
<p>了解 UDP 协议基础后，来看一下 Node.js 中 UDP 模块的实现。</p>
<h2>服务器</h2>
<p>看一下 Node.js 如何创建一个 UDP 服务器。</p>
<pre><code class="hljs language-javascript">    <span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);  
    <span class="hljs-comment">// 创建一个 UDP 对象  </span>
    <span class="hljs-keyword">const</span> server = dgram.<span class="hljs-title function_">createSocket</span>(<span class="hljs-string">'udp4'</span>);  
    <span class="hljs-comment">// 监听 UDP 数据的到来  </span>
    server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">msg, rinfo</span>) =></span> {  
      <span class="hljs-comment">// 处理数据  </span>
    });  
    <span class="hljs-comment">// 绑定端口  </span>
    server.<span class="hljs-title function_">bind</span>(<span class="hljs-number">41234</span>);  
</code></pre>
<p>我们看到创建一个 UDP 服务器很简单，绑定到端口后就可以通过 message 事件接收客户端发送的数据。看一下 createSocket 的实现。</p>
<pre><code class="hljs language-ini">function createSocket(type, listener) {  
  return new Socket(type, listener)<span class="hljs-comment">;  </span>
} 
 
function Socket(type, listener) {  
  EventEmitter.call(this)<span class="hljs-comment">;  </span>
  let lookup<span class="hljs-comment">;  </span>
  let recvBufferSize<span class="hljs-comment">;  </span>
  let sendBufferSize<span class="hljs-comment">;  </span>
  
  let options<span class="hljs-comment">;  </span>
  if (type !== null &#x26;&#x26; typeof <span class="hljs-attr">type</span> === <span class="hljs-string">'object'</span>) {  
    <span class="hljs-attr">options</span> = type<span class="hljs-comment">;  </span>
    <span class="hljs-attr">type</span> = options.type<span class="hljs-comment">;  </span>
    <span class="hljs-attr">lookup</span> = options.lookup<span class="hljs-comment">;  </span>
    <span class="hljs-attr">recvBufferSize</span> = options.recvBufferSize<span class="hljs-comment">;  </span>
    <span class="hljs-attr">sendBufferSize</span> = options.sendBufferSize<span class="hljs-comment">;  </span>
  }  
  const <span class="hljs-attr">handle</span> = newHandle(type, lookup)<span class="hljs-comment">;   </span>
  <span class="hljs-attr">this.type</span> = type<span class="hljs-comment">;  </span>
  if (typeof <span class="hljs-attr">listener</span> === <span class="hljs-string">'function'</span>)  
    this.on('message', listener)<span class="hljs-comment">;  </span>
  // 保存上下文
  this<span class="hljs-section">[kStateSymbol]</span> = {  
    handle,  
    receiving: false,  
    // 还没有执行bind
    bindState: BIND_STATE_UNBOUND,  
    connectState: CONNECT_STATE_DISCONNECTED,  
    queue: undefined,  
    // 端口复用，只使于多播   
    reuseAddr: options &#x26;&#x26; options.reuseAddr, 
    ipv6Only: options &#x26;&#x26; options.ipv6Only,  
    // 发送缓冲区和接收缓冲区大小
    recvBufferSize,  
    sendBufferSize  
  }<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>socket 对象是对底层一个 handle 的一个封装，那 handle 是什么呢？</p>
<pre><code class="hljs language-ini">function newHandle(type, lookup) {  
  // 用于 DNS 解析的函数，比如我们调 send 的时候，传的是一个域名  
  if (<span class="hljs-attr">lookup</span> === undefined) {  
    if (<span class="hljs-attr">dns</span> === undefined) {  
      <span class="hljs-attr">dns</span> = require(<span class="hljs-string">'dns'</span>)<span class="hljs-comment">;  </span>
    }  
    <span class="hljs-attr">lookup</span> = dns.lookup<span class="hljs-comment">;  </span>
  }   
  
  if (<span class="hljs-attr">type</span> === <span class="hljs-string">'udp4'</span>) {  
    const <span class="hljs-attr">handle</span> = new UDP()<span class="hljs-comment">;  </span>
    <span class="hljs-attr">handle.lookup</span> = lookup4.bind(handle, lookup)<span class="hljs-comment">;  </span>
    return handle<span class="hljs-comment">;  </span>
  }  
  // 忽略 ipv6 的处理  
}  
</code></pre>
<p>handle 是对 UDP 模块的封装，UDP 是 C++ 模块，当我们在 JS 层 new UDP 的时候，会新建一个 C++ 对象。</p>
<pre><code class="hljs language-arduino">UDPWrap::<span class="hljs-built_in">UDPWrap</span>(Environment* env, Local&#x3C;Object> object)  
    : <span class="hljs-built_in">HandleWrap</span>(env,  
                 object,  
                 <span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">uv_handle_t</span>*>(&#x26;handle_),  
                 AsyncWrap::PROVIDER_UDPWRAP) {  
  <span class="hljs-type">int</span> r = <span class="hljs-built_in">uv_udp_init</span>(env-><span class="hljs-built_in">event_loop</span>(), &#x26;handle_);  
}  

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv_udp_init</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv_udp_t</span>* handle)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">uv_udp_init_ex</span>(loop, handle, AF_UNSPEC);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv_udp_init_ex</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv_udp_t</span>* handle, <span class="hljs-type">unsigned</span> flags)</span> </span>{
  <span class="hljs-type">int</span> domain = flags &#x26; <span class="hljs-number">0xFF</span>;
  <span class="hljs-built_in">uv__udp_init_ex</span>(loop, handle, flags, domain);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv__udp_init_ex</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop,
                    <span class="hljs-type">uv_udp_t</span>* handle,
                    <span class="hljs-type">unsigned</span> flags,
                    <span class="hljs-type">int</span> domain)</span> </span>{
  <span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;
  <span class="hljs-built_in">uv__handle_init</span>(loop, (<span class="hljs-type">uv_handle_t</span>*)handle, UV_UDP);
  handle->alloc_cb = <span class="hljs-literal">NULL</span>;
  handle->recv_cb = <span class="hljs-literal">NULL</span>;
  handle->send_queue_size = <span class="hljs-number">0</span>;
  handle->send_queue_count = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// IO 观察者的回调为 uv__udp_io，可读可写时执行</span>
  <span class="hljs-built_in">uv__io_init</span>(&#x26;handle->io_watcher, uv__udp_io, fd);
  <span class="hljs-built_in">QUEUE_INIT</span>(&#x26;handle->write_queue);
  <span class="hljs-built_in">QUEUE_INIT</span>(&#x26;handle->write_completed_queue);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>创建 C++ 层的对象主要是对 Libuv 数据结构 uv_udp_t 进行了初始化，其中关键的是设置了 IO 观察者的回调是 uv__udp_io，当 socket 有数据可读或者 socket 可写时会执行 uv__udp_io。接着我们来看一下执行 bind 时候的逻辑。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">Socket.prototype.bind</span> = function(port_, address_ /* , callback */) {  
  let <span class="hljs-attr">port</span> = port_<span class="hljs-comment">;  </span>
  // socket 的上下文  
  const <span class="hljs-attr">state</span> = this[kStateSymbol]<span class="hljs-comment">;    </span>
  // 否则标记已经绑定了  
  <span class="hljs-attr">state.bindState</span> = BIND_STATE_BINDING<span class="hljs-comment">;  </span>
  // 没传地址则默认绑定所有地址  
  if (!address) {  
    if (<span class="hljs-attr">this.type</span> === <span class="hljs-string">'udp4'</span>)  
      <span class="hljs-attr">address</span> = <span class="hljs-string">'0.0.0.0'</span><span class="hljs-comment">;  </span>
    else  
      <span class="hljs-attr">address</span> = <span class="hljs-string">'::'</span><span class="hljs-comment">;  </span>
  }  
  // DNS 解析后再绑定，如果需要的话  
  state.handle.lookup(address, (err, ip) => {  
     state.handle.bind(ip, port || 0, flags)<span class="hljs-comment">;  </span>
     startListening(this)<span class="hljs-comment">;  </span>
  }
  return this<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>bind 函数主要的逻辑是 handle.bind 和 startListening。我们一个个看，首先看一下 C++ 层的 bind。</p>
<pre><code class="hljs language-ini">void UDPWrap::DoBind(const FunctionCallbackInfo&#x3C;Value>&#x26; args, int family) {  
  UDPWrap* wrap<span class="hljs-comment">;  </span>
  ASSIGN_OR_RETURN_UNWRAP(&#x26;wrap,  
                          args.Holder(),  
                          args.GetReturnValue().Set(UV_EBADF))<span class="hljs-comment">;  </span>
  node::Utf8Value address(args.GetIsolate(), args<span class="hljs-section">[0]</span>)<span class="hljs-comment">;  </span>
  Local&#x3C;Context> <span class="hljs-attr">ctx</span> = args.GetIsolate()->GetCurrentContext()<span class="hljs-comment">;  </span>
  uint32_t port, flags<span class="hljs-comment">;  </span>
  struct sockaddr_storage addr_storage<span class="hljs-comment">;  </span>
  int <span class="hljs-attr">err</span> = sockaddr_for_family(family, 
                                   address.out(), 
                                   port, 
                                   &#x26;addr_storage)<span class="hljs-comment">;  </span>
  if (<span class="hljs-attr">err</span> == <span class="hljs-number">0</span>) {  
    <span class="hljs-attr">err</span> = uv_udp_bind(&#x26;wrap->handle_,  
                      reinterpret_cast&#x3C;const sockaddr*>(&#x26;addr_storage),  
                      flags)<span class="hljs-comment">;  </span>
  }  
  
  args.GetReturnValue().Set(err)<span class="hljs-comment">;  </span>
}                  
</code></pre>
<p>DoBind 也没有太多逻辑，处理参数再执行 uv_udp_bind 设置一些标记、属性和端口复用（端口复用后续会单独分析），然后执行操作系统 bind 的函数把本端的 IP 和端口保存到 socket 中。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_udp_bind</span><span class="hljs-params">(<span class="hljs-type">uv_udp_t</span>* handle,
                <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr,
                <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span> {
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addrlen;

  <span class="hljs-keyword">if</span> (addr->sa_family == AF_INET)
    addrlen = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (addr->sa_family == AF_INET6)
    addrlen = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in6);
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">return</span> UV_EINVAL;

  <span class="hljs-keyword">return</span> uv__udp_bind(handle, addr, addrlen, flags);
}

<span class="hljs-type">int</span> <span class="hljs-title function_">uv__udp_bind</span><span class="hljs-params">(<span class="hljs-type">uv_udp_t</span>* handle,
                 <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr,
                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addrlen,
                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span> {
  <span class="hljs-type">int</span> yes;
  <span class="hljs-type">int</span> fd;
  <span class="hljs-comment">// 创建一个 UDP socket</span>
  fd = uv__socket(addr->sa_family, SOCK_DGRAM, <span class="hljs-number">0</span>);
  <span class="hljs-comment">// 保存到 handle 中</span>
  handle->io_watcher.fd = fd;
  <span class="hljs-comment">// 设置端口复用，后续单独分析</span>
  <span class="hljs-keyword">if</span> (flags &#x26; UV_UDP_REUSEADDR) {
    uv__set_reuse(fd);
  }

  <span class="hljs-keyword">if</span> (flags &#x26; UV_UDP_IPV6ONLY) {
    <span class="hljs-comment">// 设置 IPV6 Only，只能发送和接收 IPV6 的数据包</span>
    setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &#x26;yes, <span class="hljs-keyword">sizeof</span> yes);
  }
  <span class="hljs-comment">// 绑定地址到 socket</span>
  bind(fd, addr, addrlen);
  <span class="hljs-comment">// 设置已绑定地址标记</span>
  handle->flags |= UV_HANDLE_BOUND;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv__udp_bind 主要是创建了一个 UDP socket 并设置了一些标记和绑定地址到 socket 中。这样服务器就启动完成了。</p>
<h2>客户端</h2>
<p>接着我们来看一下客户端的使用方式和使用流程。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">dgram</span> = require(<span class="hljs-string">'dgram'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">message</span> = Buffer.from(<span class="hljs-string">'Some bytes'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">client</span> = dgram.createSocket(<span class="hljs-string">'udp4'</span>)<span class="hljs-comment">;  </span>
client.connect(41234, 'localhost', (err) => {  
  client.send(message, (err) => {  
    client.close()<span class="hljs-comment">;  </span>
  })<span class="hljs-comment">;  </span>
})<span class="hljs-comment">;  </span>
</code></pre>
<p>具体的流程是先调用 connect 函数绑定服务器的地址，再调用 send 函数发送信息，最后调用 close 函数关闭 socket。那我们先来看看 connect 函数的实现。</p>
<pre><code class="hljs language-kotlin">Socket.prototype.connect = function(port, address, callback) {  
  <span class="hljs-keyword">const</span> state = <span class="hljs-keyword">this</span>[kStateSymbol];  
  <span class="hljs-comment">// 设置socket状态  </span>
  state.connectState = CONNECT_STATE_CONNECTING;  
  <span class="hljs-comment">// 还没有绑定客户端地址信息，则先绑定随机地址（操作系统决定）  </span>
  <span class="hljs-keyword">if</span> (state.bindState === BIND_STATE_UNBOUND)  
    <span class="hljs-keyword">this</span>.bind({ port: <span class="hljs-number">0</span>, exclusive: <span class="hljs-literal">true</span> }, <span class="hljs-literal">null</span>);  
  <span class="hljs-comment">// 执行 bind 的时候，如果 bind 不是同步执行的，则入队等待处理，比如需要 DNS 解析</span>
  <span class="hljs-keyword">if</span> (state.bindState !== BIND_STATE_BOUND) {  
    enqueue(<span class="hljs-keyword">this</span>, _connect.bind(<span class="hljs-keyword">this</span>, port, address, callback));
    <span class="hljs-keyword">return</span>;  
  }  
  <span class="hljs-comment">// 否则继续 connect</span>
  _connect.call(<span class="hljs-keyword">this</span>, port, address, callback);  
};  
</code></pre>
<p>上面的代码逻辑分为两种情况，一种是在 connect 之前已经调用了 bind，第二种是没有调用 bind，如果没有调用 bind，则在 connect 之前先要调用 bind（这里并不是因为 UDP socket 一定需要设置客户端地址，而是因为 bind 里面会创建 socket，没有 socket 后续就无法通信）。我们只分析没有调用 bind 的情况，因为这是最长的路径。bind 刚才我们分析过了，我们从以下代码继续分析 connect 的实现。</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (state.bindState !== BIND_STATE_BOUND) {  
    enqueue(<span class="hljs-keyword">this</span>, _connect.bind(<span class="hljs-keyword">this</span>, port, address, callback)); 
    <span class="hljs-keyword">return</span>;  
}  
</code></pre>
<p>enqueue 把任务加入任务队列，并且监听了 listening 事件（该事件在 bind 成功后触发）。</p>
<pre><code class="hljs language-ini">function enqueue(self, toEnqueue) {  
  const <span class="hljs-attr">state</span> = self[kStateSymbol]<span class="hljs-comment">;  </span>
  if (<span class="hljs-attr">state.queue</span> === undefined) {  
    <span class="hljs-attr">state.queue</span> = []<span class="hljs-comment">;  </span>
    self.once('error', onListenError)<span class="hljs-comment">;  </span>
    self.once('listening', onListenSuccess)<span class="hljs-comment">;  </span>
  }  
  state.queue.push(toEnqueue)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>这时候 connect 函数就执行完了，等待 bind 成功后会执行 startListening 函数。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">startListening</span>(<span class="hljs-params">socket</span>) {  
 <span class="hljs-comment">// 触发listening事件  </span>
 socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'listening'</span>);  
}  
</code></pre>
<p>startListening 触发了 listening 事件，从而执行我们刚才入队的回调 onListenSuccess。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function">function <span class="hljs-title">onListenSuccess</span><span class="hljs-params">()</span> </span>{  
  <span class="hljs-keyword">this</span>.<span class="hljs-built_in">removeListener</span>(<span class="hljs-string">'error'</span>, onListenError);  
  clearQueue.<span class="hljs-built_in">call</span>(<span class="hljs-keyword">this</span>);  
}  
  
<span class="hljs-function">function <span class="hljs-title">clearQueue</span><span class="hljs-params">()</span> </span>{  
  <span class="hljs-type">const</span> state = <span class="hljs-keyword">this</span>[kStateSymbol];  
  <span class="hljs-type">const</span> queue = state.queue;  
  state.queue = undefined;  
  
  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> queueEntry of queue)  
    <span class="hljs-built_in">queueEntry</span>();  
}  
</code></pre>
<p>回调就是把队列中的回调执行一遍，connect 函数设置的回调是 _connect。</p>
<pre><code class="hljs language-ini">function _connect(port, address, callback) {  
  const <span class="hljs-attr">state</span> = this[kStateSymbol]<span class="hljs-comment">;  </span>

  const <span class="hljs-attr">afterDns</span> = (ex, ip) => {  
    defaultTriggerAsyncIdScope(  
      this<span class="hljs-section">[async_id_symbol]</span>,  
      doConnect,  
      ex, this, ip, address, port, callback  
    )<span class="hljs-comment">;  </span>
  }<span class="hljs-comment">;  </span>
  
  state.handle.lookup(address, afterDns)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>这里的 address 是服务器地址，_connect 函数主要逻辑是对服务器地址进行 DNS 解析。解析成功后执行 afterDns，最后执行 doConnect，并传入解析出来的 IP。看看 doConnect 函数的实现。</p>
<pre><code class="hljs language-php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doConnect</span>(<span class="hljs-params">ex, <span class="hljs-built_in">self</span>, ip, address, port, callback</span>) </span>{  
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">state</span> = <span class="hljs-built_in">self</span>[kStateSymbol];  
  <span class="hljs-comment">// DNS 解析成功，执行底层的 connect  </span>
  state.handle.<span class="hljs-title function_ invoke__">connect</span>(ip, port);  
  <span class="hljs-comment">// connect 成功，触发 connect 事件  </span>
  state.connectState = CONNECT_STATE_CONNECTED;  
  process.<span class="hljs-title function_ invoke__">nextTick</span>(() => <span class="hljs-built_in">self</span>.<span class="hljs-title function_ invoke__">emit</span>(<span class="hljs-string">'connect'</span>));  
}  
</code></pre>
<p>connect 接着调用了 C++ 层的 Connect 函数。</p>
<pre><code class="hljs language-ini">void UDPWrap::Connect(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {
  DoConnect(args, AF_INET)<span class="hljs-comment">;</span>
}

void UDPWrap::DoConnect(const FunctionCallbackInfo&#x3C;Value>&#x26; args, int family) {
  UDPWrap* wrap<span class="hljs-comment">;</span>
  ASSIGN_OR_RETURN_UNWRAP(&#x26;wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF))<span class="hljs-comment">;</span>

  node::Utf8Value address(args.GetIsolate(), args<span class="hljs-section">[0]</span>)<span class="hljs-comment">;</span>
  Local&#x3C;Context> <span class="hljs-attr">ctx</span> = args.GetIsolate()->GetCurrentContext()<span class="hljs-comment">;</span>
  uint32_t port<span class="hljs-comment">;</span>
  struct sockaddr_storage addr_storage<span class="hljs-comment">;</span>
  int <span class="hljs-attr">err</span> = sockaddr_for_family(family, address.out(), port, &#x26;addr_storage)<span class="hljs-comment">;</span>
  if (<span class="hljs-attr">err</span> == <span class="hljs-number">0</span>) {
    <span class="hljs-attr">err</span> = uv_udp_connect(&#x26;wrap->handle_,
                         reinterpret_cast&#x3C;const sockaddr*>(&#x26;addr_storage))<span class="hljs-comment">;</span>
  }

  args.GetReturnValue().Set(err)<span class="hljs-comment">;</span>
}
</code></pre>
<p>C++ 层的 Connect 函数做了些简单的处理，接着调用 Libuv 的 uv_udp_connect。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv_udp_connect</span><span class="hljs-params">(<span class="hljs-type">uv_udp_t</span>* handle, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">uv__udp_connect</span>(handle, addr, addrlen);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv__udp_connect</span><span class="hljs-params">(<span class="hljs-type">uv_udp_t</span>* handle,
                    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr,
                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addrlen)</span> </span>{

  <span class="hljs-built_in">connect</span>(handle->io_watcher.fd, addr, addrlen);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>最终调用了操作系统的 connect。UDP 的 connect 和 TCP 不一样，TCP 的 connect 会发起三次握手，UDP 的 connect 只是把服务器地址保存到 socket 中。后续发送数据时就不需要显式指定了，当然我们也可以不调用 connect，然后在发送数据时指定。connect 的流程就走完了，接下来我们就可以发送和接收数据。</p>
<h2>发送数据</h2>
<p>发送数据接口是 send（sendto 最终也是调用了 send）。</p>
<pre><code class="hljs language-kotlin">Socket.prototype.send = function(buffer,  
                                 offset,  
                                 length,  
                                 port,  
                                 address,  
                                 callback) {  
  
  let list;  
  <span class="hljs-keyword">const</span> state = <span class="hljs-keyword">this</span>[kStateSymbol];  
  <span class="hljs-keyword">const</span> connected = state.connectState === CONNECT_STATE_CONNECTED;  
  <span class="hljs-comment">// 没有调用过 connect 绑定过服务端地址，则需要传服务端地址信息  </span>
  <span class="hljs-keyword">if</span> (!connected) {  
    <span class="hljs-comment">// ...</span>
  } <span class="hljs-keyword">else</span> {  
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// 已经绑定了服务端地址，则不能再传了  </span>
    <span class="hljs-keyword">if</span> (port || address)  
      <span class="hljs-keyword">throw</span> new ERR_SOCKET_DGRAM_IS_CONNECTED();  
  }  
  <span class="hljs-comment">// 如果没有绑定服务器端口，则这里需要传，并且校验  </span>
  <span class="hljs-keyword">if</span> (!connected)  
    port = validatePort(port);  
  <span class="hljs-comment">// 忽略一些参数处理逻辑  </span>
  <span class="hljs-comment">// 没有调用过 bind，则需要先调用 bind 创建 socket，发送方地址由操作系统决定</span>
  <span class="hljs-keyword">if</span> (state.bindState === BIND_STATE_UNBOUND)  
    <span class="hljs-keyword">this</span>.bind({ port: <span class="hljs-number">0</span>, exclusive: <span class="hljs-literal">true</span> }, <span class="hljs-literal">null</span>);  
  <span class="hljs-comment">// bind 还没有完成，则先入队，等待 bind 完成再执行  </span>
  <span class="hljs-keyword">if</span> (state.bindState !== BIND_STATE_BOUND) {  
    enqueue(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.send.bind(<span class="hljs-keyword">this</span>, 
                                    list, 
                                    port, 
                                    address, 
                                    callback));  
    <span class="hljs-keyword">return</span>;  
  }  
  <span class="hljs-keyword">const</span> afterDns = (ex, ip) => {  
    defaultTriggerAsyncIdScope(  
      <span class="hljs-keyword">this</span>[async_id_symbol],  
      doSend,  
      ex, <span class="hljs-keyword">this</span>, ip, list, address, port, callback  
    );  
  };  
  
  <span class="hljs-comment">// 已经绑定服务器地址了，则直接发送，否则首先走 DNS 流程（如果传的是域名的话）</span>
  <span class="hljs-keyword">if</span> (!connected) {  
    state.handle.lookup(address, afterDns);  
  } <span class="hljs-keyword">else</span> {  
    afterDns(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);  
  }  
}  
</code></pre>
<p>send 函数很多逻辑都是和 bind 以及 connect 类似的，因为发送数据前需要保证 socket 状态的正确性，总的来说就是要保证通信时，需要有一个 socket、绑定了客户端和设置了服务器地址，接着看 doSend 函数。</p>
<pre><code class="hljs language-ini">function doSend(ex, self, ip, list, address, port, callback) {  
  const <span class="hljs-attr">state</span> = self[kStateSymbol]<span class="hljs-comment">;  </span>
  // 定义一个请求对象  
  const <span class="hljs-attr">req</span> = new SendWrap()<span class="hljs-comment">;  </span>
  <span class="hljs-attr">req.list</span> = list<span class="hljs-comment">;</span>
  <span class="hljs-attr">req.address</span> = address<span class="hljs-comment">;  </span>
  <span class="hljs-attr">req.port</span> = port<span class="hljs-comment">;  </span>
  /*
    设置 Node.js 和用户的回调，oncomplete 由 C++ 层调用，
    callback 由 oncomplete 调用 
  */ 
  if (callback) {  
    <span class="hljs-attr">req.callback</span> = callback<span class="hljs-comment">;  </span>
    <span class="hljs-attr">req.oncomplete</span> = afterSend<span class="hljs-comment">;  </span>
  }  
  
  let err<span class="hljs-comment">;  </span>
  // 根据是否需要设置服务端地址，调 C++ 层函数  
  if (port)  
    <span class="hljs-attr">err</span> = state.handle.send(req, list, list.length, port, ip, !!callback)<span class="hljs-comment">;  </span>
  else  
    <span class="hljs-attr">err</span> = state.handle.send(req, list, list.length, !!callback)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>doSend 创建了一个请求对象 SendWrap，并在其中记录了请求信息，然后调用 C++ 层的 Send。</p>
<pre><code class="hljs language-ini">void UDPWrap::Send(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {
  DoSend(args, AF_INET)<span class="hljs-comment">;</span>
}

void UDPWrap::DoSend(const FunctionCallbackInfo&#x3C;Value>&#x26; args, int family) {
  // sendto 代表还没有绑定对端地址，send 的时候才指定
  bool <span class="hljs-attr">sendto</span> = args.Length() == <span class="hljs-number">6</span><span class="hljs-comment">;</span>

  Local&#x3C;Object> <span class="hljs-attr">req_wrap_obj</span> = args[<span class="hljs-number">0</span>].As&#x3C;Object>()<span class="hljs-comment">;</span>
  Local&#x3C;Array> <span class="hljs-attr">chunks</span> = args[<span class="hljs-number">1</span>].As&#x3C;Array>()<span class="hljs-comment">;</span>
  // 待发送数据的个数，每一个里面有一部分数据
  size_t <span class="hljs-attr">count</span> = args[<span class="hljs-number">2</span>].As&#x3C;Uint32>()->Value()<span class="hljs-comment">;</span>
  const bool <span class="hljs-attr">have_callback</span> = sendto ? args[<span class="hljs-number">5</span>]->Is<span class="hljs-literal">True</span>() : args[<span class="hljs-number">3</span>]->Is<span class="hljs-literal">True</span>()<span class="hljs-comment">;</span>

  size_t <span class="hljs-attr">msg_size</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>

  MaybeStackBuffer&#x3C;uv_buf_t, 16> bufs(count)<span class="hljs-comment">;</span>

  // 数据处理
  for (size_t <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; count; i++) {</span>
    Local&#x3C;Value> <span class="hljs-attr">chunk</span> = chunks->Get(env->context(), i).ToLocalChecked()<span class="hljs-comment">;</span>

    size_t <span class="hljs-attr">length</span> = Buffer::Length(chunk)<span class="hljs-comment">;</span>

    bufs<span class="hljs-section">[i]</span> = uv_buf_init(Buffer::Data(chunk), length)<span class="hljs-comment">;</span>
    msg_size += length<span class="hljs-comment">;</span>
  }

  int <span class="hljs-attr">err</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
  struct sockaddr_storage addr_storage<span class="hljs-comment">;</span>
  sockaddr* <span class="hljs-attr">addr</span> = nullptr<span class="hljs-comment">;</span>
  // 设置了对端地址则进行处理
  if (sendto) {
    const unsigned short <span class="hljs-attr">port</span> = args[<span class="hljs-number">3</span>].As&#x3C;Uint32>()->Value()<span class="hljs-comment">;</span>
    node::Utf8Value address(env->isolate(), args<span class="hljs-section">[4]</span>)<span class="hljs-comment">;</span>
    <span class="hljs-attr">err</span> = sockaddr_for_family(family, address.out(), port, &#x26;addr_storage)<span class="hljs-comment">;</span>
    if (<span class="hljs-attr">err</span> == <span class="hljs-number">0</span>) {
      <span class="hljs-attr">addr</span> = reinterpret_cast&#x3C;sockaddr*>(&#x26;addr_storage)<span class="hljs-comment">;</span>
    }
  }
  // 待发送的数据
  uv_buf_t* <span class="hljs-attr">bufs_ptr</span> = *bufs<span class="hljs-comment">;</span>
  // 没有设置这个 flag 则尝试调 uv_udp_try_send 直接发送，
  // 失败或没有发送完毕再调 uv_udp_send 排队等待发送，发送结束后触发 JS 层回调
  // 如果直接发送成功并全部发送完毕则 JS 直接触发回调
  if (<span class="hljs-attr">err</span> == <span class="hljs-number">0</span> &#x26;&#x26; !UNLIKELY(env->options()->test_udp_no_try_send)) {
    <span class="hljs-attr">err</span> = uv_udp_try_send(&#x26;wrap->handle_, bufs_ptr, count, addr)<span class="hljs-comment">;</span>
    // 发送失败
    if (<span class="hljs-attr">err</span> == UV_ENOSYS || err == UV_EAGAIN) {
      <span class="hljs-attr">err</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    } else if (err >= 0) { // 发送成功，可能发完了也可能只发送了一部分
      // 已发送到字节数
      size_t <span class="hljs-attr">sent</span> = err<span class="hljs-comment">;</span>
      // 通过已发送的字节计算出哪些 buf 的数据被发送了，bufs_ptr 记录还没有被发送的
      while (count > 0 &#x26;&#x26; bufs_ptr->len &#x3C;= sent) {
        sent <span class="hljs-attr">-</span>= bufs_ptr->len<span class="hljs-comment">;</span>
        bufs_ptr++<span class="hljs-comment">;</span>
        count--<span class="hljs-comment">;</span>
      }
      // count > 0 说明还有数据没有被发完，
      //     此时 sent 可能是 0，恰好前几个 buf 被发完了
      //     sent 也可能非 0，说明第 n 个 buf 的数据被发送了一部分
      // 所以需要更新下一个待发送 buf 的数据指针
      if (count > 0) {
        bufs_ptr->base += sent<span class="hljs-comment">;</span>
        bufs_ptr->len <span class="hljs-attr">-</span>= sent<span class="hljs-comment">;</span>
      } else {
        // 发完了则直接返回 JS
        args.GetReturnValue().Set(static_cast&#x3C;uint32_t>(msg_size) + 1)<span class="hljs-comment">;</span>
        return<span class="hljs-comment">;</span>
      }
    }
  }
  // 否则排队等待发送
  if (<span class="hljs-attr">err</span> == <span class="hljs-number">0</span>) {
     <span class="hljs-attr">err</span> = req_wrap->Dispatch(uv_udp_send, ...)<span class="hljs-comment">;</span>
  }

  return err<span class="hljs-comment">;</span>
}
</code></pre>
<p>默认情况下，UDP 发送数据时会先尝试直接发送。</p>
<pre><code class="hljs language-ini">int uv__udp_try_send(uv_udp_t* handle,
                     const uv_buf_t bufs<span class="hljs-section">[]</span>,
                     unsigned int nbufs,
                     const struct sockaddr* addr,
                     unsigned int addrlen) {
  int err<span class="hljs-comment">;</span>
  struct msghdr h<span class="hljs-comment">;</span>
  ssize_t size<span class="hljs-comment">;</span>

  memset(&#x26;h, 0, sizeof h)<span class="hljs-comment">;</span>
  <span class="hljs-attr">h.msg_name</span> = (struct sockaddr*) addr<span class="hljs-comment">;</span>
  <span class="hljs-attr">h.msg_namelen</span> = addrlen<span class="hljs-comment">;</span>
  <span class="hljs-attr">h.msg_iov</span> = (struct iovec*) bufs<span class="hljs-comment">;</span>
  <span class="hljs-attr">h.msg_iovlen</span> = nbufs<span class="hljs-comment">;</span>

  do {
    // 发送数据
    <span class="hljs-attr">size</span> = sendmsg(handle->io_watcher.fd, &#x26;h, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
  } while (<span class="hljs-attr">size</span> == -<span class="hljs-number">1</span> &#x26;&#x26; err<span class="hljs-literal">no</span> == EINTR)<span class="hljs-comment">;</span>
  // 发送失败则返回错误码
  if (<span class="hljs-attr">size</span> == -<span class="hljs-number">1</span>) {
    if (<span class="hljs-attr">errno</span> == EAGAIN || err<span class="hljs-literal">no</span> == EWOULDBLOCK || err<span class="hljs-literal">no</span> == ENOBUFS)
      return UV_EAGAIN<span class="hljs-comment">;</span>
    else
      return UV__ERR(errno)<span class="hljs-comment">;</span>
  }

  return size<span class="hljs-comment">;</span>
}
</code></pre>
<p>如果直接发送成功且全部发送完毕则直接返回 JS 了，如果直接发送失败或者还没发送完毕则进行排队，等待可写事件触发后再调用 uv__udp_send 进行发送。</p>
<pre><code class="hljs language-rust">int <span class="hljs-title function_ invoke__">uv__udp_send</span>(uv_udp_send_t* req,
                 uv_udp_t* handle,
                 <span class="hljs-keyword">const</span> uv_buf_t bufs[],
                 unsigned int nbufs,
                 <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* addr,
                 unsigned int addrlen,
                 uv_udp_send_cb send_cb) {
  int err;
  int empty_queue;
  <span class="hljs-comment">// 当前是否没有数据等待发送，是的话可以直接进行发送操作</span>
  empty_queue = (handle<span class="hljs-punctuation">-></span>send_queue_count == <span class="hljs-number">0</span>);
  <span class="hljs-comment">// 初始化请求</span>
  <span class="hljs-title function_ invoke__">uv__req_init</span>(handle<span class="hljs-punctuation">-></span><span class="hljs-keyword">loop</span>, req, UV_UDP_SEND);
  <span class="hljs-comment">// 需要发送给哪个服务器</span>
  <span class="hljs-title function_ invoke__">if</span> (addr == NULL)
    req<span class="hljs-punctuation">-></span>addr.ss_family = AF_UNSPEC;
  <span class="hljs-keyword">else</span>
    <span class="hljs-title function_ invoke__">memcpy</span>(&#x26;req<span class="hljs-punctuation">-></span>addr, addr, addrlen);
  <span class="hljs-comment">// 记录请求上下文到请求结构体</span>
  req<span class="hljs-punctuation">-></span>send_cb = send_cb;
  req<span class="hljs-punctuation">-></span>handle = handle;
  req<span class="hljs-punctuation">-></span>nbufs = nbufs;

  req<span class="hljs-punctuation">-></span>bufs = req<span class="hljs-punctuation">-></span>bufsml;
  <span class="hljs-comment">// 默认的不够则扩容</span>
  <span class="hljs-title function_ invoke__">if</span> (nbufs > <span class="hljs-title function_ invoke__">ARRAY_SIZE</span>(req<span class="hljs-punctuation">-></span>bufsml))
    req<span class="hljs-punctuation">-></span>bufs = <span class="hljs-title function_ invoke__">uv__malloc</span>(nbufs * <span class="hljs-title function_ invoke__">sizeof</span>(bufs[<span class="hljs-number">0</span>]));
  <span class="hljs-comment">// 复制指向数据到元信息到请求结构体</span>
  <span class="hljs-title function_ invoke__">memcpy</span>(req<span class="hljs-punctuation">-></span>bufs, bufs, nbufs * <span class="hljs-title function_ invoke__">sizeof</span>(bufs[<span class="hljs-number">0</span>]));
  <span class="hljs-comment">// 记录待发送到字节数和请求个数</span>
  handle<span class="hljs-punctuation">-></span>send_queue_size += <span class="hljs-title function_ invoke__">uv__count_bufs</span>(req<span class="hljs-punctuation">-></span>bufs, req<span class="hljs-punctuation">-></span>nbufs);
  handle<span class="hljs-punctuation">-></span>send_queue_count++;
  <span class="hljs-title function_ invoke__">QUEUE_INSERT_TAIL</span>(&#x26;handle<span class="hljs-punctuation">-></span>write_queue, &#x26;req<span class="hljs-punctuation">-></span>queue);
  <span class="hljs-title function_ invoke__">uv__handle_start</span>(handle);
  <span class="hljs-comment">// 如果当前没有数据等待发送，则尝试直接发送</span>
  <span class="hljs-title function_ invoke__">if</span> (empty_queue &#x26;&#x26; !(handle<span class="hljs-punctuation">-></span>flags &#x26; UV_HANDLE_UDP_PROCESSING)) {
    <span class="hljs-title function_ invoke__">uv__udp_sendmsg</span>(handle);
    <span class="hljs-comment">// 如果还没有发送完则注册可写事件等下次发送</span>
    <span class="hljs-title function_ invoke__">if</span> (!<span class="hljs-title function_ invoke__">QUEUE_EMPTY</span>(&#x26;handle<span class="hljs-punctuation">-></span>write_queue))
      <span class="hljs-title function_ invoke__">uv__io_start</span>(handle<span class="hljs-punctuation">-></span><span class="hljs-keyword">loop</span>, &#x26;handle<span class="hljs-punctuation">-></span>io_watcher, POLLOUT);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 如果当前有数据正在等待发送，则注册可写，等待发送</span>
    <span class="hljs-title function_ invoke__">uv__io_start</span>(handle<span class="hljs-punctuation">-></span><span class="hljs-keyword">loop</span>, &#x26;handle<span class="hljs-punctuation">-></span>io_watcher, POLLOUT);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>我们只分析最长路径，那就是当前不可直接发送，需要等待可写事件触发再发送，可写事件触发时执行的函数是 uv__udp_io。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">uv__udp_io</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv__io_t</span>* w, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> revents)</span> </span>{
  <span class="hljs-type">uv_udp_t</span>* handle;

  handle = <span class="hljs-built_in">container_of</span>(w, <span class="hljs-type">uv_udp_t</span>, io_watcher);
  <span class="hljs-comment">// 可发送</span>
  <span class="hljs-keyword">if</span> (revents &#x26; POLLOUT) {
    <span class="hljs-built_in">uv__udp_sendmsg</span>(handle);
    <span class="hljs-built_in">uv__udp_run_completed</span>(handle);
  }
}
</code></pre>
<p>从上面代码中可以看到，当可写事件触发时会执行 uv__udp_sendmsg。</p>
<pre><code class="hljs language-ini">static void uv__udp_sendmsg(uv_udp_t* handle) {
  uv_udp_send_t* req<span class="hljs-comment">;</span>
  QUEUE* q<span class="hljs-comment">;</span>
  struct msghdr h<span class="hljs-comment">;</span>
  ssize_t size<span class="hljs-comment">;</span>

  while (!QUEUE_EMPTY(&#x26;handle->write_queue)) {
    <span class="hljs-attr">q</span> = QUEUE_HEAD(&#x26;handle->write_queue)<span class="hljs-comment">;</span>
    <span class="hljs-attr">req</span> = QUEUE_DATA(q, uv_udp_send_t, queue)<span class="hljs-comment">;</span>
    memset(&#x26;h, 0, sizeof h)<span class="hljs-comment">;</span>
    // 如果发送时才执行对端地址，则设置对端地址，如果发送前调用 connect 绑定了地址则不需要再指定
    if (req-><span class="hljs-attr">addr.ss_family</span> == AF_UNSPEC) {
      <span class="hljs-attr">h.msg_name</span> = NULL<span class="hljs-comment">;</span>
      <span class="hljs-attr">h.msg_namelen</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    } else {
      <span class="hljs-attr">h.msg_name</span> = &#x26;req->addr<span class="hljs-comment">;</span>
      if (req-><span class="hljs-attr">addr.ss_family</span> == AF_INET6)
        <span class="hljs-attr">h.msg_namelen</span> = sizeof(struct sockaddr_in6)<span class="hljs-comment">;</span>
      else if (req-><span class="hljs-attr">addr.ss_family</span> == AF_INET)
        <span class="hljs-attr">h.msg_namelen</span> = sizeof(struct sockaddr_in)<span class="hljs-comment">;</span>
      else if (req-><span class="hljs-attr">addr.ss_family</span> == AF_UNIX)
        <span class="hljs-attr">h.msg_namelen</span> = sizeof(struct sockaddr_un)<span class="hljs-comment">;</span>
    }
    <span class="hljs-attr">h.msg_iov</span> = (struct iovec*) req->bufs<span class="hljs-comment">;</span>
    <span class="hljs-attr">h.msg_iovlen</span> = req->nbufs<span class="hljs-comment">;</span>

    do {
      <span class="hljs-attr">size</span> = sendmsg(handle->io_watcher.fd, &#x26;h, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    } while (<span class="hljs-attr">size</span> == -<span class="hljs-number">1</span> &#x26;&#x26; err<span class="hljs-literal">no</span> == EINTR)<span class="hljs-comment">;</span>
    // 发送失败则跳出循环等待下次可写事件触发
    if (<span class="hljs-attr">size</span> == -<span class="hljs-number">1</span>) {
      if (<span class="hljs-attr">errno</span> == EAGAIN || err<span class="hljs-literal">no</span> == EWOULDBLOCK || err<span class="hljs-literal">no</span> == ENOBUFS)
        break<span class="hljs-comment">;</span>
    }
    // 发送结果
    req-><span class="hljs-attr">status</span> = (size == -<span class="hljs-number">1</span> ? UV__ERR(err<span class="hljs-literal">no</span>) : size)<span class="hljs-comment">;</span>

    // 移出待发送队列
    QUEUE_REMOVE(&#x26;req->queue)<span class="hljs-comment">;</span>
    // 插入发送结束队列
    QUEUE_INSERT_TAIL(&#x26;handle->write_completed_queue, &#x26;req->queue)<span class="hljs-comment">;</span>
    // 在 pending 阶段继续处理
    uv__io_feed(handle->loop, &#x26;handle->io_watcher)<span class="hljs-comment">;</span>
  }
}
</code></pre>
<p>执行了发送操作后，如果失败则继续等待下一次可写事件的触发，如果成功了就会把发送请求对应的节点插入结束队列，然后通过 uv__udp_run_completed 处理。</p>
<pre><code class="hljs language-scss">static void <span class="hljs-built_in">uv__udp_run_completed</span>(uv_udp_t* handle) {
  uv_udp_send_t* req;
  QUEUE* <span class="hljs-selector-tag">q</span>;

  handle->flags |= UV_HANDLE_UDP_PROCESSING;
  <span class="hljs-comment">// 遍历节点，执行回调</span>
  while (!QUEUE_EMPTY(&#x26;handle->write_completed_queue)) {
    <span class="hljs-selector-tag">q</span> = <span class="hljs-built_in">QUEUE_HEAD</span>(&#x26;handle->write_completed_queue);
    <span class="hljs-built_in">QUEUE_REMOVE</span>(q);

    req = <span class="hljs-built_in">QUEUE_DATA</span>(q, uv_udp_send_t, queue);
    <span class="hljs-built_in">uv__req_unregister</span>(handle->loop, req);
    <span class="hljs-comment">// 重新计算待发送数据的信息</span>
    handle->send_queue_size -= <span class="hljs-built_in">uv__count_bufs</span>(req->bufs, req->nbufs);
    handle->send_queue_count--;
    <span class="hljs-comment">// 如果申请了堆内存则释放</span>
    if (req->bufs != req->bufsml)
      <span class="hljs-built_in">uv__free</span>(req->bufs);
    req->bufs = NULL;
    <span class="hljs-comment">// 执行回调</span>
    if (req->status >= <span class="hljs-number">0</span>)
      req-><span class="hljs-built_in">send_cb</span>(req, <span class="hljs-number">0</span>);
    else
      req-><span class="hljs-built_in">send_cb</span>(req, req->status);
  }
  <span class="hljs-comment">// 如果待写队列为空则注销可写事件，因为没有数据写了</span>
  if (QUEUE_EMPTY(&#x26;handle->write_queue)) {
    <span class="hljs-built_in">uv__io_stop</span>(handle->loop, &#x26;handle->io_watcher, POLLOUT);
    if (!uv__io_active(&#x26;handle->io_watcher, POLLIN))
      <span class="hljs-built_in">uv__handle_stop</span>(handle);
  }

  handle->flags &#x26;= ~UV_HANDLE_UDP_PROCESSING;
}
</code></pre>
<p>uv__udp_run_completed 会执行每一个写请求的回调，这里是 C++ 层的 OnSend 函数。</p>
<pre><code class="hljs language-rust">void UDPWrap::<span class="hljs-title function_ invoke__">OnSend</span>(uv_udp_send_t* req, int status) {
  std::unique_ptr&#x3C;SendWrap> req_wrap{static_cast&#x3C;SendWrap*>(req<span class="hljs-punctuation">-></span>data)};
  <span class="hljs-title function_ invoke__">if</span> (req_wrap<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">have_callback</span>()) {
    Environment* env = req_wrap<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">env</span>();
    HandleScope <span class="hljs-title function_ invoke__">handle_scope</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">isolate</span>());
    Context::Scope <span class="hljs-title function_ invoke__">context_scope</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">context</span>());
    Local&#x3C;Value> arg[] = {
      Integer::<span class="hljs-title function_ invoke__">New</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">isolate</span>(), status),
      Integer::<span class="hljs-title function_ invoke__">New</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">isolate</span>(), req_wrap<span class="hljs-punctuation">-></span>msg_size),
    };
    req_wrap<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">MakeCallback</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">oncomplete_string</span>(), <span class="hljs-number">2</span>, arg);
  }
}
</code></pre>
<p>OnSend 直接回调 JS 层。到这里，数据发送的流程就结束了。</p>
<h2>接收数据</h2>
<p>我们调用 bind 之后，会接着执行 startListening。</p>
<pre><code class="hljs language-ini">function startListening(socket) {  
  const <span class="hljs-attr">state</span> = socket[kStateSymbol]<span class="hljs-comment">;  </span>
  // 有数据时的回调，触发 message 事件  
  <span class="hljs-attr">state.handle.onmessage</span> = <span class="hljs-literal">on</span>Message<span class="hljs-comment">;  </span>
  // 注册可读事件，开始监听数据  
  state.handle.recvStart()<span class="hljs-comment">;  </span>
  <span class="hljs-attr">state.receiving</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;  </span>
  <span class="hljs-attr">state.bindState</span> = BIND_STATE_BOUND<span class="hljs-comment">;  </span>
   // 设置操作系统的接收和发送缓冲区大小
  if (state.recvBufferSize)  
    bufferSize(socket, state.recvBufferSize, RECV_BUFFER)<span class="hljs-comment">;  </span>
  
  if (state.sendBufferSize)  
    bufferSize(socket, state.sendBufferSize, SEND_BUFFER)<span class="hljs-comment">;  </span>
  
  socket.emit('listening')<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>和 TCP 不一样，TCP 的 listen 是等待连接的到来，因为 UDP 不是面向连接的，所以 startListening 主要是为了设置可读事件，等待数据的到来。startListening 函数除了会设置发送和接收缓冲区的大小，以及设置接收数据的回调 onMessage 外，重点是 recvStart 函数，我们看 C++ 的实现。</p>
<pre><code class="hljs language-scss">void UDPWrap::RecvStart(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {  
  UDPWrap* wrap;  
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap,  
                          args.Holder(),  
                          args<span class="hljs-selector-class">.GetReturnValue</span>()<span class="hljs-selector-class">.Set</span>(UV_EBADF));  
  int err = <span class="hljs-built_in">uv_udp_recv_start</span>(&#x26;wrap->handle_, OnAlloc, OnRecv);  
  args<span class="hljs-selector-class">.GetReturnValue</span>()<span class="hljs-selector-class">.Set</span>(err);  
}  
</code></pre>
<p>OnAlloc, OnRecv 分别是分配内存接收数据的函数和数据到来时执行的回调，最终调用 uv__udp_recv_start 注册等待可读事件，看一下 uv_udp_recv_start 函数的实现。</p>
<pre><code class="hljs language-scss">int <span class="hljs-built_in">uv_udp_recv_start</span>(uv_udp_t* handle,
                      uv_alloc_cb alloc_cb,
                      uv_udp_recv_cb recv_cb) {
    return <span class="hljs-built_in">uv__udp_recv_start</span>(handle, alloc_cb, recv_cb);
}

int <span class="hljs-built_in">uv__udp_recv_start</span>(uv_udp_t* handle,
                       uv_alloc_cb alloc_cb,
                       uv_udp_recv_cb recv_cb) {
  <span class="hljs-comment">// 保存回调</span>
  handle->alloc_cb = alloc_cb;
  handle->recv_cb = recv_cb;
  <span class="hljs-comment">// 注册可读事件</span>
  <span class="hljs-built_in">uv__io_start</span>(handle->loop, &#x26;handle->io_watcher, POLLIN);
  <span class="hljs-built_in">uv__handle_start</span>(handle);

  return <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv_udp_recv_start 会注册 socket 的可读事件，等待数据的到来。当操作系统收到数据后，会通知 Node.js ，Node.js 会在 Poll IO 阶段处理。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">uv__udp_io</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv__io_t</span>* w, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> revents)</span> </span>{
  <span class="hljs-type">uv_udp_t</span>* handle;

  handle = <span class="hljs-built_in">container_of</span>(w, <span class="hljs-type">uv_udp_t</span>, io_watcher);
  <span class="hljs-keyword">if</span> (revents &#x26; POLLIN)
    <span class="hljs-built_in">uv__udp_recvmsg</span>(handle);
}
</code></pre>
<p>来看一下 uv__udp_recvmsg 函数的实现。</p>
<pre><code class="hljs language-ini">static void uv__udp_recvmsg(uv_udp_t* handle) {
  struct sockaddr_storage peer<span class="hljs-comment">;</span>
  struct msghdr h<span class="hljs-comment">;</span>
  ssize_t nread<span class="hljs-comment">;</span>
  uv_buf_t buf<span class="hljs-comment">;</span>
  int flags<span class="hljs-comment">;</span>
  int count<span class="hljs-comment">;</span>

  <span class="hljs-attr">count</span> = <span class="hljs-number">32</span><span class="hljs-comment">;</span>
  // 循环读，但是不要一直读，这样会导致事件循环的其他事件无法被处理
  do {
    <span class="hljs-attr">buf</span> = uv_buf_init(NULL, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    // 分配内存接收数据，保证大于一个数据包的长度
    handle->alloc_cb((uv_handle_t*) handle, 64 * 1024, &#x26;buf)<span class="hljs-comment">;</span>
    memset(&#x26;h, 0, sizeof(h))<span class="hljs-comment">;</span>
    memset(&#x26;peer, 0, sizeof(peer))<span class="hljs-comment">;</span>
    // 保存对端的地址信息
    <span class="hljs-attr">h.msg_name</span> = &#x26;peer<span class="hljs-comment">;</span>
    <span class="hljs-attr">h.msg_namelen</span> = sizeof(peer)<span class="hljs-comment">;</span>
    // 保存数据
    <span class="hljs-attr">h.msg_iov</span> = (void*) &#x26;buf<span class="hljs-comment">;</span>
    <span class="hljs-attr">h.msg_iovlen</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>

    do {
      <span class="hljs-attr">nread</span> = recvmsg(handle->io_watcher.fd, &#x26;h, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    }
    while (<span class="hljs-attr">nread</span> == -<span class="hljs-number">1</span> &#x26;&#x26; err<span class="hljs-literal">no</span> == EINTR)<span class="hljs-comment">;</span>
    // 忽略错误处理
    // 回调上层
    handle->recv_cb(handle, nread, &#x26;buf, (const struct sockaddr*) &#x26;peer, flags)<span class="hljs-comment">;</span>
  }
  /* recv_cb callback may decide to pause or close the handle */
  while (nread != -1
      &#x26;&#x26; count-- > 0
      &#x26;&#x26; handle->io_watcher.fd != -1
      &#x26;&#x26; handle->recv_cb != NULL)<span class="hljs-comment">;</span>
}
</code></pre>
<p>上层对应的 C++ 回调是 OnRecv。</p>
<pre><code class="hljs language-scss">void UDPWrap::OnRecv(uv_udp_t* handle,
                     ssize_t nread,
                     const uv_buf_t* buf_,
                     const struct sockaddr* addr,
                     unsigned int flags) {
  UDPWrap* wrap = static_cast&#x3C;UDPWrap*>(handle->data);
  Environment* env = wrap-><span class="hljs-built_in">env</span>();

  AllocatedBuffer <span class="hljs-built_in">buf</span>(env, *buf_);
  
  Local&#x3C;<span class="hljs-selector-tag">Object</span>> wrap_obj = wrap-><span class="hljs-selector-tag">object</span>();
  <span class="hljs-comment">// 回调时的参数</span>
  Local&#x3C;Value> argv<span class="hljs-selector-attr">[]</span> = {
    Integer::New(env->isolate(), nread),
    wrap_obj,
    Undefined(env->isolate()),
    Undefined(env->isolate())
  };
  
  buf<span class="hljs-selector-class">.Resize</span>(nread);
  argv<span class="hljs-selector-attr">[2]</span> = buf<span class="hljs-selector-class">.ToBuffer</span>()<span class="hljs-selector-class">.ToLocalChecked</span>();
  argv<span class="hljs-selector-attr">[3]</span> = <span class="hljs-built_in">AddressToJS</span>(env, addr);
  <span class="hljs-comment">// 执行 JS 的 onmessage 回调</span>
  wrap-><span class="hljs-built_in">MakeCallback</span>(env->onmessage_string(), <span class="hljs-built_in">arraysize</span>(argv), argv);
}
</code></pre>
<p>C++ 层执行了 JS 的 onmessage 函数，从而触发 message 事件，这样，一次数据接收的流程就结束了。</p>
<pre><code class="hljs language-lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(nread, handle, buf, rinfo)</span></span> {
  const <span class="hljs-built_in">self</span> = handle[owner_symbol];
  <span class="hljs-built_in">self</span>.emit(<span class="hljs-string">'message'</span>, buf, rinfo);
}
</code></pre>
<h1>发送 / 接收缓冲区</h1>
<p>了解了 Node.js UDP 服务器、客户端以及数据通信等实现后，接下来看一下数据通信时缓冲区的概念，因为缓存区不足会导致发送送/ 接收数据包失败。</p>
<p>UDP 模块提供了设置发送和接收缓冲区大小的 API。前面讲过，发送缓冲区用于控制单次可以发送多大的数据包，接收缓冲区用于控制可以缓存多少还没有被应用层读取的数据。首先来看一下发送缓冲区的使用。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> { createSocket } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">createSocket</span>(<span class="hljs-string">'udp4'</span>);
socket.<span class="hljs-title function_">bind</span>(<span class="hljs-number">8888</span>, <span class="hljs-function">() =></span> {
    socket.<span class="hljs-title function_">setSendBufferSize</span>(<span class="hljs-number">300</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'sendBufferSize:'</span>, socket.<span class="hljs-title function_">getSendBufferSize</span>());
    socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">'1'</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">500</span>), <span class="hljs-number">9999</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)
    }); 
});
</code></pre>
<p>上面的代码设置了发送缓冲区为 300，然后发送了 500 个字节，最终导致了报错，错误信息如下。</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">Error:</span> <span class="hljs-string">send</span> <span class="hljs-string">EMSGSIZE</span> <span class="hljs-string">undefined:9999</span>
    <span class="hljs-string">at</span> <span class="hljs-string">doSend</span> <span class="hljs-string">(dgram.js:681:16)</span>
    <span class="hljs-string">at</span> <span class="hljs-string">defaultTriggerAsyncIdScope</span> <span class="hljs-string">(internal/async_hooks.js:313:12)</span>
    <span class="hljs-string">at</span> <span class="hljs-string">afterDns</span> <span class="hljs-string">(dgram.js:627:5)</span>
    <span class="hljs-string">at</span> <span class="hljs-string">processTicksAndRejections</span> <span class="hljs-string">(internal/process/task_queues.js:85:21)</span> {
  <span class="hljs-attr">errno:</span> <span class="hljs-number">-40</span>,
  <span class="hljs-attr">code:</span> <span class="hljs-string">'EMSGSIZE'</span>,
  <span class="hljs-attr">syscall:</span> <span class="hljs-string">'send'</span>,
  <span class="hljs-attr">address:</span> <span class="hljs-string">undefined</span>,
  <span class="hljs-attr">port:</span> <span class="hljs-number">9999</span>
}
</code></pre>
<p>EMSGSIZE 代表发送的数据太大了，当我们改成发送 200 个字节就可以了。那我们接着看接收缓冲区的使用。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> { createSocket } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">createSocket</span>(<span class="hljs-string">'udp4'</span>);
socket.<span class="hljs-title function_">bind</span>(<span class="hljs-number">8888</span>, <span class="hljs-function">() =></span> {
    socket.<span class="hljs-title function_">setRecvBufferSize</span>(<span class="hljs-number">100</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'RecvBufferSize:'</span>, socket.<span class="hljs-title function_">getRecvBufferSize</span>());
    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);
    <span class="hljs-title function_">createSocket</span>(<span class="hljs-string">'udp4'</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">"1"</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">200</span>), <span class="hljs-number">8888</span>);
});
</code></pre>
<p>上面代码首先创建了一个 UDP 服务器，然后再创建一个 UDP 客户端，但是执行后发现没有输出，因为发送的数据大于服务器的接收缓冲区了，我们把 200 改成 50 就可以了。</p>
<h1>UDP 的端口复用 REUSEADDR</h1>
<p>我们在网络编程中经常会遇到端口重复绑定的错误，前面的 TCP 课程中，已经讲过端口复用 REUSEADDR，UDP 中也支持端口复用的功能，但是它支持的功能、用途和 TCP 不太一样。下面我们来分析一下 UDP 的端口复用特性。在 Node.js 中，使用UDP的时候，可以通过 reuseAddr 选项使得进程可以复用端口，并且每一个想复用端口的 socket 都需要设置 reuseAddr。接下来，我们看看 reuseAddr 的逻辑。</p>
<pre><code class="hljs language-c">Socket.prototype.bind = function(port_, address_ <span class="hljs-comment">/* , callback */</span>) {  
  let flags = <span class="hljs-number">0</span>;  
    <span class="hljs-keyword">if</span> (state.reuseAddr)  
      flags |= UV_UDP_REUSEADDR;  
    state.handle.bind(ip, port || <span class="hljs-number">0</span>, flags);  
};  
<span class="hljs-comment">// 我们看到在 bind 的时候会处理 reuseAddr 字段。我们直接看 Libuv 的逻辑。</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">uv__udp_bind</span><span class="hljs-params">(<span class="hljs-type">uv_udp_t</span>* handle,  
                 <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr,  
                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addrlen,  
                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span> {  
  <span class="hljs-keyword">if</span> (flags &#x26; UV_UDP_REUSEADDR) {  
    err = uv__set_reuse(fd);  
  }  
  bind(fd, addr, addrlen))
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}  
  
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uv__set_reuse</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> {  
  <span class="hljs-type">int</span> yes;  
  yes = <span class="hljs-number">1</span>;  
  
  <span class="hljs-keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &#x26;yes, <span class="hljs-keyword">sizeof</span>(yes)))  
    <span class="hljs-keyword">return</span> UV__ERR(errno);  
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}  
</code></pre>
<p>我们看到 Libuv 最终通过 setsockopt 设置了端口复用，并且是在 bind 之前。接下来，我们看一下在 UDP 中 SO_REUSEADDR 的作用。</p>
<h2>单播下的端口复用</h2>
<p>首先，我们看一个端口复用的例子。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">dgram</span> = require(<span class="hljs-string">'dgram'</span>)<span class="hljs-comment">;    </span>
function startServer() {
  for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; 2; i++) {   </span>
    let <span class="hljs-attr">index</span> = i + <span class="hljs-number">1</span><span class="hljs-comment">;</span>
    const <span class="hljs-attr">udp</span> = dgram.createSocket({type: <span class="hljs-string">'udp4'</span>, reuseAddr: <span class="hljs-literal">true</span>})<span class="hljs-comment">;    </span>
    udp.bind(8080)<span class="hljs-comment">;    </span>
    udp.on('message', (msg) => {  
      console.log(`server ${index}`, msg.toString('utf-8'))<span class="hljs-comment">;  </span>
    })<span class="hljs-comment">;  </span>
  }
}

function startClient() {
  const <span class="hljs-attr">message</span> = Buffer.from(<span class="hljs-string">'Some bytes'</span>)<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">client</span> = dgram.createSocket(<span class="hljs-string">'udp4'</span>)<span class="hljs-comment">;  </span>
  // 发送数据
  client.send(message, 8080, () => { 
    // 关闭 socket
    client.close()<span class="hljs-comment">;  </span>
  })<span class="hljs-comment">;  </span>
}

startServer()<span class="hljs-comment">;</span>
startClient()<span class="hljs-comment">;</span>
</code></pre>
<p>执行以上代码，我们会发现只有一个进程会收到数据。在单播模式下（一个数据包只能被一个主机接收），如果有两个进程都监听了同一个 IP 和端口，那么哪一个进程会收到数据取决于操作系统的实现，在 Linux 中，后启动的服务器会收到数据，Windows下则相反，先启动的服务器会收到数据。那么端口复用有什么用呢？</p>
<h2>多播下的端口复用</h2>
<p>UDP 的端口复用主要是用于多播，多播就是客户端发送一个数据包可以被多个主机收到。除了多播还有多播组，也就是多个主机的集合。客户端发送一个多播数据包时（多播数据包即给某个多播组发送一个数据包），通过多播 IP 指定哪个多播组的主机可以收到这个数据包。例如下图中，主机 1 发送给多播组 1.1.1.1 的包，主机 3，4可以收到，2 收不到。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b722ddb38adb42db89eeed2a526f7748~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下面看看在多播的情况下端口复用的使用，看一个例子。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">startServer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">2</span>; i++) {
    <span class="hljs-keyword">let</span> index = i + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> udp = dgram.<span class="hljs-title function_">createSocket</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">'udp4'</span>, <span class="hljs-attr">reuseAddr</span>: <span class="hljs-literal">true</span>});    
    udp.<span class="hljs-title function_">bind</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =></span> {   
        <span class="hljs-comment">// 设置 127.0.0.1 对应的接口加入多播组 224.0.0.114</span>
        <span class="hljs-comment">// 局域网多播地址（224.0.0.0~224.0.0.255，该范围的多播数据包，路由器不会转发）   </span>
        udp.<span class="hljs-title function_">addMembership</span>(<span class="hljs-string">'224.0.0.114'</span>, <span class="hljs-string">'127.0.0.1'</span>); 
    });    
    udp.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">msg, rinfo</span>) =></span> {  
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`server <span class="hljs-subst">${index}</span>`</span>, msg.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf-8'</span>), rinfo);
    });  
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">startClient</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> udp = dgram.<span class="hljs-title function_">createSocket</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">'udp4'</span>}); 
  <span class="hljs-comment">// 1234 为客户端地址</span>
  udp.<span class="hljs-title function_">bind</span>(<span class="hljs-number">1234</span>,<span class="hljs-function">() =></span> {
    <span class="hljs-comment">// 设置多播包的出口地址，不设置操作系统会默认选一个，如果选的不是 server 加入的 ip，则 server 收不到数据</span>
    udp.<span class="hljs-title function_">setMulticastInterface</span>(<span class="hljs-string">'127.0.0.1'</span>);
  }); 
  <span class="hljs-comment">// 给多播组发送数据</span>
  udp.<span class="hljs-title function_">send</span>(<span class="hljs-string">'test'</span>, <span class="hljs-number">8080</span>, <span class="hljs-string">'224.0.0.114'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {});   
}

<span class="hljs-title function_">startServer</span>();
<span class="hljs-title function_">startClient</span>();
</code></pre>
<p>上面代码使得两个服务器都监听了同样的 IP 和端口并且加入了同一个多播组。当客户端给这个多播组发送了一个数据，可以看到两个服务器进程都收到了数据。输出如下。</p>
<pre><code class="hljs language-yaml"><span class="hljs-string">server</span> <span class="hljs-number">1</span> <span class="hljs-string">test</span> { <span class="hljs-attr">address:</span> <span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-attr">family:</span> <span class="hljs-string">'IPv4'</span>, <span class="hljs-attr">port:</span> <span class="hljs-number">1234</span>, <span class="hljs-attr">size:</span> <span class="hljs-number">4</span> }
<span class="hljs-string">server</span> <span class="hljs-number">2</span> <span class="hljs-string">test</span> { <span class="hljs-attr">address:</span> <span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-attr">family:</span> <span class="hljs-string">'IPv4'</span>, <span class="hljs-attr">port:</span> <span class="hljs-number">1234</span>, <span class="hljs-attr">size:</span> <span class="hljs-number">4</span> }
</code></pre>
<p>我们也可以把 127.0.0.1 改成其他的局域网 IP，比如我电脑的 192.168.3.9。输出如下。</p>
<pre><code class="hljs language-yaml"><span class="hljs-string">server</span> <span class="hljs-number">1</span> <span class="hljs-string">test</span> { <span class="hljs-attr">address:</span> <span class="hljs-string">'192.168.3.9'</span>, <span class="hljs-attr">family:</span> <span class="hljs-string">'IPv4'</span>, <span class="hljs-attr">port:</span> <span class="hljs-number">1234</span>, <span class="hljs-attr">size:</span> <span class="hljs-number">4</span> }
<span class="hljs-string">server</span> <span class="hljs-number">2</span> <span class="hljs-string">test</span> { <span class="hljs-attr">address:</span> <span class="hljs-string">'192.168.3.9'</span>, <span class="hljs-attr">family:</span> <span class="hljs-string">'IPv4'</span>, <span class="hljs-attr">port:</span> <span class="hljs-number">1234</span>, <span class="hljs-attr">size:</span> <span class="hljs-number">4</span> }
</code></pre>
<p>但是如果客户端通过 setMulticastInterface 和服务器通过 addMembership 设置的 IP 不一样，则服务器无法收到数据。如果 addMembership 没有设置第二个参数，而操作系统会自己选择一个。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">startServer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">2</span>; i++) {
    <span class="hljs-keyword">let</span> index = i + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> udp = dgram.<span class="hljs-title function_">createSocket</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">'udp4'</span>, <span class="hljs-attr">reuseAddr</span>: <span class="hljs-literal">true</span>});    
    udp.<span class="hljs-title function_">bind</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =></span> {   
        udp.<span class="hljs-title function_">addMembership</span>(<span class="hljs-string">'224.0.0.114'</span>); 
    });    
    udp.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">msg, rinfo</span>) =></span> {  
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`server <span class="hljs-subst">${index}</span>`</span>, msg.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf-8'</span>), rinfo);
    });  
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">startClient</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> udp = dgram.<span class="hljs-title function_">createSocket</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">'udp4'</span>}); 
  <span class="hljs-comment">// 1234 为客户端地址</span>
  udp.<span class="hljs-title function_">bind</span>(<span class="hljs-number">1234</span>,<span class="hljs-function">() =></span> {
    <span class="hljs-comment">//  udp.setMulticastInterface('127.0.0.1');</span>
  }); 
  <span class="hljs-comment">// 给多播组发送数据</span>
  udp.<span class="hljs-title function_">send</span>(<span class="hljs-string">'test'</span>, <span class="hljs-number">8080</span>, <span class="hljs-string">'224.0.0.114'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {});   
}

<span class="hljs-title function_">startServer</span>();
<span class="hljs-title function_">startClient</span>();
</code></pre>
<p>上面的代码在我们的电脑中输出如下。</p>
<pre><code class="hljs language-yaml"><span class="hljs-string">server</span> <span class="hljs-number">1</span> <span class="hljs-string">test</span> { <span class="hljs-attr">address:</span> <span class="hljs-string">'192.168.3.9'</span>, <span class="hljs-attr">family:</span> <span class="hljs-string">'IPv4'</span>, <span class="hljs-attr">port:</span> <span class="hljs-number">1234</span>, <span class="hljs-attr">size:</span> <span class="hljs-number">4</span> }
<span class="hljs-string">server</span> <span class="hljs-number">2</span> <span class="hljs-string">test</span> { <span class="hljs-attr">address:</span> <span class="hljs-string">'192.168.3.9'</span>, <span class="hljs-attr">family:</span> <span class="hljs-string">'IPv4'</span>, <span class="hljs-attr">port:</span> <span class="hljs-number">1234</span>, <span class="hljs-attr">size:</span> <span class="hljs-number">4</span> }
</code></pre>
<p>说明客户端的数据包出口地址是 192.168.3.9，如果客户端打开 udp.setMulticastInterface('127.0.0.1') 注释，服务器则无法收到数据。另外可以多次调用 udp.addMembership 设置接收来自多个入口 IP 的数据。例如下面的例子。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">startServer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">2</span>; i++) {
    <span class="hljs-keyword">let</span> index = i + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> udp = dgram.<span class="hljs-title function_">createSocket</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">'udp4'</span>, <span class="hljs-attr">reuseAddr</span>: <span class="hljs-literal">true</span>});    
    udp.<span class="hljs-title function_">bind</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =></span> {   
        udp.<span class="hljs-title function_">addMembership</span>(<span class="hljs-string">'224.0.0.114'</span>, <span class="hljs-string">'127.0.0.1'</span>); 
        udp.<span class="hljs-title function_">addMembership</span>(<span class="hljs-string">'224.0.0.114'</span>, <span class="hljs-string">'192.168.3.9'</span>); 
    });    
    udp.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">msg, rinfo</span>) =></span> {  
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`server <span class="hljs-subst">${index}</span>`</span>, msg.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf-8'</span>), rinfo);
    });  
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">startClient</span>(<span class="hljs-params">ip, port</span>) {
  <span class="hljs-keyword">const</span> udp = dgram.<span class="hljs-title function_">createSocket</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">'udp4'</span>}); 
  udp.<span class="hljs-title function_">bind</span>(port,<span class="hljs-function">() =></span> {
    udp.<span class="hljs-title function_">setMulticastInterface</span>(ip);
  }); 
  udp.<span class="hljs-title function_">send</span>(<span class="hljs-string">'test'</span>, <span class="hljs-number">8080</span>, <span class="hljs-string">'224.0.0.114'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {});   
}

<span class="hljs-title function_">startServer</span>();
<span class="hljs-title function_">startClient</span>(<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">1234</span>);
<span class="hljs-title function_">startClient</span>(<span class="hljs-string">'192.168.3.9'</span>, <span class="hljs-number">5678</span>);
</code></pre>
<p>上面的代码创建了两个客户端，分别设置了两个不同的出口 IP，同时服务器也设置了两个入口 IP，所以服务器可以收到所有的数据。输出如下。</p>
<pre><code class="hljs language-yaml"><span class="hljs-string">server</span> <span class="hljs-number">1</span> <span class="hljs-string">test</span> { <span class="hljs-attr">address:</span> <span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-attr">family:</span> <span class="hljs-string">'IPv4'</span>, <span class="hljs-attr">port:</span> <span class="hljs-number">1234</span>, <span class="hljs-attr">size:</span> <span class="hljs-number">4</span> }
<span class="hljs-string">server</span> <span class="hljs-number">1</span> <span class="hljs-string">test</span> { <span class="hljs-attr">address:</span> <span class="hljs-string">'192.168.3.9'</span>, <span class="hljs-attr">family:</span> <span class="hljs-string">'IPv4'</span>, <span class="hljs-attr">port:</span> <span class="hljs-number">5678</span>, <span class="hljs-attr">size:</span> <span class="hljs-number">4</span> }
<span class="hljs-string">server</span> <span class="hljs-number">2</span> <span class="hljs-string">test</span> { <span class="hljs-attr">address:</span> <span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-attr">family:</span> <span class="hljs-string">'IPv4'</span>, <span class="hljs-attr">port:</span> <span class="hljs-number">1234</span>, <span class="hljs-attr">size:</span> <span class="hljs-number">4</span> }
<span class="hljs-string">server</span> <span class="hljs-number">2</span> <span class="hljs-string">test</span> { <span class="hljs-attr">address:</span> <span class="hljs-string">'192.168.3.9'</span>, <span class="hljs-attr">family:</span> <span class="hljs-string">'IPv4'</span>, <span class="hljs-attr">port:</span> <span class="hljs-number">5678</span>, <span class="hljs-attr">size:</span> <span class="hljs-number">4</span> }
</code></pre>
<p>多播是一个比较复杂的内容，这里例举几个例子，大家有兴趣可以参考官网或者 Linux 文档。</p>
<h1>总结</h1>
<p>UDP 是 TCP / IP 协议簇中一个非常重要的协议，HTTP 3.0 和 DNS 都用到了 UDP 协议作为传输协议，另外像音频、视频数据的传输也经常是使用 UDP 协议。这节课我们详细地讲解了 UDP。</p>
<ol>
<li>UDP 是无连接、不可靠的数据报协议，发送数据前不需要建立连接，而是直接把应用层的数据作为一个单独的数据包进行发送，并且不保证数据可以到达对端，这些需要应用层进行处理。</li>
<li>UDP 和 TCP 一样，也有客户端和服务器的概念，使用上遵循网络编程的那一套逻辑，客户端可以调用 bind 和 connect 分别绑定本端和对端端地址，然后通过 sendto / write 函数发送数据。服务器则只需要调用 bind 绑定地址，然后就可以通过 recvmsg 等函数接收对端的数据。相比 TCP 来说，UDP 使用上比较简单。</li>
<li>Node.js 中 UDP 客户端和服务器的实现，本质上是结合了操作系统提供的 API 和 V8 的能力。如果我们理解了 UDP 基础部分，再学习 Node.js 的实现就会变得非常简单。</li>
<li>除了正常的 UDP 通信外，UDP 还有一些特性，比如发送 / 接收缓冲区分别控制发送的数据包最大字节数和接收的数据包最大字节数。另外还有端口复用，端口复用使得可以有多个 UDP 服务器监听同一个地址，但是在单播的情况下，只有一个 UDP 服务器可以收到客户端的数据。而结合多播的能力，我们就可以在多个服务器中同时接收客户端的数据。</li>
</ol>
<p>最后我们也来总结下 TCP 和 UDP 协议的区别。</p>


























<table><thead><tr><th>协议</th><th>数据格式</th><th>可靠性</th><th>是否基于连接</th><th>使用场景</th></tr></thead><tbody><tr><td>TCP</td><td>流式：TCP 把应用层的数据当作字节流发送，接收方需要实现解析器解析出每一个应用层协议包。</td><td>可靠：TCP 通过数据缓存、超时重传、ACK 等机制保证了数据的可靠性，但是如果达到一定的条件，TCP 也会放弃数据包，比如重传次数达到阈值。</td><td>是：使用TCP 通信之前需要先通过三次握手建立虚拟连接，然后才能发送 / 接收数据。</td><td>TCP 协议通常用于需要保证数据可靠性的场景，比如 HTTP 协议、DNS 主从机器间的数据同步。</td></tr><tr><td>UDP</td><td>数据包格式：UDP 协议按照应用层下发到数据组包发送，对端是否需要实现解析器取决于发送方每次发送的数据包是否是完整的应用层数据包。</td><td>不可靠：需要应用层保证可靠性，比如 QUIC 协议。</td><td>否：每次应用层传递一个数据给 UDP 协议时，UDP 协议直接发送到对端。</td><td>UDP 协议通常用户对数据实时性比较高，但数据可靠性比较低的场景，比如视频播放。</td></tr></tbody></table></div>
</body></html>