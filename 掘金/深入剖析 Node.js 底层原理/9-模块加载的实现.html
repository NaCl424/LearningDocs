<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>模块加载的实现</h1>
<p>上一节课我们讲了 Node.js 的启动过程，启动完成后就开始执行代码了。但是，代码不是一整块被加载执行的，而是按模块进行加载的。不管在什么语言里面，代码组织和模块加载都是非常必要且核心的功能，因为用户的代码不可能全部写在一个文件中，而是有组织地分布在各个文件中，所以在一个文件里引入另一个文件的代码就需要用到模块加载器。本节课我们就来讲一下 Node.js 中 CommonJs 模块加载器的实现，了解模块加载器，我们才能知道我们的代码是如何被加载的，同时我们也可以基于模块加载器的原理实现自己的模块加载器。</p>
<p>Node.js 中，我们只需要使用 require 就可以加载各种类型的模块，但是这个 require 到底是什么呢？它的背后到底做了什么事情？下面来详细看一下它的实现。我们从执行一个 Node.js 应用开始分析，假设我们有一个文件 demo.js，代码如下：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-number">1</span>;
</code></pre>
<p>我们看一下执行 node demo.js 的过程是怎样的。在 Node.js 启动过程的课程中讲过，Node.js 启动过程中最终会执行以下代码。</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/modules/cjs/loader'</span>).<span class="hljs-property">Module</span>.<span class="hljs-title function_">runMain</span>(process.<span class="hljs-property">argv</span>[<span class="hljs-number">1</span>]);
</code></pre>
<p>require 是 C++ 层传入的内置 JS 模块加载器，runMain 函数在 pre_execution.js 的 initializeCJSLoader 中挂载。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initializeCJSLoader</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">CJSLoader</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/modules/cjs/loader'</span>);  
  <span class="hljs-title class_">CJSLoader</span>.<span class="hljs-property">Module</span>.<span class="hljs-property">runMain</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/modules/run_main'</span>).<span class="hljs-property">executeUserEntryPoint</span>;  
}  
</code></pre>
<p>我们看到 runMain 是 run_main.js 模块导出的函数。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CJSLoader</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/modules/cjs/loader'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">Module</span> } = <span class="hljs-title class_">CJSLoader</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">executeUserEntryPoint</span>(<span class="hljs-params">main = process.argv[<span class="hljs-number">1</span>]</span>) {  
  <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">_load</span>(main, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);    
}  
  
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {  
  executeUserEntryPoint  
};  
</code></pre>
<p>最终执行的是 executeUserEntryPoint，入参是 process.argv[1]，process.argv[1] 就是我们要执行的 JS 文件，最后通过 Module._load 加载了demo.js。下面看一下具体的处理逻辑。</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Module</span>.<span class="hljs-property">_load</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">request, parent, isMain</span>) {  
  <span class="hljs-keyword">const</span> filename = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">_resolveFilename</span>(request, parent, isMain);  
  
  <span class="hljs-keyword">const</span> cachedModule = <span class="hljs-title class_">Module</span>.<span class="hljs-property">_cache</span>[filename];  
  <span class="hljs-comment">// 有缓存则直接返回  </span>
  <span class="hljs-keyword">if</span> (cachedModule !== <span class="hljs-literal">undefined</span>) {  
    <span class="hljs-keyword">return</span> cachedModule.<span class="hljs-property">exports</span>;  
  }  
  <span class="hljs-comment">// 是否是可访问的内置 JS 模块，是则返回  </span>
  <span class="hljs-keyword">const</span> mod = <span class="hljs-title function_">loadNativeModule</span>(filename, request);  
  <span class="hljs-keyword">if</span> (mod &#x26;&#x26; mod.<span class="hljs-property">canBeRequiredByUsers</span>) <span class="hljs-keyword">return</span> mod.<span class="hljs-property">exports</span>;  
  <span class="hljs-comment">// 非原生 JS 模块，则新建一个 Module 表示加载的模块  </span>
  <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Module</span>(filename, parent);  
  <span class="hljs-comment">// 缓存  </span>
  <span class="hljs-title class_">Module</span>.<span class="hljs-property">_cache</span>[filename] = <span class="hljs-variable language_">module</span>;  
  <span class="hljs-keyword">let</span> threw = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 加载</span>
    <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">load</span>(filename);
    threw = <span class="hljs-literal">false</span>;
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 加载失败则删除缓存，避免内存泄露</span>
    <span class="hljs-keyword">if</span> (threw) {
      <span class="hljs-keyword">delete</span> <span class="hljs-title class_">Module</span>.<span class="hljs-property">_cache</span>[filename];
    }
  }
  <span class="hljs-comment">// 加载中设置了 module.exports 的值，这里返回</span>
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;  
};  
</code></pre>
<p>_load 函数主要是 3 个逻辑：</p>
<ol>
<li>判断是否有缓存，有则返回；</li>
</ol>

<ol start="2">
<li>没有缓存，则判断是否是原生 JS 模块，是则交给原生模块处理；</li>
</ol>

<ol start="3">
<li>不是原生模块，则新建一个 Module 表示用户的 JS 模块，然后执行 load 函数加载。</li>
</ol>
<p>这里我们只需要关注 3 的逻辑，在 Node.js 中，用户定义的模块使用 Module 表示，也就是我们在代码里使用的 module 对象，比如我们经常使用 module.exports 导出模块的功能。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Module</span>(<span class="hljs-params">id = <span class="hljs-string">''</span>, parent</span>) {  
  <span class="hljs-comment">// 模块对应的文件路径  </span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;  
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">path</span> = path.<span class="hljs-title function_">dirname</span>(id);  
  <span class="hljs-comment">// 在模块里使用的 exports 变量  </span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">exports</span> = {};  
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span> = parent;  
  <span class="hljs-comment">// 加入父模块的 children 队列  </span>
  <span class="hljs-title function_">updateChildren</span>(parent, <span class="hljs-variable language_">this</span>, <span class="hljs-literal">false</span>);  
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">filename</span> = <span class="hljs-literal">null</span>;  
  <span class="hljs-comment">// 是否已经加载  </span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">loaded</span> = <span class="hljs-literal">false</span>;  
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = [];  
}  
</code></pre>
<p>接着看一下 load 函数的逻辑。</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Module</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">load</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">filename</span>) {  
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">filename</span> = filename;  
  <span class="hljs-comment">// 根据文件名找到拓展名  </span>
  <span class="hljs-keyword">const</span> extension = <span class="hljs-title function_">findLongestRegisteredExtension</span>(filename);  
  <span class="hljs-comment">// 根据拓展名使用不同的加载方式  </span>
  <span class="hljs-title class_">Module</span>.<span class="hljs-property">_extensions</span>[extension](<span class="hljs-variable language_">this</span>, filename);  
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">loaded</span> = <span class="hljs-literal">true</span>;  
};  
</code></pre>
<p>Node.js 会根据不同的文件拓展名使用不同的函数处理。_extensions 有 3 种，分别是 json、js、node（Addon 模块）。</p>
<h2>JSON 模块</h2>
<p>加载 JSON 模块是比较简单的，直接读取 JSON 文件的内容，然后解析成对象就行。</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Module</span>.<span class="hljs-property">_extensions</span>[<span class="hljs-string">'.json'</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, filename</span>) {  
  <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(filename, <span class="hljs-string">'utf8'</span>);  
  
  <span class="hljs-keyword">try</span> {  
    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">JSON</span>Parse(<span class="hljs-title function_">stripBOM</span>(content));  
  } <span class="hljs-keyword">catch</span> (err) {  
    err.<span class="hljs-property">message</span> = filename + <span class="hljs-string">': '</span> + err.<span class="hljs-property">message</span>;  
    <span class="hljs-keyword">throw</span> err;  
  }  
};  
</code></pre>
<h2>用户 JS 模块</h2>
<p>用户 JS 模块就是我们自己实现的 JS 代码，而不是 Node.js 内置的 JS 代码。用户 JS 模块的处理函数如下。</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Module</span>.<span class="hljs-property">_extensions</span>[<span class="hljs-string">'.js'</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, filename</span>) {
  <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(filename, <span class="hljs-string">'utf8'</span>);
  <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">_compile</span>(content, filename);
};
</code></pre>
<p>首先同步从硬盘中读取文件内容到内存中，读完文件的内容后，接着执行 _compile 函数。</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Module</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_compile</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">content, filename</span>) {  
  <span class="hljs-comment">// 生成一个函数  </span>
  <span class="hljs-keyword">const</span> compiledWrapper = <span class="hljs-title function_">wrapSafe</span>(filename, content, <span class="hljs-variable language_">this</span>);  
  <span class="hljs-keyword">const</span> dirname = path.<span class="hljs-title function_">dirname</span>(filename);  
  <span class="hljs-comment">// 模块里使用的 require 函数，用于加载其他模块（用户 JS 和内置 JS 模块）</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">require</span> = (<span class="hljs-params">path</span>) => {
      <span class="hljs-comment">// this.require是对 _load 函数的封装 </span>
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-built_in">require</span>(path);
    };
  <span class="hljs-keyword">let</span> result;  
  <span class="hljs-comment">// 我们平时使用的 exports 变量</span>
  <span class="hljs-keyword">const</span> <span class="hljs-built_in">exports</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">exports</span>;  
  <span class="hljs-keyword">const</span> thisValue = <span class="hljs-built_in">exports</span>; 
  <span class="hljs-comment">// 我们平时使用的 module 变量 </span>
  <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-variable language_">this</span>;  
  <span class="hljs-comment">// 执行函数  </span>
  result = compiledWrapper.<span class="hljs-title function_">call</span>(thisValue,
                                <span class="hljs-built_in">exports</span>, 
                                <span class="hljs-built_in">require</span>, 
                                <span class="hljs-variable language_">module</span>, 
                                filename, 
                                dirname);  
  <span class="hljs-keyword">return</span> result;  
}  
</code></pre>
<p>_compile 首先通过 wrapSafe 编译需要加载的 JS 代码。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">wrapSafe</span>(<span class="hljs-params">filename, content, cjsModuleInstance</span>) {    
    compiled = <span class="hljs-title function_">compileFunction</span>(
      <span class="hljs-comment">// 要执行的代码</span>
      content,
      <span class="hljs-comment">// 对应的文件</span>
      filename,
      <span class="hljs-number">0</span>,
      <span class="hljs-number">0</span>,
      <span class="hljs-literal">undefined</span>,
      <span class="hljs-literal">false</span>,
      <span class="hljs-literal">undefined</span>,
      [],
      <span class="hljs-comment">// 形参</span>
      [
        <span class="hljs-string">'exports'</span>,
        <span class="hljs-string">'require'</span>,
        <span class="hljs-string">'module'</span>,
        <span class="hljs-string">'__filename'</span>,
        <span class="hljs-string">'__dirname'</span>,
      ]
    );  
}    
   
</code></pre>
<p>compileFunction 是 C++ 层提供的函数，主要是对 V8 CompileFunctionInContext 的封装。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ContextifyContext::CompileFunction</span><span class="hljs-params">(
    <span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
  Environment* env = Environment::<span class="hljs-built_in">GetCurrent</span>(args);
  Isolate* isolate = env-><span class="hljs-built_in">isolate</span>();
  Local&#x3C;Context> context = env-><span class="hljs-built_in">context</span>();

  <span class="hljs-comment">// 要执行的代码</span>
  Local&#x3C;String> code = args[<span class="hljs-number">0</span>].<span class="hljs-built_in">As</span>&#x3C;String>();

  <span class="hljs-comment">// 对应的文件</span>
  Local&#x3C;String> filename = args[<span class="hljs-number">1</span>].<span class="hljs-built_in">As</span>&#x3C;String>();
  
  <span class="hljs-comment">// 忽略其他参数的处理</span>
  
  <span class="hljs-comment">// 形参</span>
  Local&#x3C;Array> params_buf;
  <span class="hljs-keyword">if</span> (!args[<span class="hljs-number">8</span>]-><span class="hljs-built_in">IsUndefined</span>()) {
    params_buf = args[<span class="hljs-number">8</span>].<span class="hljs-built_in">As</span>&#x3C;Array>();
  }
  <span class="hljs-comment">// 代码的元信息</span>
  <span class="hljs-function">ScriptOrigin <span class="hljs-title">origin</span><span class="hljs-params">(filename, ...)</span></span>;

  <span class="hljs-function">ScriptCompiler::Source <span class="hljs-title">source</span><span class="hljs-params">(code, origin, cached_data)</span></span>;
  
  <span class="hljs-comment">// 形参</span>
  std::vector&#x3C;Local&#x3C;String>> params;
  <span class="hljs-keyword">if</span> (!params_buf.<span class="hljs-built_in">IsEmpty</span>()) {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> n = <span class="hljs-number">0</span>; n &#x3C; params_buf-><span class="hljs-built_in">Length</span>(); n++) {
      Local&#x3C;Value> val;
      <span class="hljs-keyword">if</span> (!params_buf-><span class="hljs-built_in">Get</span>(context, n).<span class="hljs-built_in">ToLocal</span>(&#x26;val)) <span class="hljs-keyword">return</span>;
      params.<span class="hljs-built_in">push_back</span>(val.<span class="hljs-built_in">As</span>&#x3C;String>());
    }
  }

  Local&#x3C;ScriptOrModule> script;
  <span class="hljs-comment">// 编译代码执行</span>
  MaybeLocal&#x3C;Function> maybe_fn = ScriptCompiler::<span class="hljs-built_in">CompileFunctionInContext</span>(
      parsing_context, &#x26;source, params.<span class="hljs-built_in">size</span>(), params.<span class="hljs-built_in">data</span>(),
      context_extensions.<span class="hljs-built_in">size</span>(), context_extensions.<span class="hljs-built_in">data</span>(), options,
      v8::ScriptCompiler::NoCacheReason::kNoCacheNoReason, &#x26;script);
  <span class="hljs-comment">// 返回一个函数，函数里面的代码是传入的 code</span>
  Local&#x3C;Function> fn = maybe_fn.<span class="hljs-built_in">ToLocalChecked</span>();
  <span class="hljs-comment">// 最终返回这个函数的信息</span>
}
</code></pre>
<p>CompileFunction 返回类似以下函数。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"><span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span>, <span class="hljs-variable language_">module</span>, __filename, __dirname</span>) { 
  <span class="hljs-comment">// code</span>
};   
</code></pre>
<p>接着传入实参并执行这个函数，可以看到一共有五个参数，exports 和 module 就是我们在代码里经常用来导出模块内容的变量，module 是一个 Module 对象，exports 是 module 的属性，另外还有一个参数是 require，从这可以看到为什么我们在代码里没有定义 require 但是却可以使用，这个 require 函数就是从参数里来的，而不是全局变量。</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Module</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">require</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) {  
   requireDepth++;  
   <span class="hljs-keyword">try</span> {  
     <span class="hljs-keyword">return</span> <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">_load</span>(id, <span class="hljs-variable language_">this</span>, <span class="hljs-comment">/* isMain */</span> <span class="hljs-literal">false</span>);  
   } <span class="hljs-keyword">finally</span> {  
     requireDepth--;  
   }  
};  
</code></pre>
<p>require 是对 Module._load 的封装，这就意味着我们在代码里可以通过 require 加载用户 JS 和内置 JS 模块。最终执行以下代码。</p>
<pre><code class="hljs language-js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span>, <span class="hljs-variable language_">module</span>, __filename, __dirname</span>) {  
  <span class="hljs-comment">// 可以 require 其他模块</span>
  <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-number">1</span>;
});   
</code></pre>
<p>当执行require加载模块时，又回到了我们前面分析的这个过程，整体流程如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6184a0a7650e4fffba2f189d4cc0d890~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>Addon 模块</h2>
<p>接着看 Addon 模块的加载，Addon 模块本质上是动态链接库，所以我们先看看如何创建和使用一个动态链接库，代码可以参考<a href="https://github.com/theanarkh/nodejs-book/tree/main/src/dynamic_library" target="_blank" rel="nofollow noopener noreferrer">这里</a>。首先创建一个 library.c 文件。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>
{
  <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<p>library.c 定义里一个 add 函数，然后使用以下命令编译成动态链接库。</p>
<pre><code class="hljs language-vbnet">gcc -fPIC -<span class="hljs-keyword">shared</span> library.c -o liblibrary.so
</code></pre>
<p>接着写一个测试函数动态打开并使用该动态链接库。</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span>  </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdlib.h></span>  </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;dlfcn.h></span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span><span class="hljs-params">(*fn)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{  
    <span class="hljs-comment">// 打开一个动态链接库，拿到一个 handler  </span>
    <span class="hljs-type">void</span> * handler = dlopen(<span class="hljs-string">"liblibrary.so"</span>,RTLD_LAZY);  
    <span class="hljs-comment">// 取出动态链接库里的函数 add  </span>
    <span class="hljs-type">void</span> * add = dlsym(handler, <span class="hljs-string">"add"</span>);  
    <span class="hljs-comment">// 执行  </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,((fn)add)(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>));  
    dlclose(handler);  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}  
</code></pre>
<p>执行 gcc main.c -o main &#x26;&#x26; ./main 后我们可以看到输出 2。每次调 dlopen 动态链接库的引用数会加一，引用数大于 0 时再调用 dlopen 不会再执行动态链接库的初始化函数，并且拿到的 handler 地址是一样的。每次 dlclose 会减一，如果引用数为 0 再调用 dlopen 则会重新执行动态链接库的初始化函数，并且 handler 对应的地址可能是不一样的，更多例子参考<a href="https://github.com/theanarkh/nodejs-book/tree/main/src/dynamic_library" target="_blank" rel="nofollow noopener noreferrer">这里</a>。</p>
<p>了解动态链接库的使用后，我们来看一下 Node.js 中几个和 Addon 相关的数据结构。先看看 binding::DLib 这个类。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DLib</span> {  
 <span class="hljs-keyword">public</span>:  
  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kDefaultFlags = RTLD_LAZY;  
  <span class="hljs-built_in">DLib</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, <span class="hljs-type">int</span> flags);  
  <span class="hljs-comment">// 打开 / 关闭一个动态链接库</span>
  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Open</span><span class="hljs-params">()</span></span>;  
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;  
  <span class="hljs-comment">// 根据名字获取动态链接库中的函数地址</span>
  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">GetSymbolAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span></span>;
  <span class="hljs-comment">// 模块名</span>
  <span class="hljs-type">const</span> std::string filename_;  
  <span class="hljs-comment">// 打开动态链接库时传入的 flags</span>
  <span class="hljs-type">const</span> <span class="hljs-type">int</span> flags_;  
  std::string errmsg_;
  <span class="hljs-comment">// 动态链接库的信息  </span>
  <span class="hljs-type">void</span>* handle_;  
  <span class="hljs-type">uv_lib_t</span> lib_;  
};  
</code></pre>
<p>DLib 负责管理一个动态链接库，包括打开、关闭和获取某个函数的地址等。接着看一下 node_module。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node_module</span> {
  <span class="hljs-type">int</span> nm_version;
  <span class="hljs-comment">// 模块属性，比如类型</span>
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nm_flags;
  <span class="hljs-comment">// 打开动态链接库时返回的 handler</span>
  <span class="hljs-type">void</span>* nm_dso_handle;
  <span class="hljs-comment">// 文件</span>
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* nm_filename;
  <span class="hljs-comment">// 钩子函数，不同钩子不同的签名格式</span>
  node::addon_register_func nm_register_func;
  node::addon_context_register_func nm_context_register_func;
  <span class="hljs-comment">// 模块名</span>
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* nm_modname;
  <span class="hljs-comment">// 根据模块类型自定义的数据结构</span>
  <span class="hljs-type">void</span>* nm_priv;
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node_module</span>* nm_link;
};
</code></pre>
<p>node_module 是表示 C++ 模块的数据结构，比如内置 C++ 模块和 Addon 模块。其中 Addon 模块可以通过原生（struct node_module）和 NAPI 方式定义（struct napi_module），原生方式是直接面向 V8 和 Libuv 编程，需要考虑所使用 API 的兼容性问题，如果是源码分发，用户安装时需要有相应的环境，如果是预构建分发，我们通常需要为多个操作系统和多个 Node.js 提供相应的版本，所以我们尽量使用 NAPI 来写 Addon ，并根据操作系统提供预构建版本。</p>
<p>先看一下原生的定义方式，第一种方式如下。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(v8::Local&#x3C;v8::Object> exports)</span> </span>{}

<span class="hljs-built_in">NODE_MODULE</span>(hello, Init)
</code></pre>
<p>NODE_MODULE 展开如下：</p>
<pre><code class="hljs language-c++"> <span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_MODULE(modname, regfunc)  \
     NODE_MODULE_X(modname, regfunc, NULL, 0)</span>
     
 <span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_MODULE_X(modname, regfunc, priv, flags)                  \
 static node::node_module _module =                                \
    {                                                                 \
      NODE_MODULE_VERSION,                                            \
      flags,                                                          \
      NULL,              \
      __FILE__,             \                                         \
      (node::addon_register_func) (regfunc), <span class="hljs-comment">/* Init 函数 */</span>           \
      NULL,               \
      NODE_STRINGIFY(modname),                                        \
      priv,                                                           \
      NULL                   \
    };                                                                \
    static void _register_modname(void) __attribute__((constructor)); \                      \
    static void _register_modname(void)  {                            \
      node_module_register(&#x26;_module);                                 \
    }                                                                 \
  }</span>
</code></pre>
<p>这种方式定义了一个 node_module 和一个 _register_modname（modname 由用户定义） 函数，__attribute((constructor)) 说明加载动态链接库时会执行该函数，也就是说这个函数会在我们 require 时被执行，下面再详细分析 _register_modname 的逻辑。另外需要注意的是，通过 NODE_MODULE 方式定义的 Addon 是只能被加载一次，除非关闭后重新打开。使用场景如下</p>
<ol>
<li>如果先在主线程里加载该 Addon，则不能再在子线程里加载。</li>
</ol>

<ol start="2">
<li>如果先在子线程里加载该 Addon，则不能再在主线程和其他子线程里加载，除非打开该 Addon 的子线程退出。</li>
</ol>
<p>否则会提示 Module did not self-register 错误，当碰到这个错误时，很多同学可能不知道具体原因，其实从错误提示中，我们也的确看不出是什么原因。这也是看源码的一个好处，我们通过分析源码知道这个错误具体的原因。看一下下面的例子，当我们以以下方式加载一个通过 NODE_MODULE 定义的 addon 时，就会触发这个 Module did not self-register 错误，如果单独加载则正常，为什么呢？下面的内容会详细讲解。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Worker</span>, isMainThread } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);
<span class="hljs-keyword">if</span> (isMainThread) {
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'addon'</span>);
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(__filename);
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'addon'</span>);
}
</code></pre>
<p>如果我们想要定一个在主线程和子线程里都可以加载的 Addon，则需要定义一个 Context-aware Addon，具体可以参考 <a href="https://nodejs.org/dist/latest-v19.x/docs/api/addons.html#context-aware-addons" target="_blank" rel="nofollow noopener noreferrer">Node.js 文档</a>，下面看一下定义方式。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(
  Local&#x3C;Object> exports,
  Local&#x3C;Value> <span class="hljs-keyword">module</span>,
  Local&#x3C;Context> context
)</span> </span>{
  
}

<span class="hljs-built_in">NODE_MODULE_CONTEXT_AWARE</span>(NODE_GYP_MODULE_NAME, Initialize)
</code></pre>
<p>宏展开后如下：</p>
<pre><code class="hljs language-c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_MODULE_CONTEXT_AWARE(modname, regfunc)                   \
  NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, NULL, 0)</span>
  
  
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, priv, flags)    \
  extern <span class="hljs-string">"C"</span> {                                                        \
    static node::node_module _module =                                \
    {                                                                 \
      NODE_MODULE_VERSION,                                            \
      flags,                                                          \
      NULL,  <span class="hljs-comment">/* NOLINT (readability/null_usage) */</span>                    \
      __FILE__,                                                       \
      NULL,  <span class="hljs-comment">/* NOLINT (readability/null_usage) */</span>                    \
      (node::addon_context_register_func) (regfunc),                  \
      NODE_STRINGIFY(modname),                                        \
      priv,                                                           \
      NULL  <span class="hljs-comment">/* NOLINT (readability/null_usage) */</span>                     \
    };                                                                \
    NODE_C_CTOR(_register_ ## modname) {                              \
      node_module_register(&#x26;_module);                                 \
    }                                                                 \
  }    </span>
</code></pre>
<p>这种也是定义了一个 node_module 和 _register_modname 函数，区别是设置的钩子函数是 addon_context_register_func，而不是 addon_register_func。继续看下一种定义方式。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hello</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
  
}

<span class="hljs-built_in">NODE_MODULE_INIT</span>(<span class="hljs-comment">/*exports, module, context*/</span>) {
  <span class="hljs-built_in">NODE_SET_METHOD</span>(exports, <span class="hljs-string">"hello"</span>, Hello);
}
</code></pre>
<p>宏展开后如下。</p>
<pre><code class="hljs language-c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_MODULE_INIT()                                            \
  extern <span class="hljs-string">"C"</span> NODE_MODULE_EXPORT void                                  \
  NODE_MODULE_INITIALIZER(v8::Local<span class="hljs-string">&#x3C;v8::Object></span> exports,              \
                          v8::Local<span class="hljs-string">&#x3C;v8::Value></span> module,                \
                          v8::Local<span class="hljs-string">&#x3C;v8::Context></span> context);            \
  NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME,                     \
                            NODE_MODULE_INITIALIZER)                  \
  void NODE_MODULE_INITIALIZER(v8::Local<span class="hljs-string">&#x3C;v8::Object></span> exports,         \
                               v8::Local<span class="hljs-string">&#x3C;v8::Value></span> module,           \
                               v8::Local<span class="hljs-string">&#x3C;v8::Context></span> context)</span>
</code></pre>
<p>再次展开。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> __attribute__((<span class="hljs-built_in">visibility</span>(<span class="hljs-string">"default"</span>))) <span class="hljs-function"><span class="hljs-type">void</span>
<span class="hljs-title">node_register_module_vNODE_MODULE_VERSION</span><span class="hljs-params">(Local&#x3C;Object> exports,
                        Local&#x3C;Value> <span class="hljs-keyword">module</span>,
                        Local&#x3C;Context> context)</span></span>;
  <span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> {                                                        \
    <span class="hljs-type">static</span> node::node_module _module =                                \
    {                                                                 \
      NODE_MODULE_VERSION,                                            \
      flags,                                                          \
      <span class="hljs-literal">NULL</span>,  <span class="hljs-comment">/* NOLINT (readability/null_usage) */</span>                    \
      __FILE__,                                                       \
      <span class="hljs-literal">NULL</span>,                                                           \
       <span class="hljs-comment">/* node_register_module_vNODE_MODULE_VERSION */</span>                \
      (node::addon_context_register_func) (regfunc),                  \
      <span class="hljs-built_in">NODE_STRINGIFY</span>(modname),                                        \
      priv,                                                           \
      <span class="hljs-literal">NULL</span>  <span class="hljs-comment">/* NOLINT (readability/null_usage) */</span>                     \
    };                                                                \
    <span class="hljs-built_in">NODE_C_CTOR</span>(_register_ #<span class="hljs-meta"># modname) {                              \
      node_module_register(&#x26;_module);                                 \
    }                                                                 \
  }  </span>
  
<span class="hljs-built_in">node_register_module_vNODE_MODULE_VERSION</span>(Local&#x3C;Object> exports,
                        Local&#x3C;Value> <span class="hljs-keyword">module</span>,
                        Local&#x3C;Context> context) {
  <span class="hljs-built_in">NODE_SET_METHOD</span>(exports, <span class="hljs-string">"hello"</span>, Hello);
}
</code></pre>
<p>这种方式和前面一种类似，只是函数名格式不一样（从 _register_modname 变成 node_register_module_vNODE_MODULE_VERSION）。继续看下一种定义方式。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function">NODE_MODULE_EXPORT <span class="hljs-type">void</span>
<span class="hljs-title">NODE_MODULE_INITIALIZER</span><span class="hljs-params">(Local&#x3C;Object> exports,
                        Local&#x3C;Value> <span class="hljs-keyword">module</span>,
                        Local&#x3C;Context> context)</span> </span>{
}
</code></pre>
<p>宏展开后如下。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> __attribute__((<span class="hljs-built_in">visibility</span>(<span class="hljs-string">"default"</span>))) <span class="hljs-function"><span class="hljs-type">void</span>
<span class="hljs-title">node_register_module_vNODE_MODULE_VERSION</span><span class="hljs-params">(Local&#x3C;Object> exports,
                        Local&#x3C;Value> <span class="hljs-keyword">module</span>,
                        Local&#x3C;Context> context)</span> </span>{
}
</code></pre>
<p>这种方式不需要定义 node_module 数据结构，而是通过显式定义一个node_register_module_vxxx 函数并导出来告诉 Node.js 该 Addon 的初始化函数，其中 NODE_MODULE_VERSION 随着 Node.js 的大版本变化，Node.js 加载 Addon 时会执行该函数，下面会具体分析。对于 Context-aware Addon 的定义我们随便选一种方式就可以了。</p>
<p>接着看通过 NAPI Addon 的定义方式，NAPI 的好处是 ABI 兼容的，我们编写的代码可跨 Node.js 的大版本运行。NAPI 方式定义的 Addon 有自己的数据结构 napi_module。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
  <span class="hljs-type">int</span> nm_version;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nm_flags;
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* nm_filename;
  napi_addon_register_func nm_register_func;
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* nm_modname;
  <span class="hljs-type">void</span>* nm_priv;
  <span class="hljs-type">void</span>* reserved[<span class="hljs-number">4</span>];
} napi_module;
</code></pre>
<p>先看第一种定义方式。</p>
<pre><code class="hljs language-c++"><span class="hljs-function">napi_value <span class="hljs-title">Init</span><span class="hljs-params">(napi_env env, napi_value exports)</span> </span>{}
<span class="hljs-built_in">NAPI_MODULE</span>(NODE_GYP_MODULE_NAME, Init)
</code></pre>
<p>这是个宏定义，宏展开后如下。</p>
<pre><code class="hljs language-c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAPI_MODULE(modname, regfunc) \    </span>
  <span class="hljs-built_in">NAPI_MODULE_X</span>(modname, regfunc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)    
  
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NAPI_MODULE_X(modname, regfunc, priv, flags)                  \    </span>
   <span class="hljs-type">static</span> napi_module _module = \    
   {                  \    
     NAPI_MODULE_VERSION, \    
     flags,          \    
     __FILE__,        \   
     <span class="hljs-comment">// nm_register_func \ </span>
     regfunc,        \    
     <span class="hljs-meta">#modname,        \    </span>
     priv,            \    
     {<span class="hljs-number">0</span>},            \    
   };                \    
   <span class="hljs-type">static</span> <span class="hljs-type">void</span> _register_modname(<span class="hljs-type">void</span>) __attribute__((constructor)); \    
   <span class="hljs-type">static</span> <span class="hljs-type">void</span> _register_modname(<span class="hljs-type">void</span>)      {    \    
     <span class="hljs-built_in">napi_module_register</span>(&#x26;_module);  \    
   }      
</code></pre>
<p>通过 NAPI_MODULE 定义的 Addon，定义了一个 napi_module 结构体和 _register_modname 函数，并且 _register_modname 里调用的是 napi_module_register 而不是 node_module_register，不过 napi_module_register 里最终还是会调用 node_module_register。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">napi_module_register</span><span class="hljs-params">(napi_module* mod)</span> </span>{
  node::node_module* nm = <span class="hljs-keyword">new</span> node::node_module {
    <span class="hljs-number">-1</span>,
    mod->nm_flags | NM_F_DELETEME,
    <span class="hljs-literal">nullptr</span>,
    mod->nm_filename,
    <span class="hljs-literal">nullptr</span>,
    <span class="hljs-comment">// addon_context_register_func</span>
    napi_module_register_cb,
    mod->nm_modname,
    mod,  <span class="hljs-comment">// 保存 napi_module 结构体</span>
    <span class="hljs-literal">nullptr</span>,
  };
  node::<span class="hljs-built_in">node_module_register</span>(nm);
}
</code></pre>
<p>接着看另一种 NAPI Addon 定义方式。</p>
<pre><code class="hljs language-c++"><span class="hljs-built_in">NAPI_MODULE_INIT</span>() {
}
</code></pre>
<p>宏展开如下。</p>
<pre><code class="hljs language-c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAPI_MODULE_INIT()                                            \
  EXTERN_C_START                                                      \
  NAPI_MODULE_EXPORT napi_value                                       \
  NAPI_MODULE_INITIALIZER(napi_env env, napi_value exports);          \
  EXTERN_C_END                                                        \
  NAPI_MODULE(NODE_GYP_MODULE_NAME, NAPI_MODULE_INITIALIZER)          \
  napi_value NAPI_MODULE_INITIALIZER(napi_env env, napi_value exports)</span>
</code></pre>
<p>继续展开如下。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> __attribute__((<span class="hljs-built_in">visibility</span>(<span class="hljs-string">"default"</span>))) <span class="hljs-function">napi_value
<span class="hljs-title">napi_register_module_vNAPI_MODULE_VERSION</span><span class="hljs-params">(napi_env env, napi_value exports)</span></span>;

<span class="hljs-type">static</span> napi_module _module = \    
   {                  \    
     NAPI_MODULE_VERSION, \    
     flags,          \    
     __FILE__,        \   
     <span class="hljs-comment">// nm_register_func \ </span>
     napi_register_module_vNAPI_MODULE_VERSION,        \    
     <span class="hljs-meta">#modname,        \    </span>
     priv,            \    
     {<span class="hljs-number">0</span>},            \    
   };                \
                  \    
<span class="hljs-type">static</span> <span class="hljs-type">void</span> _register_modname(<span class="hljs-type">void</span>) __attribute__((constructor)); \    
<span class="hljs-type">static</span> <span class="hljs-type">void</span> _register_modname(<span class="hljs-type">void</span>)      {    \    
 <span class="hljs-built_in">napi_module_register</span>(&#x26;_module);  \    
}   
      
<span class="hljs-function">napi_value <span class="hljs-title">napi_register_module_vNAPI_MODULE_VERSION</span><span class="hljs-params">(napi_env env, napi_value exports)</span>
</span></code></pre>
<p>这种方式和第一种是类似的，区别是函数的名字格式不一样，由用户定义的函数变成 napi_register_module_vNAPI_MODULE_VERSION，相当于 Node.js 帮起了名字。另外 NAPI 定义的 Addon 都是 Context-aware 的。</p>
<p>定义的方式很多，但是总结下来，第一种是导出一个函数，第二种是在打开动态链接库时注册执行 一个函数，另外 NODE_MODULE 定义的是 nm_register_func 钩子，其他定义方式定义的是 addon_context_register_func 钩子。接着看一下 Node.js 里是如何处理的，我们从加载 .node 模块的源码开始看。</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Module</span>.<span class="hljs-property">_extensions</span>[<span class="hljs-string">'.node'</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, filename</span>) {  
  <span class="hljs-comment">// ...  </span>
  <span class="hljs-keyword">return</span> process.<span class="hljs-title function_">dlopen</span>(<span class="hljs-variable language_">module</span>, path.<span class="hljs-title function_">toNamespacedPath</span>(filename)); 
};  
</code></pre>
<p>直接调了 process.dlopen，该函数在 node.js 里定义。</p>
<pre><code class="hljs language-c++"><span class="hljs-type">const</span> rawMethods = <span class="hljs-built_in">internalBinding</span>(<span class="hljs-string">'process_methods'</span>);  
process.dlopen = rawMethods.dlopen;  
</code></pre>
<p>找到 process_methods 模块对应的是 node_process_methods.cc。</p>
<pre><code class="hljs language-c++">env-><span class="hljs-built_in">SetMethod</span>(target, <span class="hljs-string">"dlopen"</span>, binding::DLOpen);  
</code></pre>
<p>继续分析刚才看到的 DLOpen 函数。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DLOpen</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{  
  
  <span class="hljs-type">int32_t</span> flags = DLib::kDefaultFlags;
  <span class="hljs-comment">// 模块名</span>
  <span class="hljs-function">node::Utf8Value <span class="hljs-title">filename</span><span class="hljs-params">(env->isolate(), args[<span class="hljs-number">1</span>])</span></span>;  
  <span class="hljs-comment">// 加载并执行回调</span>
  env-><span class="hljs-built_in">TryLoadAddon</span>(*filename, flags, [&#x26;](DLib* dlib) {  
    <span class="hljs-comment">// ... </span>
  });  
}  
</code></pre>
<p>接着看 TryLoadAddon 函数。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Environment::TryLoadAddon</span><span class="hljs-params">(
    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename,
    <span class="hljs-type">int</span> flags,
    <span class="hljs-type">const</span> std::function&#x3C;<span class="hljs-type">bool</span>(binding::DLib*)>&#x26; was_loaded)</span> </span>{
  <span class="hljs-comment">// std::list&#x3C;binding::DLib> loaded_addons_;</span>
  <span class="hljs-comment">// 创建一个 DLib 对象</span>
  loaded_addons_.<span class="hljs-built_in">emplace_back</span>(filename, flags);
  <span class="hljs-comment">// loaded_addons_.back() 拿到上面创建的 DLib 对象</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">was_loaded</span>(&#x26;loaded_addons_.<span class="hljs-built_in">back</span>())) {
    loaded_addons_.<span class="hljs-built_in">pop_back</span>();
  }
}
</code></pre>
<p>TryLoadAddon 创建了一个 binding::DLib 对象，接着以此对象为入参执行传入的函数，接着看 TryLoadAddon 里执行的函数，里面代码比较多，我们分开讲。</p>
<pre><code class="hljs language-c++"> env-><span class="hljs-built_in">TryLoadAddon</span>(*filename, flags, [&#x26;](DLib* dlib) {  
    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> is_opened = dlib-><span class="hljs-built_in">Open</span>();
 }); 
   
</code></pre>
<p>首先通过 dlib->Open() 打开动态链接库。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DLib::Open</span><span class="hljs-params">()</span> </span>{  
  handle_ = <span class="hljs-built_in">dlopen</span>(filename_.<span class="hljs-built_in">c_str</span>(), flags_);  
  <span class="hljs-keyword">if</span> (handle_ != <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  
  errmsg_ = <span class="hljs-built_in">dlerror</span>();  
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  
}  
</code></pre>
<p>刚才讲过，Addon 主要是两种定义方式，第一种是定义了一个打开链接库时执行 _register_modname 函数，第二种是导出了一个函数。我们看一下 _register_modname 做了什么事情，对于原生方式定义的 Addon，_register_modname 里执行了 node_module_register，对于 NAPI 定义的 Addon，_register_modname 里执行了 napi_module_register。我们只分析最长路径的情况：napi_module_register。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">napi_module_register</span><span class="hljs-params">(napi_module* mod)</span> </span>{
  node::node_module* nm = <span class="hljs-keyword">new</span> node::node_module {
    <span class="hljs-number">-1</span>,
    mod->nm_flags | NM_F_DELETEME,
    <span class="hljs-literal">nullptr</span>,
    mod->nm_filename,
    <span class="hljs-literal">nullptr</span>,
    <span class="hljs-comment">// addon_context_register_func</span>
    napi_module_register_cb,
    mod->nm_modname,
    mod,  <span class="hljs-comment">// 保存 napi_module 结构体</span>
    <span class="hljs-literal">nullptr</span>,
  };
  node::<span class="hljs-built_in">node_module_register</span>(nm);
}
</code></pre>
<p>napi_module_register 中创建了一个 node_module 结构体，最终也是调用了 node_module_register。这里有两个关键的地方，首先 noed_module 结构体的钩子函数是 napi_module_register_cb，而不是用户定义的函数，用户定义的函数由 napi_module 保存。另外在 node_module 中保存了 napi_module 结构体，后续加载的时候会用到，最后继续调用 node_module_register。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">node_module_register</span><span class="hljs-params">(<span class="hljs-type">void</span>* m)</span> </span>{  
  thread_local_modpending = <span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-keyword">struct</span> node_module*>(m); 
}  
</code></pre>
<p>node_module_register 把 node_module 保存到 thread_local_modpending 中。thread_local_modpending 是一个线程独立的静态变量，所以多线程加载一个 Addon 也是安全的，它保存当前加载的模块。我们继续看 TryLoadAddon 中执行的代码。</p>
<pre><code class="hljs language-c++"><span class="hljs-type">const</span> <span class="hljs-type">bool</span> is_opened = dlib-><span class="hljs-built_in">Open</span>();
node_module* mp = thread_local_modpending;  
thread_local_modpending = <span class="hljs-literal">nullptr</span>;  
</code></pre>
<p>这时候我们就知道刚才那个变量 thread_local_modpending 的作用了。node_module* mp = thread_local_modpending 后我们拿到了我们刚才定义的 Addon 模块的信息，继续看下面的代码。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// mp 非空说明 Addon 定义了初始化函数，并且是第一次加载或者关闭后重新加载</span>
<span class="hljs-comment">// 初始化函数最终会执行 node_module_register</span>
<span class="hljs-keyword">if</span> (mp != <span class="hljs-literal">nullptr</span>) {
  mp->nm_dso_handle = dlib->handle_;
  <span class="hljs-comment">// 保存起来后面复用 global_handle_map.set(handle_, mp);</span>
  dlib-><span class="hljs-built_in">SaveInGlobalHandleMap</span>(mp);
}
</code></pre>
<p>缓存后继续处理</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 针对非 NAPI 格式定义的 Addon 进行校验，-1 是 NAPI 的值</span>
<span class="hljs-comment">// 如果 Addon 的 nm_version 和当前 Node.js 版本的不一致</span>
<span class="hljs-keyword">if</span> ((mp->nm_version != <span class="hljs-number">-1</span>) &#x26;&#x26; (mp->nm_version != NODE_MODULE_VERSION)) {
  <span class="hljs-comment">// 如果定义了 node_register_module_vNODE_MODULE_VERSION 函数则执行</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> callback = <span class="hljs-built_in">GetInitializerCallback</span>(dlib)) {
    <span class="hljs-built_in">callback</span>(exports, <span class="hljs-keyword">module</span>, context);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-comment">// 否则报错</span>
  <span class="hljs-type">char</span> errmsg[<span class="hljs-number">1024</span>];
  <span class="hljs-built_in">snprintf</span>(errmsg,
           <span class="hljs-built_in">sizeof</span>(errmsg),
           <span class="hljs-string">"The module '%s'"</span>
           <span class="hljs-string">"\nwas compiled against a different Node.js version using"</span>
           <span class="hljs-string">"\nNODE_MODULE_VERSION %d. This version of Node.js requires"</span>
           <span class="hljs-string">"\nNODE_MODULE_VERSION %d. Please try re-compiling or "</span>
           <span class="hljs-string">"re-installing\nthe module (for instance, using `npm rebuild` "</span>
           <span class="hljs-string">"or `npm install`)."</span>,
           *filename,
           mp->nm_version,
           NODE_MODULE_VERSION);

  dlib-><span class="hljs-built_in">Close</span>();
  env-><span class="hljs-built_in">ThrowError</span>(errmsg);
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<p>从上面的代码中，可以看到非 NAPI 方式定义的 Addon 是不能跨 Node.js 版版本运行的，需要重新编译，否则就会报错，这个报错相信大家也见过。但是也有一个方法可以解决，也就是为其他版本的 Node.js 定义钩子函数，例如下面的代码。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(
  Local&#x3C;Object> exports,
  Local&#x3C;Value> <span class="hljs-keyword">module</span>,
  Local&#x3C;Context> context
)</span> </span>{
  <span class="hljs-built_in">NODE_SET_METHOD</span>(exports, <span class="hljs-string">"hello"</span>, Hello);
}
<span class="hljs-comment">// 为 Node.js 18 定义钩子函数</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> __attribute__((<span class="hljs-built_in">visibility</span>(<span class="hljs-string">"default"</span>))) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">node_register_module_v108</span><span class="hljs-params">(
  Local&#x3C;Object> exports,
  Local&#x3C;Value> <span class="hljs-keyword">module</span>,
  Local&#x3C;Context> context
)</span> </span>{
  <span class="hljs-built_in">NODE_SET_METHOD</span>(exports, <span class="hljs-string">"hello"</span>, Hello);
}

<span class="hljs-built_in">NODE_MODULE_CONTEXT_AWARE</span>(NODE_GYP_MODULE_NAME, Initialize)
</code></pre>
<p>上面的代码在 Node.js 17 下编译，然后可以直接在 Node.js 17 和 18 版本下运行。通过了校验后，则继续往下处理。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">if</span> (mp->nm_context_register_func != <span class="hljs-literal">nullptr</span>) {
  mp-><span class="hljs-built_in">nm_context_register_func</span>(exports, <span class="hljs-keyword">module</span>, context, mp->nm_priv);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mp->nm_register_func != <span class="hljs-literal">nullptr</span>) {
  mp-><span class="hljs-built_in">nm_register_func</span>(exports, <span class="hljs-keyword">module</span>, mp->nm_priv);
}
</code></pre>
<p>Addon 定义的方式不同，对应的钩子函数也不同，这里判断定义了哪个钩子函数，然后执行它，从而拿到导出的内容。对于 非 NAPI 的模块，就直接执行用户定义的代码，对于 NAPI 模块则执行 napi_module_register_cb。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">napi_module_register_cb</span><span class="hljs-params">(v8::Local&#x3C;v8::Object> exports,  
                                    v8::Local&#x3C;v8::Value> <span class="hljs-keyword">module</span>,  
                                    v8::Local&#x3C;v8::Context> context,  
                                    <span class="hljs-type">void</span>* priv)</span> </span>{  
  <span class="hljs-built_in">napi_module_register_by_symbol</span>(exports, <span class="hljs-keyword">module</span>, context,  
      <span class="hljs-built_in">static_cast</span>&#x3C;napi_module*>(priv)->nm_register_func);  
}  
</code></pre>
<p>该函数调用 napi_module_register_by_symbol 函数，并传入 napi_module 的 nm_register_func 函数，也就是用户定义的代码。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">napi_module_register_by_symbol</span><span class="hljs-params">(v8::Local&#x3C;v8::Object> exports,  
                                    v8::Local&#x3C;v8::Value> <span class="hljs-keyword">module</span>,  
                                    v8::Local&#x3C;v8::Context> context,  
                                    napi_addon_register_func init)</span> </span>{  
  
  napi_env env = v8impl::<span class="hljs-built_in">NewEnv</span>(context);  
  
  napi_value _exports;  
  env-><span class="hljs-built_in">CallIntoModuleThrow</span>([&#x26;](napi_env env) {  
    <span class="hljs-comment">// 执行用户的代码</span>
    _exports = <span class="hljs-built_in">init</span>(env, v8impl::<span class="hljs-built_in">JsValueFromV8LocalValue</span>(exports));  
  });  
  <span class="hljs-comment">// 设置 JS 层拿到的内容</span>
  <span class="hljs-keyword">if</span> (_exports != <span class="hljs-literal">nullptr</span> &#x26;&#x26;  
      _exports != v8impl::<span class="hljs-built_in">JsValueFromV8LocalValue</span>(exports)) { 
    napi_value _module = v8impl::<span class="hljs-built_in">JsValueFromV8LocalValue</span>(<span class="hljs-keyword">module</span>);  
    <span class="hljs-built_in">napi_set_named_property</span>(env, _module, <span class="hljs-string">"exports"</span>, _exports);  
  }  
}  
</code></pre>
<p>init 就是我们 Addon 最后一行定义的函数。入参是 env 和 exports，可以对比我们 Addon 中定义的函数的入参。最后我们修改 exports 变量。即设置导出的内容。最后在 JS 里，我们就拿到了 Addon 定义的内容。</p>
<p>如果 mp 为空，有两种情况</p>
<ol>
<li>
<p>Addon 没有定义初始化函数，只导出里某种格式的函数。</p>
</li>
<li>
<p>Addon 已经被加载过了，再次加载时初始化函数也不会执行了。比如主线程打开了 Addon，子线程也打开，则子线程中不会再执行初始化函数，也就是说 mp 是空。</p>
</li>
</ol>
<p>Node.js 会先尝试查找动态链接库中符合某种格式的函数，看一下如何查找是否定义某种格式的函数，首先看第一种函数格式。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> InitializerCallback <span class="hljs-title">GetInitializerCallback</span><span class="hljs-params">(DLib* dlib)</span> </span>{
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">"node_register_module_v"</span> <span class="hljs-built_in">STRINGIFY</span>(NODE_MODULE_VERSION);
  <span class="hljs-comment">// 获取函数地址</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&#x3C;InitializerCallback>(dlib-><span class="hljs-built_in">GetSymbolAddress</span>(name));
}

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> callback = <span class="hljs-built_in">GetInitializerCallback</span>(dlib)) {
    <span class="hljs-built_in">callback</span>(exports, <span class="hljs-keyword">module</span>, context);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p>第一种查找的格式是 node_register_module_v 开头的，接着看第二种函数函数。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> napi_addon_register_func <span class="hljs-title">GetNapiInitializerCallback</span><span class="hljs-params">(DLib* dlib)</span> </span>{
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">"napi_register_module_vNAPI_MODULE_VERSION"</span>;
  <span class="hljs-comment">// 获取函数地址</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&#x3C;napi_addon_register_func>(dlib-><span class="hljs-built_in">GetSymbolAddress</span>(name));
}

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> napi_callback = <span class="hljs-built_in">GetNapiInitializerCallback</span>(dlib)) {
    <span class="hljs-comment">// 执行 napi_callback 获取导出的内容</span>
    <span class="hljs-built_in">napi_module_register_by_symbol</span>(exports, <span class="hljs-keyword">module</span>, context, napi_callback);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
} 
</code></pre>
<p>第二种函数格式是 napi_register_module_v 开头的，如果都找不到，则查找缓存看是否已经加载过。</p>
<pre><code class="hljs language-c++"> <span class="hljs-comment">// 尝试从之前缓存中获取，比如主线程已经加载了 Addon，子线程也加载 Addon 的场景</span>
 mp = dlib-><span class="hljs-built_in">GetSavedModuleFromGlobalHandleMap</span>();
<span class="hljs-comment">// 不存在或者不符合规范则报错</span>
<span class="hljs-keyword">if</span> (mp == <span class="hljs-literal">nullptr</span> || mp->nm_context_register_func == <span class="hljs-literal">nullptr</span>) {
  dlib-><span class="hljs-built_in">Close</span>();
  <span class="hljs-type">char</span> errmsg[<span class="hljs-number">1024</span>];
  <span class="hljs-built_in">snprintf</span>(errmsg,
           <span class="hljs-built_in">sizeof</span>(errmsg),
           <span class="hljs-string">"Module did not self-register: '%s'."</span>,
           *filename);
  env-><span class="hljs-built_in">ThrowError</span>(errmsg);
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<p>如果缓存中存在则继续执行刚才介绍的 mp 非空时的逻辑，如果缓存中不存在或者没有 nm_context_register_func 钩子函数，则直接报错。通过这里的逻辑就可以知道为什么 NODE_MODULE 定义的 Addon 只能被加载一次，比如主线程加载时会执行 Addon 的初始化函数，从而在缓存里保存了数据结构 node_module，然后子线程加载时，不会再执行初始化函数，所以 Node.js 是会从缓存里拿到 node_module 结构体，但是 Node.js 会判断 node_module 是否存在 nm_context_register_func 钩子，而 NODE_MODULE 定义的钩子函数是 nm_register_func，所以就导致了 not self-register 错误。</p>
<p>最后来看一下 Addon 加载的整体流程。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cb8f1d14fad4369a952fefacb14e0b8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>内置 JS 模块</h2>
<p>刚才已经分析了加载用户 JS 模块的过程，也讲到了加载用户 JS 时传入的 require 函数是对 Module._load 的封装。当我们在 JS 里通过 require 加载内置 JS 模块时，比如 net 模块，_load 函数就会通过 Module._load 中的 loadNativeModule 函数加载原生 JS 模块。我们看这个函数的定义。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadNativeModule</span>(<span class="hljs-params">filename, request</span>) {  
  <span class="hljs-keyword">const</span> mod = <span class="hljs-title class_">NativeModule</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">get</span>(filename);  
  <span class="hljs-keyword">if</span> (mod) {  
    mod.<span class="hljs-title function_">compileForPublicLoader</span>();  
    <span class="hljs-keyword">return</span> mod;  
  }  
}  

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeModule</span> {  
  <span class="hljs-comment">// 原生 JS 模块的 map   </span>
  <span class="hljs-keyword">static</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(moduleIds.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =></span> [id, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeModule</span>(id)]));  
  
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id</span>) {  
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">filename</span> = <span class="hljs-string">`<span class="hljs-subst">${id}</span>.js`</span>;  
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;  
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canBeRequiredByUsers</span> = !id.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'internal/'</span>);  
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exports</span> = {};  
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">loaded</span> = <span class="hljs-literal">false</span>;  
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span> = <span class="hljs-literal">false</span>;  
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">module</span> = <span class="hljs-literal">undefined</span>;  
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exportKeys</span> = <span class="hljs-literal">undefined</span>;  
  }  
} 
</code></pre>
<p>NativeModule.map 是在 Node.js 启动过程中进行初始化的一个 Map 对象，key 是模块名，值是一个 NativeModule 对象，loadNativeModule 就是根据加载的模块名从 map 中拿到一个 NativeModule 对象，接着看执行 NativeModule 对象的 compileForPublicLoader 函数。</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">compileForPublicLoader</span>(<span class="hljs-params"></span>) {  
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileForInternalLoader</span>();  
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">exports</span>;  
}  
  
<span class="hljs-title function_">compileForInternalLoader</span>(<span class="hljs-params"></span>) {  
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">loaded</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span>) {  
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">exports</span>;  
    }  
    <span class="hljs-comment">// id 就是我们要加载的模块，比如 net </span>
    <span class="hljs-keyword">const</span> id = <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>;  
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span> = <span class="hljs-literal">true</span>;  
    <span class="hljs-keyword">try</span> {  
      <span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">compileFunction</span>(id);  
      <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">exports</span>, 
         <span class="hljs-comment">// 加载原生 JS 模块的加载器</span>
         nativeModuleRequire, 
         <span class="hljs-variable language_">this</span>, 
         process, 
         <span class="hljs-comment">// 加载 C++ 模块的加载器</span>
         internalBinding, 
         primordials);  
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">loaded</span> = <span class="hljs-literal">true</span>;  
    } <span class="hljs-keyword">finally</span> {  
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span> = <span class="hljs-literal">false</span>;  
    }  
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">exports</span>;  
  }  
</code></pre>
<p>首先看一下 compileFunction 这里的逻辑，compileFunction 和刚才讲用户 JS 模块加载时的 compileFunction 不一样，该函数是 node_native_module_env.cc 模块导出的函数。具体的代码就不贴了，通过层层查找，最后到 node_native_module.cc 的NativeModuleLoader::CompileAsModule</p>
<pre><code class="hljs language-c++"><span class="hljs-function">MaybeLocal&#x3C;Function> <span class="hljs-title">NativeModuleLoader::CompileAsModule</span><span class="hljs-params">(  
    Local&#x3C;Context> context,  
    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* id,  
    NativeModuleLoader::Result* result)</span> </span>{  
  
  Isolate* isolate = context-><span class="hljs-built_in">GetIsolate</span>();  
  <span class="hljs-comment">// 函数的形参  </span>
  std::vector&#x3C;Local&#x3C;String>> parameters = {  
      <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(isolate, <span class="hljs-string">"exports"</span>),  
      <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(isolate, <span class="hljs-string">"require"</span>),  
      <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(isolate, <span class="hljs-string">"module"</span>),  
      <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(isolate, <span class="hljs-string">"process"</span>),  
      <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(isolate, <span class="hljs-string">"internalBinding"</span>),  
      <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(isolate, <span class="hljs-string">"primordials"</span>)};  
  <span class="hljs-comment">// 编译出一个函数  </span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">LookupAndCompile</span>(context, id, &#x26;parameters, result);  
}  
</code></pre>
<p>继续看 LookupAndCompile。</p>
<pre><code class="hljs language-c++"><span class="hljs-function">MaybeLocal&#x3C;Function> <span class="hljs-title">NativeModuleLoader::LookupAndCompile</span><span class="hljs-params">(  
    Local&#x3C;Context> context,  
    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* id,  
    std::vector&#x3C;Local&#x3C;String>>* parameters,  
    NativeModuleLoader::Result* result)</span> </span>{  
  
  Isolate* isolate = context-><span class="hljs-built_in">GetIsolate</span>();  
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(isolate)</span></span>;  
  
  Local&#x3C;String> source;  
  <span class="hljs-comment">// 找到原生 JS 模块内容所在的内存地址  </span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">LoadBuiltinModuleSource</span>(isolate, id).<span class="hljs-built_in">ToLocal</span>(&#x26;source)) {  
    <span class="hljs-keyword">return</span> {};  
  }  
  <span class="hljs-comment">// 'net' + '.js'</span>
  std::string filename_s = id + std::<span class="hljs-built_in">string</span>(<span class="hljs-string">".js"</span>);  
  Local&#x3C;String> filename =  <span class="hljs-built_in">OneByteString</span>(isolate, 
                                              filename_s.<span class="hljs-built_in">c_str</span>(), 
                                              filename_s.<span class="hljs-built_in">size</span>());  
  <span class="hljs-comment">// 省略一些参数处理  </span>
  <span class="hljs-comment">// 脚本源码  </span>
  <span class="hljs-function">ScriptCompiler::Source <span class="hljs-title">script_source</span><span class="hljs-params">(source, origin, cached_data)</span></span>;  
  <span class="hljs-comment">// 编译出一个函数  </span>
  MaybeLocal&#x3C;Function> maybe_fun =  
      ScriptCompiler::<span class="hljs-built_in">CompileFunctionInContext</span>(context,  
                                               &#x26;script_source,  
                                               parameters-><span class="hljs-built_in">size</span>(),
                                               parameters-><span class="hljs-built_in">data</span>(),
                                               <span class="hljs-number">0</span>,  
                                               <span class="hljs-literal">nullptr</span>,  
                                               options);  
  Local&#x3C;Function> fun = maybe_fun.<span class="hljs-built_in">ToLocalChecked</span>();  
  <span class="hljs-keyword">return</span> scope.<span class="hljs-built_in">Escape</span>(fun);  
}  
</code></pre>
<p>LookupAndCompile 函数首先找到加载模块的源码，然后编译出一个函数，和用户 JS 模块加载器的原理一样，区别是加载用户 JS 模块的代码时，代码是同步从硬盘读到内存的，但是内置 JS 模块的代码是 Node.js 启动时就存在内存的，看一下LoadBuiltinModuleSource 如何查找模块源码的。</p>
<pre><code class="hljs language-c++"><span class="hljs-function">MaybeLocal&#x3C;String> <span class="hljs-title">NativeModuleLoader::LoadBuiltinModuleSource</span><span class="hljs-params">(Isolate* isolate, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* id)</span> </span>{  
  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> source_it = source_.<span class="hljs-built_in">find</span>(id);  
  <span class="hljs-keyword">return</span> source_it->second.<span class="hljs-built_in">ToStringChecked</span>(isolate);  
}  
</code></pre>
<p>这里的 id 是 net，通过该 id 从 _source 中找到对应的数据，那么 _source 是什么呢？因为Node.js 为了提高加载速度，通过空间换时间，把原生 JS 模块的源码字符串直接转成 ASCII 码存到内存里。这样加载这些模块的时候，就不需要从硬盘读取了，直接从内存读取就行。看一下 _source 的定义（在编译 Node.js 源码或者执行 js2c.py 生成的 node_javascript.cc 中）。</p>
<pre><code class="hljs language-c++">source_.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">"net"</span>, UnionBytes{net_raw, <span class="hljs-number">46682</span>});  
source_.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">"cyb"</span>, UnionBytes{cyb_raw, <span class="hljs-number">63</span>});  
source_.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">"os"</span>, UnionBytes{os_raw, <span class="hljs-number">7548</span>});  
</code></pre>
<p>cyb 是我增加的测试模块。我们可以看一下该模块的内容。</p>
<pre><code class="hljs language-c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> cyb_raw[] = {  
    <span class="hljs-number">99</span>,<span class="hljs-number">111</span>,<span class="hljs-number">110</span>,<span class="hljs-number">115</span>,<span class="hljs-number">116</span>, <span class="hljs-number">32</span>, <span class="hljs-number">99</span>,<span class="hljs-number">121</span>, <span class="hljs-number">98</span>, <span class="hljs-number">32</span>, <span class="hljs-number">61</span>, <span class="hljs-number">32</span>,<span class="hljs-number">105</span>,<span class="hljs-number">110</span>,<span class="hljs-number">116</span>,<span class="hljs-number">101</span>,<span class="hljs-number">114</span>,<span class="hljs-number">110</span>, <span class="hljs-number">97</span>,<span class="hljs-number">108</span>, <span class="hljs-number">66</span>,<span class="hljs-number">105</span>,<span class="hljs-number">110</span>,<span class="hljs-number">100</span>,<span class="hljs-number">105</span>,<span class="hljs-number">110</span>,<span class="hljs-number">103</span>, <span class="hljs-number">40</span>, <span class="hljs-number">39</span>, <span class="hljs-number">99</span>,  
    <span class="hljs-number">121</span>, <span class="hljs-number">98</span>, <span class="hljs-number">95</span>,<span class="hljs-number">119</span>,<span class="hljs-number">114</span>, <span class="hljs-number">97</span>,<span class="hljs-number">112</span>, <span class="hljs-number">39</span>, <span class="hljs-number">41</span>, <span class="hljs-number">59</span>, <span class="hljs-number">32</span>, <span class="hljs-number">10</span>,<span class="hljs-number">109</span>,<span class="hljs-number">111</span>,<span class="hljs-number">100</span>,<span class="hljs-number">117</span>,<span class="hljs-number">108</span>,<span class="hljs-number">101</span>, <span class="hljs-number">46</span>,<span class="hljs-number">101</span>,<span class="hljs-number">120</span>,<span class="hljs-number">112</span>,<span class="hljs-number">111</span>,<span class="hljs-number">114</span>,<span class="hljs-number">116</span>,<span class="hljs-number">115</span>, <span class="hljs-number">32</span>, <span class="hljs-number">61</span>, <span class="hljs-number">32</span>, <span class="hljs-number">99</span>,  
    <span class="hljs-number">121</span>, <span class="hljs-number">98</span>, <span class="hljs-number">59</span>  
};  
</code></pre>
<p>转成字符串看一下是什么</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([
    <span class="hljs-number">99</span>,<span class="hljs-number">111</span>,<span class="hljs-number">110</span>,<span class="hljs-number">115</span>,<span class="hljs-number">116</span>, <span class="hljs-number">32</span>, <span class="hljs-number">99</span>,<span class="hljs-number">121</span>, <span class="hljs-number">98</span>, <span class="hljs-number">32</span>, <span class="hljs-number">61</span>, <span class="hljs-number">32</span>,<span class="hljs-number">105</span>,<span class="hljs-number">110</span>,<span class="hljs-number">116</span>,<span class="hljs-number">101</span>,<span class="hljs-number">114</span>,<span class="hljs-number">110</span>, <span class="hljs-number">97</span>,<span class="hljs-number">108</span>, <span class="hljs-number">66</span>,<span class="hljs-number">105</span>,<span class="hljs-number">110</span>,<span class="hljs-number">100</span>,<span class="hljs-number">105</span>,<span class="hljs-number">110</span>,<span class="hljs-number">103</span>, <span class="hljs-number">40</span>, <span class="hljs-number">39</span>, <span class="hljs-number">99</span>,
    <span class="hljs-number">121</span>, <span class="hljs-number">98</span>, <span class="hljs-number">95</span>,<span class="hljs-number">119</span>,<span class="hljs-number">114</span>, <span class="hljs-number">97</span>,<span class="hljs-number">112</span>, <span class="hljs-number">39</span>, <span class="hljs-number">41</span>, <span class="hljs-number">59</span>, <span class="hljs-number">32</span>, <span class="hljs-number">10</span>,<span class="hljs-number">109</span>,<span class="hljs-number">111</span>,<span class="hljs-number">100</span>,<span class="hljs-number">117</span>,<span class="hljs-number">108</span>,<span class="hljs-number">101</span>, <span class="hljs-number">46</span>,<span class="hljs-number">101</span>,<span class="hljs-number">120</span>,<span class="hljs-number">112</span>,<span class="hljs-number">111</span>,<span class="hljs-number">114</span>,<span class="hljs-number">116</span>,<span class="hljs-number">115</span>, <span class="hljs-number">32</span>, <span class="hljs-number">61</span>, <span class="hljs-number">32</span>, <span class="hljs-number">99</span>,    
    <span class="hljs-number">121</span>, <span class="hljs-number">98</span>, <span class="hljs-number">59</span>
].<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>)).<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf-8'</span>)  
</code></pre>
<p>输出</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">cyb</span> = internalBinding(<span class="hljs-string">'cyb_wrap'</span>)<span class="hljs-comment">;   </span>
<span class="hljs-attr">module.exports</span> = cyb<span class="hljs-comment">;  </span>
</code></pre>
<p>所以我们执行 require('net') 时，通过 NativeModule 的 compileForInternalLoader，最终会在_source中找到net 模块对应的源码字符串，然后编译成一个函数，最终执行这个函数。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">nativeModuleRequire</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-keyword">const</span> mod = <span class="hljs-title class_">NativeModule</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">get</span>(id);
  <span class="hljs-keyword">return</span> mod.<span class="hljs-title function_">compileForInternalLoader</span>();
}

<span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">compileFunction</span>(id);  
<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">exports</span>, 
   <span class="hljs-comment">// 加载原生 JS 模块的加载器</span>
   nativeModuleRequire, 
   <span class="hljs-variable language_">this</span>, 
   process, 
   <span class="hljs-comment">// 加载 C++ 模块的加载器</span>
   internalBinding, 
   primordials);   
</code></pre>
<p>fn 入参和用户 JS 模块是不一样的，这里的 this 是 NativeModule 对象，exports 是 NativeModule 对象的属性，另外还有一个参数 internalBinding，这个是用于加载 C++ 模块的，我们一会详细分析，最重要的是这里传入的 require 函数和用户 JS 模块的也不一样。由 fn 的入参可以知道，我们在 net（或其它原生 JS 模块中）只能加载原生 JS 模块和内置的C++ 模块。当 fn 执行完毕后，原生模块加载器就会把 mod.exports 的值返回给调用方。整体流程如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ecbcb667b644740bc6ab3fbe49f1e26~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>内置 C++ 模块</h2>
<p>除了通过 require 加载以上的三种模块外，还有一种模块就是 C++ 模块，C++ 模块通常是在内置 JS 模块里加载的，我们也可以通过 process.binding 进行加载。在原生 JS 模块中加载内置的 C++ 模块，这是 Node.js 拓展 JS 功能的关键之处。比如我们 require("net") 的时候，net 模块会加载 C++ 模块 tcp_wrap。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> {  
  <span class="hljs-variable constant_">TCP</span>,  
  <span class="hljs-title class_">TCPConnectWrap</span>,  
  <span class="hljs-attr">constants</span>: <span class="hljs-title class_">TCPConstants</span>  
} = <span class="hljs-title function_">internalBinding</span>(<span class="hljs-string">'tcp_wrap'</span>)  
</code></pre>
<p>Node.js 在初始化的时候会注册 C++ 模块，并且形成一个 C++ 模块链表，当加载 C++ 模块时，Node.js 就通过模块名，从这个链表里面找到对应的节点，然后去执行它里面的钩子函数，执行完之后就可以拿到 C++ 模块导出的内容。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbcacea991d24e1fb2cc70b99328decc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>C++ 模块加载器是在 internal/bootstrap/loaders.js 中定义的，分为三种。</p>
<ol>
<li>process._linkedBinding: 暴露给用户访问 C++ 模块的接口，用于访问用户自己添加的但是没有加到内置模块的 C++ 模块（flag为NM_F_LINKED）。</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> bindingObj= <span class="hljs-title class_">ObjectCreate</span>(<span class="hljs-literal">null</span>);  
process.<span class="hljs-property">_linkedBinding</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">_linkedBinding</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) {  
  <span class="hljs-variable language_">module</span> = <span class="hljs-title class_">String</span>(<span class="hljs-variable language_">module</span>);  
  <span class="hljs-keyword">let</span> mod = bindingObj[<span class="hljs-variable language_">module</span>];  
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> mod !== <span class="hljs-string">'object'</span>)  
    mod = bindingObj[<span class="hljs-variable language_">module</span>] = <span class="hljs-title function_">getLinkedBinding</span>(<span class="hljs-variable language_">module</span>);  
  <span class="hljs-keyword">return</span> mod;  
};  
</code></pre>
<p>_linkedBinding 是在 getLinkedBinding 函数基础上加了缓存功能，getLinkedBinding 是 C++ 层定义的函数。它从另一个 C++ 模块链表中查找对应的模块，这个通常不会用到，就不详细介绍。</p>
<ol start="2">
<li>internalBinding：不暴露给用户的访问的接口，只能在 Node.js 代码中访问，比如原生 JS 模块。</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> internalBinding;  
{  
  <span class="hljs-keyword">const</span> bindingObj = <span class="hljs-title class_">ObjectCreate</span>(<span class="hljs-literal">null</span>);   
  internalBinding = <span class="hljs-keyword">function</span> <span class="hljs-title function_">internalBinding</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) {  
    <span class="hljs-keyword">let</span> mod = bindingObj[<span class="hljs-variable language_">module</span>];  
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> mod !== <span class="hljs-string">'object'</span>) {  
      mod = bindingObj[<span class="hljs-variable language_">module</span>] = <span class="hljs-title function_">getInternalBinding</span>(<span class="hljs-variable language_">module</span>);  
      moduleLoadList.<span class="hljs-title function_">push</span>(<span class="hljs-string">`Internal Binding <span class="hljs-subst">${<span class="hljs-variable language_">module</span>}</span>`</span>);  
    }  
    <span class="hljs-keyword">return</span> mod;  
  };  
}  
</code></pre>
<p>internalBinding 是在 getInternalBinding 函数基础上加了缓存功能。getInternalBinding 是 C++ 层定义的函数，它的作用是从 C++ 模块链表中找到对应的模块。 3. process.binding：暴露给用户调用 C++ 模块的接口，但是只能访问部分 C++ 模块。</p>
<pre><code class="hljs language-js">process.<span class="hljs-property">binding</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">binding</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) {  
  <span class="hljs-variable language_">module</span> = <span class="hljs-title class_">String</span>(<span class="hljs-variable language_">module</span>);  
  <span class="hljs-keyword">if</span> (internalBindingWhitelist.<span class="hljs-title function_">has</span>(<span class="hljs-variable language_">module</span>)) {  
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">internalBinding</span>(<span class="hljs-variable language_">module</span>);  
  }  
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`No such module: <span class="hljs-subst">${<span class="hljs-variable language_">module</span>}</span>`</span>);  
};  
</code></pre>
<p>binding 是在 internalBinding 的基础上加了白名单的逻辑，只对外暴露部分模块，因为 internalBinding 是对 getInternalBinding 的封装。所以直接看 getInternalBinding， 对应的是 binding::GetInternalBinding（node_binding.cc）。</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// 根据模块名查找对应的模块  </span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetInternalBinding</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{  
  Environment* env = Environment::<span class="hljs-built_in">GetCurrent</span>(args);  
  <span class="hljs-comment">// 模块名  </span>
  Local&#x3C;String> <span class="hljs-keyword">module</span> = args[<span class="hljs-number">0</span>].<span class="hljs-built_in">As</span>&#x3C;String>();  
  <span class="hljs-function">node::Utf8Value <span class="hljs-title">module_v</span><span class="hljs-params">(env->isolate(), <span class="hljs-keyword">module</span>)</span></span>;  
  Local&#x3C;Object> exports;  
  <span class="hljs-comment">// 从 C++ 内部模块找  </span>
  node_module* mod = <span class="hljs-built_in">FindModule</span>(modlist_internal, 
                                     *module_v, 
                                     NM_F_INTERNAL);  
  exports = <span class="hljs-built_in">InitModule</span>(env, mod, <span class="hljs-keyword">module</span>); 
  <span class="hljs-comment">// 返回 C++ 层导出的功能</span>
  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(exports);  
}  
</code></pre>
<p>modlist_internal 是一条链表，在 Node.js 启动过程的时候，由各个 C++ 模块连成的链表，FindModule 就是从这个链表中找到对应的数据结构。</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node_module</span>* <span class="hljs-built_in">FindModule</span>(<span class="hljs-keyword">struct</span> node_module* list,
                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,
                                      <span class="hljs-type">int</span> flag) {
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node_module</span>* mp;

  <span class="hljs-keyword">for</span> (mp = list; mp != <span class="hljs-literal">nullptr</span>; mp = mp->nm_link) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(mp->nm_modname, name) == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">return</span> mp;
}
</code></pre>
<p>通过模块名找到对应的 C++ 模块后，执行 InitModule 初始化模块。</p>
<pre><code class="hljs language-c++">    <span class="hljs-comment">// 初始化一个模块，即执行它里面的注册函数  </span>
    <span class="hljs-function"><span class="hljs-type">static</span> Local&#x3C;Object> <span class="hljs-title">InitModule</span><span class="hljs-params">(Environment* env,  
                                    node_module* mod,  
                                    Local&#x3C;String> <span class="hljs-keyword">module</span>)</span> </span>{ 
          <span class="hljs-comment">// 新建一个对象，需要导出到 JS 的内容设置到该对象中 </span>
      Local&#x3C;Object> exports = Object::<span class="hljs-built_in">New</span>(env-><span class="hljs-built_in">isolate</span>());  
      Local&#x3C;Value> unused = <span class="hljs-built_in">Undefined</span>(env-><span class="hljs-built_in">isolate</span>());  
      mod-><span class="hljs-built_in">nm_context_register_func</span>(exports, unused, env-><span class="hljs-built_in">context</span>(), mod->nm_priv);  
      <span class="hljs-keyword">return</span> exports;  
    }  
</code></pre>
<p>传入一个 exports 变量进去，然后执行 C++ 模块的 nm_context_register_func 指向的函数。这个函数就是在 C++ 模块最后一行定义的 Initialize 函数。Initialize 会通过修改 exports 设置导出的对象，比如 TCP 模块的 Initialize。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPWrap::Initialize</span><span class="hljs-params">(Local&#x3C;Object> target,
                         Local&#x3C;Value> unused,
                         Local&#x3C;Context> context,
                         <span class="hljs-type">void</span>* priv)</span> </span>{
  target-><span class="hljs-built_in">Set</span>(env-><span class="hljs-built_in">context</span>(), tcpString, ...).<span class="hljs-built_in">Check</span>();
  <span class="hljs-comment">// 设置对象的TCPConnectWrap属性 </span>
  target-><span class="hljs-built_in">Set</span>(env-><span class="hljs-built_in">context</span>(), wrapString, ...).<span class="hljs-built_in">Check</span>();

  <span class="hljs-comment">// 设置对象的constant属性 </span>
  Local&#x3C;Object> constants = Object::<span class="hljs-built_in">New</span>(env-><span class="hljs-built_in">isolate</span>());
  <span class="hljs-built_in">NODE_DEFINE_CONSTANT</span>(constants, SOCKET);
  <span class="hljs-built_in">NODE_DEFINE_CONSTANT</span>(constants, SERVER);
  <span class="hljs-built_in">NODE_DEFINE_CONSTANT</span>(constants, UV_TCP_IPV6ONLY);
  target-><span class="hljs-built_in">Set</span>(context, env-><span class="hljs-built_in">constants_string</span>(), constants).<span class="hljs-built_in">Check</span>();
}
</code></pre>
<p>target 里设置的值就是 JS 层能拿到的值，最后我们就可以从 JS 访问到 Initialize 导出的内容了。</p>
<h2>自定义模块加载器</h2>
<p>了解了 Node.js 的各种模块加载器原理后，我们最后实现两个自己的模块加载器，这样不仅可以处理其他类型的模块，还能深入理解模块加载的实现原理。通过前面的介绍可以知道，我们通过拓展 Module._extensions 来支持我们自己的模块类型。首先看一下如何实现一个 TS 模块加载器。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Module</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'module'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> ts = <span class="hljs-built_in">require</span>(<span class="hljs-string">'typescript'</span>);
<span class="hljs-keyword">const</span> { compileFunction } = process.<span class="hljs-title function_">binding</span>(<span class="hljs-string">'contextify'</span>);

<span class="hljs-comment">// 加入处理 TS 的函数</span>
<span class="hljs-title class_">Module</span>.<span class="hljs-property">_extensions</span>[<span class="hljs-string">'.ts'</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, filename</span>) {
    <span class="hljs-comment">// 获取模块内容</span>
    <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(filename, <span class="hljs-string">'utf8'</span>);
    <span class="hljs-comment">// 先把 TS 转成 JS</span>
    <span class="hljs-keyword">const</span> { outputText } = ts.<span class="hljs-title function_">transpileModule</span>(content, { <span class="hljs-attr">compilerOptions</span>: { <span class="hljs-attr">module</span>: ts.<span class="hljs-property">ModuleKind</span>.<span class="hljs-property">CommonJS</span> }});
    <span class="hljs-comment">// 编译代码拿到一个函数</span>
    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">compileFunction</span>(
        outputText,
        filename,
        <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>,
        <span class="hljs-literal">undefined</span>,
        <span class="hljs-literal">false</span>,
        <span class="hljs-literal">undefined</span>,
        [],
        [
          <span class="hljs-string">'exports'</span>,
          <span class="hljs-string">'require'</span>,
          <span class="hljs-string">'module'</span>,
          <span class="hljs-string">'__filename'</span>,
          <span class="hljs-string">'__dirname'</span>,
        ]
    );
    <span class="hljs-comment">// 执行</span>
    result.<span class="hljs-property">function</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =></span> <span class="hljs-variable language_">module</span>.<span class="hljs-built_in">require</span>(...args), <span class="hljs-variable language_">module</span>, filename, path.<span class="hljs-title function_">dirname</span>(filename));
};
</code></pre>
<p>我们只需要保证上面的代码在我们的 TS 代码之前执行，这样就可以直接执行 TS 代码了。TS 模块加载器的原理是拓展 _extensions 的类型，使得它遇到 .ts 类型的文件时执行我们设置的函数，然后读取到文件内容后，利用 typescript 把 TS 转成 JS，最后执行 JS 代码，有兴趣可以参考<a href="https://github.com/theanarkh/tiny-ts-node" target="_blank" rel="nofollow noopener noreferrer">这里</a>。</p>
<p>我们不仅可以通过 Module._extensions 拓展自定义的模块类型，我们甚至可以通过 Addon 来实现一个自己的 JS 模块加载器，代码可以参考<a href="https://github.com/theanarkh/nodejs-book/tree/main/src/loader" target="_blank" rel="nofollow noopener noreferrer">这里</a>。</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Compile</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
    Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();
    Local&#x3C;Context> context = isolate-><span class="hljs-built_in">GetCurrentContext</span>();
    <span class="hljs-function">String::Utf8Value <span class="hljs-title">filename</span><span class="hljs-params">(isolate, args[<span class="hljs-number">0</span>].As&#x3C;String>())</span></span>;
    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(*filename, <span class="hljs-number">0</span> , O_RDONLY);
    std::string content;
    <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span>];
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
    {
      <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">4096</span>);
      <span class="hljs-type">int</span> ret = <span class="hljs-built_in">read</span>(fd, buffer, <span class="hljs-number">4096</span>);
      <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) {
        <span class="hljs-keyword">return</span> args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(<span class="hljs-built_in">newStringToLcal</span>(isolate, <span class="hljs-string">"read file error"</span>));
      }
      <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">break</span>;
      }
      content.<span class="hljs-built_in">append</span>(buffer, ret);
    }
    <span class="hljs-built_in">close</span>(fd);
    <span class="hljs-function">ScriptCompiler::Source <span class="hljs-title">script_source</span><span class="hljs-params">(newStringToLcal(isolate, content.c_str()))</span></span>;
    Local&#x3C;String> params[] = {
      <span class="hljs-built_in">newStringToLcal</span>(isolate, <span class="hljs-string">"require"</span>),
      <span class="hljs-built_in">newStringToLcal</span>(isolate, <span class="hljs-string">"exports"</span>),
      <span class="hljs-built_in">newStringToLcal</span>(isolate, <span class="hljs-string">"module"</span>),
    };
    MaybeLocal&#x3C;Function> fun =
    ScriptCompiler::<span class="hljs-built_in">CompileFunctionInContext</span>(context, &#x26;script_source, <span class="hljs-number">3</span>, params, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);
    <span class="hljs-keyword">if</span> (fun.<span class="hljs-built_in">IsEmpty</span>()) {
      args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(<span class="hljs-built_in">Undefined</span>(isolate));
    } <span class="hljs-keyword">else</span> {
      args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(fun.<span class="hljs-built_in">ToLocalChecked</span>());
    }
}
</code></pre>
<p>Compile 函数首先从参数中拿到文件路径，然后把文件的内容读到内存中，最后通过 CompileFunctionInContext 编译成一个 JS 函数，所以执行完 Compile 后我们就可以拿到一个函数。下面看看怎么使用。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> loader = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/main.node'</span>);
<span class="hljs-keyword">const</span> filepath = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'demo.js'</span>);
loader.<span class="hljs-title function_">compile</span>(filepath)(<span class="hljs-built_in">require</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, <span class="hljs-variable language_">module</span>);
</code></pre>
<p>使用方式也很简单，传入实参然后执行 compile 返回的函数，至于传入哪些参数这个是可以自己根据情况自定义。</p>
<h2>总结</h2>
<p>通过本节课的内容可以知道，Node.js 中一共有 JSON、用户 JS、原生 JS、C++、Addon 五种模块，虽然我们平时只需要一个 require 就可以了，但是 Node.js 中处理细节还是非常多的，尤其是 Addon 模块。在 Node.js 中，json 模块加载器是通过文件模块和 V8 的 JSON.Parse 实现的，JS 模块是通过 V8 的 CompileFunctionInContext 实现的，C++ 模块是通过 V8 把 C++ 的功能导出到 JS 层实现的，Addon 本质上是加载和使用动态链接库。</p>
<p>理解了这些模块加载器原理，不仅可以帮助我们更了解 Node.js 的内部机制，我们也可以自己实现新的模块加载器，比如课程中的 JS 和 TS 模块加载器，另外在使用 Addon 模块时碰到问题我们也能引刃而解。</p></div>
</body></html>