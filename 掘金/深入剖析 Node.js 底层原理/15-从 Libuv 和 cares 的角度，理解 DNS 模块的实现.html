<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>从 Libuv 和 cares 的角度，理解 DNS 模块的实现</h1>
<p>DNS 是 Node.js 中非常核心的底层模块，TCP、UDP、HTTP 等模块都依赖它。那么，DNS 模块如何实现呢？</p>
<p>在 Node.js 中，DNS 模块是使用 cares 库和 Libuv 实现的。cares 是一个异步 DNS 解析库，它实现了 DNS 协议的封包和解析，Libuv 提供的 DNS 解析主要是利用阻塞式的系统库函数和线程池实现的。这节课我们详细讲解 Node.js DNS 模块在 cares 和 Libuv 中的实现。</p>
<h1>Libuv 是如何实现 DNS 的？</h1>
<p>在 Node.js 中，lookup 和 lookupService 是由 Libuv 实现的，它们实现的原理类似，所以我们这里只分析 lookup 函数。 dns.lookup 用于查询一个域名对应的 IP 的信息。</p>
<pre><code class="hljs language-javascript">dns.<span class="hljs-title function_">lookup</span>(<span class="hljs-string">'www.a.com'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, address, family</span>) {  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(address);  
});  
</code></pre>
<p>lookup 函数的 JS 层实现在 dns.js 中。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">req</span> = new GetAddrInfoReqWrap()<span class="hljs-comment">;  </span>
<span class="hljs-attr">req.callback</span> = callback<span class="hljs-comment">;  </span>
<span class="hljs-attr">req.family</span> = family<span class="hljs-comment">;  </span>
<span class="hljs-attr">req.hostname</span> = hostname<span class="hljs-comment">;  </span>
<span class="hljs-attr">req.oncomplete</span> = all ? <span class="hljs-literal">on</span>lookupall : <span class="hljs-literal">on</span>lookup<span class="hljs-comment">;  </span>
  
const <span class="hljs-attr">err</span> = cares.getaddrinfo(  
  req, toASCII(hostname), family, hints, verbatim  
)<span class="hljs-comment">;  </span>
</code></pre>
<p>GetAddrInfoReqWrap 表示一次 DNS 查询请求，然后调用 cares_wrap.cc 的 GetAddrInfo 方法。GetAddrInfo 的主要逻辑如下。</p>
<pre><code class="hljs language-ini">void GetAddrInfo(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {
  Environment* <span class="hljs-attr">env</span> = Environment::GetCurrent(args)<span class="hljs-comment">;</span>
  // JS 层请求对象
  Local&#x3C;Object> <span class="hljs-attr">req_wrap_obj</span> = args[<span class="hljs-number">0</span>].As&#x3C;Object>()<span class="hljs-comment">;</span>
  // 参数处理
  node::Utf8Value hostname(env->isolate(), args<span class="hljs-section">[1]</span>)<span class="hljs-comment">;</span>

  int32_t <span class="hljs-attr">flags</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
  if (args<span class="hljs-section">[3]</span>->IsInt32()) {
    <span class="hljs-attr">flags</span> = args[<span class="hljs-number">3</span>].As&#x3C;Int32>()->Value()<span class="hljs-comment">;</span>
  }

  int family<span class="hljs-comment">;</span>

  switch (args<span class="hljs-section">[2]</span>.As&#x3C;Int32>()->Value()) {
    case 0:
      <span class="hljs-attr">family</span> = AF_UNSPEC<span class="hljs-comment">;</span>
      break<span class="hljs-comment">;</span>
    case 4:
      <span class="hljs-attr">family</span> = AF_INET<span class="hljs-comment">;</span>
      break<span class="hljs-comment">;</span>
    case 6:
      <span class="hljs-attr">family</span> = AF_INET6<span class="hljs-comment">;</span>
      break<span class="hljs-comment">;</span>
    default:
      CHECK(0 &#x26;&#x26; "bad address family")<span class="hljs-comment">;</span>
  }
  // 创建一个 C++ GetAddrInfoReqWrap 对象，和 JS 对象 req_wrap_obj（GetAddrInfoReqWrap）互相关联
  auto <span class="hljs-attr">req_wrap</span> = std::make_unique&#x3C;GetAddrInfoReqWrap>(env,
                                                       req_wrap_obj,
                                                       args<span class="hljs-section">[4]</span>->IsTrue())<span class="hljs-comment">;</span>

  struct addrinfo hints<span class="hljs-comment">;</span>
  memset(&#x26;hints, 0, sizeof(hints))<span class="hljs-comment">;</span>
  <span class="hljs-attr">hints.ai_family</span> = family<span class="hljs-comment">;</span>
  <span class="hljs-attr">hints.ai_socktype</span> = SOCK_STREAM<span class="hljs-comment">;</span>
  <span class="hljs-attr">hints.ai_flags</span> = flags<span class="hljs-comment">;</span>

  req_wrap->Dispatch(uv_getaddrinfo,
                     AfterGetAddrInfo,
                     *hostname,
                     nullptr,
                     &#x26;hints)<span class="hljs-comment">;</span>
}
</code></pre>
<p>GetAddrInfo 首先做了参数处理，然后执行 Libuv 的 uv_getaddrinfo 函数，并且设置了回调函数为 AfterGetAddrInfo，我们看一下 Libuv 的 uv_getaddrinfo。</p>
<pre><code class="hljs language-ini">int uv_getaddrinfo(uv_loop_t* loop,
                   // 上层传进来的 req
                   uv_getaddrinfo_t* req,
                   // 解析完后的上层回调
                   uv_getaddrinfo_cb cb,
                   // 需要解析的 host
                   const char* hostname,
                   /*
                     查询的过滤条件：服务名。比如 http smtp。
                     也可以是一个端口。见下面注释
                   */
                   const char service,
                   // 其他查询过滤条件
                   const struct addrinfo* hints) {
        size_t hostname_len<span class="hljs-comment">;</span>
        size_t service_len<span class="hljs-comment">;</span>
        size_t hints_len<span class="hljs-comment">;</span>
        size_t len<span class="hljs-comment">;</span>
        char* buf<span class="hljs-comment">;</span>
        <span class="hljs-attr">hostname_len</span> = hostname? strlen(hostname) + <span class="hljs-number">1</span> : <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        <span class="hljs-attr">service_len</span> = service? strlen(service) + <span class="hljs-number">1</span> : <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        <span class="hljs-attr">hints_len</span> = hints? sizeof(*hints) : <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        <span class="hljs-attr">buf</span> = uv__malloc(hostname_len + service_len + hints_len)<span class="hljs-comment">;</span>
        uv__req_init(loop, req, UV_GETADDRINFO)<span class="hljs-comment">;</span>
        req-><span class="hljs-attr">loop</span> = loop<span class="hljs-comment">;</span>
        // 设置请求的回调
        req-><span class="hljs-attr">cb</span> = cb<span class="hljs-comment">;</span>
        req-><span class="hljs-attr">addrinfo</span> = NULL<span class="hljs-comment">;</span>
        req-><span class="hljs-attr">hints</span> = NULL<span class="hljs-comment">;</span>
        req-><span class="hljs-attr">service</span> = NULL<span class="hljs-comment">;</span>
        req-><span class="hljs-attr">hostname</span> = NULL<span class="hljs-comment">;</span>
        req-><span class="hljs-attr">retcode</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        <span class="hljs-attr">len</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        if (hints) {
            req-><span class="hljs-attr">hints</span> = memcpy(buf + len, hints, sizeof(hints))<span class="hljs-comment">;</span>
            len += sizeof(hints)<span class="hljs-comment">;</span>
        }
        if (service) {
            req-><span class="hljs-attr">service</span> = memcpy(buf + len, service, service_len)<span class="hljs-comment">;</span>
            len += service_len<span class="hljs-comment">;</span>
        }
        if (hostname)
            req-><span class="hljs-attr">hostname</span> = memcpy(buf + len, hostname, hostname_len)<span class="hljs-comment">;</span>
        // 传了 cb 是异步
        if (cb) {
            // 提交任务到线程池
            uv__work_submit(loop,
                            &#x26;req->work_req,
                            UV__WORK_SLOW_IO,
                            uv__getaddrinfo_work,
                            uv__getaddrinfo_done)<span class="hljs-comment">;</span>
            return 0<span class="hljs-comment">;</span>
        } else {
            // 阻塞式查询，然后返回查询状态和信息
            uv__getaddrinfo_work(&#x26;req->work_req)<span class="hljs-comment">;</span>
            uv__getaddrinfo_done(&#x26;req->work_req, 0)<span class="hljs-comment">;</span>
            return req->retcode<span class="hljs-comment">;</span>
        }
}
</code></pre>
<p>uv_getaddrinfo 首先对一个 request 结构体进行初始化，然后根据是否传了回调，决定走异步还是同步的模式。同步的方式比较简单，就是直接阻塞线程，直到解析完成，但是 DNS 解析可能会非常慢，所以 Node.js 并没有提供同步的 API。异步方式则是给线程池提交一个慢 IO 的任务，工作函数是 uv__getaddrinfo_work，回调是uv__getaddrinfo_done。我们看一下这两个函数的实现：</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 解析的工作函数</span>
static void <span class="hljs-built_in">uv__getaddrinfo_work</span>(struct uv__work* w) {
    uv_getaddrinfo_t* req;
    int err;
    <span class="hljs-comment">// 根据结构体的字段获取结构体首地址</span>
    req = <span class="hljs-built_in">container_of</span>(w, uv_getaddrinfo_t, work_req);
    <span class="hljs-comment">// 阻塞在这</span>
    err = <span class="hljs-built_in">getaddrinfo</span>(req->hostname, req->service, req->hints, &#x26;req->addrinfo);
    req->retcode = <span class="hljs-built_in">uv__getaddrinfo_translate_error</span>(err);
}
</code></pre>
<p>工作函数主要是调用了底层提供的 getaddrinfo 去做解析，然后阻塞线程。结果返回后，执行 uv__getaddrinfo_done 处理结果。</p>
<pre><code class="hljs language-scss">static void <span class="hljs-built_in">uv__getaddrinfo_done</span>(struct uv__work* w, int status) {
    uv_getaddrinfo_t* req;
    req = <span class="hljs-built_in">container_of</span>(w, uv_getaddrinfo_t, work_req);
    <span class="hljs-built_in">uv__req_unregister</span>(req->loop, req);
    <span class="hljs-comment">// 释放初始化时申请的内存</span>
    if (req->hints)
        <span class="hljs-built_in">uv__free</span>(req->hints);
    else if (req->service)
        <span class="hljs-built_in">uv__free</span>(req->service);
    else if (req->hostname)
        <span class="hljs-built_in">uv__free</span>(req->hostname);
    else
        <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);
    req->hints = NULL;
    req->service = NULL;
    req->hostname = NULL;
    <span class="hljs-comment">// 解析请求被用户取消了</span>
    if (status == UV_ECANCELED) {
        req->retcode = UV_EAI_CANCELED;
    }
    <span class="hljs-comment">// 执行上层回调</span>
    if (req->cb)
        req-><span class="hljs-built_in">cb</span>(req, req->retcode, req->addrinfo);
}
</code></pre>
<p>uv__getaddrinfo_done 最后执行 C++ 层回调 AfterGetAddrInfo，AfterGetAddrInfo 最终执行 JS 层的回调 oncomplete，这样一次 DNS 解析就完成了。</p>
<h1>cares 是如何实现 DNS 的？</h1>
<p>除了dns.lookup 和 dns.lookService 外，其余的 DNS 功能都由 cares 实现，cares 提供了一系列 API，可结合事件驱动模块实现真正的异步 DNS 解析。基于 cares，Node.js 提供的核心功能由 Resolver 对象提供。</p>
<h2>实现 DNS 解析的对象：Resolver</h2>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> {
  <span class="hljs-title class_">ChannelWrap</span>,
} = <span class="hljs-title function_">internalBinding</span>(<span class="hljs-string">'cares_wrap'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Resolver</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_handle</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelWrap</span>();
  }

  <span class="hljs-title function_">cancel</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_handle</span>.<span class="hljs-title function_">cancel</span>();
  }

  <span class="hljs-title function_">getServers</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_handle</span>.<span class="hljs-title function_">getServers</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =></span> {
      <span class="hljs-comment">// ...</span>
    });
  }

  <span class="hljs-title function_">setServers</span>(<span class="hljs-params">servers</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_handle</span>.<span class="hljs-title function_">setServers</span>(...);
  }
}
</code></pre>
<p>Resolver 主要是对 C++ 层 ChannelWrap 的封装，ChannelWrap 则是对 cares 的封装。除此之外，Resolver 还有一系列函数，下面列举几个。</p>
<pre><code class="hljs language-ini">function resolver(bindingName) {
  function query(name, /* options, */ callback) {
    let options<span class="hljs-comment">;</span>
    if (arguments.length > 2) {
      <span class="hljs-attr">options</span> = callback<span class="hljs-comment">;</span>
      <span class="hljs-attr">callback</span> = arguments[<span class="hljs-number">2</span>]<span class="hljs-comment">;</span>
    }
    const <span class="hljs-attr">req</span> = new QueryReqWrap()<span class="hljs-comment">;</span>
    <span class="hljs-attr">req.bindingName</span> = bindingName<span class="hljs-comment">;</span>
    <span class="hljs-attr">req.callback</span> = callback<span class="hljs-comment">;</span>
    <span class="hljs-attr">req.hostname</span> = name<span class="hljs-comment">;</span>
    <span class="hljs-attr">req.oncomplete</span> = <span class="hljs-literal">on</span>resolve<span class="hljs-comment">;</span>
    <span class="hljs-attr">req.ttl</span> = !!(options &#x26;&#x26; options.ttl)<span class="hljs-comment">;</span>
    // this._handle 是 C++ 层 ChannelWrap 对象
    this._handle<span class="hljs-section">[bindingName]</span>(req, toASCII(name))<span class="hljs-comment">;</span>
    return req<span class="hljs-comment">;</span>
  }
  ObjectDefineProperty(query, 'name', { value: bindingName })<span class="hljs-comment">;</span>
  return query<span class="hljs-comment">;</span>
}

<span class="hljs-attr">Resolver.prototype.resolveAny</span> = resolver(<span class="hljs-string">'queryAny'</span>)<span class="hljs-comment">;</span>
<span class="hljs-attr">Resolver.prototype.resolve4</span> = resolver(<span class="hljs-string">'queryA'</span>)<span class="hljs-comment">;</span>
<span class="hljs-attr">Resolver.prototype.resolve6</span> = resolver(<span class="hljs-string">'queryAaaa'</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Resolver 的 API 通过 resolver 函数统一提供，resolver 函数主要是创建了一个 QueryReqWrap 请求对象，然后根据bindingName 直接调用 C++ 层 ChannelWrap 对象的相应函数。所以我们重点来看一下 C++ 层的 ChannelWrap，下面是把 ChannelWrap 导出到 JS 的逻辑。</p>
<pre><code class="hljs language-scss">Local&#x3C;FunctionTemplate> channel_wrap = env-><span class="hljs-built_in">NewFunctionTemplate</span>(ChannelWrap::New);

env-><span class="hljs-built_in">SetProtoMethod</span>(channel_wrap, "queryAny", Query&#x3C;QueryAnyWrap>);
env-><span class="hljs-built_in">SetProtoMethod</span>(channel_wrap, "queryA", Query&#x3C;QueryAWrap>);
<span class="hljs-comment">// ... 还有类似的很多函数</span>

Local&#x3C;String> channelWrapString = <span class="hljs-built_in">FIXED_ONE_BYTE_STRING</span>(env->isolate(), "ChannelWrap");
channel_wrap-><span class="hljs-built_in">SetClassName</span>(channelWrapString);
target-><span class="hljs-built_in">Set</span>(env->context(),  channelWrapString, channel_wrap-><span class="hljs-built_in">GetFunction</span>(context)<span class="hljs-selector-class">.ToLocalChecked</span>())<span class="hljs-selector-class">.Check</span>();
</code></pre>
<p>当在 JS 层 new ChannelWrap 时，就会执行 ChannelWrap::New。</p>
<pre><code class="hljs language-php"><span class="hljs-keyword">void</span> <span class="hljs-title class_">ChannelWrap</span>::<span class="hljs-title function_ invoke__">New</span>(<span class="hljs-keyword">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args) {
  Environment* env = <span class="hljs-title class_">Environment</span>::<span class="hljs-title function_ invoke__">GetCurrent</span>(args);
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelWrap</span>(env, args.<span class="hljs-title function_ invoke__">This</span>());
}
</code></pre>
<p>ChannelWrap::New 创建了一个 ChannelWrap 对象。看一下类 ChannelWrap 的定义。</p>
<pre><code class="hljs language-arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelWrap</span> : <span class="hljs-keyword">public</span> AsyncWrap {  
 <span class="hljs-keyword">public</span>:  
  <span class="hljs-comment">// ...  </span>
  
 <span class="hljs-keyword">private</span>:  
  <span class="hljs-comment">// 超时管理  </span>
  <span class="hljs-type">uv_timer_t</span>* timer_handle_;  
  <span class="hljs-comment">// cares 结构体，用于管理多个查询请求  </span>
  ares_channel channel_;  
  <span class="hljs-comment">// 标记查询结果  </span>
  <span class="hljs-type">bool</span> query_last_ok_;  
  <span class="hljs-type">bool</span> is_servers_default_;  
  <span class="hljs-comment">// 是否已经初始化 cares 库  </span>
  <span class="hljs-type">bool</span> library_inited_;  
  <span class="hljs-comment">// 正在发起的查询个数  </span>
  <span class="hljs-type">int</span> active_query_count_;  
  <span class="hljs-comment">// 发起查询的任务队列  </span>
  node_ares_task_list task_list_;  
};  
</code></pre>
<p>了解了 ChannelWrap 的字段后，接着看看 ChannelWrap 构造函数的代码。</p>
<pre><code class="hljs language-scss">ChannelWrap::ChannelWrap(...) {  
  <span class="hljs-built_in">Setup</span>();  
}  
</code></pre>
<p>ChannelWrap 里调用了 Setup。</p>
<pre><code class="hljs language-ini">void ChannelWrap::Setup() {  
  struct ares_options options<span class="hljs-comment">;  </span>
  memset(&#x26;options, 0, sizeof(options))<span class="hljs-comment">;  </span>
  <span class="hljs-attr">options.flags</span> = ARES_FLAG_NOCHECKRESP<span class="hljs-comment">;   </span>
  /*
    caresd socket 状态（读写）发生变更时，执行的函数，
    第一个入参是 sock_state_cb_data
  */
  <span class="hljs-attr">options.sock_state_cb</span> = ares_sockstate_cb<span class="hljs-comment">;  </span>
  <span class="hljs-attr">options.sock_state_cb_data</span> = this<span class="hljs-comment">;  </span>
  
  // 还没初始化则初始化 
  if (!library_inited_) {  
   Mutex::ScopedLock lock(ares_library_mutex)<span class="hljs-comment">;  </span>
   // 初始化 cares 库，每次调用会使得引用数加一，析构时减一  
   ares_library_init(ARES_LIB_INIT_ALL)<span class="hljs-comment">;  </span>
 }  
 // 设置 channel 的配置  
 ares_init_options(&#x26;channel_,  
                   &#x26;options,  
                   ARES_OPT_FLAGS | ARES_OPT_SOCK_STATE_CB)<span class="hljs-comment">;</span>
 <span class="hljs-attr">library_inited_</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;  </span>
}  
</code></pre>
<p>Setup 中除了增加 cares 库的引用计数，最重要的就是设置了 cares socket 状态变更时执行的回调 ares_sockstate_cb（比如 socket 可以读取数据或者写入数据）。前面讲到 cares 是和事件驱动模块配合使用的，那么它们是如何配合的呢？cares 提供了一种机制，当调用方发起 DNS 查询时，cares 会创建一个 socket，然后把请求报文发送出去，接着传递创建的 socket 给调用者（比如 Node.js），调用者把 socket 对应 fd 注册到事件驱动模块等待读事件（DNS 响应），数据可读时再调用 cares 函数解析 DNS 响应。流程如下图所所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffa6dc897aac4f51a9689ba4817e6894~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下面我们看一下使用 cares 进行 DNS 查询的具体实现，我们从发起一个 cname 查询开始分析（其他函数的实现是类似的），代码如下。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">req</span> = new QueryReqWrap()<span class="hljs-comment">;</span>
<span class="hljs-attr">req.bindingName</span> = bindingName<span class="hljs-comment">;</span>
<span class="hljs-attr">req.callback</span> = callback<span class="hljs-comment">;</span>
<span class="hljs-attr">req.hostname</span> = name<span class="hljs-comment">;</span>
<span class="hljs-attr">req.oncomplete</span> = <span class="hljs-literal">on</span>resolve<span class="hljs-comment">;</span>
<span class="hljs-attr">req.ttl</span> = !!(options &#x26;&#x26; options.ttl)<span class="hljs-comment">;</span>
this._handle<span class="hljs-section">['queryCname']</span>(req, toASCII(name))<span class="hljs-comment">;</span>
</code></pre>
<p>上面代码最终调用了 C++ 层导出的 queryCname 函数。</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">env</span>->SetProtoMethod(channel_wrap, <span class="hljs-string">"queryCname"</span>, Query&#x3C;QueryCnameWrap>);
</code></pre>
<p>queryCname 对应的是 C++ 的 Query 函数，Query 是 C++ 模板函数，QueryCnameWrap 是 C++ 类。</p>
<pre><code class="hljs language-scss">template &#x3C;class Wrap>  
static void <span class="hljs-built_in">Query</span>(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {  
  Environment* env = Environment::GetCurrent(args);  
  ChannelWrap* channel;  
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;channel, args.Holder());  
  <span class="hljs-comment">// 拿到 JS 层的请求对象 QueryReqWrap</span>
  Local&#x3C;<span class="hljs-selector-tag">Object</span>> req_wrap_obj = args<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.As</span>&#x3C;<span class="hljs-selector-tag">Object</span>>();  
  Local&#x3C;String> string = args<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.As</span>&#x3C;String>();  
  <span class="hljs-comment">/*
    根据参数新建一个 C++ 对象，这里是 QueryCnameWrap，
    QueryCnameWrap 和 JS 对象 QueryReqWrap 互相关联
  */</span>
  Wrap* wrap = new <span class="hljs-built_in">Wrap</span>(channel, req_wrap_obj);  
  
  node::Utf8Value name(env->isolate(), string);
  <span class="hljs-comment">// 发起请求数加一  </span>
  channel-><span class="hljs-built_in">ModifyActivityQueryCount</span>(<span class="hljs-number">1</span>);  
    <span class="hljs-comment">// 调用 Send 函数发起查询</span>
  int err = wrap-><span class="hljs-built_in">Send</span>(*name);  
  <span class="hljs-comment">// 失败则请求数减一</span>
  if (err) {  
    channel-><span class="hljs-built_in">ModifyActivityQueryCount</span>(-<span class="hljs-number">1</span>);  
    delete wrap;  
  }  
  
  args<span class="hljs-selector-class">.GetReturnValue</span>()<span class="hljs-selector-class">.Set</span>(err);  
 }  
</code></pre>
<p>Query 只实现了一些通用的逻辑，然后调用 Send 函数，具体的 Send 函数逻辑由各个具体的类实现，QueryCnameWrap 类的 Send 实现如下。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span> <span class="hljs-keyword">override</span> </span>{  
    <span class="hljs-built_in">AresQuery</span>(name, ns_c_in, ns_t_cname);  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
  }  
</code></pre>
<p>Send 函数最终会调用基类的 AresQuery 函数，基类 QueryWrap 中 AresQuery 的实现如下所示。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AresQuery</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,  
                       <span class="hljs-type">int</span> dnsclass,  
                       <span class="hljs-type">int</span> type)</span> </span>{  
    <span class="hljs-built_in">ares_query</span>(channel_-><span class="hljs-built_in">cares_channel</span>(), 
               name, 
               dnsclass, 
               type, 
               Callback,  
               <span class="hljs-built_in">static_cast</span>&#x3C;<span class="hljs-type">void</span>*>(<span class="hljs-keyword">this</span>));  
  }  
</code></pre>
<p>AresQuery 函数提供统一的发送查询操作，cares 查询完成后执行 Callback 回调。接下来就涉及 cares 和 Node.js 的具体交互了。我们看一下ares_query 的关键逻辑。</p>
<pre><code class="hljs language-ini">void ares_query(ares_channel channel, const char *name, int dnsclass,  
                int type, ares_callback callback, void *arg)  
{  
  struct qquery *qquery<span class="hljs-comment">;  </span>
  unsigned char *qbuf<span class="hljs-comment">;  </span>
  int qlen, rd, status<span class="hljs-comment">;  </span>

  // 构造 DNS 报文，内容在 qbuf
  <span class="hljs-attr">rd</span> = !(channel->flags &#x26; ARES_FLAG_NORECURSE)<span class="hljs-comment">;</span>
  <span class="hljs-attr">status</span> = ares_create_query(name, dnsclass, type, channel->next_id, rd, &#x26;qbuf,
              &#x26;qlen, (channel->flags &#x26; ARES_FLAG_EDNS) ? channel->ednspsz : 0)<span class="hljs-comment">;</span>
              
  <span class="hljs-attr">qquery</span> = ares_malloc(sizeof(struct qquery))<span class="hljs-comment">;  </span>
  // 保存 Node.js 的回调，查询完成时回调  
  qquery-><span class="hljs-attr">callback</span> = callback<span class="hljs-comment">;  </span>
  qquery-><span class="hljs-attr">arg</span> = arg<span class="hljs-comment">;  </span>
  // 发送报文，回调是 qcallback
  ares_send(channel, qbuf, qlen, qcallback, qquery)<span class="hljs-comment">;  </span>
}  
    
void ares__send_query(ares_channel channel, struct query *query,
                      struct timeval *now)
{
  struct send_request *sendreq<span class="hljs-comment">;</span>
  struct server_state *server<span class="hljs-comment">;</span>
  int timeplus<span class="hljs-comment">;</span>

  <span class="hljs-attr">server</span> = &#x26;channel->servers[query->server]<span class="hljs-comment">;</span>
  // 如果还没有创建 socket，则创建一个 UDP socket
  if (server-><span class="hljs-attr">udp_socket</span> == ARES_SOCKET_BAD)
    {
      open_udp_socket(channel, server)<span class="hljs-comment">;</span>
    }
  // 发送 qbuf 里的数据，发起 DNS 查询
  socket_write(channel, server->udp_socket, query->qbuf, query->qlen)<span class="hljs-comment">;</span>
}
</code></pre>
<p>cares 会根据查询类型构造请求报文，如果还没有创建 socket 的话，则创建一个 UDP socket（也可以使用 TCP socket），最后调用 socket_write 把数据发送出去。这个过程中有一个重要的逻辑是把创建的 socket 告诉 Node.js，具体逻辑在 open_udp_socket 中。</p>
<pre><code class="hljs language-ini">static int open_udp_socket(ares_channel channel, struct server_state *server)
{
  ares_socket_t s<span class="hljs-comment">;</span>
  ares_socklen_t salen<span class="hljs-comment">;</span>
  union {
    struct sockaddr_in  sa4<span class="hljs-comment">;</span>
    struct sockaddr_in6 sa6<span class="hljs-comment">;</span>
  } saddr<span class="hljs-comment">;</span>
  struct sockaddr *sa<span class="hljs-comment">;</span>
  // 拿到服务器地址
  switch (server->addr.family)
    {
      case AF_INET:
        <span class="hljs-attr">sa</span> = (void *)&#x26;saddr.sa4<span class="hljs-comment">;</span>
        <span class="hljs-attr">salen</span> = sizeof(saddr.sa4)<span class="hljs-comment">;</span>
        memset(sa, 0, salen)<span class="hljs-comment">;</span>
        <span class="hljs-attr">saddr.sa4.sin_family</span> = AF_INET<span class="hljs-comment">;</span>
        if (server->addr.udp_port) {
          <span class="hljs-attr">saddr.sa4.sin_port</span> = aresx_sitous(server->addr.udp_port)<span class="hljs-comment">;</span>
        } else {
          <span class="hljs-attr">saddr.sa4.sin_port</span> = aresx_sitous(channel->udp_port)<span class="hljs-comment">;</span>
        }
        memcpy(&#x26;saddr.sa4.sin_addr, &#x26;server->addr.addrV4,
               sizeof(server->addr.addrV4))<span class="hljs-comment">;</span>
        break<span class="hljs-comment">;</span>
      // 忽略 IPV6 的处理
    }

  // 创建一个 UDP socket
  <span class="hljs-attr">s</span> = open_socket(channel, server->addr.family, SOCK_DGRAM, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
  // 设置一些属性，比如非阻塞、发送缓冲区和接收缓冲区大小
  configure_socket(s, server->addr.family, channel)<span class="hljs-comment">;</span>
  // 设置服务器地址
  connect_socket(channel, s, sa, salen)<span class="hljs-comment">;</span>
  // 通知调用方，socket 状态变更，1，0 表示需要可读事件，即 DNS 响应
  channel->sock_state_cb(channel->sock_state_cb_data, s, 1, 0)<span class="hljs-comment">;  </span>
  // 保存 socket，下次查询不用再创建了
  server-><span class="hljs-attr">udp_socket</span> = s<span class="hljs-comment">;</span>
  return 0<span class="hljs-comment">;</span>
}
</code></pre>
<p>open_udp_socket 创建完 socket 后通过 channel->sock_state_cb 通知 Node.js，也就是初始化 ChannelWrap 时，ChannelWrap::Setup 中设置的 ares_sockstate_cb。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">ares_sockstate_cb</span>(void* data,
                       ares_socket_t sock,
                       int read,
                       int write) {
  ChannelWrap* channel = static_cast&#x3C;ChannelWrap*>(data);
  node_ares_task* task;

  node_ares_task lookup_task;
  lookup_task<span class="hljs-selector-class">.sock</span> = sock;
  <span class="hljs-comment">// 判断 sock 是否已经存在任务队列中</span>
  auto it = channel-><span class="hljs-built_in">task_list</span>()-><span class="hljs-built_in">find</span>(&#x26;lookup_task);
  
  task = (it == channel->task_list()-><span class="hljs-built_in">end</span>()) ? nullptr : *it;
  <span class="hljs-comment">// 需要注册读或写事件</span>
  if (read || write) {
    <span class="hljs-comment">// 之前还没有保存这个 sock，则创建一个相应的任务并插入任务队列</span>
    if (!task) {
      <span class="hljs-comment">// 启动定时器，如果很久都没有触发感兴趣的事件则触发超时，超时后通知 cares</span>
      channel-><span class="hljs-built_in">StartTimer</span>();
      task = <span class="hljs-built_in">ares_task_create</span>(channel, sock);
      channel-><span class="hljs-built_in">task_list</span>()-><span class="hljs-built_in">insert</span>(task);
    }
    <span class="hljs-comment">// 注册 sock 对应的 IO 观察者和事件到 Libuv 中</span>
    <span class="hljs-built_in">uv_poll_start</span>(&#x26;task->poll_watcher,
                  (read ? UV_READABLE : <span class="hljs-number">0</span>) | (write ? UV_WRITABLE : <span class="hljs-number">0</span>),
                  ares_poll_cb);

  } else { <span class="hljs-comment">// 不需要注册事件，说明不使用了</span>
    <span class="hljs-comment">// 从任务队列中删除，</span>
    channel-><span class="hljs-built_in">task_list</span>()-><span class="hljs-built_in">erase</span>(it);
    channel-><span class="hljs-built_in">env</span>()-><span class="hljs-built_in">CloseHandle</span>(&#x26;task->poll_watcher, ares_poll_close_cb);
    <span class="hljs-comment">// 如果任务队列为空，则清除定时器</span>
    <span class="hljs-comment">// 一个 ChannelWrap 对象中，只有一个定时器，它负责 cares channel 中所有 DNS 解析请求的超时管理</span>
    if (channel->task_list()-><span class="hljs-built_in">empty</span>()) {
      channel-><span class="hljs-built_in">CloseTimer</span>();
    }
  }
}
</code></pre>
<p>ares_sockstate_cb 往 Libuv 中注册了事件（这里是可读事件），然后等待 DNS 响应数据包到达后，就执行 ares_poll_cb 处理响应。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ares_poll_cb</span><span class="hljs-params">(<span class="hljs-type">uv_poll_t</span>* watcher, <span class="hljs-type">int</span> status, <span class="hljs-type">int</span> events)</span> </span>{
  node_ares_task* task = <span class="hljs-built_in">ContainerOf</span>(&#x26;node_ares_task::poll_watcher, watcher);
  ChannelWrap* channel = task->channel;
  <span class="hljs-comment">// 调用 cares 函数处理响应并告知触发了什么事件，</span>
  <span class="hljs-comment">// 第二个参数代表是否触发可读事件，第三个参数表示是否触发可写事件</span>
  <span class="hljs-built_in">ares_process_fd</span>(channel-><span class="hljs-built_in">cares_channel</span>(),
                  events &#x26; UV_READABLE ? task->sock : ARES_SOCKET_BAD,
                  events &#x26; UV_WRITABLE ? task->sock : ARES_SOCKET_BAD);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ares_process_fd</span><span class="hljs-params">(ares_channel channel,
                     <span class="hljs-type">ares_socket_t</span> read_fd, <span class="hljs-comment">/* use ARES_SOCKET_BAD or valid file descriptors */</span>
                     <span class="hljs-type">ares_socket_t</span> write_fd)</span>
</span>{
  <span class="hljs-built_in">processfds</span>(channel, <span class="hljs-literal">NULL</span>, read_fd, <span class="hljs-literal">NULL</span>, write_fd);
}
</code></pre>
<p>ares_poll_cb 中执行了 cares 的 ares_process_fd 函数进行处理，ares_process_fd 进一步执行了 processfds。</p>
<pre><code class="hljs language-scss">static void <span class="hljs-built_in">processfds</span>(ares_channel channel,
                       fd_set *read_fds, ares_socket_t read_fd,
                       fd_set *write_fds, ares_socket_t write_fd)
{
  struct timeval now = <span class="hljs-built_in">ares__tvnow</span>();
  <span class="hljs-built_in">read_udp_packets</span>(channel, read_fds, read_fd, &#x26;now);
}
</code></pre>
<p>这里我们只关注 processfds 中的 read_udp_packets 函数，不需要关注其它的逻辑，比如查询超时。</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">read_udp_packets</span><span class="hljs-params">(ares_channel channel, fd_set *read_fds,
                             <span class="hljs-type">ares_socket_t</span> read_fd, <span class="hljs-keyword">struct</span> timeval *now)</span>
{
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">server_state</span> *<span class="hljs-title">server</span>;</span>
  <span class="hljs-type">int</span> i;
  <span class="hljs-type">ares_ssize_t</span> count;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[MAXENDSSZ + <span class="hljs-number">1</span>];
  <span class="hljs-type">ares_socklen_t</span> fromlen;
  <span class="hljs-class"><span class="hljs-keyword">union</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span>     <span class="hljs-title">sa</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span>  <span class="hljs-title">sa4</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span> <span class="hljs-title">sa6</span>;</span>
  } from;
  <span class="hljs-keyword">do</span> {
    <span class="hljs-comment">// 读取数据和对端地址信息</span>
    <span class="hljs-keyword">if</span> (server->addr.family == AF_INET)
        fromlen = <span class="hljs-keyword">sizeof</span>(from.sa4);
    <span class="hljs-keyword">else</span>
        fromlen = <span class="hljs-keyword">sizeof</span>(from.sa6);
    count = socket_recvfrom(channel, server->udp_socket, (<span class="hljs-type">void</span> *)buf,
                            <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-number">0</span>, &#x26;from.sa, &#x26;fromlen);
    <span class="hljs-comment">// 处理数据</span>
    process_answer(channel, buf, (<span class="hljs-type">int</span>)count, i, <span class="hljs-number">0</span>, now);
  } <span class="hljs-keyword">while</span> (count > <span class="hljs-number">0</span>); <span class="hljs-comment">// 没读完接着读</span>
}
</code></pre>
<p>read_udp_packets 调用 socket_recvfrom 读取响应数据，接着执行 process_answer 处理数据。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">process_answer</span><span class="hljs-params">(ares_channel channel, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *abuf, <span class="hljs-type">int</span> alen, ...)</span>
</span>{
  <span class="hljs-built_in">end_query</span>(channel, query, ARES_SUCCESS, abuf, alen);
}

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">end_query</span><span class="hljs-params">(ares_channel channel, <span class="hljs-keyword">struct</span> query *query, <span class="hljs-type">int</span> status,
                       <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *abuf, <span class="hljs-type">int</span> alen)</span>
</span>{
  <span class="hljs-comment">// 执行回调</span>
  query-><span class="hljs-built_in">callback</span>(query->arg, status, query->timeouts, abuf, alen);
  <span class="hljs-comment">// 释放内存</span>
  <span class="hljs-built_in">ares__free_query</span>(query);
}
</code></pre>
<p>process_answer 调用了 end_query，end_query 最终调用了 query->callback，query->callback 是在发起查询时（ares_query）设置的 qcallback。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">qcallback</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg, <span class="hljs-type">int</span> status, <span class="hljs-type">int</span> timeouts, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *abuf, <span class="hljs-type">int</span> alen)</span>
</span>{
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">qquery</span> *qquery = (<span class="hljs-keyword">struct</span> qquery *) arg;
  qquery-><span class="hljs-built_in">callback</span>(qquery->arg, status, timeouts, abuf, alen);
}
</code></pre>
<p>qcallback 最终调用了调用方设置的回调，比如 Node.js 的 Callback。</p>
<pre><code class="hljs language-ini">  static void Callback(void* arg, int status, int timeouts,
                       unsigned char* answer_buf, int answer_len) {
    QueryWrap* <span class="hljs-attr">wrap</span> = FromCallbackPointer(arg)<span class="hljs-comment">;</span>
    
    unsigned char* <span class="hljs-attr">buf_copy</span> = nullptr<span class="hljs-comment">;</span>
    if (<span class="hljs-attr">status</span> == ARES_SUCCESS) {
      <span class="hljs-attr">buf_copy</span> = node::Malloc&#x3C;unsigned char>(answer_len)<span class="hljs-comment">;</span>
      memcpy(buf_copy, answer_buf, answer_len)<span class="hljs-comment">;</span>
    }

    wrap-><span class="hljs-attr">response_data_</span> = std::make_unique&#x3C;ResponseData>()<span class="hljs-comment">;</span>
    ResponseData* <span class="hljs-attr">data</span> = wrap->response_data_.get()<span class="hljs-comment">;</span>
    data-><span class="hljs-attr">status</span> = status<span class="hljs-comment">;</span>
    data-><span class="hljs-attr">is_host</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
    data-><span class="hljs-attr">buf</span> = MallocedBuffer&#x3C;unsigned char>(buf_copy, answer_len)<span class="hljs-comment">;</span>
    // 继续下一步处理
    wrap->QueueResponseCallback(status)<span class="hljs-comment">;</span>
  }
  
  void QueueResponseCallback(int status) {
    BaseObjectPtr&#x3C;QueryWrap> strong_ref{this}<span class="hljs-comment">;</span>
    // 插入一个任务，check 阶段处理
    env()->SetImmediate(<span class="hljs-section">[this, strong_ref]</span>(Environment*) {
      AfterResponse()<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>

    channel_->set_query_last_ok(status != ARES_ECONNREFUSED)<span class="hljs-comment">;</span>
    // 请求完成，请求数减一
    channel_->ModifyActivityQueryCount(-1)<span class="hljs-comment">;</span>
  }
</code></pre>
<p>Node.js 的回调会插入一个任务到 Immediate 队列，然后在 check 阶段被处理。接着看 AfterResponse。</p>
<pre><code class="hljs language-csharp">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AfterResponse</span>()</span> {
    Parse(response_data_->host.<span class="hljs-keyword">get</span>());
  }
</code></pre>
<p>不同的查询类型对应不同的 Parse 逻辑，下面看一下 cname 查询对应的逻辑。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">Parse</span>(unsigned char* buf, int len) override {
    HandleScope <span class="hljs-built_in">handle_scope</span>(env()-><span class="hljs-built_in">isolate</span>());
    Context::Scope context_scope(env()->context());

    Local&#x3C;Array> ret = Array::New(env()->isolate());
    int type = ns_t_cname;
    <span class="hljs-comment">// 调用 ares_parse_a_reply 进行解析</span>
    <span class="hljs-built_in">ParseGeneralReply</span>(env(), buf, len, &#x26;type, ret);

    this-><span class="hljs-built_in">CallOnComplete</span>(ret);
  }
  
  void <span class="hljs-built_in">CallOnComplete</span>(Local&#x3C;Value> answer,
                      Local&#x3C;Value> extra = Local&#x3C;Value>()) {
    
    Local&#x3C;Value> argv<span class="hljs-selector-attr">[]</span> = {
      Integer::New(env()->isolate(), <span class="hljs-number">0</span>),
      answer,
      extra
    };
    const int argc = <span class="hljs-built_in">arraysize</span>(argv) - extra<span class="hljs-selector-class">.IsEmpty</span>();
    <span class="hljs-comment">// 执行 JS 层回调</span>
    <span class="hljs-built_in">MakeCallback</span>(env()-><span class="hljs-built_in">oncomplete_string</span>(), argc, argv);
 }
</code></pre>
<p>最终通过 MakeCallback 把解析结果告诉 JS 层。整体结构图如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70685430e2a84cf9a2a3f006fc4b90be~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>从上图中可以看到，一个 JS 层的 Resolver 是对 C++ 层 ChannelWrap 的封装，ChannelWrap 则是对 cares ares_channel 的封装，每个 ares_channel 中有多个 UDP 服务器的配置。当一个 UDP 服务器失败时，cares 会尝试使用下一个，cares 和每一个 UDP 服务器通信前会创建一个 UDP socket，然后通知 Node.js，Node.js 再把 socket 封装成一个个任务插入到 ChannelWrap 的任务对队列中。</p>
<h2>DNS 的超时管理</h2>
<p>当我们发起 DNS 请求时，如果服务器一直不返回，我们总不能一直等待，这时就需要超时管理机制。前面讲过一个 ares_channel 负责管理多个 DNS 查询，但是 cares 不支持给每一个查询设置超时时间，只能按照 ares_channel 的维度设置一个超时时间，有兴趣的同学可以参考这个 <a href="https://github.com/c-ares/c-ares/issues/135" target="_blank" rel="nofollow noopener noreferrer">issue</a>。 刚才讲解 ChannelWrap 时已经提到了超时的逻辑，下面再来具体看一下。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">ares_sockstate_cb</span>(void* data,
                       ares_socket_t sock,
                       int read,
                       int write) {
  ChannelWrap* channel = static_cast&#x3C;ChannelWrap*>(data);
  node_ares_task* task;

  node_ares_task lookup_task;
  lookup_task<span class="hljs-selector-class">.sock</span> = sock;
  auto it = channel-><span class="hljs-built_in">task_list</span>()-><span class="hljs-built_in">find</span>(&#x26;lookup_task);

  task = (it == channel->task_list()-><span class="hljs-built_in">end</span>()) ? nullptr : *it;

  if (read || write) {
    if (!task) {
      channel-><span class="hljs-built_in">StartTimer</span>();
      task = <span class="hljs-built_in">ares_task_create</span>(channel, sock);
      channel-><span class="hljs-built_in">task_list</span>()-><span class="hljs-built_in">insert</span>(task);
    }
  } else {
    channel-><span class="hljs-built_in">task_list</span>()-><span class="hljs-built_in">erase</span>(it);
    channel-><span class="hljs-built_in">env</span>()-><span class="hljs-built_in">CloseHandle</span>(&#x26;task->poll_watcher, ares_poll_close_cb);

    if (channel->task_list()-><span class="hljs-built_in">empty</span>()) {
      channel-><span class="hljs-built_in">CloseTimer</span>();
    }
  }
}
</code></pre>
<p>从上面的代码中可以看到，每次创建一个新的 UDP socket 时，就会生成一个任务并执行 StartTimer 启动定时器，每次 socket 不再使用时就会从队列中删除该任务，如果队列为空则关闭定时器。下面看看 StartTimer。</p>
<pre><code class="hljs language-scss">void ChannelWrap::StartTimer() {
  if (timer_handle_ == nullptr) {
    timer_handle_ = new <span class="hljs-built_in">uv_timer_t</span>();
    timer_handle_->data = static_cast&#x3C;void*>(this);
    <span class="hljs-built_in">uv_timer_init</span>(env()-><span class="hljs-built_in">event_loop</span>(), timer_handle_);
  } else if (uv_is_active(reinterpret_cast&#x3C;uv_handle_t*>(timer_handle_))) {
    return;
  }
  <span class="hljs-built_in">uv_timer_start</span>(timer_handle_, AresTimeout, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>);
}
</code></pre>
<p>StartTimer 的逻辑很简单，就是如果还没有启动定时器则启动它，否则不做任何处理。定时器每一秒就会触发一次超时（后续的 Node.js 版本支持设置这个时间），除非有响应数据返回，比如 ares_poll_cb 是有数据返回时的回调，它会重置定时器。</p>
<pre><code class="hljs language-ini">void ares_poll_cb(uv_poll_t* watcher, int status, int events) {
  node_ares_task* <span class="hljs-attr">task</span> = ContainerOf(&#x26;node_ares_task::poll_watcher, watcher)<span class="hljs-comment">;</span>
  ChannelWrap* <span class="hljs-attr">channel</span> = task->channel<span class="hljs-comment">;</span>
  uv_timer_again(channel->timer_handle())<span class="hljs-comment">;</span>
}
</code></pre>
<p>那么如果一直没有数据返回就会触发超时回调 AresTimeout，但是定时器超时并不代表 DNS 查询超时，这里只是定时调用 cares 的函数，由 cares 判断是否超时。</p>
<pre><code class="hljs language-ini">void ChannelWrap::AresTimeout(uv_timer_t* handle) {
  ChannelWrap* <span class="hljs-attr">channel</span> = static_cast&#x3C;ChannelWrap*>(handle->data)<span class="hljs-comment">;</span>
  ares_process_fd(channel->cares_channel(), ARES_SOCKET_BAD, ARES_SOCKET_BAD)<span class="hljs-comment">;</span>
}
</code></pre>
<p>ares_process_fd 调用 process_timeouts。</p>
<pre><code class="hljs language-ini">static void process_timeouts(ares_channel channel, struct timeval *now)
{
  time_t t<span class="hljs-comment">;  /* the time of the timeouts we're processing */</span>
  struct query *query<span class="hljs-comment">;</span>
  struct list_node* list_head<span class="hljs-comment">;</span>
  struct list_node* list_node<span class="hljs-comment">;</span>
  // 遍历请求，判断是否已经超时，如果超时了则换一个服务器
  for (<span class="hljs-attr">t</span> = channel->last_timeout_processed<span class="hljs-comment">; t &#x3C;= now->tv_sec; t++)</span>
    {
      <span class="hljs-attr">list_head</span> = &#x26;(channel->queries_by_timeout[t % ARES_TIMEOUT_TABLE_SIZE])<span class="hljs-comment">;</span>
      for (<span class="hljs-attr">list_node</span> = list_head->next<span class="hljs-comment">; list_node != list_head; )</span>
        {
          <span class="hljs-attr">query</span> = list_node->data<span class="hljs-comment">;</span>
          <span class="hljs-attr">list_node</span> = list_node->next<span class="hljs-comment">;  /* in case the query gets deleted */</span>
          if (query->timeout.tv_sec &#x26;&#x26; ares__timedout(now, &#x26;query->timeout))
            {
              query-><span class="hljs-attr">error_status</span> = ARES_ETIMEOUT<span class="hljs-comment">;</span>
              // 记录超时次数
              ++query->timeouts<span class="hljs-comment">;</span>
              next_server(channel, query, now)<span class="hljs-comment">;</span>
            }
        }
     }
  // 更新上次处理时间
  channel-><span class="hljs-attr">last_timeout_processed</span> = now->tv_sec<span class="hljs-comment">;</span>
}
</code></pre>
<p>当 DNS 请求超时时，cares 会调用 next_server 切换到下一个服务器。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">static</span> void <span class="hljs-title function_ invoke__">next_server</span>(ares_channel channel, <span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span> *query,
                        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> *now)
{
  <span class="hljs-comment">// 请求错误次数是否到达阈值，否则换一个服务器</span>
  <span class="hljs-title function_ invoke__">while</span> (++(query<span class="hljs-punctuation">-></span>try_count) &#x3C; (channel<span class="hljs-punctuation">-></span>nservers * channel<span class="hljs-punctuation">-></span>tries))
    {
      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">server_state</span> *server;
      <span class="hljs-comment">// 更新查询对应的服务器</span>
      query<span class="hljs-punctuation">-></span>server = (query<span class="hljs-punctuation">-></span>server + <span class="hljs-number">1</span>) % channel<span class="hljs-punctuation">-></span>nservers;
      <span class="hljs-comment">// 拿到服务器结构体</span>
      server = &#x26;channel<span class="hljs-punctuation">-></span>servers[query<span class="hljs-punctuation">-></span>server];
      <span class="hljs-comment">// 判断服务器是否可用，是则再次发起查询</span>
      <span class="hljs-title function_ invoke__">if</span> (...)
        {
           <span class="hljs-title function_ invoke__">ares__send_query</span>(channel, query, now);
           <span class="hljs-keyword">return</span>;
        }
    }

  <span class="hljs-comment">// 请求错误次数达到阈值或者没有可用的服务器了，则报错，比如执行 Node.js 回调。</span>
  <span class="hljs-title function_ invoke__">end_query</span>(channel, query, query<span class="hljs-punctuation">-></span>error_status, NULL, <span class="hljs-number">0</span>);
}
</code></pre>
<p>在服务器没有数据返回的情况下，Node.js 会定时触发定时器，再由 cares 判断是否有超时的请求。整体流程如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bde7a2f83e14f3291b139d4bf13a766~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>因为无法针对某一个查询请求设置超时时间，所以如果同一个 channel 下有一个请求耗时很久，但是其他请求响应正常，则会导致这个耗时很长的请求没有如期超时。</p>
<h1>总结</h1>
<p>这节课，我们从 Libuv 和 cares 的角度讲解了 Node.js 中 DNS 模块的实现。</p>
<p>在 Libuv 中，DNS 查询功能主要是利用了底层的线程池和系统库提供的阻塞式函数实现的。</p>
<p>cares 中主要是利用了 cares 这个异步 DNS 解析库，这个库只实现了处理 DNS 数据的逻辑，数据驱动机制则是交给调用者实现，比如 Libuv。当 Node.js 发起 DNS 查询时，cares 会创建一个 socket（如果还没有创建的话），接着把 DNS 查询报文发送出去并且把 socket 传递给 Node.js，Node.js 会把这个 socket 注册到事件驱动模块等待 DNS 响应，当 DNS 响应到达时，Node.js 会通知 cares 进行处理（解析 DNS 响应）。</p>
<p>理解了底层之后，上层就很容易理解了，JS 层默认设置了一个默认的 Resolver 对象，我们平时使用的 setServers 或者 resolvexxx 函数都是来自这个 Resolver 对象。我们也可以自己创建一个 Resolver 来进行 DNS 查询，比如后续 Node.js 的 Resolver 函数支持自定义的重试和超时配置，可以根据自己的情况来使用。</p></div>
</body></html>