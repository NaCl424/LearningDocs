<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>详解文件模块的同步、异步、Promise 化、流式操作 API</h1>
<p>文件操作是我们使用 Node.js 时经常会用到的功能，在 Node.js 文件操作的能力是通过文件模块提供的，而文件模块的功能又是通过操作系统的文件系统实现的，文件系统是操作系统中负责管理文件的子系统，这里的文件并不是我们平时熟悉的 JS 或者 JSON 文件，而是更广义的文件，比如网络、普通文件、管道等等在 Linux 中都被当作文件管理，操作系统通过虚拟文件系统屏蔽了底层的实现细节，然后提供统一的 API 给用户调用。</p>
<p>因此，理解 Node.js 的文件模块是我们理解文件系统的一种方式，而理解 Node.js 的文件模块最好的方式就是去看它是怎么实现的，Node.js 文件模块提供了包括同步、异步、Promise 化、流式 API和文件监听的功能。这节课，我们首先讲解前面四种和文件操作相关的 API，下一节课再详细介绍文件监听的实现。</p>
<p>在 Node.js 中，文件模块的 API 几乎都提供了同步和异步的版本。同步的 API 是直接在主线程中调用操作系统提供的接口，它会导致主线程阻塞，异步 API 则是在 Libuv 提供的线程池中执行阻塞式 API 实现的，这样就不会导致主线程阻塞。文件 IO 不同于网络 IO，文件 IO 由于系统兼容性问题，无法像网络 IO 一样利用操作系统提供的能力直接实现异步。在 Libuv 中，文件操作是以线程池实现的，所以这种异步只是对用户而言。另外，Node.js 提供的 Promise 化 API，可以实现以同步的方式写异步代码，提供的流式 API 可以帮助同步控制消费者和生产者的读写速率。理解了这些 API 的实现不仅可以帮助我们更好地使用 Node.js，还可以帮助我们理解文件系统的知识。</p>
<p>下面具体介绍 Node.js 文件模块中文件操作的实现。</p>
<h2>同步API</h2>
<p>在 Node.js 中，同步 API 的本质是直接在主线程里调用操作系统提供的系统调用。下面以 readFileSync 为例，看一下整体的流程，如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3aedf197cba4ecbb98a2a1c3164d373~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下面看一下具体的代码。</p>
<pre><code class="hljs language-ini">function readFileSync(path, options) {  
  <span class="hljs-attr">options</span> = getOptions(options, { flag: <span class="hljs-string">'r'</span> })<span class="hljs-comment">;  </span>
  // 传的是 fd 还是文件路径  
  const <span class="hljs-attr">isUserFd</span> = isFd(path)<span class="hljs-comment">;   </span>
  // 传的是路径，则先同步打开文件  
  const <span class="hljs-attr">fd</span> = isUserFd ? path : fs.openSync(path, options.flag, <span class="hljs-number">0</span>o666)<span class="hljs-comment">;  </span>
  // 查看文件的 stat 信息，拿到文件的大小  
  const <span class="hljs-attr">stats</span> = tryStatSync(fd, isUserFd)<span class="hljs-comment">;  </span>
  // 是否是一般文件  
  const <span class="hljs-attr">size</span> = isFileType(stats, S_IFREG) ? stats[<span class="hljs-number">8</span>] : <span class="hljs-number">0</span><span class="hljs-comment">;  </span>
  let <span class="hljs-attr">pos</span> = <span class="hljs-number">0</span><span class="hljs-comment">;  </span>
  let buffer<span class="hljs-comment">; </span>
  let buffers<span class="hljs-comment">;  </span>
  // 分配一个大小为 size 的 buffer，size 需要小于 2G  
  <span class="hljs-attr">buffer</span> = tryCreateBuffer(size, fd, isUserFd)<span class="hljs-comment">;  </span>
  
  let bytesRead<span class="hljs-comment">;  </span>
  // 不断地同步读文件内容  
  if (size !== 0) {  
    do {  
      <span class="hljs-attr">bytesRead</span> = tryReadSync(fd, isUserFd, buffer, pos, size - pos)<span class="hljs-comment">;  </span>
      pos += bytesRead<span class="hljs-comment">;  </span>
    } while (bytesRead !== 0 &#x26;&#x26; pos &#x3C; size)<span class="hljs-comment">;  </span>
  } else {  
    // 省略特殊情况 
  }  
  // 用户传的是文件路径，Node.js 打开了文件，所以需要关闭  
  if (!isUserFd)  
    fs.closeSync(fd)<span class="hljs-comment">;  </span>
  // 编码处理
  if (options.encoding) <span class="hljs-attr">buffer</span> = buffer.toString(options.encoding)<span class="hljs-comment">;  </span>
  // 返回文件内容
  return buffer<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>我们重点看一下 tryReadSync。tryReadSync 调用的是 fs.readSync，readSync 调用的是 read，这对应的是 C++ 层的 Read 函数，Read 函数主要逻辑如下。</p>
<pre><code class="hljs language-ini">Environment* <span class="hljs-attr">env</span> = Environment::GetCurrent(args)<span class="hljs-comment">;</span>
  // 参数处理
  const int <span class="hljs-attr">argc</span> = args.Length()<span class="hljs-comment">;</span>
  const int <span class="hljs-attr">fd</span> = args[<span class="hljs-number">0</span>].As&#x3C;Int32>()->Value()<span class="hljs-comment">;</span>
  const size_t <span class="hljs-attr">off</span> = static_cast&#x3C;size_t>(args[<span class="hljs-number">2</span>].As&#x3C;Integer>()->Value())<span class="hljs-comment">;</span>
  const size_t <span class="hljs-attr">len</span> = static_cast&#x3C;size_t>(args[<span class="hljs-number">3</span>].As&#x3C;Int32>()->Value())<span class="hljs-comment">;</span>
  const int64_t <span class="hljs-attr">pos</span> = args[<span class="hljs-number">4</span>].As&#x3C;Integer>()->Value()<span class="hljs-comment">;</span>
  // 数据处理
  Local&#x3C;Object> <span class="hljs-attr">buffer_obj</span> = args[<span class="hljs-number">1</span>].As&#x3C;Object>()<span class="hljs-comment">;</span>
  char* <span class="hljs-attr">buffer_data</span> = Buffer::Data(buffer_obj)<span class="hljs-comment">;</span>
  size_t <span class="hljs-attr">buffer_length</span> = Buffer::Length(buffer_obj)<span class="hljs-comment">;</span>
  char* <span class="hljs-attr">buf</span> = buffer_data + <span class="hljs-literal">off</span><span class="hljs-comment">;</span>
  uv_buf_t <span class="hljs-attr">uvbuf</span> = uv_buf_init(buf, len)<span class="hljs-comment">;</span>
  // 创建一个请求对象
  FSReqBase* <span class="hljs-attr">req_wrap_async</span> = GetReqWrap(env, args[<span class="hljs-number">5</span>])<span class="hljs-comment">;</span>
  // 调用 Libuv 的函数 uv_fs_read 发起读取请求
  const int <span class="hljs-attr">bytesRead</span> = SyncCall(env, 
                                 args<span class="hljs-section">[6]</span>, 
                                 &#x26;req_wrap_sync, 
                                 "read",
                                 uv_fs_read, 
                                 fd, 
                                 &#x26;uvbuf, 
                                 1, 
                                 pos)<span class="hljs-comment">; </span>
  // 读取的字节数 
  args.GetReturnValue().Set(bytesRead)<span class="hljs-comment">;</span>
}
</code></pre>
<p>Read 函数首先进行了参数的处理，比如从文件当哪个位置开始读取，读取多少字节等等，主要是把 V8 的数据转成 C、C++ 的数据，然后调用 SyncCall 函数，SyncCall 是所有同步 API 的通用函数，接下来看看 SyncCall 的实现。</p>
<pre><code class="hljs language-php"><span class="hljs-keyword">int</span> <span class="hljs-title function_ invoke__">SyncCall</span>(...) {  
  <span class="hljs-comment">/*
      req_wrap->req 是一个 uv_fs_t 结构体，属于 request 类，管理一次文件操作的请求 
      fn 是具体的 Libuv 函数，这里是 uv_fs_read 
  */</span>
  <span class="hljs-keyword">int</span> err = <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params">env->event_loop(<span class="hljs-params"></span>), 
               &#x26;(<span class="hljs-params">req_wrap->req</span>), 
               args..., 
               nullptr</span>)</span>;  
  <span class="hljs-comment">// 忽略出错处理</span>
  <span class="hljs-comment">// 返回读到的字节数</span>
  <span class="hljs-keyword">return</span> err;  
}  
</code></pre>
<p>我们看到 SyncCall 函数最终调用的是调用方传进来的函数，这里是 Libuv 的 uv_fs_read，并使用 uv_fs_t 管理本次请求。</p>
<pre><code class="hljs language-ini">int uv_fs_read(uv_loop_t* loop, uv_fs_t* req,
               uv_file file,
               const uv_buf_t bufs<span class="hljs-section">[]</span>,
               unsigned int nbufs,
               int64_t off,
               uv_fs_cb cb) {
  // 初始化请求结构体，设置请求类型
  UV_REQ_INIT(req, UV_FS)<span class="hljs-comment">; </span>
  // 请求子类型                                                 
  req-><span class="hljs-attr">fs_type</span> = UV_FS_READ<span class="hljs-comment">;</span>
  // 读取的字节数                                         
  req-><span class="hljs-attr">result</span> = <span class="hljs-number">0</span><span class="hljs-comment">;                                                          </span>
  req-><span class="hljs-attr">bufs</span> = NULL<span class="hljs-comment">;   </span>
  // 回调，同步时为空                                                      
  req-><span class="hljs-attr">cb</span> = cb<span class="hljs-comment">;   </span>
  // 读取哪个文件
  req-><span class="hljs-attr">file</span> = file<span class="hljs-comment">;</span>
  // 保存读取的数据
  // buf 个数
  req-><span class="hljs-attr">nbufs</span> = nbufs<span class="hljs-comment">;</span>
  // 保存数据的 buf 地址
  req-><span class="hljs-attr">bufs</span> = req->bufsml<span class="hljs-comment">;</span>
  // 复制保存数据的元信息到 req->bufs，后续把数据读到 req->bufs 指向的内存
  memcpy(req->bufs, bufs, nbufs * sizeof(*bufs))<span class="hljs-comment">;</span>
  // 从哪个位置开始读
  req-><span class="hljs-attr">off</span> = <span class="hljs-literal">off</span><span class="hljs-comment">;</span>
  // 执行文件操作
  uv__fs_work(&#x26;req->work_req)<span class="hljs-comment">; </span>
  return req->result<span class="hljs-comment">;      </span>
}
</code></pre>
<p>uv_fs_read 中根据 Libuv 的约定也做了一些初始化工作，然后接着调用了 uv__fs_work 函数。</p>
<pre><code class="hljs language-ini">static void uv__fs_work(struct uv__work* w) {
  int retry_on_eintr<span class="hljs-comment">;</span>
  uv_fs_t* req<span class="hljs-comment">;</span>
  ssize_t r<span class="hljs-comment">;</span>

  <span class="hljs-attr">req</span> = container_of(w, uv_fs_t, work_req)<span class="hljs-comment">;</span>
  // 调用操作系统 API，数据保存到 req->bufs 中
  <span class="hljs-attr">r</span> = uv__fs_read(req)<span class="hljs-comment">;</span>
  if (<span class="hljs-attr">r</span> == -<span class="hljs-number">1</span>)
    req-><span class="hljs-attr">result</span> = UV__ERR(err<span class="hljs-literal">no</span>)<span class="hljs-comment">;</span>
  else
    req-><span class="hljs-attr">result</span> = r<span class="hljs-comment">;</span>
}
</code></pre>
<p>uv__fs_work 最终以阻塞的方式调用操作系统的 read 函数。当第一次读取文件的数据时，操作系统会先给底层的硬盘发送请求，然后阻塞线程，等待硬盘完成数据读取后，会通过中断通知操作系统，从而操作系统唤醒线程。</p>
<p>另外，操作系统底层也做了很多优化，比如后续再读取一样的内容时，就不需要再请求硬盘了，因为操作系统会缓存在内存里，这里还会涉及淘汰机制，数据被修改时的同步问题，有兴趣的可以参考操作系统的知识或者参考这篇<a href="https://zhuanlan.zhihu.com/p/64536225" target="_blank" rel="nofollow noopener noreferrer">文章</a>。</p>
<h2>异步API</h2>
<p>了解了同步 API 的实现后，接下来看一下异步 API 的实现。异步 API 的实现是依赖于 Libuv 的线程池，Node.js 把任务放到线程池，然后返回主线程继续处理其它事情，等到条件满足时，比如文件读写完毕，线程池就会通知主线程，主线程就会执行回调。我们以 readFile 为例讲解这个过程。异步读取文件的流程图，如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/152b0b4df28a4feebab6655192e027d2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下面我们看具体的实现。</p>
<pre><code class="hljs language-ini">function readFile(path, options, callback) {  
  // 管理文件读的对象  
  if (!ReadFileContext)  
    <span class="hljs-attr">ReadFileContext</span> = require(<span class="hljs-string">'internal/fs/read_file_context'</span>)<span class="hljs-comment">; </span>
  const <span class="hljs-attr">context</span> = new ReadFileContext(callback, options.encoding)
  // 传的是文件路径还是 fd  
  <span class="hljs-attr">context.isUserFd</span> = isFd(path)<span class="hljs-comment">;</span>
  // C++ 层的对象，封装了 uv_fs_t 结构体，管理一次文件读请求  
  const <span class="hljs-attr">req</span> = new FSReqCallback()<span class="hljs-comment">;  </span>
  <span class="hljs-attr">req.context</span> = context<span class="hljs-comment">;  </span>
  // 设置回调，打开文件后，执行  
  <span class="hljs-attr">req.oncomplete</span> = readFileAfterOpen<span class="hljs-comment">;  </span>
  // 传的是 fd，则不需要打开文件，下一个 tick 直接执行回调读取文件  
  if (context.isUserFd) {  
    process.nextTick(function tick() {  
      req.oncomplete(null, path)<span class="hljs-comment">;  </span>
    })<span class="hljs-comment">;  </span>
    return<span class="hljs-comment">;  </span>
  }  
  
  const <span class="hljs-attr">flagsNumber</span> = stringToFlags(options.flags)<span class="hljs-comment">;  </span>
  // 调用 C++ 层 open 打开文件  
  binding.open(pathModule.toNamespacedPath(path),  
        flagsNumber,  
        0o666,  
        req)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>ReadFileContext 对象用于管理文件读操作整个过程，FSReqCallback 是对 uv_fs_t 的封装，每次读操作对于 Libuv 来说就是一次请求，该请求的上下文就是使用 uv_fs_t 表示。请求完成后，会执行 FSReqCallback 对象的 oncomplete 函数。因为读取文件时我们通常传的是一个文件路径，所以需要先打开一个文件，我们先看 readFileAfterOpen。</p>
<pre><code class="hljs language-ini">    function readFileAfterOpen(err, fd) {  
      const <span class="hljs-attr">context</span> = this.context<span class="hljs-comment">;  </span>
      // 保存打开文件的 fd  
      <span class="hljs-attr">context.fd</span> = fd<span class="hljs-comment">;  </span>
      // 新建一个 FSReqCallback 对象管理下一个异步请求和回调  
      const <span class="hljs-attr">req</span> = new FSReqCallback()<span class="hljs-comment">;  </span>
      <span class="hljs-attr">req.oncomplete</span> = readFileAfterStat<span class="hljs-comment">; </span>
      // 保存操作的结果 
      <span class="hljs-attr">req.context</span> = context<span class="hljs-comment">;  </span>
      // 获取文件的元数据，拿到文件大小  
      binding.fstat(fd, false, req)<span class="hljs-comment">;  </span>
    }  
</code></pre>
<p>binding.fstat 用于异步获取文件的元信息，比如文件大小、创建者和修改时间等，这里主要用于获取文件的大小，拿到元信息后，接着执行 readFileAfterStat。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function">function <span class="hljs-title">readFileAfterStat</span><span class="hljs-params">(err, stats)</span> </span>{
  <span class="hljs-type">const</span> context = <span class="hljs-keyword">this</span>.context;
  <span class="hljs-comment">// 文件大小</span>
  <span class="hljs-type">const</span> size = context.size;
  <span class="hljs-comment">// 根据文件大小分配内存</span>
  context.buffer = Buffer.<span class="hljs-built_in">allocUnsafeSlow</span>(size);
  <span class="hljs-comment">// 开始执行读操作</span>
  context.<span class="hljs-built_in">read</span>();
}
</code></pre>
<p>readFileAfterStat 根据元数据中记录的文件大小，分配一个 buffer 用于后续读取文件内容。然后调用 context.read 进行读操作。</p>
<pre><code class="hljs language-ini">read() {  
    const <span class="hljs-attr">buffer</span> = this.buffer<span class="hljs-comment">;  </span>
    const <span class="hljs-attr">offset</span> = this.pos<span class="hljs-comment">;  </span>
    const <span class="hljs-attr">length</span> = MathMin(kReadFileBufferLength, this.size - this.pos)<span class="hljs-comment">;;  </span>

    // 省略部分 buffer 处理的逻辑  
    // 创建一个读操作请求
    const <span class="hljs-attr">req</span> = new FSReqCallback()<span class="hljs-comment">;  </span>
    <span class="hljs-attr">req.oncomplete</span> = readFileAfterRead<span class="hljs-comment">;  </span>
    <span class="hljs-attr">req.context</span> = this<span class="hljs-comment">;  </span>

    read(this.fd, buffer, offset, length, -1, req)<span class="hljs-comment">;  </span>
  }  
</code></pre>
<p>read 新建了一个 FSReqCallback 对象管理异步读取操作和回调。我们看一下 C++ 层 read 函数的实现。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 拿到 JS FSReqCallback 对象关联的 C++ 对象</span>
FSReqBase* req_wrap_async = <span class="hljs-built_in">GetReqWrap</span>(env, args[<span class="hljs-number">5</span>]);  
<span class="hljs-comment">// 异步调用 uv_fs_read，回调是 AfterInteger  </span>
<span class="hljs-built_in">AsyncCall</span>(env, req_wrap_async, args, "read", UTF8, AfterInteger,uv_fs_read, fd, &#x26;uvbuf, <span class="hljs-number">1</span>, pos);  
</code></pre>
<p>AsyncCall 的逻辑和分析同步 API 时类似，最后调用 Libuv 的 uv_fs_read 函数。我们看一下这个函数的关键逻辑。</p>
<pre><code class="hljs language-rust"><span class="hljs-title function_ invoke__">uv__req_register</span>(<span class="hljs-keyword">loop</span>, req);    
<span class="hljs-title function_ invoke__">uv__work_submit</span>(<span class="hljs-keyword">loop</span>,      
                &#x26;req<span class="hljs-punctuation">-></span>work_req,   
                UV__WORK_FAST_IO,   
                uv__fs_work,  
                uv__fs_done);   
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   
</code></pre>
<p>uv__work_submit 是给线程池提交一个任务，当子线程执行这个任务时，就会执行uv__fs_work，uv__fs_work 会调用操作系统的系统调用 read（和刚才同步的方式一样，区别是异步模式时 read 是在子线程执行，所以不会阻塞主线程）。等到读取成功后执行 uv__fs_done。uv__fs_done 会执行 C++ 层的回调 AfterInteger。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">AfterInteger</span>(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope <span class="hljs-built_in">after</span>(req_wrap, req);
  req_wrap-><span class="hljs-built_in">Resolve</span>(Integer::New(req_wrap->env()-><span class="hljs-built_in">isolate</span>(), req->result));
}

void FSReqCallback::Resolve(Local&#x3C;Value> value) {
  Local&#x3C;Value> argv<span class="hljs-selector-attr">[2]</span> {
    <span class="hljs-built_in">Null</span>(env()-><span class="hljs-built_in">isolate</span>()),
    value
  };
  <span class="hljs-built_in">MakeCallback</span>(env()-><span class="hljs-built_in">oncomplete_string</span>(),
               value-><span class="hljs-built_in">IsUndefined</span>() ? <span class="hljs-number">1</span> : arraysize(argv),
               argv);
}
</code></pre>
<p>最终执行 JS 层 oncpmolete 的回调，对应的是 readFileAfterRead 函数。</p>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">readFileAfterRead</span>(err, bytesRead) {
  <span class="hljs-comment">// 读出错</span>
  if (err)
      return context<span class="hljs-selector-class">.close</span>(err);
  const context = this<span class="hljs-selector-class">.context</span>;
  <span class="hljs-comment">// bytesRead 为读取了多少字节，更新 pos，更新下一个读取位置</span>
  context<span class="hljs-selector-class">.pos</span> += bytesRead;
  <span class="hljs-comment">// 读够了或者读完了，执行 close</span>
  if (context.pos === context.size || bytesRead === <span class="hljs-number">0</span>) {
    context<span class="hljs-selector-class">.close</span>();
  } else {
    <span class="hljs-comment">// 否则接着读</span>
    context<span class="hljs-selector-class">.read</span>();
  }
}
</code></pre>
<p>readFileAfterRead 判断是否需要停止读操作，比如读取的字节数和需要读取的相等了或者文件内容被读完了（需要读 100 字节，文件内容只有 50 字节）。如果还需要读则继续调用 read，以此类推，不断重复这个过程，直到满足结束条件。</p>
<h2>Promise化API</h2>
<p>Node.js 的 API 都是遵循 callback 模式的，比如我们要读取一个文件的内容。我们通常会这样写：</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);  
fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'filename'</span>, <span class="hljs-string">'utf-8'</span> ,<span class="hljs-function">(<span class="hljs-params">err,data</span>) =></span> {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)  
});
</code></pre>
<p>在需要调用大量 callback 风格的函数时，这样的写法会导致回调地狱，使得代码很难维护。为了支持 Promise 模式，我们通常这样写：</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);  
<span class="hljs-keyword">function</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-params">filename</span>) {  
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {  
        fs.<span class="hljs-title function_">readFile</span>(filename, <span class="hljs-string">'utf-8'</span> ,<span class="hljs-function">(<span class="hljs-params">err,data</span>) =></span> {  
            err ?  <span class="hljs-title function_">reject</span>(err) : <span class="hljs-title function_">resolve</span>(data);  
        });  
    });  
}  
</code></pre>
<p>这种方法可行，但是会增加了用户的负担，但在后期的 Node.js 版本中，文件模块支持了 Promise 化的 API，这样我们就可以直接使用 await 进行文件操作。来看一个使用例子。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> { readFile} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).<span class="hljs-property">promises</span>;  
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runDemo</span>(<span class="hljs-params"></span>) {   
  <span class="hljs-keyword">try</span> {  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-string">'11111.md'</span>, { <span class="hljs-attr">encoding</span>: <span class="hljs-string">'utf-8'</span> }));  
  } <span class="hljs-keyword">catch</span> (e){  
  
  }  
}  
<span class="hljs-title function_">runDemo</span>();  
</code></pre>
<p>从例子中看到，我们不用再写回调了，而是通过 await 的方式接收结果，这只是新版 API 的特性之一，同时新版 API 还支持面向对象的调用方式。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> { open,readFile } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).<span class="hljs-property">promises</span>;  
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runDemo</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-keyword">let</span> filehandle;  
  <span class="hljs-keyword">try</span> {  
    filehandle = <span class="hljs-keyword">await</span> <span class="hljs-title function_">open</span>(<span class="hljs-string">'filename'</span>, <span class="hljs-string">'r'</span>);  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> filehandle.<span class="hljs-title function_">readFile</span>({ <span class="hljs-attr">encoding</span>: <span class="hljs-string">'utf-8'</span> }));  
  } <span class="hljs-keyword">finally</span> {  
    <span class="hljs-keyword">if</span> (filehandle) {  
        <span class="hljs-keyword">await</span> filehandle.<span class="hljs-title function_">close</span>();     
    }  
  }  
}  
<span class="hljs-title function_">runDemo</span>();  
</code></pre>
<p>面向对象的模式中，我们首先需要通过 open 函数拿到一个 FileHandle 对象（对文件描述符的封装），然后就可以在该对象上调各种文件操作的函数。在使用面向对象模式的 API 时有一个需要注意的地方，那就是即使文件操作出错，Node.js 也不会为我们关闭文件描述符。因此，我们需要自己手动关闭文件描述符，否则就会造成文件描述符泄漏。而在非面向对象模式中，在文件操作完毕后，不管成功还是失败，Node.js 都会为我们关闭文件描述符。</p>
<p>无论是面向对象的方式还是直接使用 API 的方式，底层的实现都是一样的，它们都是首先通过 open 函数拿到一个 FileHandle，然后基于 FileHandle 实现其他操作。下面以 readFile 为例看一下具体的实现。</p>
<pre><code class="hljs language-ini">async function readFile(path, options) {
  <span class="hljs-attr">options</span> = getOptions(options, { flag: <span class="hljs-string">'r'</span> })<span class="hljs-comment">;</span>
  const <span class="hljs-attr">flag</span> = options.flag || <span class="hljs-string">'r'</span><span class="hljs-comment">;</span>
  const <span class="hljs-attr">fd</span> = await open(path, flag, <span class="hljs-number">0</span>o666)<span class="hljs-comment">;</span>
  return readFileHandle(fd, options).finally(fd.close)<span class="hljs-comment">;</span>
}
</code></pre>
<p>readFile 首先调用 open 打开文件。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">path, flags, mode</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileHandle</span>(<span class="hljs-keyword">await</span> binding.<span class="hljs-title function_">openFileHandle</span>(...));
}
</code></pre>
<p>open 调用了 C++ 层的 openFileHandle 打开文件并且以其返回值创建了一个 FileHandle 对象。来看一下 openFileHandle。</p>
<pre><code class="hljs language-scss">static void <span class="hljs-built_in">OpenFileHandle</span>(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env-><span class="hljs-built_in">isolate</span>();

  const int argc = args<span class="hljs-selector-class">.Length</span>();
  BufferValue <span class="hljs-built_in">path</span>(isolate, args[<span class="hljs-number">0</span>]);
  const int flags = args<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.As</span>&#x3C;Int32>()-><span class="hljs-built_in">Value</span>();
  const int mode = args<span class="hljs-selector-attr">[2]</span><span class="hljs-selector-class">.As</span>&#x3C;Int32>()-><span class="hljs-built_in">Value</span>();
  <span class="hljs-comment">// req_wrap_async 为 FSReqPromise 对象</span>
  FSReqBase* req_wrap_async = <span class="hljs-built_in">GetReqWrap</span>(env, args[<span class="hljs-number">3</span>]);
  <span class="hljs-comment">// 异步打开文件</span>
  <span class="hljs-built_in">AsyncCall</span>(env, req_wrap_async, args, "open", UTF8, AfterOpenFileHandle,
            uv_fs_open, *path, flags, mode);
}
</code></pre>
<p>首先通过 GetReqWrap 创建了一个 FSReqPromise 对象。</p>
<pre><code class="hljs language-rust">FSReqBase* <span class="hljs-title function_ invoke__">GetReqWrap</span>(Environment* env, v8::Local&#x3C;v8::Value> value) {
  <span class="hljs-comment">// JS 层传入的 kUsePromises</span>
  <span class="hljs-title function_ invoke__">if</span> (value<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">StrictEquals</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">fs_use_promises_symbol</span>())) {
    <span class="hljs-keyword">return</span> FSReqPromise&#x3C;AliasedFloat64Array>::<span class="hljs-title function_ invoke__">New</span>(env);
  }
}

FSReqPromise&#x3C;AliasedBufferT>::<span class="hljs-title function_ invoke__">New</span>(Environment* env, ...) {
  v8::Local&#x3C;v8::Object> obj;
  <span class="hljs-comment">// 创建一个 JS 对象 FSReqPromise 并保存到 obj 中</span>
  <span class="hljs-title function_ invoke__">if</span> (!env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">fsreqpromise_constructor_template</span>()
           <span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">NewInstance</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">context</span>())
           .<span class="hljs-title function_ invoke__">ToLocal</span>(&#x26;obj)) {
    <span class="hljs-keyword">return</span> nullptr;
  }
  v8::Local&#x3C;v8::Promise::Resolver> resolver;
  <span class="hljs-comment">// 在 JS 对象 obj（FSReqPromise） 中设置一个 promise 属性</span>
  <span class="hljs-title function_ invoke__">if</span> (!v8::Promise::Resolver::<span class="hljs-title function_ invoke__">New</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">context</span>()).<span class="hljs-title function_ invoke__">ToLocal</span>(&#x26;resolver) ||
      obj<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">Set</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">context</span>(), env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">promise_string</span>(), resolver).<span class="hljs-title function_ invoke__">IsNothing</span>()) {
    <span class="hljs-keyword">return</span> nullptr;
  } 
  <span class="hljs-comment">// 创建一个 C++ 对象 FSReqPromise，C++ FSReqPromise 和 JS FSReqPromise（obj） 互相关联</span>
  <span class="hljs-keyword">return</span> new <span class="hljs-title function_ invoke__">FSReqPromise</span>(env, obj, ...);
}
</code></pre>
<p>从上面的分析可以知道 GetReqWrap 拿到了一个 FSReqPromise 对象，这个对象又关联了一个 JS 对象 FSReqPromise。接着执行 AsyncCall。</p>
<pre><code class="hljs language-scss">FSReqBase* <span class="hljs-built_in">AsyncCall</span>(...) {
  return <span class="hljs-built_in">AsyncDestCall</span>(...);
}

FSReqBase* <span class="hljs-built_in">AsyncDestCall</span>(...) {
  <span class="hljs-comment">// req 是一个 FSReqPromise 对象</span>
  req_wrap-><span class="hljs-built_in">Init</span>(syscall, dest, len, enc);
  <span class="hljs-comment">// fn 为 Libuv 的文件操作 API</span>
  int err = req_wrap-><span class="hljs-built_in">Dispatch</span>(fn, fn_args..., after);
  req_wrap-><span class="hljs-built_in">SetReturnValue</span>(args);
  return req_wrap;
}
</code></pre>
<p>AsyncCall 首先调用 Libuv 发起了一个异步操作，然后调用 req_wrap->SetReturnValue。因为 req_wrap 是 FSReqPromise 对象，来看看它的 SetReturnValue。</p>
<pre><code class="hljs language-rust">void FSReqPromise&#x3C;AliasedBufferT>::<span class="hljs-title function_ invoke__">SetReturnValue</span>(...) {
  <span class="hljs-comment">// 取出 JS 对象 FSReqPromise 的 promise 属性的值</span>
  v8::Local&#x3C;v8::Value> val =
      <span class="hljs-title function_ invoke__">object</span>()<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">Get</span>(<span class="hljs-title function_ invoke__">env</span>()<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">context</span>(),
                    <span class="hljs-title function_ invoke__">env</span>()<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">promise_string</span>()).<span class="hljs-title function_ invoke__">ToLocalChecked</span>();
  v8::Local&#x3C;v8::Promise::Resolver> resolver = val.As&#x3C;v8::Promise::Resolver>();
   <span class="hljs-comment">// 返回一个 Promise 给 JS</span>
  args.<span class="hljs-title function_ invoke__">GetReturnValue</span>().<span class="hljs-title function_ invoke__">Set</span>(resolver<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">GetPromise</span>());
}
</code></pre>
<p>SetReturnValue 最终给 JS 层返回了一个 Promise 对象，因为 JS 层使用 await 等待了这个 Promise 决议。那我们来看看决议后的值是什么，当文件打开成功后会执行 AfterOpenFileHandle。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">AfterOpenFileHandle</span>(uv_fs_t* req) {
  <span class="hljs-comment">// req_wrap 是 FSReqPromise 对象</span>
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope <span class="hljs-built_in">after</span>(req_wrap, req);
  <span class="hljs-comment">// req->result 是文件描述符</span>
  <span class="hljs-comment">// FileHandle::New 创建了一个 C++ 对象 FileHandle，并关联了一个 JS 对象</span>
  FileHandle* fd = FileHandle::New(..., req->result);
  <span class="hljs-comment">// 返回 FileHandle 中关联的 JS 对象</span>
  req_wrap-><span class="hljs-built_in">Resolve</span>(fd->object());
}
</code></pre>
<p>AfterOpenFileHandle 中拿到了文件对应的文件描述符，然后创建了一个 FileHandle，该 FileHandle 对象里记录了这个文件描述符，最后调用 req_wrap->Resolve。</p>
<pre><code class="hljs language-rust">void FSReqPromise&#x3C;AliasedBufferT>::<span class="hljs-title function_ invoke__">Resolve</span>(v8::Local&#x3C;v8::Value> value) {
  finished_ = <span class="hljs-literal">true</span>;
  v8::HandleScope <span class="hljs-title function_ invoke__">scope</span>(<span class="hljs-title function_ invoke__">env</span>()<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">isolate</span>());
  InternalCallbackScope <span class="hljs-title function_ invoke__">callback_scope</span>(this);
  v8::Local&#x3C;v8::Value> val =
      <span class="hljs-title function_ invoke__">object</span>()<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">Get</span>(<span class="hljs-title function_ invoke__">env</span>()<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">context</span>(),
                    <span class="hljs-title function_ invoke__">env</span>()<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">promise_string</span>()).<span class="hljs-title function_ invoke__">ToLocalChecked</span>();
  v8::Local&#x3C;v8::Promise::Resolver> resolver = val.As&#x3C;v8::Promise::Resolver>();
  <span class="hljs-title function_ invoke__">USE</span>(resolver<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">Resolve</span>(<span class="hljs-title function_ invoke__">env</span>()<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">context</span>(), value).<span class="hljs-title function_ invoke__">FromJust</span>());
}
</code></pre>
<p>Resolve 实际上就是执行了 Promise 对象的 resolve 函数，并把 C++ FileHandle 关联的 JS 对象返回给 JS 层。流程图如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e1aa2c42101442b83bb11fb02ede8f7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>再回到 JS 的 open 函数，open 函数把 C++ 层返回的 JS 对象封装在 FileHandle 中。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">path, flags, mode</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileHandle</span>(<span class="hljs-keyword">await</span> binding.<span class="hljs-title function_">openFileHandle</span>(...));
}
</code></pre>
<p>通过 open 拿到一个 FileHandle 对象后，就可以基于这个 FileHandle 对象进行操作。</p>
<pre><code class="hljs language-scss">async function <span class="hljs-built_in">readFile</span>(path, options) {
  <span class="hljs-comment">// fd 为 FileHandle 对象</span>
  const fd = await <span class="hljs-built_in">open</span>(path, flag, <span class="hljs-number">0</span>o666);
  return <span class="hljs-built_in">readFileHandle</span>(fd, options)<span class="hljs-selector-class">.finally</span>(fd.close);
}
</code></pre>
<p>看一下 readFileHandle。</p>
<pre><code class="hljs language-ini">async function readFileHandle(filehandle, options) {
  // 获取文件元信息，kUsePromises 表示使用 Promise 方式
  const <span class="hljs-attr">statFields</span> = await binding.fstat(filehandle.fd, <span class="hljs-literal">false</span>, kUsePromises)<span class="hljs-comment">;</span>
  // 获取文件大小
  const <span class="hljs-attr">size</span> = statFields[<span class="hljs-number">8</span>/* size */]<span class="hljs-comment">;</span>
  const <span class="hljs-attr">chunks</span> = []<span class="hljs-comment">;</span>
  // 计算每次读取的大小
  const <span class="hljs-attr">chunkSize</span> = size<span class="hljs-comment">;</span>
  let <span class="hljs-attr">endOfFile</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
  do {
    // 分配存储数据的内存
    const <span class="hljs-attr">buf</span> = Buffer.alloc(chunkSize)<span class="hljs-comment">;</span>
    // 读取的数据和大小
    const { bytesRead, buffer } = await read(filehandle, buf, 0, chunkSize, -1)<span class="hljs-comment">;</span>
    // 是否读完了
    <span class="hljs-attr">endOfFile</span> = bytesRead === <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    // 读取了有效数据则把有效数据部分存起来
    if (bytesRead > 0)
      chunks.push(buffer.slice(0, bytesRead))<span class="hljs-comment">;</span>
  } while (!endOfFile)<span class="hljs-comment">;</span>

  const <span class="hljs-attr">result</span> = Buffer.concat(chunks)<span class="hljs-comment">;</span>
  if (options.encoding) {
    return result.toString(options.encoding)<span class="hljs-comment">;</span>
  } else {
    return result<span class="hljs-comment">;</span>
  }
}
</code></pre>
<p>readFileHandle 首先获取了文件夹大小，接着不断调用 read 函数进行数据读取。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function">async function <span class="hljs-title">read</span><span class="hljs-params">(handle, buffer, offset, length, position)</span> </span>{
  <span class="hljs-type">const</span> bytesRead = (await binding.<span class="hljs-built_in">read</span>(handle.fd, buffer, offset, length, position, kUsePromises));
  <span class="hljs-keyword">return</span> { bytesRead, buffer };
}
</code></pre>
<p>read 从 handle（FileHandle） 中获取文件描述符（open 时拿到的）然后调用 C++ 层 Read 函数读取数据并且通过 kUsePromises 表示使用 Promise 的方式。</p>
<h2>流式API</h2>
<p>前面分析了 Node.js 中多种文件操作的方式，不管是同步、异步还是 Promise 化的 API，它们都有一个问题，就是对于用户来说，文件操作都是一次性完成的。比如我们调用 readFile 读取一个文件时，Node.js 会通过一次或多次调用操作系统的接口把所有的文件内容读到内存中，这对内存来说是非常有压力的。假设我们有这样的一个场景，我们需要读取一个文件的内容，然后返回给前端，如果我们直接读取整个文件内容，然后再执行写操作这无疑是非常消耗内存，也是非常低效的。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">http</span> = require(<span class="hljs-string">'http'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">'fs'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">server</span> = http.createServer((req, res) => {  
  fs.readFile('11111.md', (err, data) => {  
    res.end(data)<span class="hljs-comment">;  </span>
  })  
}).listen(11111)<span class="hljs-comment">;  </span>
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/024e9ccaeb274372886c9e9380926fd4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这时候，我们需要使用流式的 API。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">http</span> = require(<span class="hljs-string">'http'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">'fs'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">server</span> = http.createServer((req, res) => {  
  fs.createReadStream('11111.md').pipe(res)<span class="hljs-comment">;  </span>
}).listen(11111)<span class="hljs-comment">;  </span>
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddad0c3a23be42218dffb71872fc7f0f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>流式 API 的好处在于文件的内容并不是一次性读取到内存，而是部分读取，也就是消费完后再继续读取。Node.js 内部帮我们做了流量的控制。下面看一下流式 API 的具体实现。</p>
<h3>可读文件流</h3>
<p>可读文件流是对流式读取文件内容的抽象。可以通过 fs.createReadStream 创建一个文件可读流。文件可读流继承于可读流，所以我们可以以可读流的方式使用它。我们可以实现自定义的可写流，然后通过 pipe 消费可读流的数据。</p>
<pre><code class="hljs language-scala">const fs= require('fs');  
const { <span class="hljs-type">Writable</span> } = require('stream');  
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Writable</span> </span>{  
  _write(data, encoding, cb) {  
    console.log(data);  
    cb(<span class="hljs-literal">null</span>);  
  }  
}  
fs.createReadStream('<span class="hljs-number">11111.</span>md').pipe(<span class="hljs-keyword">new</span> <span class="hljs-type">DemoWritable</span>);  
</code></pre>
<p>我们也可以通过可读流的 data 事件接收可读流的数据，然后再决定如何消费。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">'fs'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">readStream</span> = fs.createReadStream(<span class="hljs-string">'11111.md'</span>)<span class="hljs-comment">;  </span>
readStream.on('data', (data) => {  
    console.log(data)  
})<span class="hljs-comment">;  </span>
</code></pre>
<p>我们看一下 createReadStream 的实现。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">fs.createReadStream</span> = function(path, options) {  
  return new ReadStream(path, options)<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
</code></pre>
<p>CreateReadStream 是对 ReadStream 的封装。</p>
<pre><code class="hljs language-kotlin">function ReadStream(path, options) {  
  options = copyObject(getOptions(options, {}));  
  <span class="hljs-comment">// 支持其他文件模块，默认是 Node.js 内置的 fs 模块</span>
  <span class="hljs-keyword">this</span>[kFs] = options.fs || fs;
  
  Readable.call(<span class="hljs-keyword">this</span>, options);  
  
  <span class="hljs-keyword">this</span>.path = toPathIfFileURL(path);
  <span class="hljs-comment">// 支持传文件路径或文件描述符  </span>
  <span class="hljs-keyword">this</span>.fd = options.fd === undefined ? <span class="hljs-literal">null</span> : options.fd;  
  <span class="hljs-keyword">this</span>.flags = options.flags === undefined ? <span class="hljs-string">'r'</span> : options.flags;  
  <span class="hljs-keyword">this</span>.mode = options.mode === undefined ? 0o666 : options.mode;  
  <span class="hljs-comment">// 读取的开始和结束位置  </span>
  <span class="hljs-keyword">this</span>.start = options.start; 
  <span class="hljs-keyword">this</span>.end = options.end;
  <span class="hljs-comment">// 流出错或结束时是否自动销毁流  </span>
  <span class="hljs-keyword">this</span>.autoClose = options.autoClose === undefined ? <span class="hljs-literal">true</span> : options.autoClose;  
  <span class="hljs-keyword">this</span>.pos = undefined;  
  <span class="hljs-comment">// 已读的字节数  </span>
  <span class="hljs-keyword">this</span>.bytesRead = <span class="hljs-number">0</span>;  
  <span class="hljs-comment">// 流是否已经关闭  </span>
  <span class="hljs-keyword">this</span>.closed = <span class="hljs-literal">false</span>;  
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.start !== undefined) {
    <span class="hljs-keyword">this</span>.pos = <span class="hljs-keyword">this</span>.start;
  } 
  <span class="hljs-comment">// 如果是根据一个文件名创建一个流，则首先打开这个文件  </span>
  <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">this</span>.fd !== <span class="hljs-string">'number'</span>)  
    _openReadFs(<span class="hljs-keyword">this</span>);  
  
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'end'</span>, function() {  
    <span class="hljs-comment">// 流结束时自动销毁流  </span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.autoClose) {  
      <span class="hljs-keyword">this</span>.destroy();  
    }  
  });  
}  
</code></pre>
<p>ReadStream 初始化完后做了两个操作，首先调用 open 打开文件（如果需要的话），接着监听流结束事件，用户可以设置 autoClose 选项控制当流结束或者出错时是否销毁流，对于文件流来说，销毁流意味着关闭底层的文件描述符。接着，我们来看看 open 的实现。</p>
<pre><code class="hljs language-ini">function _openReadFs(stream) {  
  stream<span class="hljs-section">[kFs]</span>.open(stream.path, stream.flags, stream.mode, function(er, fd) {  
    // 保存文件对应的文件描述符
    <span class="hljs-attr">stream.fd</span> = fd<span class="hljs-comment">;  </span>
    // 打开成功后开始流式读取文件内容  
    stream.read()<span class="hljs-comment">;  </span>
  })<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
</code></pre>
<p>open 函数首先打开文件，打开成功后开启流式读取。这样一来，文件内容就会源源不断地流向目的流。读取操作的具体实现如下：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 实现可读流的钩子函数  </span>
<span class="hljs-title class_">ReadStream</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_read</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) {   
  <span class="hljs-variable language_">this</span>[kFs].<span class="hljs-title function_">read</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fd</span>, pool, pool.<span class="hljs-property">used</span>, toRead, <span class="hljs-variable language_">this</span>.<span class="hljs-property">pos</span>, <span class="hljs-function">(<span class="hljs-params">er, bytesRead</span>) =></span> {
    <span class="hljs-comment">// push 到底层流的 bufferList 中，底层的 push 会触发 data 事件  </span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(b);  
  });  
};  
</code></pre>
<p>主要的逻辑是调用异步 read 函数读取文件的内容再放到可读流中，可读流会触发 data 事件通知用户有数据到来，然后继续执行 read 函数，不断驱动着数据的读取（可读流会根据当前情况判断是否继续执行 read 函数，以达到流量控制的目的）。</p>
<h3>可写文件流</h3>
<p>可写文件流是对流式写入文件的抽象（我们不需要关注它的实现细节，只要遵循它的约定来使用）。我们可以通过 fs.createWriteStream 创建一个文件可写流。文件可写流继承于可写流，所以我们可以以可写流的方式使用它。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);  
<span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'123.md'</span>);
writeStream.<span class="hljs-title function_">end</span>(<span class="hljs-string">'world'</span>);  
<span class="hljs-comment">// 或者</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);  
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);  
  
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoReadStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Readable</span> {  
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {  
        <span class="hljs-variable language_">super</span>();  
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span> = <span class="hljs-number">0</span>;  
    }  
    <span class="hljs-title function_">_read</span>(<span class="hljs-params">n</span>) {  
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span>++;  
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span> > <span class="hljs-number">10</span>) {  
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);  
        } <span class="hljs-keyword">else</span> {  
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'1'</span>.<span class="hljs-title function_">repeat</span>(n));  
        }  
          
    }  
}  
<span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoReadStream</span>().<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'123.md'</span>));  
</code></pre>
<p>我们看一下 createWriteStream 的实现。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">fs.createWriteStream</span> = function(path, options) {  
  return new WriteStream(path, options)<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
</code></pre>
<p>createWriteStream 是对 WriteStream 的封装，看一下 WriteStream 的实现</p>
<pre><code class="hljs language-ini">function WriteStream(path, options) {  
  <span class="hljs-attr">options</span> = copyObject(getOptions(options, {}))<span class="hljs-comment">;  </span>
  this<span class="hljs-section">[kFs]</span> = options.fs || fs<span class="hljs-comment">;</span>
  Writable.call(this, options)<span class="hljs-comment">;  </span>
  <span class="hljs-attr">this.path</span> = toPathIfFileURL(path)<span class="hljs-comment">;</span>
  <span class="hljs-attr">this.fd</span> = options.fd === undefined ? null : options.fd<span class="hljs-comment">;  </span>
  <span class="hljs-attr">this.flags</span> = options.flags === undefined ? <span class="hljs-string">'w'</span> : options.flags<span class="hljs-comment">;  </span>
  <span class="hljs-attr">this.mode</span> = options.mode === undefined ? <span class="hljs-number">0</span>o666 : options.mode<span class="hljs-comment">;  </span>
  // 写入的开始位置  
  <span class="hljs-attr">this.start</span> = options.start<span class="hljs-comment">;  </span>
  // 流结束和触发错误的时候是否销毁流  
  <span class="hljs-attr">this.autoClose</span> = options.autoClose === undefined ? <span class="hljs-literal">true</span> : !!options.autoClose<span class="hljs-comment">;  </span>
  // 当前写入位置  
  <span class="hljs-attr">this.pos</span> = undefined<span class="hljs-comment">;  </span>
  // 写成功的字节数  
  <span class="hljs-attr">this.bytesWritten</span> = <span class="hljs-number">0</span><span class="hljs-comment">;  </span>
  <span class="hljs-attr">this.closed</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;  </span>
  
  // 没有传文件描述符则打开一个新的文件  
  if (typeof this.fd !== 'number')
    _openWriteFs(this)<span class="hljs-comment">;</span>
}  

// 写结束后是否自动销毁流
<span class="hljs-attr">WriteStream.prototype._final</span> = function(callback) {
  if (this.autoClose) {
    this.destroy()<span class="hljs-comment">;</span>
  }

  callback()<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>WriteStream 初始化了一系列字段后，接着打开文件（如果需要的话）。</p>
<pre><code class="hljs language-ini">function _openWriteFs(stream) {
  stream<span class="hljs-section">[kFs]</span>.open(stream.path, stream.flags, stream.mode, (er, fd) => {
    <span class="hljs-attr">stream.fd</span> = fd<span class="hljs-comment">;</span>
    stream.emit('open', fd)<span class="hljs-comment">;</span>
    stream.emit('ready')<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;</span>
}
</code></pre>
<p>打开文件后会触发 open 事件并拿到 fd，这样就可以开始执行写操作了，写入文件的逻辑如下：</p>
<pre><code class="hljs language-kotlin">WriteStream.prototype._write = function(<span class="hljs-keyword">data</span>, encoding, cb) {  
  <span class="hljs-comment">// 文件还没有打开成功，则先监听 open 事件</span>
  <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">this</span>.fd !== <span class="hljs-string">'number'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.once(<span class="hljs-string">'open'</span>, function() {
      <span class="hljs-keyword">this</span>._write(<span class="hljs-keyword">data</span>, encoding, cb);
    });
  }
  <span class="hljs-comment">// 执行写操作,0代表从data的哪个位置开始写，这里是全部写入，所以是0，pos代表文件的位置  </span>
  <span class="hljs-keyword">this</span>[kFs].write(<span class="hljs-keyword">this</span>.fd, <span class="hljs-keyword">data</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">data</span>.length, <span class="hljs-keyword">this</span>.pos, (er, bytes) => { 
    <span class="hljs-comment">// 写成功的字节数</span>
    <span class="hljs-keyword">this</span>.bytesWritten += bytes; 
    <span class="hljs-comment">// 执行回调通知继续写</span>
    cb();  
  });  
};  
</code></pre>
<p>WriteStream 继承 Writable，但是 Writable 只实现了一些通用的逻辑，具体的写逻辑是子类的 _write 或 _writev 实现的。因为这两个函数的实现原理是类似的，所以这里只分析 _write，_write 就是根据用户传入数据的大小，不断调用 fs.write 往底层写入数据，直到写完成或者出错。接下来，我们看看关闭文件可写流的实现。</p>
<pre><code class="hljs language-kotlin">WriteStream.prototype.close = function(cb) {  
  <span class="hljs-comment">/* 
      如果 autoClose 是 false，说明流结束触发 finish 事件时，
      不会销毁流，见 WriteStream 初始化代码
      
      所以以这里需要监听 finish 事件，保证可写流结束时可以关闭文件描述符 
  */</span>  
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.autoClose) {  
    <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'finish'</span>, <span class="hljs-keyword">this</span>.destroy.bind(<span class="hljs-keyword">this</span>));  
  }  
  
  <span class="hljs-comment">// 结束流，会触发finish事件  </span>
  <span class="hljs-keyword">this</span>.end();  
};  
</code></pre>
<p>可写文件流和可读文件流的销毁机制不一样，默认情况下，在可读流读完文件内容后，Node.js 会自动销毁流（关闭文件描述符）。而在某些情况下，Node.js 是无法知道可写流是什么结束的，这需要我们显式地通知 Node.js。在下面的例子中，我们是不需要显式通知 Node.js 的。</p>
<pre><code class="hljs language-arduino"> fs.<span class="hljs-built_in">createReadStream</span>(<span class="hljs-string">'11111.md'</span>).<span class="hljs-built_in">pipe</span>(fs.<span class="hljs-built_in">createWriteStream</span>(<span class="hljs-string">'123.md'</span>));  
</code></pre>
<p>因为可读文件流在文件读完后会调用可写文件的 end 方法，从而关闭可读流和可写流对应的文件描述符。而在以下代码中情况就变得复杂。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">stream</span> = fs.createWriteStream(<span class="hljs-string">'123.md'</span>)<span class="hljs-comment">;  </span>
stream.write('hello')<span class="hljs-comment">;  </span>
// stream.close 或 stream.end()<span class="hljs-comment">;</span>
</code></pre>
<p>在默认情况，我们可以调用 end 或者 close 去通知 Node.js 流结束。但如果我们设置 autoClose 为 false，就只能调用 close 而不能调用 end，否则文件描述符就会泄漏。因为 end 只是结束写入数据，没有触发销毁流的逻辑，而 close 会触发销毁流的逻辑，我们看下面这个例子。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">'fs'</span>)<span class="hljs-comment">;  </span>
// autoClose 默认为 true
const <span class="hljs-attr">stream</span> = fs.createWriteStream(<span class="hljs-string">'123.md'</span>)<span class="hljs-comment">;  </span>
stream.end('hello')<span class="hljs-comment">;  </span>
setInterval(() => {}, 1000)<span class="hljs-comment">;  </span>
</code></pre>
<p>执行上面的代码，然后执行 lsof -p your_pid | grep 123.md 查看，我们发现没有 123.md 文件对应的文件描述符，即它被关闭了。接着修改一下代码，autoClose 改成 false：</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">'fs'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">stream</span> = fs.createWriteStream(<span class="hljs-string">'123.md'</span>, { autoClose: <span class="hljs-literal">false</span> })<span class="hljs-comment">;  </span>
stream.end('hello')<span class="hljs-comment">;  </span>
setInterval(() => {})<span class="hljs-comment">;  </span>
</code></pre>
<p>执行上面的代码，然后执行 lsof -p your_pid | grep 123.md 查看，我们发现 123.md 对应的文件没有被关闭，由此可见，当 autoClose 为 false 时，使用 end 是无法关闭文件描述符的，从而造成文件描述符泄露。接着把 end 改成 close 函数看看。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">'fs'</span>)<span class="hljs-comment">;  </span>
const <span class="hljs-attr">stream</span> = fs.createWriteStream(<span class="hljs-string">'123.md'</span>, {autoClose: <span class="hljs-literal">false</span>})
stream.close()<span class="hljs-comment">;  </span>
setInterval(() => {})<span class="hljs-comment">;  </span>
</code></pre>
<p>执行上面的代码，然后执行 lsof -p your_pid | grep 123.md 查看，我们发现没有 123.md 文件对应的文件描述符，即它被关闭了。</p>
<h2>总结</h2>
<p>文件系统是操作系统的核心子系统，主要负责文件管理的功能，这里的文件包括网络、普通文件等底层资源，Node.js 的文件系统正是对操作系统文件系统功能的封装，所以理解 Node.js 的文件系统有助于我们更好地使用 Node.js 和理解文件系统。这节课我们重点讲了同步 API、异步 API、Promise 化 API 和流式 API。</p>
<ol>
<li>同步 API：同步 API 原理比较简单，直接在线程中调用系统调用就行。它的问题在于会阻塞线程，所以我们一般尽量避免使用。</li>
<li>异步 API：异步 API 和同步 API 相似，都是对系统调用的简单调用，区别是异步 API 的实现中，是在 Libuv 的线程池中调用系统调用，这样不会导致主线程阻塞，一般推荐使用这类 API。</li>
<li>Promise 化 API：Promise 化 API 我们可以理解为异步 API 的 Promise 方式，它简化了我们代码的编写，使得我们可以方便地以同步的方式写异步代码。</li>
<li>流式 API：流式 API 相比前面三种 API 来说，好处在于流量控制，因为它会控制生产者和消费者的速度，减轻内存压力。</li>
</ol></div>
</body></html>