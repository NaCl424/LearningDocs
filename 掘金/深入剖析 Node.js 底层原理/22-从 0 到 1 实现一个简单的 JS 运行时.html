<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>从 0 到 1 实现一个简单的 JS 运行时</h1>
<p>随着 Node.js 的出现和不断发展，其他新的 JS 运行时也穷出不断，例如开源的 Deno、Just、Bun，还有各个大厂自研的 Worker。JS 运行时很多，我们不可能全部学习，幸好它们底层的技术有很多是相通的，所以我们只需要了解这些底层原理，往往就能触类旁通，让新 JS 运行时的学习变得更简单。</p>
<p>因此这一节课，我们就结合前面讲过的 Node.js 底层原理来介绍如何实现一个简单的 JS 运行时，完整代码可以参考 <a href="https://github.com/theanarkh/js-runtime-demo" target="_blank" rel="nofollow noopener noreferrer">js-runtime-demo</a> 这个仓库。</p>
<h2>JS 引擎</h2>
<p>在 JS 运行时中，必须要有一个 JS 引擎来解析和执行 JS，所以我们首先需要选择一个 JS 引擎。大部分的 JS 运行时都是基于 V8 的，所以我们这节课使用 V8 作为底层的 JS 引擎。有了 JS 引擎后，就可以通过它提供的一些 C++ API 来实现一个可以执行 JS 代码的程序，代码如下。</p>
<pre><code class="hljs language-arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;string.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;unistd.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/stat.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;fcntl.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sys/types.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"libplatform/libplatform.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"v8.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"core/env.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"core/core.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"core/util.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"core/loop.h"</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> v8;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Deer::Util;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Deer::Core;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Deer::Env;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>{
  <span class="hljs-comment">// 不需要输出缓冲，可以实时看到代码里的输出</span>
  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-literal">nullptr</span>, _IONBF, <span class="hljs-number">0</span>);
  <span class="hljs-built_in">setvbuf</span>(stderr, <span class="hljs-literal">nullptr</span>, _IONBF, <span class="hljs-number">0</span>);
  <span class="hljs-comment">// V8 的一些通用初始化逻辑</span>
  v8::V8::<span class="hljs-built_in">InitializeICUDefaultLocation</span>(argv[<span class="hljs-number">0</span>]);
  v8::V8::<span class="hljs-built_in">InitializeExternalStartupData</span>(argv[<span class="hljs-number">0</span>]);
  std::unique_ptr&#x3C;Platform> platform = platform::<span class="hljs-built_in">NewDefaultPlatform</span>();
  v8::V8::<span class="hljs-built_in">InitializePlatform</span>(platform.<span class="hljs-built_in">get</span>());
  v8::V8::<span class="hljs-built_in">Initialize</span>();
  <span class="hljs-comment">// 创建 Isolate 时传入的参数</span>
  Isolate::CreateParams create_params;
  create_params.array_buffer_allocator = ArrayBuffer::Allocator::<span class="hljs-built_in">NewDefaultAllocator</span>();
  <span class="hljs-comment">// 创建一个 Isolate，V8 的对象</span>
  Isolate* isolate = Isolate::<span class="hljs-built_in">New</span>(create_params);
  {
    <span class="hljs-function">Isolate::Scope <span class="hljs-title">isolate_scope</span><span class="hljs-params">(isolate)</span></span>;
    <span class="hljs-comment">// 创建一个 HandleScope，用于下面分配 Handle</span>
    <span class="hljs-function">HandleScope <span class="hljs-title">handle_scope</span><span class="hljs-params">(isolate)</span></span>;
    <span class="hljs-comment">// 创建一个对象模版，用于创建全局对象</span>
    Local&#x3C;ObjectTemplate> global = ObjectTemplate::<span class="hljs-built_in">New</span>(isolate);
    <span class="hljs-comment">// 创建一个上下文</span>
    Local&#x3C;Context> context = Context::<span class="hljs-built_in">New</span>(isolate, <span class="hljs-literal">nullptr</span>, global);
    <span class="hljs-comment">// 创建一个 Environment 保存运行时的一些公共数据</span>
    Environment * env = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Environment</span>(context);
    <span class="hljs-comment">// 保存命令行参数</span>
    env-><span class="hljs-built_in">setArgv</span>(argv);
    env-><span class="hljs-built_in">setArgc</span>(argc);
    <span class="hljs-function">Context::Scope <span class="hljs-title">context_scope</span><span class="hljs-params">(context)</span></span>;
    <span class="hljs-comment">//  创建一个自定义的对象，我们可以在这个对象里挂载一些 C++ 层实现的功能</span>
    Local&#x3C;Object> Deer = Object::<span class="hljs-built_in">New</span>(isolate);
    <span class="hljs-comment">// 注册 C++ 模块，把 C++ 层实现的功能挂载到 Deer 中</span>
    <span class="hljs-built_in">register_builtins</span>(isolate, Deer);
    <span class="hljs-comment">// 获取 JS 全局对象</span>
    Local&#x3C;Object> globalInstance = context-><span class="hljs-built_in">Global</span>();
    <span class="hljs-comment">// 设置全局变量 Deer，这样在 JS 里就可以直接访问 Deer 变量了</span>
    globalInstance-><span class="hljs-built_in">Set</span>(context, <span class="hljs-type">String</span>::<span class="hljs-built_in">NewFromUtf8Literal</span>(isolate, <span class="hljs-string">"Deer"</span>, NewStringType::kNormal), Deer);
    <span class="hljs-comment">// 设置全局属性 global 指向全局对象</span>
    globalInstance-><span class="hljs-built_in">Set</span>(context, <span class="hljs-type">String</span>::<span class="hljs-built_in">NewFromUtf8Literal</span>(isolate, <span class="hljs-string">"global"</span>, NewStringType::kNormal), globalInstance).<span class="hljs-built_in">Check</span>();
    {
      <span class="hljs-comment">// 初始化事件循环</span>
      Deer::Loop::<span class="hljs-built_in">init_event_system</span>(env-><span class="hljs-built_in">get_loop</span>());
      <span class="hljs-comment">// 打开文件</span>
      <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"Deer.js"</span>, <span class="hljs-number">0</span>, O_RDONLY);
      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> info;
      <span class="hljs-comment">// 取得文件信息</span>
      <span class="hljs-built_in">fstat</span>(fd, &#x26;info);
      <span class="hljs-comment">// 分配内存保存文件内容</span>
      <span class="hljs-type">char</span> *ptr = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(info.st_size + <span class="hljs-number">1</span>);
      <span class="hljs-built_in">read</span>(fd, (<span class="hljs-type">void</span> *)ptr, info.st_size);
      ptr[info.st_size] = <span class="hljs-string">'\0'</span>;
      <span class="hljs-comment">// 要执行的 JS 代码</span>
      Local&#x3C;<span class="hljs-type">String</span>> source = <span class="hljs-type">String</span>::<span class="hljs-built_in">NewFromUtf8</span>(isolate, ptr, NewStringType::kNormal, info.st_size).<span class="hljs-built_in">ToLocalChecked</span>();
      <span class="hljs-comment">// 编译</span>
      Local&#x3C;Script> script = Script::<span class="hljs-built_in">Compile</span>(context, source).<span class="hljs-built_in">ToLocalChecked</span>();
      <span class="hljs-comment">// 解析完应该没用了，释放内存</span>
      <span class="hljs-built_in">free</span>(ptr);
      <span class="hljs-comment">// 执行 JS</span>
      Local&#x3C;Value> result = script-><span class="hljs-built_in">Run</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();
      <span class="hljs-comment">// 进入事件循环</span>
      Deer::Loop::<span class="hljs-built_in">run_event_system</span>(env-><span class="hljs-built_in">get_loop</span>());
    }
  }

  isolate-><span class="hljs-built_in">Dispose</span>();
  v8::V8::<span class="hljs-built_in">Dispose</span>();
  <span class="hljs-keyword">delete</span> create_params.array_buffer_allocator;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>上面的代码大部分是使用 V8 时的标准流程，自定义的逻辑大概分为以下几个部分。</p>
<ol>
<li>创建 Environment 对象保存运行时的一些公共数据，可以给各个模块使用。</li>
<li>注册 C++ 模块，C++ 模块是实现 JS 运行时的地方，我们通过 C++ 实现功能，然后导出给 JS 层使用。</li>
<li>读取并执行一个入口 JS 模块，该 JS 模块用于进行一些初始化工作，比如初始化内置 JS 模块，然后执行用户的 JS 文件。</li>
<li>执行完用户 JS 模块后，接着初始化事件循环并进入事件循环，这样一个 JS 运行时就跑起来了，在这个事件循环不断地产生和消费任务，驱动着整个进程的运行。</li>
</ol>
<h2>拓展功能</h2>
<p>有 JS 引擎之后，我们可以使用 JS 语言本身提供的一些能力了，可以做的事情还是不多，因为 JS 引擎本身没有提供网络、文件和进程能力。幸运的是，JS 引擎提供了拓展能力，我们可以使用 JS 引擎提供的 API 拓展网络、文件这些功能。我们通过给全局对象注入属性的方式把 C++ 层到功能导出给 JS 使用。</p>
<pre><code class="hljs language-scss">Local&#x3C;<span class="hljs-selector-tag">Object</span>> Deer = <span class="hljs-selector-tag">Object</span>::New(isolate);
<span class="hljs-comment">// 注册 C++ 模块</span>
<span class="hljs-built_in">register_builtins</span>(isolate, Deer);
Local&#x3C;<span class="hljs-selector-tag">Object</span>> globalInstance = context-><span class="hljs-built_in">Global</span>();
<span class="hljs-comment">// 设置全局对象 Deer</span>
globalInstance-><span class="hljs-built_in">Set</span>(context, String::NewFromUtf8Literal(isolate, "Deer", NewStringType::kNormal), Deer);
</code></pre>
<p>上面的代码中首先创建一个对象 Deer，然后执行 register_builtins 往 Deer 对象中挂载各种属性，最后把 Deer 挂载到全局对象中，这样我们在 JS 层就可以使用 C++ 模块的功能了，下面以注册一个 console.log 函数为例。</p>
<pre><code class="hljs language-arduino"><span class="hljs-comment">// JS 调用 log 时就会执行 C++ 的 log 函数</span>
<span class="hljs-type">void</span> Deer::<span class="hljs-built_in">Console</span>::<span class="hljs-built_in">log</span>(V8_ARGS) {
    <span class="hljs-function">V8_ISOLATE
    <span class="hljs-type">String</span>::Utf8Value <span class="hljs-title">str</span><span class="hljs-params">(isolate, args[<span class="hljs-number">0</span>])</span></span>;
    <span class="hljs-built_in">Log</span>(*str);
}

<span class="hljs-type">void</span> Deer::<span class="hljs-built_in">Console</span>::<span class="hljs-built_in">Init</span>(Isolate* isolate, Local&#x3C;Object> target) {
  <span class="hljs-comment">// 创建一个对象模块</span>
  Local&#x3C;ObjectTemplate> console = ObjectTemplate::<span class="hljs-built_in">New</span>(isolate);
  <span class="hljs-comment">// 设置 log 属性</span>
  <span class="hljs-built_in">setMethod</span>(isolate, console, <span class="hljs-string">"log"</span>, Deer::<span class="hljs-built_in">Console</span>::log);
  <span class="hljs-comment">// 给目标对象挂载一个 console 属性，值是由上面的对象模版创建的对象</span>
  <span class="hljs-built_in">setObjectValue</span>(isolate, target, <span class="hljs-string">"console"</span>, console-><span class="hljs-built_in">NewInstance</span>(isolate-><span class="hljs-built_in">GetCurrentContext</span>()).<span class="hljs-built_in">ToLocalChecked</span>());
}

<span class="hljs-type">void</span> Deer::Core::<span class="hljs-built_in">register_builtins</span>(Isolate * isolate, Local&#x3C;Object> Deer) {
    <span class="hljs-comment">// 创建一个新的对象</span>
    Local&#x3C;Object> target = Object::<span class="hljs-built_in">New</span>(isolate);
    <span class="hljs-comment">// 把 Console 模块的功能挂载到上面创建的对象中</span>
    <span class="hljs-built_in">Console</span>::<span class="hljs-built_in">Init</span>(isolate, target);
    <span class="hljs-comment">// 给 Deer 挂载一个 buildin 属性，值为上面创建的对象</span>
    <span class="hljs-built_in">setObjectValue</span>(isolate, Deer, <span class="hljs-string">"buildin"</span>, target);
}
</code></pre>
<p>register_builtins 中也同样创建了一个新的对象 target，然后往 target 注册了一个 console 属性，console 属性的值也是一个对象，里面有一个 log 属性，最后再把 target 对象挂载到 Deer 对象中，属性名是 buildin，执行完毕后，结构如下。</p>
<pre><code class="hljs language-javascript">{
    <span class="hljs-string">"Deer"</span>: {
        <span class="hljs-string">"buildin"</span>: {
            <span class="hljs-string">"console"</span>: {
                <span class="hljs-string">"log"</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {}
            }
        }
    }
}
</code></pre>
<p>当我们在 JS 里执行 Deer.buildin.console.log 时就会执行 C++ 层的 log 函数，这样我们就完成了 C++ 代码和 JS 代码的交互。</p>
<h2>事件循环</h2>
<p>我们通过 JS 引擎实现了解析和执行 JS 代码，也通过 JS 引擎的拓展能力实现了网络、文件等功能，但是这些只是代码层面的交互，还有一个非常重要的事情是执行架构，因为 JS 运行时不可能一直执行代码，那么不执行代码时应该怎么处理呢？这里就需要一个阻塞 / 唤醒的机制，没有任务处理时 JS 运行时就处于阻塞状态，有任务到来时 JS 运行时就被唤醒继续执行任务。这个机制通常是通过操作系统的事件驱动模块实现的，下面我们以 MaxOS 下的 kqueue 为例进行讲解。</p>
<p>首先定义一个事件循环的核心结构体。</p>
<pre><code class="hljs language-ini">struct event_loop
{
   int <span class="hljs-attr">event_fd</span> = -<span class="hljs-number">1</span><span class="hljs-comment">;</span>
   int <span class="hljs-attr">event_fd_count</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
   std::list&#x3C;io_watcher*> io_watchers<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>event_fd 是 kqueue API 返回的 fd，这个 fd 在整个事件循环周期都会用到，io_watchers 是 IO 观察者，它是事件驱动模块最核心的数据结构，本质上是对 fd、感兴趣的事件和回调的封装。</p>
<p>有了数据结构之后，我们再来看看如何使用。JS 运行时初始化时会首先执行 init_event_system 初始化事件循环相关的数据结构。</p>
<pre><code class="hljs language-arduino"><span class="hljs-type">void</span> Deer::Loop::<span class="hljs-built_in">init_event_system</span>(<span class="hljs-keyword">struct</span> event_loop* loop) {
    loop->event_fd = <span class="hljs-built_in">kqueue</span>();
}
</code></pre>
<p>init_event_system 里通过 kqueue 创建了一个实例，下面会讲到它的用处。初始化事件循环相关的数据结构完毕后，接着执行内置 JS 和用户自定义的代码注册一些任务到事件循环中，最终进入事件循环中，代码如下。</p>
<pre><code class="hljs language-arduino"><span class="hljs-type">void</span> Deer::Loop::<span class="hljs-built_in">run_event_system</span>(<span class="hljs-keyword">struct</span> event_loop* loop) {
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
        <span class="hljs-type">int</span> event = <span class="hljs-built_in">poll</span>(loop);
        <span class="hljs-keyword">if</span> (event == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">break</span>;
        }
    }
};
</code></pre>
<p>run_event_system 实现了简单的事件循环，run_event_system 中不断调用 poll 函数注册事件和判断是否有事件触发，返回值为当前注册的 fd 个数，为 0 则说明可以退出事件循环了，接着看一下 poll 的实现。</p>
<pre><code class="hljs language-ini">int Deer::Loop::poll(struct event_loop* loop) {
    struct kevent events<span class="hljs-section">[MAX_EVENT_SIZE]</span><span class="hljs-comment">;</span>
    struct kevent ready_events<span class="hljs-section">[MAX_EVENT_SIZE]</span><span class="hljs-comment">;</span>
    int <span class="hljs-attr">nevent</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    // 遍历 IO 观察者，把它们感兴趣的事件注册到事件驱动模块
    for (auto watcher: loop->io_watchers) {
        // 当前对可读事件感兴趣并且还没有注册到操作系统则注册
        if ((watcher->event &#x26; POLL_IN) == 0 &#x26;&#x26; (watcher->pevent &#x26; POLL_IN) != 0) {
            EV_SET(&#x26;events<span class="hljs-section">[nevent++]</span>, watcher->fd, EVFILT_READ, EV_ADD, 0, 0, (void *)watcher)<span class="hljs-comment">;</span>
        }
        if ((watcher->event &#x26; POLL_OUT) == 0 &#x26;&#x26; (watcher->pevent &#x26; POLL_OUT) != 0) {
            EV_SET(&#x26;events<span class="hljs-section">[nevent++]</span>, watcher->fd, EVFILT_WRITE, EV_ADD, 0, 0, (void *)watcher)<span class="hljs-comment">;</span>
        }
        watcher-><span class="hljs-attr">event</span> = watcher->pevent<span class="hljs-comment">;</span>
    }
    struct timespec *<span class="hljs-attr">timeout</span> = nullptr<span class="hljs-comment">;</span>
    loop->event_fd_count += nevent<span class="hljs-comment">;</span>
    if (loop-><span class="hljs-attr">event_fd_count</span> == <span class="hljs-number">0</span>) {
        return 0<span class="hljs-comment">;</span>
    }
    // 注册并等待事件触发
    int <span class="hljs-attr">n</span> = kevent(loop->event_fd, events, nevent, ready_events, MAX_EVENT_SIZE, timeout)<span class="hljs-comment">;</span>
    if (n > 0) {
        // 遍历触发的事件
        for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &#x3C; n; i++) {</span>
            io_watcher* <span class="hljs-attr">watcher</span> = static_cast&#x3C;io_watcher *>(ready_events[i].udata)<span class="hljs-comment">;</span>
            int <span class="hljs-attr">event</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
            // 事件触发了但是用户对该事件已经不感兴趣了，删除它
            if (watcher-><span class="hljs-attr">pevent</span> == <span class="hljs-number">0</span>) {
                struct kevent event<span class="hljs-section">[1]</span><span class="hljs-comment">;</span>
                loop->event_fd_count--<span class="hljs-comment">;</span>
                EV_SET(&#x26;event<span class="hljs-section">[0]</span>, watcher->fd, ready_events<span class="hljs-section">[i]</span>.filter, EV_DELETE, 0, 0, nullptr)<span class="hljs-comment">;</span>
                kevent(loop->event_fd, event, 1, nullptr, 0, nullptr)<span class="hljs-comment">;</span>
                watcher->handler(watcher, 0)<span class="hljs-comment">;</span>
                continue<span class="hljs-comment">;</span>
            } else if (ready_events<span class="hljs-section">[i]</span>.<span class="hljs-attr">filter</span> == EVFILT_READ) { // 可读事件触发
                // 判断当前用户对事件是否还感兴趣
                if (watcher->pevent &#x26; POLL_IN) {
                    watcher->handler(watcher, POLL_IN)<span class="hljs-comment">;</span>
                } else {
                    struct kevent event<span class="hljs-section">[1]</span><span class="hljs-comment">;</span>
                    loop->event_fd_count--<span class="hljs-comment">;</span>
                    EV_SET(&#x26;event<span class="hljs-section">[0]</span>, watcher->fd, EVFILT_READ, EV_DELETE, 0, 0, nullptr)<span class="hljs-comment">;</span>
                    kevent(loop->event_fd, event, 1, nullptr, 0, nullptr)<span class="hljs-comment">;</span>
                }
            } else if (ready_events<span class="hljs-section">[i]</span>.<span class="hljs-attr">filter</span> == EVFILT_WRITE) { // 同上
                if (watcher->pevent &#x26; POLL_OUT) {
                    watcher->handler(watcher, POLL_OUT)<span class="hljs-comment">;</span>
                } else {
                    struct kevent event<span class="hljs-section">[1]</span><span class="hljs-comment">;</span>
                    loop->event_fd_count--<span class="hljs-comment">;</span>
                    EV_SET(&#x26;event<span class="hljs-section">[0]</span>, watcher->fd, EVFILT_WRITE, EV_DELETE, 0, 0, nullptr)<span class="hljs-comment">;</span>
                    kevent(loop->event_fd, event, 1, nullptr, 0, nullptr)<span class="hljs-comment">;</span>
                }
            }
        }
    }
    return loop->event_fd_count<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>poll 函数本质上是对操作系统事件驱动模块的封装，现在大多数主流的操作系统都有提供这个能力，这里是使用 MacOS 的 kqueue。我们可以通过 kevent API 注册事件和等待事件的触发，其中 struct kevent 用于管理一个 fd 的事件订阅和发布，事件触发后，kevent 会返回一个 struct kevent 结构体数组，每个 struct kevent 中记录了哪些 fd 的哪些事件触发了，我们通过遍历结构体数组就可以拿到具体的事件信息。同时，因为我们可以通过 struct kevent 结构体中的 udata 字段记录对应的上下文，所以事件触发后通过 struct kevent 我们可以拿到对应的 IO 观察者，执行对应的回调。</p>
<p>JS 运行时就是通过 kevent 控制了整个生命周期，比如注册事件、没有事件时阻塞等待事件、事件触发后被唤醒并处理事件等等，直到没有订阅者和任务时进程退出。当然这并不是一个无限循环，我们可以通过额外的手段控制着进程的生命周期，比如通过一个 stop 函数强制退出进程。</p>
<h2>模块加载器</h2>
<p>到这里，我们就基本实现了一个 JS 运行时，但是还有一个重要的部分需要实现，那就是模块加载器，内置的功能可以通过挂载到全局变量的方式来实现，这样用户就不需要通过模块加载器的方式来使用拓展功能了，但用户的 JS 依然需要一个模块加载器，否则全部 JS 代码就只能写到一个 JS 文件里了，这并不是良好的代码组织方式。接下来，我们一起看看如何实现一个模块加载器。</p>
<pre><code class="hljs language-scss">void Deer::Loader::Compile(V8_ARGS) {
    V8_ISOLATE
    V8_CONTEXT
    String::Utf8Value filename(isolate, args[<span class="hljs-number">0</span>].As&#x3C;String>());
    <span class="hljs-comment">// 打开需要加载的模块</span>
    int fd = <span class="hljs-built_in">open</span>(*filename, <span class="hljs-number">0</span> , O_RDONLY);
    std::string content;
    char buffer<span class="hljs-selector-attr">[4096]</span>;
    while (<span class="hljs-number">1</span>)
    {
      <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">4096</span>);
      <span class="hljs-comment">// 不断读取里面的数据</span>
      int ret = <span class="hljs-built_in">read</span>(fd, buffer, <span class="hljs-number">4096</span>);
      <span class="hljs-comment">// 读出错</span>
      if (ret == -<span class="hljs-number">1</span>) {
        return args<span class="hljs-selector-class">.GetReturnValue</span>()<span class="hljs-selector-class">.Set</span>(newStringToLcal(isolate, "read file error"));
      }
      <span class="hljs-comment">// 读完毕</span>
      if (ret == <span class="hljs-number">0</span>) {
        break;
      }
      <span class="hljs-comment">// 记录读取到的模块内容</span>
      <span class="hljs-attribute">content</span><span class="hljs-selector-class">.append</span>(buffer, ret);
    }
    <span class="hljs-built_in">close</span>(fd);
    <span class="hljs-comment">// 编译模块的代码，返回一个函数给 JS 层，格式如下</span>
    <span class="hljs-comment">/*
        function(require, exports, module) {
            // 模块代码
        }
    */</span>
    ScriptCompiler::Source script_source(newStringToLcal(isolate, content.c_str()));
    Local&#x3C;String> params<span class="hljs-selector-attr">[]</span> = {
      <span class="hljs-built_in">newStringToLcal</span>(isolate, "require"),
      <span class="hljs-built_in">newStringToLcal</span>(isolate, "exports"),
      <span class="hljs-built_in">newStringToLcal</span>(isolate, "module"),
    };
    MaybeLocal&#x3C;Function> fun = ScriptCompiler::CompileFunction(context, &#x26;script_source, <span class="hljs-number">3</span>, params, <span class="hljs-number">0</span>, nullptr);
    if (fun.IsEmpty()) {
      args<span class="hljs-selector-class">.GetReturnValue</span>()<span class="hljs-selector-class">.Set</span>(Undefined(isolate));
    } else {
      args<span class="hljs-selector-class">.GetReturnValue</span>()<span class="hljs-selector-class">.Set</span>(fun.ToLocalChecked());
    }
}
</code></pre>
<p>Compile 函数首先根据模块名读取模块的内容，然后通过 V8 的 CompileFunction 函数把代码编译成一个函数，这个函数的形参包括 require、exports 和 module。接着看 JS 层是如何使用这个模块加载器的。</p>
<pre><code class="hljs language-ini">const {
    loader,
} = Deer.buildin<span class="hljs-comment">;</span>

class Module {
    constructor(filename) {
        <span class="hljs-attr">this.filename</span> = filename<span class="hljs-comment">;</span>
        <span class="hljs-attr">this.exports</span> = {}<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>

<span class="hljs-attr">module.exports</span> = Module<span class="hljs-comment">;</span>
</code></pre>
<p>Module 对象用于管理一个 JS 模块的加载，然后提供一个工具函数 load 用于加载 JS 模块。</p>
<pre><code class="hljs language-arduino"> <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-title">load</span><span class="hljs-params">(filename, ...args)</span> </span>{
    <span class="hljs-comment">// 已经有缓存则直接返回</span>
    <span class="hljs-keyword">if</span> (map[filename]) {
        <span class="hljs-keyword">return</span> map[filename];
    }
    <span class="hljs-comment">// 创建一个 Module 对象并执行它的 load 函数</span>
    <span class="hljs-type">const</span> <span class="hljs-keyword">module</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Module</span>(filename, ...args);
    <span class="hljs-keyword">return</span> (map[filename] = <span class="hljs-keyword">module</span>.<span class="hljs-built_in">load</span>());
}
</code></pre>
<p>load 函数是对 Module 的封装，主要是创建一个 Module 对象表示一个 JS 模块的加载，然后调用 Module 对象的 load 函数进行真正的加载工作。</p>
<pre><code class="hljs language-kotlin"> load() {
    <span class="hljs-comment">// 调用 C++ 层函数，返回一个函数</span>
    <span class="hljs-keyword">const</span> result = loader.compile(<span class="hljs-keyword">this</span>.filename);
    <span class="hljs-comment">// 传入实参并执行 C++ 层返回的函数，即执行自定义的 JS 的代码</span>
    result.call(<span class="hljs-keyword">this</span>, Module.load, <span class="hljs-keyword">this</span>.exports, <span class="hljs-keyword">this</span>);
    <span class="hljs-comment">// JS 代码会把需要导出的功能设置到 exports 对象中，模块加载者就可以使用被加载模块所导出的功能</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.exports;
}
</code></pre>
<p>load 是对刚才介绍的 C++ Compile 函数的封装，主要是调用 C++ 的函数拿到一个 函数并在 JS 层执行该函数拿到被加载模块所导出的内容。</p>
<p>至此，一个 JS 运行时的核心部分就介绍完毕了，剩下的代码就取决于我们要实现什么功能，比如这节课的 js-runtime-demo 运行时实现了一个简单的 TCP Server，可以处理连接、进行数据读写。</p>
<h2>总结</h2>
<p>这节课，我们介绍了从 0 到 1 实现一个简单的 JS 运行时的过程，包括如下几个比较核心的部分。</p>
<ol>
<li>选择 V8 作为底层的 JS 引擎来解析和执行 JS，然后我们就可以完成 JS 、C 和 C++ 代码的交互，为后面的具体功能实现奠定基础。</li>
<li>事件循环是 JS 运行时的核心，它支撑着整个 JS 运行时的运行，本质上是对操作系统事件驱动模块的封装，事件驱动模块提供了订阅 / 发布机制。我们首先实现了 IO 观察者，然后把 IO 观察者注册到事件驱动模块中，如果没有事件触发，则进程会处于阻塞状态。当事件触发时操作系统就会通知我们。基于事件驱动，我们还可以衍生出其他的功能，比如 Node.js 里的 check、timer 阶段等。</li>
<li>没有模块加载器，我们的代码就只能写到一个大文件里，这显然不符合现实，实现一个模块加载器本质上是对文件操作和 V8 知识的了解，模块加载器首先通过文件操作把模块中的代码读进内存，然后再通过 V8 API 编译执行。</li>
</ol>
<p>实现了上面几个部分后，一个 JS 运行时的架子就实现出来了。接下来就需要我们对 V8、操作系统和网络深入学习，来实现更多、更复杂的功能了。</p>
<p>最后我还想多说几句，其实通过整个实现过程你也能看到，写一个JS 运行时并非遥不可及，但的确需要投入比较多的时间和精力来学习、思考和琢磨。并且，随着实现功能的不断增加，我们发现这不仅是个脑力活，还是个体力活。</p>
<p>幸运的是，我们很多时候并不需要自己重新造一个轮子，但也只有理解 JS 运行时的技术基础和实现原理，我们才能更好地使用它，更快地解决所遇到问题，更方便、快捷地掌握其他 JS 运行时，以及深入学习操作系统、网络等基础知识。</p></div>
</body></html>