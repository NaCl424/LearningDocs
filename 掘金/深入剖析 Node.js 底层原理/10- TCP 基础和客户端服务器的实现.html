<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1> TCP 基础和客户端 / 服务器的实现</h1>
<p>从这一节课开始，我们将深入学习 Node.js 各个核心模块的实现。今天讲解的是 TCP 模块，TCP 是 Node.js 中非常核心的模块，HTTP、TLS 和 HTTPS 等模块都是基于 TCP 模块实现的。这节课，我们先讲讲 TCP 协议的核心概念，了解了核心概念后，接着讲解如何在网络编程中使用 TCP，有了这些底层的基础后，最后深入讲解 Node.js 中 TCP 服务器和客户端的实现。</p>
<h1>TCP 协议是什么？</h1>
<p>TCP 是一种面向连接的、可靠的、基于字节流的传输层全双工通信协议，因此，它有 4 个特点：<strong>面向连接、可靠、流式、全双工</strong>。下面我们详细讲解这些特性。</p>
<h2><strong>面向连接的本质</strong></h2>
<p>TCP 中的连接是一个虚拟的连接，本质上是主机在内存里记录了对端的信息，我们可以将<strong>连接</strong>理解为一个通信的凭证。如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d5a0dc99bc940c98622baa8455c7afc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>那么如何建立连接呢？</strong> TCP 的连接是通过三次握手建立的。</p>
<ol>
<li>服务器首先需要监听一个端口。</li>
<li>客户端主动往服务器监听的端口发起一个 syn 包（<strong>第一次握手</strong>）。</li>
<li>当服务器所在操作系统收到一个 syn 包时，会先根据 syn 包里的目的 IP 和端口找到对应的监听 socket，如果找不到则回复 rst 包，如果找到则发送 ack 给客户端（<strong>第二次握手</strong>），并新建一个通信 socket 并插入到监听 socket 的连接中队列（具体的细节会随着不同版本的操作系统而变化。比如连接中队列和连接完成队列是一条队列还是两条队列，再比如是否使用了 syn cookie 技术来防止 syn flood 攻击，如果使用了，收到 syn 包的时候就不会创建 socket，而是收到第三次握手的包时再创建）。</li>
<li>客户端收到服务器的 ack 后，再次发送 ack 给服务器，客户端就完成三次握手进入连接建立状态了。</li>
<li>当服务器所在操作系统收到客户端的 ack 时（<strong>第三次握手</strong>），处于连接中队列的 socket 就会被移到连接完成队列中。</li>
<li>当操作系统完成了一个 TCP 连接，操作系统就会通知相应的进程，进程从连接完成队列中摘下一个已完成连接的 socket 结点，然后生成一个新的 fd，后续就可以在该 fd 上和对端通信。具体的流程如下图所示。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88b0d7f8918240a69081e1fb07dbf593~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>完成三次握手后，客户端和服务器就可以进行数据通信了</strong> <strong>。</strong> 操作系统收到数据包和收到 syn 包的流程不一样，操作系统会根据报文中的 IP 和端口找到处理该报文的通信 socket（而不是监听 socket），然后把数据包（操作系统实现中是一个 skb 结构体）挂到该通信 socket 的数据队列中，如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88aaaba9e06840b98071892089de6235~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>当应用层调用 read 读取该 socket 的数据时，操作系统会根据应用层所需大小，从一个或多个 skb 中返回对应的字节数。同样，写也是类似的流程，当应用层往 socket 写入数据时，操作系统不一定会立刻发送出去，而是会保存到写缓冲区中，然后根据复杂的 TCP 算法发送。</p>
<p><strong>当两端完成通信后需要关闭连接，否则会浪费内存。</strong> TCP 通过四次挥手实现连接的断开，第一次挥手可以由任意一端发起。前面讲过 TCP 是全双工的，所以除了通过四次挥手完成整个 TCP 连接的断开外，也可以实现半断开，比如客户端关闭写端表示不会再发送数据，但是仍然可以读取来自对端发送端数据。四次挥手的流程如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d714c86c2eff4036958acc1194bc28ab~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>可靠</h2>
<p>TCP 发送数据时会先缓存一份到已发送待确认队列中，并启动一个超时重传计时器，如果一定时间内没有收到对端的确认 ack，则触发重传机制，直到收到 ack 或者重传次数达到阈值。以下是某个版本的操作系统关于重传次数达到阈值时的逻辑。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 重传次数达到阈值</span>
if (sk->retransmits > TCP_RETR2) 
{
    <span class="hljs-comment">// 设置错误码，通知进程</span>
    sk->err = ETIMEDOUT;
    sk-><span class="hljs-built_in">error_report</span>(sk);
    <span class="hljs-comment">// 删除重传定时器</span>
    <span class="hljs-built_in">del_timer</span>(&#x26;sk->retransmit_timer);
    <span class="hljs-comment">// 修改 socket 为关闭状态</span>
    <span class="hljs-built_in">tcp_set_state</span>(sk, TCP_CLOSE);
}
</code></pre>
<h2><strong>流式协议的本质</strong></h2>
<p>建立连接后，应用层就可以调用发送接口源源不断地发送数据。通常情况下，并不是每次调用发送接口，操作系统就直接把数据发送出去，这些数据的发送是由操作系统按照一定的算法去发送的。对操作系统来说，它看到的是字节流，它会按照 TCP 算法打包出一个个包发送到对端，所以当对端收到数据后，需要处理好数据边界的问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3690afef8550476a83ab588aad1ff0cb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>从上图中可以看到，假设应用层发送了两个 HTTP 请求，操作系统在打包数据发送时可能的场景是第一个包里包括了 HTTP 请求 1 的全部数据和部分请求 2 的数据，所以当对端收到数据并进行解析时，就需要根据 HTTP 协议准确地解析出第一个 HTTP 请求对应的数据。</p>
<p>因为 TCP 的流式协议，所以基于 TCP 的应用层通常需要定义一个应用层协议，然后按照应用层协议实现对应的解析器，这样才能完成有效的数据通信，比如常用的 HTTP 协议。对比来说 UDP 是面向数据包的协议，当应用层把数据传递给 UDP 时，操作系统会直接打包发送出去（如果数据字节大小超过阈值则会报错）。</p>
<h2><strong>全双工的本质</strong></h2>
<p>刚才提到 TCP 是全双工的，全双工就是通信的两端都有一个发送队列和接收队列，可以同时发送和接收，互不影响。另外也可以选择关闭读端或者写端。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/278f026551e04499baccf6e4f6314a93~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h1>TCP 协议的使用</h1>
<p>了解了 TCP 的基础概念后，来看看如何使用 TCP 协议进行通信。TCP / IP 协议是由操作系统内核实现的，当我们需要使用 TCP 协议进行通信时，可以通过操作系统提供的系统调用来完成。首先看如何创建一个服务器（伪代码）</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 创建一个 socket（socket 表示通信的一端），但是还没有绑定地址信息</span>
const fd = <span class="hljs-built_in">socket</span>();  
<span class="hljs-comment">// 绑定到具体的 IP 和端口，如果没有显式配置，则操作系统自己决定</span>
<span class="hljs-built_in">bind</span>(fd, ip, port);  
<span class="hljs-comment">// 修改 socket 为监听状态，就可以接收 TCP 连接了</span>
<span class="hljs-built_in">listen</span>(fd);  
<span class="hljs-comment">// 等待完成三次握手的连接，如果 fd 是阻塞的，则进程被阻塞</span>
const acceptedFd = <span class="hljs-built_in">accept</span>(fd);  
<span class="hljs-comment">// 当收到一个 TCP 连接时，accept 会返回对应的连接，通过 fd 表示，然后进行数据通信</span>
<span class="hljs-built_in">read</span>(acceptedFd);  
<span class="hljs-built_in">write</span>(acceptedFd, 'hello');  
</code></pre>
<p>我们看一下这几个函数的作用。</p>
<ol>
<li>socket：socket 函数用于从操作系统申请一个 socket 结构体，该结构体用于表示和对端通信的一个连接，但是目前它还没有绑定到具体的通信地址。因为 Linux 中万物皆文件，所以最后操作系统会返回一个 fd，fd 在操作系统中类似数据库的 id，操作系统底层维护了 fd 和对应的资源关系，比如网络、文件、管道等。后续调用操作系统的接口时，传入这个 fd 和相关的参数，操作系统就会根据 fd 操作对应的资源。在 TCP 中，socket 代表了一个虚拟的连接，它由源 IP、源端口、目的 IP和目的端口组成并唯一标识。</li>
<li>bind：bind 函数用于给 fd 对应的 socket 设置本端对应的地址（IP 和端口），对于服务器来说，通常需要显式调用 bind，这样客户端才知道通过哪个端口和服务器通信，如果没有显式设置，那么操作系统会选择一个随机的端口，然后再通过其他 API 获取操作系统为我们选择的端口。</li>
<li>listen：listen 函数用于修改 fd 对应的 socket 的状态为监听状态。只有监听状态的 socket 才可以接受客户端的连接。socket 可以分为两种，一种是监听型的，一种是通信型的，监听型的 socket 只负责接收连接，通信型的 socket 负责和客户端通信。</li>
<li>accept：accept 用于从操作系统中获取一个已经完成三次握手的连接，该函数默认会阻塞进程，直到有连接到来并完成三次握手。我们也可以调用其他函数修改 socket 为非阻塞模式，这样调用 accept 时，如果没有已完成三次握手的连接，操作系统不会阻塞进程，而是会返回一个错误码。</li>
<li>read：当操作系统收到对端发过来的数据时，会先把它保存到 socket 的接收缓冲区。当应用层调用 read 时，就会把队列中数据返回给应用层。</li>
<li>write：write 用于给服务器发送数据，不过通常并不是直接发送。因为这些数据只是保存到 socket 的发送缓冲区，底层会根据 TCP 协议决定什么时候发送数据。</li>
</ol>
<p>执行完以上代码，就完成了一个服务器的启动，操作系统中的关系图如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d93891dcf094117a2db17f4f83152bb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>接下来看一下如何创建一个 TCP 客户端。</p>
<pre><code class="hljs language-scss">const fd = <span class="hljs-built_in">socket</span>(); 
<span class="hljs-comment">// 绑定到具体的 IP 和端口，如果没有显式配置，则操作系统自己决定</span>
<span class="hljs-built_in">bind</span>(fd, ip, port);  
<span class="hljs-comment">// 发起一个连接，IP 和 port 表示对端的地址，connect 默认会引起进程阻塞</span>
const connectRet = <span class="hljs-built_in">connect</span>(fd, ip, port);  
<span class="hljs-comment">// 到这说明连接结束，如果 connectRet 为 0 说明成功，可以进行数据读写</span>
<span class="hljs-built_in">write</span>(fd, 'hello');  
<span class="hljs-built_in">read</span>(fd);  
</code></pre>
<p>客户端比服务器稍微简单一点，看看这几个函数的作用。</p>
<ol>
<li>
<p>socket：和服务器一样，客户端也需要申请一个 socket 用于和服务器通信。</p>
</li>
<li>
<p>bind：bind 函数用于给 fd 对应的 socket 设置本端对应的地址（IP 和端口）。和服务器不一样的是，客户端通常不需要调用 bind，操作系统会决定使用哪个地址作为客户端地址。</p>
</li>
<li>
<p>connect：connect 用于绑定服务器地址。当进程调用 connect 时，操作系统会执行三次握手，默认情况操作系统会阻塞进程，直到连接有结果，连接结果会通过 connect 返回值告诉调用方。如果三次握手成功，我们就可以开始读取 / 发送数据了。同样，我们也可以设置 socket 为非阻塞模式。这样发起连接时，操作系统会先返回一个错误码，我们可以借助事件驱动模块订阅 socket 的可写事件，等待可写事件触发时再通过其他系统调用函数来获取连接结果。</p>
</li>
</ol>
<p>以上是 TCP 协议在底层的一些基础知识，Node.js 的 TCP 模块本质上是基于这些底层能力，再结合 V8 实现的。接下来，我们就来看看 Node.js 中是如何实现 TCP 模块的。</p>
<h1>Node.js TCP 服务器的实现</h1>
<h2>启动服务器</h2>
<p>在 Node.js 中，我们通常使用以下方式创建一个服务器。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 创建一个 TCP Server</span>
<span class="hljs-keyword">const</span> server = net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">socket</span>) =></span> {
  <span class="hljs-comment">// 处理连接</span>
});

<span class="hljs-comment">// 监听端口，启动服务器</span>
server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>);
</code></pre>
<p>使用 net.createServer 可以创建一个服务器，然后拿到一个 Server 对象，接着调用 Server 对象的 listen 函数就可以启动一个 TCP 服务器了。下面来看一下具体的实现。</p>
<pre><code class="hljs language-kotlin">function createServer(options, connectionListener) {  
  <span class="hljs-keyword">return</span> new Server(options, connectionListener);  
}  
  
function Server(options, connectionListener) {  
  EventEmitter.call(<span class="hljs-keyword">this</span>);  
  <span class="hljs-comment">// 服务器收到的连接数，可以通过 maxConnections 限制并发连接数  </span>
  <span class="hljs-keyword">this</span>._connections = <span class="hljs-number">0</span>;  
  <span class="hljs-comment">// C++ 层的对象，真正实现 TCP 功能的地方</span>
  <span class="hljs-keyword">this</span>._handle = <span class="hljs-literal">null</span>;  
  <span class="hljs-comment">// 服务器下的连接是否允许半关闭，下一节课详细讲解  </span>
  <span class="hljs-keyword">this</span>.allowHalfOpen = options.allowHalfOpen || <span class="hljs-literal">false</span>;  
  <span class="hljs-comment">// 有连接时是否注册可读事件，如果该 socket 是交给其他进程处理的话可以设置为 true </span>
  <span class="hljs-keyword">this</span>.pauseOnConnect = !!options.pauseOnConnect;  
}  
</code></pre>
<p>createServer 返回的是一个一般的 JS 对象，继续看一下 listen 函数的逻辑，listen 函数逻辑很繁琐，但是原理大致是一样的，所以我们只讲解常用的情况。</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">Server.prototype.listen</span> = function(...args) {  
  /*
    处理入参，listen 可以接收很多种格式的参数，
    假设我们这里只传了 8888 端口号
  */
    const <span class="hljs-attr">normalized</span> = normalizeArgs(args)<span class="hljs-comment">;  </span>
    //  <span class="hljs-attr">normalized</span> = [{port: <span class="hljs-number">8888</span>}, null]<span class="hljs-comment">;  </span>
    const <span class="hljs-attr">options</span> = normalized[<span class="hljs-number">0</span>]<span class="hljs-comment">; </span>
    // 监听成功后的回调 
    const <span class="hljs-attr">cb</span> = normalized[<span class="hljs-number">1</span>]<span class="hljs-comment">;  </span>
    
    // listen 成功后执行的回调  
    if (cb !== null) {
        this.once('listening', cb)<span class="hljs-comment">;</span>
    }
    listenIncluster(this, 
                    null, 
                    options.port | 0, 
                    4,      
                    ...)<span class="hljs-comment">; </span>
    return this<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
</code></pre>
<p>listen 处理了入参后，接着调用了 listenIncluster。</p>
<pre><code class="hljs language-ini">function listenIncluster(server, 
                         address, 
                         port, 
                         addressType,      
                         backlog, 
                         fd, 
                         exclusive) {  
  <span class="hljs-attr">exclusive</span> = !!exclusive<span class="hljs-comment">;  </span>
  if (<span class="hljs-attr">cluster</span> === null) cluster = require(<span class="hljs-string">'cluster'</span>)<span class="hljs-comment">; </span>
  if (cluster.isMaster || exclusive) {  
    server._listen2(address, port, addressType, backlog, fd)<span class="hljs-comment">;</span>
    return<span class="hljs-comment">;  </span>
  }  
}  
</code></pre>
<p>我们只分析在主进程创建服务器的情况，子进程中创建服务器的逻辑在 Cluster 模块分析。listenIncluster 中执行了 _listen2，_listen2 对应的函数是 setupListenHandle。</p>
<pre><code class="hljs language-kotlin">function setupListenHandle(address, port, addressType, backlog, fd) {  
    <span class="hljs-comment">// 通过 C++ 层导出的 API 创建一个对象，该对象关联了 C++ 层的 TCPWrap 对象</span>
    <span class="hljs-keyword">this</span>._handle = new TCP(TCPConstants.SERVER);
    <span class="hljs-comment">// 创建 socket 并绑定地址到 socket 中</span>
    <span class="hljs-keyword">this</span>._handle.bind(address, port); 
    <span class="hljs-comment">// 有完成三次握手的连接时执行的回调  </span>
    <span class="hljs-keyword">this</span>._handle.onconnection = onconnection;  
    <span class="hljs-comment">// 互相关联</span>
    <span class="hljs-keyword">this</span>._handle[owner_symbol] = <span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// 执行 C++ 层 listen  </span>
    <span class="hljs-keyword">this</span>._handle.listen(backlog || <span class="hljs-number">511</span>);  
    <span class="hljs-comment">// 触发 listen 回调  </span>
    nextTick(<span class="hljs-keyword">this</span>[async_id_symbol], emitListeningNT, <span class="hljs-keyword">this</span>);  
}  
</code></pre>
<p>setupListenHandle 的逻辑如下。</p>
<ol>
<li>调用 new TCP 创建一个 handle（new TCP 对象关联了 C++ 层的 TCPWrap 对象）。</li>
<li>保存处理连接的函数 onconnection，当有连接时被执行。</li>
<li>调用了 bind 绑定地址到 socket。</li>
<li>调用 listen 函数修改 socket 状态为监听状态。</li>
</ol>
<p>首先看看 new TCP 做了什么。</p>
<pre><code class="hljs language-php"><span class="hljs-keyword">void</span> <span class="hljs-title class_">TCPWrap</span>::<span class="hljs-title function_ invoke__">New</span>(<span class="hljs-keyword">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args) {
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">TCPWrap</span>(env, args.<span class="hljs-title function_ invoke__">This</span>(), ...);
}

<span class="hljs-title class_">TCPWrap</span>::<span class="hljs-title function_ invoke__">TCPWrap</span>(Environment* env, Local&#x3C;Object> <span class="hljs-keyword">object</span>, ProviderType provider)
    : <span class="hljs-title function_ invoke__">ConnectionWrap</span>(env, <span class="hljs-keyword">object</span>, provider) {
  <span class="hljs-comment">// 初始化一个 tcp handle</span>
  <span class="hljs-keyword">int</span> r = <span class="hljs-title function_ invoke__">uv_tcp_init</span>(env-><span class="hljs-title function_ invoke__">event_loop</span>(), &#x26;handle_);
}
</code></pre>
<p>new TCP 本质上是创建一个 TCP 层的 TCPWrap 对象，并初始化了 Libuv 的数据结构 uv_tcp_t（TCPWrap 是对 Libuv uv_tcp_t 的封装）。</p>
<p>接着看 bind，通过前面的学习，我们知道这时候会调用 C++ 层的 Bind。</p>
<pre><code class="hljs language-scss">template &#x3C;typename T>
void TCPWrap::Bind(...) {
  <span class="hljs-comment">// 通过 JS 对象拿到关联的 C++ TCPWrap 对象</span>
  TCPWrap* wrap;
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap,
                          args.Holder(),
                          args<span class="hljs-selector-class">.GetReturnValue</span>()<span class="hljs-selector-class">.Set</span>(UV_EBADF));
  <span class="hljs-comment">// 通过 JS 传入的地址信息直接调用 Libuv</span>
  <span class="hljs-built_in">uv_tcp_bind</span>(&#x26;wrap->handle_,
              reinterpret_cast&#x3C;const sockaddr*>(&#x26;addr),
              flags);
}
</code></pre>
<p>Bind 函数的逻辑很简单，直接调用了 Libuv 函数。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">uv_tcp_bind</span><span class="hljs-params">(...)</span> {
  <span class="hljs-keyword">return</span> uv__tcp_bind(handle, addr, addrlen, flags);
}

<span class="hljs-type">int</span> <span class="hljs-title function_">uv__tcp_bind</span><span class="hljs-params">(<span class="hljs-type">uv_tcp_t</span>* tcp,
                 <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr,
                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addrlen,
                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span> {
  <span class="hljs-comment">// 创建一个 socket，并把返回的 fd 保存到 tcp 结构体中</span>
  maybe_new_socket(tcp, addr->sa_family, <span class="hljs-number">0</span>);

  on = <span class="hljs-number">1</span>;
  <span class="hljs-comment">// 默认设置了 SO_REUSEADDR 属性，后面具体分析</span>
  setsockopt(tcp->io_watcher.fd, SOL_SOCKET, SO_REUSEADDR, &#x26;on, <span class="hljs-keyword">sizeof</span>(on));
  <span class="hljs-comment">// 绑定地址信息到 socket</span>
  bind(tcp->io_watcher.fd, addr, addrlen);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv__tcp_bind 创建了一个 TCP socket 然后把地址信息保存到该 socket 中，另外 Libuv 默认设置了 SO_REUSEADDR 标记，这个的意义我们在下节课分析。</p>
<p>执行 bind 绑定了地址信息后就继续调用 listen 把 socket 变成监听状态，C++ 层代码和 Bind 的差不多，就不再分析，直接看 Libuv 的代码。</p>
<pre><code class="hljs language-ini">int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb) {
  uv_tcp_listen((uv_tcp_t*)stream, backlog, cb)<span class="hljs-comment">;</span>
}

int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {
  static int <span class="hljs-attr">single_accept</span> = -<span class="hljs-number">1</span><span class="hljs-comment">;</span>
  unsigned long flags<span class="hljs-comment">;</span>
  int err<span class="hljs-comment">;</span>
  if (<span class="hljs-attr">single_accept</span> == -<span class="hljs-number">1</span>) {
    const char* <span class="hljs-attr">val</span> = getenv(<span class="hljs-string">"UV_TCP_SINGLE_ACCEPT"</span>)<span class="hljs-comment">;</span>
    <span class="hljs-attr">single_accept</span> = (val != NULL &#x26;&#x26; atoi(val) != <span class="hljs-number">0</span>)<span class="hljs-comment">; </span>
  }
  // 有连接时是否连续接收，或者间歇性处理，见后面分析
  if (single_accept)
    tcp->flags |= UV_HANDLE_TCP_SINGLE_ACCEPT<span class="hljs-comment">;</span>

  <span class="hljs-attr">flags</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
  // 设置 flags 到 handle 上，因为已经创建了 socket
  maybe_new_socket(tcp, AF_INET, flags)<span class="hljs-comment">;</span>
  listen(tcp->io_watcher.fd, backlog)
  // 保存回调，有连接到来时被 Libuv 执行
  tcp-><span class="hljs-attr">connection_cb</span> = cb<span class="hljs-comment">;</span>
  tcp->flags |= UV_HANDLE_BOUND<span class="hljs-comment">;</span>
  // 有连接来时的处理函数，该函数再执行上面的 connection_cb
  tcp-><span class="hljs-attr">io_watcher.cb</span> = uv__server_io<span class="hljs-comment">;</span>
  // 注册可读事件，等待连接到来
  uv__io_start(tcp->loop, &#x26;tcp->io_watcher, POLLIN)<span class="hljs-comment">;</span>

  return 0<span class="hljs-comment">;</span>
}
</code></pre>
<p>uv_tcp_listen 首先调用了 listen 函数修改 socket 状态为监听状态，这样才能接收 TCP 连接，接着保存了 C++ 层的回调，并设置 Libuv 层的回调，最后注册可读事件等待 TCP 连接的到来。这里需要注意两个回调函数的执行顺序，当有 TCP 连接到来时 Libuv 会执行 uv__server_io，在 uv__server_io 里再执行 C++ 层的回调 cb。</p>
<p>至此，服务器就启动了。</p>
<h2>处理连接</h2>
<p>当有三次握手的连接完成时，操作系统会新建一个通信的 socket，并通知 Libuv，Libuv 会执行 uv__server_io。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">uv__server_io</span>(uv_loop_t* loop, uv__io_t* w, unsigned int events) {
  uv_stream_t* stream;
  int err;

  stream = <span class="hljs-built_in">container_of</span>(w, uv_stream_t, io_watcher);
 
  <span class="hljs-built_in">uv__io_start</span>(stream->loop, &#x26;stream->io_watcher, POLLIN);
  <span class="hljs-comment">// 回调了可能关闭了 server，所以需要实时判断</span>
  while (uv__stream_fd(stream) != -<span class="hljs-number">1</span>) {
    <span class="hljs-comment">// 摘取一个 TCP 连接，成功的话，err 保存了对应的 fd</span>
    err = <span class="hljs-built_in">uv__accept</span>(uv__stream_fd(stream));
    <span class="hljs-comment">// 保存 fd 在 accepted_fd，等待处理</span>
    stream->accepted_fd = err;
    <span class="hljs-comment">// 执行回调</span>
    stream-><span class="hljs-built_in">connection_cb</span>(stream, <span class="hljs-number">0</span>);
    <span class="hljs-comment">// 如果回调里没有处理该 accepted_fd，则注销可读事件、先不处理新的连接</span>
    if (stream->accepted_fd != -<span class="hljs-number">1</span>) {
      <span class="hljs-built_in">uv__io_stop</span>(loop, &#x26;stream->io_watcher, POLLIN);
      return;
    }
    <span class="hljs-comment">// 设置了 UV_HANDLE_TCP_SINGLE_ACCEPT 则进入睡眠，让其他进程有机会参与处理</span>
    if (stream->type == UV_TCP &#x26;&#x26;
        (stream->flags &#x26; UV_HANDLE_TCP_SINGLE_ACCEPT)) {
      struct timespec timeout = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span> };
      <span class="hljs-built_in">nanosleep</span>(&#x26;timeout, NULL);
    }
  }
}
</code></pre>
<p>uv__server_io 中通过 uv__accept 从操作系统中摘取一个完成连接的 TCP socket 并拿到一个 fd ，接着保存到 accepted_fd 中并执行 connection_cb 回调。</p>
<p>此外，我们需要注意 UV_HANDLE_TCP_SINGLE_ACCEPT 标记。因为可能有多个进程监听同一个端口，当多个连接到来时，多个进程可能会竞争处理这些连接（惊群问题）。这样一来，首先被调度的进程可能会直接处理所有的连接，导致负载不均衡。通过 UV_HANDLE_TCP_SINGLE_ACCEPT 标记，可以在通知进程接收连接时，每接收到一个后先睡眠一段时间，让其他进程也有机会接收连接，一定程度解决负载不均衡的问题，不过这个逻辑最近被去掉了，Libuv 维护者 bnoordhuis 的理由是，第二次调用 uv__accept 时有 99.9% 的概念会返回 EAGAIN，那就是没有更多的连接可以处理，这样额外调用 uv__accept 带来的系统调用开销是比较可观的，有兴趣的可以参考这个 <a href="https://github.com/libuv/libuv/pull/3696" target="_blank" rel="nofollow noopener noreferrer">PR</a>。</p>
<p>接着我们看看 connection_cb，connection_cb 对应的是 C++ 层的 OnConnection。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// WrapType 为 TCPWrap，UVType 为 uv_tcp_t</span>
template &#x3C;typename WrapType, typename UVType>  
void ConnectionWrap&#x3C;WrapType, UVType>::OnConnection(uv_stream_t* handle, int status) {  
    <span class="hljs-comment">// HandleWrap 中保存了 handle 和 TCPWrap 的关系，这里取出来使用               </span>
    WrapType* wrap_data = static_cast&#x3C;WrapType*>(handle->data);  
    Environment* env = wrap_data-><span class="hljs-built_in">env</span>();  
    Local&#x3C;Value> argv<span class="hljs-selector-attr">[]</span> = {  
        Integer::New(env->isolate(), status),  
        Undefined(env->isolate())  
    };  
    
    <span class="hljs-comment">// 新建一个表示和客户端通信的对象，和 JS 层执行 new TCP 一样 </span>
    Local&#x3C;<span class="hljs-selector-tag">Object</span>> client_obj = WrapType::Instantiate(env,wrap_data,WrapType::SOCKET);  
    WrapType* wrap;  
    <span class="hljs-comment">// 从 client_obj 中取出关联的 TCPWrap 对象存到 wrap 中 </span>
    <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap, client_obj);  
    <span class="hljs-comment">// 拿到 TCPWrap 中的 uv_tcp_t 结构体，再转成 uv_stream_t，因为它们类似父类和子类的关系</span>
    uv_stream_t* client_handle = reinterpret_cast&#x3C;uv_stream_t*>(&#x26;wrap->handle_);  
    <span class="hljs-comment">// 把通信 fd 存储到 client_handle 中  </span>
    <span class="hljs-built_in">uv_accept</span>(handle, client_handle);
    argv<span class="hljs-selector-attr">[1]</span> = client_obj;  
    <span class="hljs-comment">// 回调上层的 onconnection 函数  </span>
    wrap_data-><span class="hljs-built_in">MakeCallback</span>(env->onconnection_string(), <span class="hljs-built_in">arraysize</span>(argv), argv);  
}  
</code></pre>
<p>当建立了新连接时，操作系统会新建一个 socket。同样，在 Node.js 层，也会通过 Instantiate 函数新建一个对应的对象表示和客户端的通信。结构如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f571f59f59cf410a8c954831376dca40~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>Instantiate 代码如下所示。</p>
<pre><code class="hljs language-rust">MaybeLocal&#x3C;Object> TCPWrap::<span class="hljs-title function_ invoke__">Instantiate</span>(Environment* env,
                                        AsyncWrap* parent,
                                        TCPWrap::SocketType <span class="hljs-keyword">type</span>) {
  <span class="hljs-comment">// 拿到导出到 JS 层的 TCP 构造函数（缓存在env中）</span>
  Local&#x3C;Function> constructor = env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">tcp_constructor_template</span>()
                                    <span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">GetFunction</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">context</span>())
                                    .<span class="hljs-title function_ invoke__">ToLocalChecked</span>();
  Local&#x3C;Value> type_value = Int32::<span class="hljs-title function_ invoke__">New</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">isolate</span>(), <span class="hljs-keyword">type</span>);
  <span class="hljs-comment">// 相当于我们在 JS 层调用 new TCP() 时拿到的对象</span>
  <span class="hljs-keyword">return</span> handle_scope.<span class="hljs-title function_ invoke__">EscapeMaybe</span>(
      constructor<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">NewInstance</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">context</span>(), <span class="hljs-number">1</span>, &#x26;type_value));
}
</code></pre>
<p>新建完和对端通信的对象后，接着调用 uv_accept 消费刚才保存在 accepted_fd 中的 fd，并把对应的 fd 保存到 C++ TCPWrap 对象的 uv_tcp_t 结构体中。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv_accept</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span>* server, <span class="hljs-type">uv_stream_t</span>* client)</span> </span>{
  <span class="hljs-type">int</span> err;
  <span class="hljs-comment">// 把 accepted_fd 保存到 client 中</span>
  <span class="hljs-built_in">uv__stream_open</span>(client,
                  server->accepted_fd,
                  UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);
  <span class="hljs-comment">// 处理了，重置该字段</span>
  server->accepted_fd = <span class="hljs-number">-1</span>;
  <span class="hljs-comment">// 保证注册了可读事件，继续处理新的连接</span>
  <span class="hljs-built_in">uv__io_start</span>(server->loop, &#x26;server->io_watcher, POLLIN);
  <span class="hljs-keyword">return</span> err;
}
</code></pre>
<p>C++ 层拿到一个新的对象并且保存了 fd 到对象后，接着回调 JS 层的 onconnection。</p>
<pre><code class="hljs language-php"><span class="hljs-comment">// clientHandle 代表一个和客户端建立 TCP 连接的实体  </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onconnection</span>(<span class="hljs-params">err, clientHandle</span>) </span>{  
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">handle</span> = this;  
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">self</span> = handle.owner;  
  <span class="hljs-comment">// 建立过多，关掉  </span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.maxConnections &#x26;&#x26; <span class="hljs-built_in">self</span>._connections >= <span class="hljs-built_in">self</span>.maxConnections) {  
    clientHandle.<span class="hljs-title function_ invoke__">close</span>();  
    <span class="hljs-keyword">return</span>;  
  }  
  <span class="hljs-comment">// 新建一个 socket 用于通信  </span>
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">socket</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>({  
    handle: clientHandle,  
    allowHalfOpen: <span class="hljs-built_in">self</span>.allowHalfOpen,  
    pauseOnCreate: <span class="hljs-built_in">self</span>.pauseOnConnect  
  });  
  <span class="hljs-comment">// 服务器的连接数加一  </span>
  <span class="hljs-built_in">self</span>._connections++;  
  <span class="hljs-comment">// 触发用户层连接事件  </span>
  <span class="hljs-built_in">self</span>.<span class="hljs-title function_ invoke__">emit</span>(<span class="hljs-string">'connection'</span>, socket); 
} 
</code></pre>
<p>在 JS 层也会封装一个 Socket 对象用于管理和客户端的通信，整体的关系如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77cabae6ffb443b4a6d5eef0745c4c42~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>接着触发 connection 事件，剩下的事情就是应用层处理了。</p>
<h1>Node.js TCP 客户端的实现</h1>
<p>了解了服务器的实现后，接下来看看客户端的实现。在 Node.js 中，我们可以通过 net.connect 发起 TCP 连接，下面具体来分析下 connect 函数。</p>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">connect</span>(...args) {  
  <span class="hljs-comment">// 处理参数  </span>
  const normalized = <span class="hljs-built_in">normalizeArgs</span>(args);  
  const options = normalized<span class="hljs-selector-attr">[0]</span>;  
  <span class="hljs-comment">// 申请一个 socket 表示一个客户端  </span>
  const socket = new <span class="hljs-built_in">Socket</span>(options);  
  <span class="hljs-comment">// 设置超时，超时后会触发 timeout，用户可以自定义处理超时逻辑</span>
  if (options.timeout) {  
    socket<span class="hljs-selector-class">.setTimeout</span>(options.timeout);  
  }  
  <span class="hljs-comment">// 调用 socket 的 connect  </span>
  return socket<span class="hljs-selector-class">.connect</span>(normalized);
}  
</code></pre>
<p>从代码中可以看到，connect 函数是对 Socket 对象的封装，Socket 表示一个通信的端点。我们主要分析 new Socket 和 Socket 的 connect。那么，新建一个客户端 Socket 对象都做了什么事情呢？</p>
<pre><code class="hljs language-kotlin">function Socket(options) {
  <span class="hljs-comment">// 是否正在建立连接，即三次握手中  </span>
  <span class="hljs-keyword">this</span>.connecting = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">// 对应的底层 handle，比如 TCPWrap 对象</span>
  <span class="hljs-keyword">this</span>[kHandle] = <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 是否允许半开关，即收到对端 fin 包后是否默认也发送 fin 包给对端（四次挥手）来断开连接</span>
  options.allowHalfOpen = <span class="hljs-built_in">Boolean</span>(options.allowHalfOpen);
  <span class="hljs-comment">// Socket 是全双工流</span>
  stream.Duplex.call(<span class="hljs-keyword">this</span>, options);
  <span class="hljs-comment">// 注册读端关闭的回调 </span>
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'end'</span>, onReadableStreamEnd);
}
</code></pre>
<p>Socket 是对 C++ 模块 TCPWrap 的封装，主要初始化了一些属性和监听一些事件，这里简单列了一些字段。创建了一个 socket 后，接着看一下 socket 的 connect 函数。</p>
<pre><code class="hljs language-ini">// 建立连接，即三次握手  
<span class="hljs-attr">Socket.prototype.connect</span> = function(...args) {  
  const <span class="hljs-attr">normalized</span> = normalizeArgs(args)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">options</span> = normalized[<span class="hljs-number">0</span>]<span class="hljs-comment">;  </span>
  const <span class="hljs-attr">cb</span> = normalized[<span class="hljs-number">1</span>]<span class="hljs-comment">; </span>
  // 创建一个 C++ 层的 TCPWrap 对象表示客户端  
  <span class="hljs-attr">this._handle</span> = new TCP(TCPConstants.SOCKET)<span class="hljs-comment">; </span>
  // 设置 handle 关联的 JS socket 对象
  self._handle<span class="hljs-section">[owner_symbol]</span> = self<span class="hljs-comment">;</span>
  // 有数据可读时的回调 
  <span class="hljs-attr">self._handle.onread</span> = <span class="hljs-literal">on</span>StreamRead<span class="hljs-comment">;</span>
  // 可能需要 DNS 解析，解析成功再发起连接  
  lookupAndConnect(this, options)<span class="hljs-comment">;  </span>
  return this<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
</code></pre>
<p>connect 函数主要是 3 个逻辑。</p>
<ol>
<li>首先通过 new TCP() 创建一个底层的 C++ 对象。</li>
<li>设置可读回调。</li>
<li>做 DNS 解析（如果需要的话），然后发起三次握手。</li>
</ol>
<p>new TCP 刚才已经分析过了，所以这里就不再分析，直接看 lookupAndConnect。lookupAndConnect 主要是对参数进行校验，如果传的是域名，就进行 DNS 解析，否则就不解析。</p>
<pre><code class="hljs language-ini">function lookupAndConnect(self, options) {
    const { localAddress, localPort } = options<span class="hljs-comment">;</span>
    const <span class="hljs-attr">host</span> = options.host || <span class="hljs-string">'localhost'</span><span class="hljs-comment">;</span>
    let { port } = options<span class="hljs-comment">;</span>
    port |= 0<span class="hljs-comment">;</span>
    // 是 IP，则不需要 DNS 解析，直接连接
    const <span class="hljs-attr">addressType</span> = isIP(host)<span class="hljs-comment">;</span>
    if (addressType) {
        internalConnect(self, host, port, addressType, localAddress, localPort)<span class="hljs-comment">;</span>
    } else {
        lookup(host, dnsopts, function emitLookup(err, ip, addressType) {
          internalConnect(self, ip, port, addressType, localAddress, localPort)<span class="hljs-comment">;</span>
        })<span class="hljs-comment">;</span>
    }
}
</code></pre>
<p>最终拿到 IP 后就可以发起连接了。</p>
<pre><code class="hljs language-ini">function internalConnect(  
  self,   
  // 需要连接的服务器的 IP、端口  
  address,   
  port,   
  addressType,   
  /*
      用于和对端连接的本地 IP、端口，
      如果不设置，则操作系统自己决定  
  */
  localAddress,   
  localPort) {  
  var err<span class="hljs-comment">;  </span>
   /*
      如果传了本地的地址或端口，则 TCP 连接中的源 IP
      和端口就是传的，否则由操作系统自己选
  */  
  if (localAddress || localPort) {  
      // IP v4  
    if (<span class="hljs-attr">addressType</span> === <span class="hljs-number">4</span>) {  
      <span class="hljs-attr">localAddress</span> = localAddress || <span class="hljs-string">'0.0.0.0'</span><span class="hljs-comment">;  </span>
      // 绑定本地地址和端口到 handle，即使用本主机的哪个 IP 和端口发起连接
      <span class="hljs-attr">err</span> = self._handle.bind(localAddress, localPort)<span class="hljs-comment">;  </span>
    } else if (<span class="hljs-attr">addressType</span> === <span class="hljs-number">6</span>) {  
      <span class="hljs-attr">localAddress</span> = localAddress || <span class="hljs-string">'::'</span><span class="hljs-comment">;  </span>
      <span class="hljs-attr">err</span> = self._handle.bind6(localAddress, localPort)<span class="hljs-comment">;  </span>
    }   
  }  
    // 对端的地址信息
  if (<span class="hljs-attr">addressType</span> === <span class="hljs-number">6</span> || addressType === <span class="hljs-number">4</span>) {  
    // 新建一个请求对象，C++ 层定义  
    const <span class="hljs-attr">req</span> = new TCPConnectWrap()<span class="hljs-comment">;  </span>
    // 设置一些列属性  
    <span class="hljs-attr">req.oncomplete</span> = afterConnect<span class="hljs-comment">;  </span>
    <span class="hljs-attr">req.address</span> = address<span class="hljs-comment">;  </span>
    <span class="hljs-attr">req.port</span> = port<span class="hljs-comment">;  </span>
    <span class="hljs-attr">req.localAddress</span> = localAddress<span class="hljs-comment">;  </span>
    <span class="hljs-attr">req.localPort</span> = localPort<span class="hljs-comment">;  </span>
    // 调用底层对应的函数  
    if (<span class="hljs-attr">addressType</span> === <span class="hljs-number">4</span>)  
      <span class="hljs-attr">err</span> = self._handle.connect(req, address, port)<span class="hljs-comment">;  </span>
    else  
      <span class="hljs-attr">err</span> = self._handle.connect6(req, address, port)<span class="hljs-comment">;  </span>
  }  
}  
</code></pre>
<p>这里的代码比较多，主要的逻辑是 bind 和 connect。bind 函数前面已经讲解过了，它就是给 socket 设置客户端 IP 和端口的值。我们主要来分析 connect，把 connect 这段逻辑拎出来。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">req</span> = new TCPConnectWrap()<span class="hljs-comment">;  </span>
// 设置一些列属性  
<span class="hljs-attr">req.oncomplete</span> = afterConnect<span class="hljs-comment">;  </span>
<span class="hljs-attr">req.address</span> = address<span class="hljs-comment">;  </span>
<span class="hljs-attr">req.port</span> = port<span class="hljs-comment">;  </span>
<span class="hljs-attr">req.localAddress</span> = localAddress<span class="hljs-comment">;  </span>
<span class="hljs-attr">req.localPort</span> = localPort<span class="hljs-comment">;  </span>
// 调用底层对应的函数  
self._handle.connect(req, address, port)<span class="hljs-comment">; </span>
</code></pre>
<p>TCPConnectWrap 是 C++ 层提供的类，用来表示一个 TCP 连接请求的上下文，connect 对应C++ 层的 Conenct。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPWrap::Connect</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&#x3C;Value>&#x26; args)</span> </span>{
  <span class="hljs-type">int</span> port = <span class="hljs-built_in">static_cast</span>&#x3C;<span class="hljs-type">int</span>>(args[<span class="hljs-number">2</span>].<span class="hljs-built_in">As</span>&#x3C;Uint32>()-><span class="hljs-built_in">Value</span>());
  <span class="hljs-built_in">Connect</span>&#x3C;sockaddr_in>(args, [port](<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip_address, sockaddr_in* addr) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">uv_ip4_addr</span>(ip_address, port, addr);
  });
}
</code></pre>
<p>这里把 JS 层传入的 IP 和端口取出来，继续调另一个 Connect。</p>
<pre><code class="hljs language-ini">template &#x3C;typename T>
void TCPWrap::Connect(const FunctionCallbackInfo&#x3C;Value>&#x26; args,
    std::function&#x3C;int(const char* ip_address, T* addr)> uv_ip_addr) {
    
  Environment* <span class="hljs-attr">env</span> = Environment::GetCurrent(args)<span class="hljs-comment">;</span>

  TCPWrap* wrap<span class="hljs-comment">;</span>
  // 拿到 C++ 层的 TCPWrap
  ASSIGN_OR_RETURN_UNWRAP(&#x26;wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF))<span class="hljs-comment">;</span>

  Local&#x3C;Object> <span class="hljs-attr">req_wrap_obj</span> = args[<span class="hljs-number">0</span>].As&#x3C;Object>()<span class="hljs-comment">;</span>
  node::Utf8Value ip_address(env->isolate(), args<span class="hljs-section">[1]</span>)<span class="hljs-comment">;</span>

  T addr<span class="hljs-comment">;</span>
  int <span class="hljs-attr">err</span> = uv_ip_addr(*ip_address, &#x26;addr)<span class="hljs-comment">;</span>

  if (<span class="hljs-attr">err</span> == <span class="hljs-number">0</span>) {
    // req_wrap 和 req_wrap_obj 互相关联
    ConnectWrap* <span class="hljs-attr">req_wrap</span> = new ConnectWrap(env, req_wrap_obj, ...)<span class="hljs-comment">;</span>
    // 发起请求，即调用 uv_tcp_connect 发起一个 TCP 连接
    <span class="hljs-attr">err</span> = req_wrap->Dispatch(uv_tcp_connect,
                             &#x26;wrap->handle_,
                             reinterpret_cast&#x3C;const sockaddr*>(&#x26;addr),
                             // 连接结束后执行的回调
                             AfterConnect)<span class="hljs-comment">;</span>
  }
  args.GetReturnValue().Set(err)<span class="hljs-comment">;</span>
}
</code></pre>
<p>接着进入了 Libuv 层。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv__tcp_connect</span><span class="hljs-params">(<span class="hljs-type">uv_connect_t</span>* req,
                    <span class="hljs-type">uv_tcp_t</span>* handle,
                    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr,
                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addrlen,
                    uv_connect_cb cb)</span> </span>{
  <span class="hljs-type">int</span> err;
  <span class="hljs-type">int</span> r;

  <span class="hljs-comment">// 申请一个 socket 并保存 fd 到 handle 中</span>
  err = <span class="hljs-built_in">maybe_new_socket</span>(handle,
                         addr->sa_family,
                         UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);
  <span class="hljs-comment">// 以非阻塞的方式发起一个 TCP 连接</span>
  <span class="hljs-built_in">connect</span>(<span class="hljs-built_in">uv__stream_fd</span>(handle), addr, addrlen);
 
  <span class="hljs-comment">// 初始化一个 request，并设置某些字段</span>
  <span class="hljs-built_in">uv__req_init</span>(handle->loop, req, UV_CONNECT);
  req->cb = cb;
  <span class="hljs-comment">// 保存关联的 handle</span>
  req->handle = (<span class="hljs-type">uv_stream_t</span>*) handle;
  <span class="hljs-built_in">QUEUE_INIT</span>(&#x26;req->queue);
  handle->connect_req = req;
  <span class="hljs-comment">// 注册到 IO 观察者队列，handle->io_watcher 已经保存了 fd</span>
  <span class="hljs-built_in">uv__io_start</span>(handle->loop, &#x26;handle->io_watcher, POLLOUT);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>uv__tcp_connect 以非阻塞的方式发起 TCP 连接，这样就不会阻塞线程，接着把相关请求信息保存到请求对象中，最后注册可写事件，等待连接结果。执行完的结构图如下（ConnectWrap 继承 ReqWrap，TCPWrap 继承 HandleWrap）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05d9ab052b314c70a25874f420071e0b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>连接结束后就会执行 uv__stream_connect，该函数在流机制的课程中已经讲过，就不再具体分析，它主要是获取连接结果，然后执行 C++ 层的 AfterConnect。</p>
<pre><code class="hljs language-arduino"><span class="hljs-keyword">template</span> &#x3C;<span class="hljs-keyword">typename</span> WrapType, <span class="hljs-keyword">typename</span> UVType>
<span class="hljs-type">void</span> ConnectionWrap&#x3C;WrapType, UVType>::<span class="hljs-built_in">AfterConnect</span>(<span class="hljs-type">uv_connect_t</span>* req,
                                                    <span class="hljs-type">int</span> status) {
  <span class="hljs-comment">// 根据引用关系拿到请求对应的 JS 层请求上下文，</span>
  <span class="hljs-comment">// 具体是在发起 connect 时设置的（void ReqWrap&#x3C;T>::Dispatched()）</span>
  <span class="hljs-function">std::unique_ptr&#x3C;ConnectWrap> <span class="hljs-title">req_wrap</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&#x3C;ConnectWrap*>(req->data))</span></span>;
  
  <span class="hljs-comment">// 根据引用关系拿到请求对应的 C++ 层 TCPWrap 对象，具体是 HandleWrap::HandleWrap 设置的</span>
  WrapType* wrap = <span class="hljs-built_in">static_cast</span>&#x3C;WrapType*>(req->handle->data);
  Environment* env = wrap-><span class="hljs-built_in">env</span>();

  Local&#x3C;Value> argv[<span class="hljs-number">5</span>] = {
    Integer::<span class="hljs-built_in">New</span>(env-><span class="hljs-built_in">isolate</span>(), status),
    wrap-><span class="hljs-built_in">object</span>(),
    req_wrap-><span class="hljs-built_in">object</span>(),
    ...
  };
  <span class="hljs-comment">// 执行 JS 层 oncomplete 回调函数</span>
  req_wrap-><span class="hljs-built_in">MakeCallback</span>(env-><span class="hljs-built_in">oncomplete_string</span>(), <span class="hljs-built_in">arraysize</span>(argv), argv);
}
</code></pre>
<p>AfterConnect 会执行 oncomplete 属性对应的函数，对应的是 JS 层的 afterConnect。</p>
<pre><code class="hljs language-php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">afterConnect</span>(<span class="hljs-params">status, handle, req, readable, writable</span>) </span>{
  <span class="hljs-comment">// 获取 C++ 层对象关联的 JS socket 对象，在创建 socket 对象时设置的</span>
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">self</span> = handle[owner_symbol];
  <span class="hljs-comment">// 触发 connect 事件</span>
  <span class="hljs-built_in">self</span>.<span class="hljs-title function_ invoke__">emit</span>(<span class="hljs-string">'connect'</span>);
  <span class="hljs-comment">// 如果需要开启读操作，则注册可读事件</span>
  <span class="hljs-keyword">if</span> (readable &#x26;&#x26; !<span class="hljs-built_in">self</span>.<span class="hljs-title function_ invoke__">isPaused</span>())
    <span class="hljs-built_in">self</span>.<span class="hljs-title function_ invoke__">read</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<p>这样就完成了 TCP连接，一般情况下，连接成功后，JS 层会调用 self.read(0) 注册等待可读事件，我们下节课再详细讲解。</p>
<h1>总结</h1>
<p>TCP 协议是 TCP / IP 协议簇中非常重要且复杂的协议，这一节课我们首先介绍了 TCP 协议的概念和特性。</p>
<ol>
<li>
<p>面向连接：通信前需要先建立连接，使用完需要关闭（主动关闭或者空闲时间达到阈值由操作系统关闭）。</p>
</li>
<li>
<p>可靠：发送端通过超时重发和确认等机制确保数据发送到对端。</p>
</li>
<li>
<p>流式协议：把数据当作 01 比特流传输，不感知所承载的数据格式，数据由上层解释。</p>
</li>
<li>
<p>全双工：通信两端可以同时发送和接收数据，两端都有自己的发送和接收缓冲区。</p>
</li>
</ol>
<p>我们需要对这 TCP 协议的核心概念有深入的理解才能更好地理解 TCP 协议的工作原理。这样我们学习和使用 RPC 或者 HTTP 等协议时也会更容易。</p>
<p>接着我们讲了在网络编程中如何通过 TCP 协议进行通信。TCP 通信涉及服务器和客户端两个端。</p>
<ol>
<li>
<p>服务器首先申请一个 socket，然后调用 bind 绑定地址，接着通过 listen 进入监听状态，有连接到来时通过 accept 进行处理。</p>
</li>
<li>
<p>客户端相比来说简单点，客户端也是需要先申请一个 socket，然后通过 connect 发起对服务器的连接就行，我们也可以选择通过 bind 绑定本地地址到 socket 中，但是通常不需要。</p>
</li>
</ol>
<p>讲完基础部分后，最后我们深入分析了 Node.js 中 TCP 服务器和客户端的实现。它本质上是结合网络编程和 V8 实现的。</p>
<ol>
<li>
<p>服务器的实现：Node.js 中，通过 createServer() 可以创建一个服务器，接着调用它的 listen 函数就可以启动服务器，listen 函数本质上是对操作系统 bind 和 listen 的封装，执行完 listen 后，Node.js 注册了可读事件等待连接的到来，当新连接到来时，操作系统会通知 Node.js，从而 Node.js 处理该连接。</p>
</li>
<li>
<p>客户端的实现：Node.js 中，通过 net.connect 可以发起一个 TCP 连接，connect 本质上是对操作系统 bind 和 connect 的封装，调用 connect 函数后，Node.js 注册了等待可写事件，接着操作系统会发起三次握手，等待连接结束后，操作系统会通知 Node.js，Node.js 通过系统 API 获取连接结果。</p>
</li>
</ol>
<p>深入理解 Node.js 中 TCP 服务器和客户端的实现，不仅可以帮助我们更好地使用 Node.js，同时碰到问题时我们也可以自己排查。</p>
<p>下一节课我们会在服务器和客户端建立的 TCP 连接的基础上讲解数据通信、连接管理以及 TCP 常用的一些特性。</p></div>
</body></html>