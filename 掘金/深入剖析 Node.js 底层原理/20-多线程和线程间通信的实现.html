<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>多线程和线程间通信的实现</h1>
<p>在 Node.js 中，虽然除了 JS 线程外还有很多子线程，比如 Libuv 线程池、Trace 线程、Inspector 线程等，但是这些线程都是用于执行特定任务的，Libuv 的线程池虽然提供了接口给用户使用，但是这个线程池只能执行 C、C++ 层定义的任务，如果我们想利用 Libuv 线程池执行一些耗时的 JS 代码，那就没有办法了。在早期的 Node.js 中，我们可以用进程去实现这样的需求，但进程太重了，于是新版的 Node.js 为我们提供了 worker_threads 模块来创建子线程，在 worker_threads 线程中我们可以执行 JS 代码。</p>
<p>Node.js 的子线程本质上是一个新的事件循环，但是子线程和 Node.js 主线程共享一个 Libuv 线程池，所以如果在子线程里有文件、DNS 等操作就会和主线程竞争 Libuv 线程池。worker_threads 模块虽然只是对系统线程库的封装，但是把它和 Node.js 原本的架构结合起来后就会变得复杂起来。</p>
<p>因此，这节课我们就来聊聊 Node.js 中的 worker_threads 模块，具体包括 worker_threads 的使用，基于 worker_threads 的线程是如何通信的，以及 worker_threads 的实现原理。</p>
<h1>多线程的使用</h1>
<p>我们首先看一下 worker_threads 常用的方式以及它都有哪些特性。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> {
    <span class="hljs-title class_">Worker</span>, <span class="hljs-comment">// 创建子线程的 API</span>
    isMainThread, <span class="hljs-comment">// 是否是主线程</span>
    threadId, <span class="hljs-comment">// 线程 id</span>
    parentPort, <span class="hljs-comment">// 和父线程通信的端口</span>
    workerData, <span class="hljs-comment">// 父线程传递给子线程的数据</span>
    <span class="hljs-variable constant_">SHARE_ENV</span>, <span class="hljs-comment">// 是否和主线程共享环境变量</span>
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);  

<span class="hljs-keyword">if</span> (isMainThread) {  
  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(__filename, {
      <span class="hljs-comment">/*
          1. process.env：复制父线程的环境变量，修改后不会互相影响
          2. { hello: 'world' }：显式指定数据
          3. SHARE_ENV：和父线程共享环境变量，修改后互相影响
      */</span>
      <span class="hljs-attr">env</span>: process.<span class="hljs-property">env</span>,
      <span class="hljs-comment">// 父线程传递给子线程的数据</span>
      <span class="hljs-attr">workerData</span>: { <span class="hljs-attr">hello</span>: <span class="hljs-string">'world'</span> },
      <span class="hljs-comment">// 资源限制</span>
      <span class="hljs-attr">resourceLimits</span>: {
          <span class="hljs-attr">maxOldGenerationSizeMb</span>: <span class="hljs-number">100</span>,
      }
  });  
  <span class="hljs-comment">// 监听子线程的消息</span>
  worker.<span class="hljs-title function_">once</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =></span> {  
    <span class="hljs-comment">// ...  </span>
  });  
  <span class="hljs-comment">// 给子线程发送消息</span>
  worker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">'Hello, world!'</span>);  
} <span class="hljs-keyword">else</span> {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(threadId, workerData);
  <span class="hljs-comment">// 监听父线程的消息</span>
  parentPort.<span class="hljs-title function_">once</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =></span> {  
    <span class="hljs-comment">// 给父线程发送消息</span>
    parentPort.<span class="hljs-title function_">postMessage</span>(message);  
  });  
}  
</code></pre>
<p>上面的代码列出了 worker_threads 模块常用的一些功能，我们可以新建一个 index.js 文件，然后把代码复制进去。当执行 Node.js index.js 时，isMainThread 为 true，所以执行 if 的代码，然后在 if 的代码中创建了一个 Worker，即一个子线程，当子线程运行时会加载当前的文件 index.js，但是这时候 isMainThread 为 false，所以会执行 else 里的逻辑。除了上面的执行方式，还有另 2 种方式。</p>
<ol>
<li>把 if 和 else 的代码拆分到两个文件，执行 new Worker 时第一个参数是子线程文件的路径。</li>
<li>通过 eval 执行脚本：new Worker("console.log('hello')", { eval: true })。</li>
</ol>
<p>我们这节课以示例代码的使用方式进行讲解，如果你对子线程的特性感兴趣，可以进一步参考这个<a href="https://github.com/theanarkh/nodejs-code/tree/main/thread" target="_blank" rel="nofollow noopener noreferrer">仓库</a>。</p>
<h1>线程间通信数据结构</h1>
<p>分析线程的实现前，我们首先来分析一下线程通信的实现，因为这是创建线程的前提条件。进程间的通信一般需要借助操作系统提供公共的内存来完成，因为进程间的内存是独立的，但是线程通信和和进程间通信不一样，线程间的内存是共享进程的，所以线程间通信可以基于进程内的内存来完成。</p>
<p>在 Node.js 中，线程间通信使用的是 MessageChannel 实现的，它是全双工的，任意一端都可以随时发送信息。定义一个 MessageChannel 时，Node.js 首先申请两个端点（MessagePort），然后把它们关联起来，这样就可以通过两个端点进行通信了。下面看一个使用例子。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">MessageChannel</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);
<span class="hljs-comment">// 创建一个通信通道，得到两个端点</span>
<span class="hljs-keyword">const</span> { port1, port2 } = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();

<span class="hljs-comment">// port2 监听数据</span>
port2.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'port2 receives:'</span>, message);
  <span class="hljs-comment">// 给 port1 发送数据</span>
  port2.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">'world'</span>);
});

<span class="hljs-comment">// port1 监听数据</span>
port1.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'port1 receives:'</span>, message);
});
<span class="hljs-comment">// 给 port2 发送数据</span>
port1.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">'hello'</span>);
</code></pre>
<p>可以看到通过 MessageChannel 通信非常简单，但是实现上还是比较复杂的。线程间通信的实现中有几个比较重要的数据结构：</p>
<ol>
<li>Message 代表一个消息；</li>
<li>MessagePortData 是对操作 Message 的封装和对消息的承载；</li>
<li>MessagePort 是代表通信的端点；</li>
<li>MessageChannel 是代表通信的两端，即两个 MessagePort；</li>
</ol>
<p>接着看一下这些数据结构的具体的实现。</p>
<h2>Message</h2>
<p>Message 类代表的是子线程间通信的一条消息。</p>
<pre><code class="hljs language-arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> : <span class="hljs-keyword">public</span> MemoryRetainer {  
 <span class="hljs-keyword">public</span>:  
  <span class="hljs-comment">// 线程间通信的数据需要通过序列化和反序列化处理  </span>
  <span class="hljs-function">v8::MaybeLocal&#x3C;v8::Value> <span class="hljs-title">Deserialize</span><span class="hljs-params">(...)</span></span>;  
  <span class="hljs-function">v8::Maybe&#x3C;<span class="hljs-type">bool</span>> <span class="hljs-title">Serialize</span><span class="hljs-params">(...)</span></span>;  
 <span class="hljs-keyword">private</span>:  
  <span class="hljs-comment">// 保存消息的内容  </span>
  MallocedBuffer&#x3C;<span class="hljs-type">char</span>> main_message_buf_;  
};  
</code></pre>
<p>消息对应的数据经过序列化之后保存在 main_message_buf_ 字段，传递到对端后再反序列化出来使用。除了保存一般的数据外，还可以保存一些特殊的数据类型，比如 ArrayBuffer，这样线程间就可以传递这些特殊的数据类型。因为这里我们重点在于理解原理，所以只关心普通类型的数据就可以了。</p>
<h2>MessagePortData</h2>
<p>MessagePortData 负责存储收到的消息和给对端发送消息，但是它不负责处理消息，消息是由 MessagePort 对象处理的。</p>
<pre><code class="hljs language-arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessagePortData</span> : <span class="hljs-keyword">public</span> MemoryRetainer {  
 <span class="hljs-keyword">public</span>:  
  <span class="hljs-comment">// 新增一个消息  </span>
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddToIncomingQueue</span><span class="hljs-params">(Message&#x26;&#x26; message)</span></span>;  
  <span class="hljs-comment">// 关联 / 解关联通信两端的端口  </span>
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Entangle</span><span class="hljs-params">(MessagePortData* a, MessagePortData* b)</span></span>;  
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Disentangle</span><span class="hljs-params">()</span></span>;  
    
 <span class="hljs-keyword">private</span>:  
  <span class="hljs-comment">// 消息队列</span>
  std::list&#x3C;Message> incoming_messages_;  
  <span class="hljs-comment">// 所属端口  </span>
  MessagePort* owner_ = <span class="hljs-literal">nullptr</span>;  
  <span class="hljs-comment">// 指向通信对端的指针  </span>
  MessagePortData* sibling_ = <span class="hljs-literal">nullptr</span>;  
};  
</code></pre>
<p>从 MessagePortData 的定义中可以看到，它维护了一个消息队列，当通过 Entangle 和对端关联起来后，对端就可以通过 AddToIncomingQueue 函数往消息队列中插入一条消息，如果 owner_ 字段非空，则 MessagePortData 会通知 owner_ 对象有消息需要处理，结构如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c874525e2f084fe8b8be14d8c2b8dc27~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>了解了 MessagePortData 的定义后，我们看一下 MessagePortData 的实现。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 保存所属的通信端口</span>
MessagePortData::MessagePortData(MessagePort* owner) : owner_(owner) { }  
  
MessagePortData::~MessagePortData() {  
  <span class="hljs-comment">// 析构时解除和对端的关系  </span>
  <span class="hljs-built_in">Disentangle</span>();  
}  
  
<span class="hljs-comment">// 插入一个 message  </span>
void MessagePortData::AddToIncomingQueue(Message&#x26;&#x26; message) {  
  <span class="hljs-comment">// 插入消息队列  </span>
  incoming_messages_<span class="hljs-selector-class">.emplace_back</span>(std::move(message));  
  <span class="hljs-comment">// 通知 owner 有数据需要处理 </span>
  if (owner_ != nullptr) {  
    owner_-><span class="hljs-built_in">TriggerAsync</span>();  
  }  
}  
  
<span class="hljs-comment">// 关联通信的对端，通信时就是往对端插入数据</span>
void MessagePortData::Entangle(MessagePortData* a, MessagePortData* b) {  
  <span class="hljs-selector-tag">a</span>->sibling_ = <span class="hljs-selector-tag">b</span>;  
  <span class="hljs-selector-tag">b</span>->sibling_ = <span class="hljs-selector-tag">a</span>;  
}  
  
<span class="hljs-comment">// 解除关联   </span>
void MessagePortData::Disentangle() {  
  <span class="hljs-comment">// 对端  </span>
  MessagePortData* sibling = sibling_;  
  <span class="hljs-comment">// 对端非空，则把对端的 sibling 也指向空，自己也指向空  </span>
  if (sibling_ != nullptr) {  
    sibling_->sibling_ = nullptr;  
    sibling_ = nullptr;  
  }  
  
  <span class="hljs-comment">// 插入一个空的消息给自己表示最后一个消息</span>
  <span class="hljs-built_in">AddToIncomingQueue</span>(Message()); 
  <span class="hljs-comment">// 插入一个空的消息给对端   </span>
  if (sibling != nullptr) {  
    sibling-><span class="hljs-built_in">AddToIncomingQueue</span>(Message());  
  }  
}  
</code></pre>
<p>MessagePortData 的实现也很简单，是对数据结构的一些简单操作。</p>
<h2>MessagePort</h2>
<p>MessagePort 表示的是通信的一端，负责消息的处理。</p>
<pre><code class="hljs language-arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessagePort</span> : <span class="hljs-keyword">public</span> HandleWrap {  
 <span class="hljs-keyword">public</span>:  
  <span class="hljs-comment">// 发送消息  </span>
  <span class="hljs-function">v8::Maybe&#x3C;<span class="hljs-type">bool</span>> <span class="hljs-title">PostMessage</span><span class="hljs-params">(...)</span></span>;  
  
  <span class="hljs-comment">// 开启/关闭接收消息  </span>
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;  
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span>;  
  
  <span class="hljs-comment">// 关联对端，主要是调用了 MessagePortData 的相应函数</span>
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Entangle</span><span class="hljs-params">(MessagePort* a, MessagePort* b)</span></span>;  
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Entangle</span><span class="hljs-params">(MessagePort* a, MessagePortData* b)</span></span>;  
  
 <span class="hljs-keyword">private</span>:  
  <span class="hljs-comment">// 处理消息</span>
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnMessage</span><span class="hljs-params">()</span></span>;  
  <span class="hljs-comment">// MessagePortData 对象调用该 API 通知 MessagePort 有消息需要处理</span>
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TriggerAsync</span><span class="hljs-params">()</span></span>;  
  <span class="hljs-comment">// 接收消息</span>
  <span class="hljs-function">v8::MaybeLocal&#x3C;v8::Value> <span class="hljs-title">ReceiveMessage</span><span class="hljs-params">(v8::Local&#x3C;v8::Context> context,  
                                           <span class="hljs-type">bool</span> only_if_receiving)</span></span>;  
  <span class="hljs-comment">// MessagePortData 用于管理消息 </span>
  std::unique_ptr&#x3C;MessagePortData> data_ = <span class="hljs-literal">nullptr</span>;  
  <span class="hljs-comment">// 是否开启接收消息标记  </span>
  <span class="hljs-type">bool</span> receiving_messages_ = <span class="hljs-literal">false</span>;  
  <span class="hljs-comment">// 用于收到消息时通知事件循环，事件循环执行回调处理消息  </span>
  <span class="hljs-type">uv_async_t</span> async_;  
};  
</code></pre>
<p>MessagePort 中通过 async 机制实现线程间通信，当任一方给对方发送消息时，就可以通过 async 机制通知对方 ，数据发送端功能则是由 MessagePortData 对象实现。了解了定义后，接着来看一下 MessagePort 的实现。</p>
<p>我们首先看一下构造函数。</p>
<pre><code class="hljs language-scss">MessagePort::MessagePort(Environment* env,
                         Local&#x3C;Context> context,
                         // JS 层使用的对象
                         Local&#x3C;Object> wrap)
  : HandleWrap(...),
    // 创建一个管理数据的对象，该对象的 owner 是 MessagePort 对象
    data_(new MessagePortData(this)) { 
  auto onmessage = <span class="hljs-selector-attr">[]</span>(uv_async_t* handle) {
    MessagePort* channel = <span class="hljs-built_in">ContainerOf</span>(&#x26;MessagePort::async_, handle);
    channel-><span class="hljs-built_in">OnMessage</span>();
  };
  <span class="hljs-comment">// 初始化 async 结构体，实现异步通信</span>
  <span class="hljs-built_in">uv_async_init</span>(env->event_loop(),
                &#x26;async_,
                onmessage);
  <span class="hljs-comment">// 挂载async对应的上下文</span>
  async_<span class="hljs-selector-class">.data</span> = static_cast&#x3C;void*>(this);
}
</code></pre>
<p>MessagePort 中创建了一个 MessagePortData 对象，然后初始化一个 async handle 用于线程间通信。接着，我们再来看发送消息的实现。</p>
<pre><code class="hljs language-ini">// 给对端发送消息
Maybe&#x3C;bool> MessagePort::PostMessage(Environment* env, Local&#x3C;Value> message_v, ...) {
  Isolate* <span class="hljs-attr">isolate</span> = env->isolate()<span class="hljs-comment">;</span>
  Local&#x3C;Object> <span class="hljs-attr">obj</span> = object(isolate)<span class="hljs-comment">;</span>
  Local&#x3C;Context> <span class="hljs-attr">context</span> = obj->CreationContext()<span class="hljs-comment">;</span>

  Message msg<span class="hljs-comment">;</span>
  // 序列化
  Maybe&#x3C;bool> <span class="hljs-attr">serialization_maybe</span> = msg.Serialize(env, context, message_v, transfer_v, obj)<span class="hljs-comment">;</span>
  // 把消息插入到对端队列
  data_->sibling_->AddToIncomingQueue(std::move(msg))<span class="hljs-comment">;</span>
  return Just(true)<span class="hljs-comment">;</span>
}
</code></pre>
<p>PostMessage 首先通过 Serialize 函数对发送的数据进行序列化，以下是序列化的逻辑。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function">Maybe&#x3C;<span class="hljs-type">bool</span>> <span class="hljs-title">Message::Serialize</span><span class="hljs-params">(Environment* env,
                               Local&#x3C;Context> context,
                               Local&#x3C;Value> input,
                               <span class="hljs-type">const</span> TransferList&#x26; transfer_list_v,
                               Local&#x3C;Object> source_port)</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">handle_scope</span><span class="hljs-params">(env->isolate())</span></span>;
  <span class="hljs-function">Context::Scope <span class="hljs-title">context_scope</span><span class="hljs-params">(context)</span></span>;

  <span class="hljs-function">SerializerDelegate <span class="hljs-title">delegate</span><span class="hljs-params">(env, context, <span class="hljs-keyword">this</span>)</span></span>;
  <span class="hljs-function">ValueSerializer <span class="hljs-title">serializer</span><span class="hljs-params">(env->isolate(), &#x26;delegate)</span></span>;
  delegate.serializer = &#x26;serializer;
  <span class="hljs-comment">// 忽略特殊数据的处理</span>
  <span class="hljs-comment">// 调用 V8 函数对 JS 数据进行序列化</span>
  serializer.<span class="hljs-built_in">WriteHeader</span>();
  <span class="hljs-keyword">if</span> (serializer.<span class="hljs-built_in">WriteValue</span>(context, input).<span class="hljs-built_in">IsNothing</span>()) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Nothing</span>&#x3C;<span class="hljs-type">bool</span>>();
  }

  delegate.<span class="hljs-built_in">Finish</span>();
  <span class="hljs-comment">// 拿到序列化后的数据</span>
  std::pair&#x3C;<span class="hljs-type">uint8_t</span>*, <span class="hljs-type">size_t</span>> data = serializer.<span class="hljs-built_in">Release</span>();
  <span class="hljs-comment">// 保存到 Message 对象的 main_message_buf_ 字段中</span>
  main_message_buf_ = <span class="hljs-built_in">MallocedBuffer</span>&#x3C;<span class="hljs-type">char</span>>(<span class="hljs-built_in">reinterpret_cast</span>&#x3C;<span class="hljs-type">char</span>*>(data.first), data.second);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Just</span>(<span class="hljs-literal">true</span>);
}
</code></pre>
<p>在Serialize 中，PostMessage 通过 V8 的 ValueSerializer 对 JS 对象进行序列化处理，不仅如此，PostMessage 还会对特殊数据进行额外的处理，比如 ArrayBuffer，不过这里忽略了这些逻辑。</p>
<p>数据序列化完毕后，PostMessage 接着调用 data_->sibling_->AddToIncomingQueue 插入到对端的消息队列中，AddToIncomingQueue 中会执行 TriggerAsync 通知对端有消息需要处理，看一下 TriggerAsync 的逻辑。</p>
<pre><code class="hljs language-scss">void MessagePort::TriggerAsync() {  
  <span class="hljs-built_in">uv_async_send</span>(&#x26;async_); 
}  
</code></pre>
<p>TriggerAsync 是对 uv_async_send 的封装，该函数在 Libuv 线程池那节课中讲过了，这里就不再详细介绍。对端收到通知后会执行 OnMessage 进行处理。</p>
<pre><code class="hljs language-scss">void MessagePort::OnMessage() {
  Local&#x3C;Context> context = <span class="hljs-selector-tag">object</span>(env()-><span class="hljs-built_in">isolate</span>())-><span class="hljs-built_in">CreationContext</span>();
  <span class="hljs-comment">// 接收消息条数的阈值</span>
  size_t processing_limit;
  {
    Mutex::ScopedLock(data_->mutex_);
    processing_limit = std::max(data_->incoming_messages_.size(), static_cast&#x3C;size_t>(<span class="hljs-number">1000</span>));
  }
  
  while (data_) {
    <span class="hljs-comment">// 单次处理的数据太多，等下一次事件循环再处理（TriggerAsync 实现自己通知自己）</span>
    if (processing_limit-- == <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// 通知事件循环</span>
      <span class="hljs-built_in">TriggerAsync</span>();
      return;
    }

    Local&#x3C;Value> payload;
    <span class="hljs-comment">// 读取消息</span>
    if (!ReceiveMessage(context, true)<span class="hljs-selector-class">.ToLocal</span>(&#x26;payload)) break;
    <span class="hljs-comment">// 没有了</span>
    if (payload == env()-><span class="hljs-built_in">no_message_symbol</span>()) break;
    <span class="hljs-comment">// 执行 onmessage 回调</span>
    <span class="hljs-built_in">MakeCallback</span>(env()-><span class="hljs-built_in">onmessage_string</span>(), ...); 
  }
}
</code></pre>
<p>OnMessage 中为了避免单次处理的数据过多导致其他事件无法被处理，会在处理一定数量的消息后退出，等待下一次事件循环再处理，当有数据可以处理时，OnMessage 执行 ReceiveMessage 获取一个消息，然后调用 onmessage 回调通知 JS 层，JS 层会触发 message 事件通知用户。</p>
<pre><code class="hljs language-rust">MaybeLocal&#x3C;Value> MessagePort::<span class="hljs-title function_ invoke__">ReceiveMessage</span>(Local&#x3C;Context> context, ...) {
  Message received;
  {
    <span class="hljs-comment">// 互斥访问消息队列</span>
    Mutex::ScopedLock <span class="hljs-title function_ invoke__">lock</span>(data_<span class="hljs-punctuation">-></span>mutex_);
    <span class="hljs-comment">// 获取队列第一个消息</span>
    received = std::<span class="hljs-title function_ invoke__">move</span>(data_<span class="hljs-punctuation">-></span>incoming_messages_.<span class="hljs-title function_ invoke__">front</span>());
    data_<span class="hljs-punctuation">-></span>incoming_messages_.<span class="hljs-title function_ invoke__">pop_front</span>();
  }
  <span class="hljs-comment">// 反序列化后返回</span>
  <span class="hljs-keyword">return</span> received.<span class="hljs-title function_ invoke__">Deserialize</span>(<span class="hljs-title function_ invoke__">env</span>(), context);
}
</code></pre>
<p>ReceiveMessage 从消息队列中摘取一个消息，然后通过 Deserialize 反序列化后最终返回给 JS 层。</p>
<h2>MessageChannel</h2>
<p>MessageChannel 表示通信的两个端。</p>
<pre><code class="hljs language-scss">static void <span class="hljs-built_in">MessageChannel</span>(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {  
  Environment* env = Environment::GetCurrent(args);  
   
  Local&#x3C;Context> context = args<span class="hljs-selector-class">.This</span>()-><span class="hljs-built_in">CreationContext</span>();  
  Context::Scope context_scope(context);  
  
  MessagePort* port1 = MessagePort::New(env, context);  
  MessagePort* port2 = MessagePort::New(env, context);  
  <span class="hljs-comment">// 互相关联</span>
  MessagePort::Entangle(port1, port2);  
  <span class="hljs-comment">// port1->object() 拿到 JS 层使用的对象，它关联了一个 MessagePort 对象</span>
  args<span class="hljs-selector-class">.This</span>()-><span class="hljs-built_in">Set</span>(context, env->port1_string(), port1-><span class="hljs-selector-tag">object</span>())  
      <span class="hljs-selector-class">.Check</span>();  
  args<span class="hljs-selector-class">.This</span>()-><span class="hljs-built_in">Set</span>(context, env->port2_string(), port2-><span class="hljs-selector-tag">object</span>())  
      <span class="hljs-selector-class">.Check</span>();  
}  
</code></pre>
<p>MessageChannel 的逻辑比较简单，新建两个消息端口，并且关联起来，后续就可以基于这两个端口进行通信了。 Message、MessagePortData、MessagePort 和 MessageChannel 的关系图如图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f748c56924b4849a1cefe9e0cb77961~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h1>多线程的实现</h1>
<p>了解了线程间通信的实现后，我们就可以开始分析子线程的实现了。前面讲过，可以通过 new Worker 创建一个子线程，所以下面看一下 Worker 函数的实现，代码比较复杂，我们逐步分析。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 忽略一系列参数处理，调用 C++ 层函数</span>
  this<span class="hljs-selector-attr">[kHandle]</span> = new <span class="hljs-built_in">Worker</span>(...);  
</code></pre>
<p>上面的代码中首先调用 C++ 层的 API 创建了一个 Worker 对象，以下是 C++ 层 Worker 的构造函数。</p>
<pre><code class="hljs language-scss">Worker::Worker(Environment* env, Local&#x3C;Object> wrap,...) {    
    
  <span class="hljs-comment">// 新建一个端口和子线程通信    </span>
  parent_port_ = MessagePort::New(env, env->context());     
  <span class="hljs-comment">// 创建子 MessagePortData，但是还没有关联到 MessagePort    </span>
  child_port_data_ = std::make_unique&#x3C;MessagePortData>(nullptr);   
  <span class="hljs-comment">/*
    把父子线程的 MessagePortData 对象关联起来
  */</span> 
  MessagePort::Entangle(parent_port_, child_port_data_.get());    
  <span class="hljs-comment">// 设置 JS 层 Worker 对象的 messagePort 属性为 parent_port_    </span>
  <span class="hljs-selector-tag">object</span>()-><span class="hljs-built_in">Set</span>(env->context(),    
                env-><span class="hljs-built_in">message_port_string</span>(),    
                parent_port_-><span class="hljs-selector-tag">object</span>())<span class="hljs-selector-class">.Check</span>(); 
}   
</code></pre>
<p>Worker 构造函数初始化完毕后结构图如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/567ba6285cf74a369d4bd189beee77d0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>Worker 构造函数只是初始化了一下线程间通信的字段，然后返回 JS 层继续分析。</p>
<pre><code class="hljs language-kotlin">  <span class="hljs-comment">// this[kPort] 指向本端端口，用于 Node.js 内部，实现父线程和子线程通信</span>
  <span class="hljs-keyword">this</span>[kPort] = <span class="hljs-keyword">this</span>[kHandle].messagePort;  
  <span class="hljs-comment">// 监听子线程消息</span>
  <span class="hljs-keyword">this</span>[kPort].on(<span class="hljs-string">'message'</span>, (<span class="hljs-keyword">data</span>) => <span class="hljs-keyword">this</span>[kOnMessage](<span class="hljs-keyword">data</span>));
  <span class="hljs-comment">// 开启接收消息  </span>
  <span class="hljs-keyword">this</span>[kPort].start();  
</code></pre>
<p>JS 层拿到了 C++ 层返回的端口，该端口用于 Node.js 内部，用于父线程和子线程通信，继续往下看。</p>
<pre><code class="hljs language-javascript"> <span class="hljs-comment">// 申请一个通信通道，两个端口，用户代码可以使用这两个端口进行线程间通信  </span>
  <span class="hljs-keyword">const</span> { port1, port2 } = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>(); 
  <span class="hljs-comment">//  父线程端口</span>
  <span class="hljs-variable language_">this</span>[kPublicPort] = port1;  
  <span class="hljs-comment">// 监听消息</span>
  <span class="hljs-variable language_">this</span>[kPublicPort].<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =></span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'message'</span>, message));  
</code></pre>
<p>接着，Node.js 通过 MessageChannel 创建了另一组端口，这两个端口是给用户使用的，也是用于父线程和子线程通信。接下来，Node.js 会给子线程发送消息。</p>
<pre><code class="hljs language-php">  <span class="hljs-comment">// 向另一端（子线程）发送消息  </span>
  this[kPort].<span class="hljs-title function_ invoke__">postMessage</span>({  
    argv,  
    // 消息类型
    <span class="hljs-attr">type</span>: messageTypes.LOAD_SCRIPT, 
    // 子线程中执行的 JS 文件，如果 options.<span class="hljs-keyword">eval</span>, 为 <span class="hljs-literal">true</span>，则 filename 是被子线程执行的代码
    filename,  
    <span class="hljs-attr">doEval</span>: !!options.<span class="hljs-keyword">eval</span>,   
    // 传递给子线程的数据
    <span class="hljs-attr">workerData</span>: options.workerData,  
    // 传递 port2 给子线程，用于用这个端口和父线程通信
    <span class="hljs-attr">publicPort</span>: port2,   
  }, [port2]);  
</code></pre>
<p>this[kPort] 是 C++ 返回的端口，通过 this[kPort] 可以给子线程发送消息，从前面的分析中可以看到，子线程的 MessagePortData 指向了 nullptr，所以消息只存在于 MessagePortData 中，还没有 MessagePort 处理。</p>
<p>发送完消息后，真正启动线程。</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// 开启线程  </span>
  <span class="hljs-keyword">this</span>[kHandle].startThread(); 
</code></pre>
<p>我们看一下 C++ 层的 StartThread。</p>
<pre><code class="hljs language-scss">void Worker::StartThread(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {  
  Worker* w;  
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;w, args.This());   
  <span class="hljs-comment">// 创建线程  </span>
  <span class="hljs-built_in">uv_thread_create_ex</span>(&#x26;w->tid_, &#x26;thread_options, [](void* arg) {  
    <span class="hljs-comment">// 子线程里执行以下代码</span>
    Worker* w = static_cast&#x3C;Worker*>(arg);  
    const uintptr_t stack_top = reinterpret_cast&#x3C;uintptr_t>(&#x26;arg);  
    <span class="hljs-comment">// 执行主逻辑  </span>
    w-><span class="hljs-built_in">Run</span>();  
}  
</code></pre>
<p>StartThread 新建了一个子线程，然后在子线程中执行 Run，我们继续看 Run。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Worker::Run</span><span class="hljs-params">()</span> </span>{  
  <span class="hljs-comment">// 线程执行所需要的数据结构，比如 loop，isolate，和主线程独立  </span>
  <span class="hljs-function">WorkerThreadData <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;  
}  
</code></pre>
<p>Run 中首先创建了一个 WorkerThreadData 对象，它保存了子线程执行时所需要的数据结构，比如 loop、isolate。</p>
<pre><code class="hljs language-ini">class WorkerThreadData {
 public:
  explicit WorkerThreadData(Worker* w)
    : w_(w) {
    // 创建新的 ArrayBuffer 内存分配器
    std::shared_ptr&#x3C;ArrayBufferAllocator> <span class="hljs-attr">allocator</span> = ArrayBufferAllocator::Create()<span class="hljs-comment">;</span>
    Isolate::CreateParams params<span class="hljs-comment">;</span>
    SetIsolateCreateParamsForNode(&#x26;params)<span class="hljs-comment">;</span>
    <span class="hljs-attr">params.array_buffer_allocator_shared</span> = allocator<span class="hljs-comment">;</span>
    // 创建新的 Isolate
    Isolate* <span class="hljs-attr">isolate</span> = Isolate::Allocate()<span class="hljs-comment">;</span>
    Isolate::Initialize(isolate, params)<span class="hljs-comment">;</span>
    {
      Locker locker(isolate)<span class="hljs-comment">;</span>
      Isolate::Scope isolate_scope(isolate)<span class="hljs-comment">;</span>

      HandleScope handle_scope(isolate)<span class="hljs-comment">;</span>
      // 创建一个对象保存子线程的数据
      isolate_data_.reset(CreateIsolateData(isolate,
                                            &#x26;loop_,
                                            w_->platform_,
                                            allocator.get()))<span class="hljs-comment">;</span>
    }
    // 更新子线程的 isolate
    w_-><span class="hljs-attr">isolate_</span> = isolate<span class="hljs-comment">;</span>
  }
 private:
  Worker* const w_<span class="hljs-comment">;</span>
  // 子线程的事件循环结构体
  uv_loop_t loop_<span class="hljs-comment">;</span>
  // Isolate 等信息
  DeleteFnPtr&#x3C;IsolateData, FreeIsolateData> isolate_data_<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>创建完 IsolateData 对象后，继续往下看。</p>
<pre><code class="hljs language-scss">
  {    
    <span class="hljs-comment">// std::unique_ptr&#x3C;Environment, FreeEnvironment> env_;  </span>
    DeleteFnPtr&#x3C;Environment, FreeEnvironment> env_;  
    {  
      HandleScope <span class="hljs-built_in">handle_scope</span>(isolate_);  
      Local&#x3C;Context> context;  
      <span class="hljs-comment">// 新建 一个context，和主线程独立  </span>
      context = <span class="hljs-built_in">NewContext</span>(isolate_);  
      Context::Scope context_scope(context);  
      {  
        <span class="hljs-comment">// 新建一个 env 并初始化，env 中会和新的 context 关联  </span>
        env_<span class="hljs-selector-class">.reset</span>(new Environment(data.isolate_data_.get(),  
                                   context,  
                                   std::move(argv_),  
                                   std::move(exec_argv_),  
                                   Environment::kNoFlags,  
                                   thread_id_));  
        <span class="hljs-comment">// 初始化 Libuv 相关的数据结构</span>
        env_-><span class="hljs-built_in">InitializeLibuv</span>(start_profiler_idle_notifier_);  
      }  
      {  
        Mutex::ScopedLock lock(mutex_);  
        <span class="hljs-comment">// 更新子线程所属的 env  </span>
        this->env_ = env_<span class="hljs-selector-class">.get</span>();  
      }  
        
      { 
        <span class="hljs-comment">// 执行内置 JS 和初始化模块加载器</span>
        if (!env_->RunBootstrapping()<span class="hljs-selector-class">.IsEmpty</span>()) { 
          <span class="hljs-comment">// 创建通信端口 </span>
          <span class="hljs-built_in">CreateEnvMessagePort</span>(env_.get());  
          <span class="hljs-comment">// 执行 internal/main/worker_thread.js</span>
          <span class="hljs-built_in">USE</span>(StartExecution(env_.get(), "internal/<span class="hljs-selector-tag">main</span>/worker_thread"));  
        }  
      }  
  
      {  
        SealHandleScope <span class="hljs-built_in">seal</span>(isolate_);  
        bool more;  
        <span class="hljs-comment">// 开始事件循环  </span>
        do {  
          <span class="hljs-built_in">uv_run</span>(&#x26;data.loop_, UV_RUN_DEFAULT);  
        } while (more == true &#x26;&#x26; !is_stopped());  
      }  
    }  
</code></pre>
<p>上面的代码中，主要创建了一个新的 Context 和 Environment 对象并且互相关联起来，其余的逻辑和主线程启动类似，我们已经讲过就不再详细分析。这里重点讲一下 CreateEnvMessagePort 的逻辑。</p>
<pre><code class="hljs language-css">void Worker::<span class="hljs-built_in">CreateEnvMessagePort</span>(Environment* env) {  
  // 创建一个 MessagePort，和 child_port_data_（MessagePortData） 互相关联
  child_port_ = MessagePort::<span class="hljs-built_in">New</span>(env,
                                 env-><span class="hljs-built_in">context</span>(),  
                                 std::<span class="hljs-built_in">move</span>(child_port_data_));  
  if (child_port_ != nullptr)  
    env->set_message_port(child_port_-><span class="hljs-selector-tag">object</span>(isolate_));  
}  
</code></pre>
<p>前面分析主线程中执行 new Worker 时讲过，child_port_data_ 还没有关联 MessagePort 对象，CreateEnvMessagePort 中请一个新的端口并且和 child_port_data_ 互相关联起来，看一下 MessagePort::New 的逻辑。</p>
<pre><code class="hljs language-scss">MessagePort* MessagePort::New(
    Environment* env,
    Local&#x3C;Context> context,
    std::unique_ptr&#x3C;MessagePortData> data) {
  Context::Scope context_scope(context);
  <span class="hljs-comment">// 获取一个函数模版</span>
  Local&#x3C;FunctionTemplate> ctor_templ = <span class="hljs-built_in">GetMessagePortConstructorTemplate</span>(env);

  Local&#x3C;<span class="hljs-selector-tag">Object</span>> instance;
  <span class="hljs-comment">// 创建一个 JS 层使用的对象</span>
  if (!ctor_templ->InstanceTemplate()-><span class="hljs-built_in">NewInstance</span>(context)<span class="hljs-selector-class">.ToLocal</span>(&#x26;instance))
    return nullptr;
  <span class="hljs-comment">// 创建一个 MessagePort 对象，并和刚才创建的 JS 对象关联起来</span>
  MessagePort* port = new <span class="hljs-built_in">MessagePort</span>(env, context, instance);
  <span class="hljs-comment">// 需要关联的 MessagePortData</span>
  if (data) {
    <span class="hljs-comment">// 指向 MessagePortData 对象</span>
    port->data_ = std::move(data);
    <span class="hljs-comment">// 修改 MessagePortData 的 owner 为当前消息端口</span>
    port->data_->owner_ = port;
    <span class="hljs-comment">// MessagePortData 如果有缓存的消息则通知 port 处理</span>
    port-><span class="hljs-built_in">TriggerAsync</span>();
  }
  return port;
}
</code></pre>
<p>MessagePort::New 执行完毕后返回一个 MessagePort 对象，Node.js 接着把它缓存到 env 中，后续会使用。这时候的关系图如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ee849e2b2e140d4af50832631820ff9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>至此，子线程启动成功，接着来分析子线程的执行逻辑。子线程启动的过程中会首先执行internal/main/worker_thread.js。</p>
<pre><code class="hljs language-ini"> // 获取刚才缓存在 env 中的端口（child_port_） 
onst <span class="hljs-attr">port</span> = getEnvMessagePort()<span class="hljs-comment">;  </span>
// 接收来自父线程的消息
port.on('message', (message) => {  
  // 加载脚本  
  if (<span class="hljs-attr">message.type</span> === LOAD_SCRIPT) {  
    const {  
      argv,  
      cwdCounter,  
      filename,  
      doEval,  
      workerData,  
      publicPort,  
      manifestSrc,  
      manifestURL,  
      hasStdin  
    } = message<span class="hljs-comment">;  </span>
  
    const <span class="hljs-attr">CJSLoader</span> = require(<span class="hljs-string">'internal/modules/cjs/loader'</span>)<span class="hljs-comment">;  </span>
    // 加载预加载模块
    loadPreloadModules()<span class="hljs-comment">;  </span>
    /* 
        主线程传递过来的端口，即我们平时在代码里使用的 parentPort 变量
    */  
    <span class="hljs-attr">publicWorker.parentPort</span> = publicPort<span class="hljs-comment">;  </span>
    // 主线程传递过来的数据
    <span class="hljs-attr">publicWorker.workerData</span> = workerData<span class="hljs-comment">;  </span>
    // 通知主线程，正在执行脚本  
    port.postMessage({ type: UP_AND_RUNNING })<span class="hljs-comment">;  </span>
    // 执行 new Worker(filename) 时传入的文件  
    CJSLoader.Module.runMain(filename)<span class="hljs-comment">;  </span>
})<span class="hljs-comment">;</span>
// 开始接收消息  
port.start()  
</code></pre>
<p>前面讲过，父线程创建子线程时会发送一个类型为 LOAD_SCRIPT 的消息，子线程启动时就会处理这个消息，子线程首先保存父线程传递过来的数据，然后通过 runMain 执行用户的代码，最后开始事件循环，这样子线程就真正启动起来了。</p>
<p>子线程启动后，有两种情况下会退出，分别是事件循环退出和用户手动执行 terminate。首先看一下<strong>当事件循环结束时</strong>的逻辑。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 给主线程提交一个任务，通知主线程子线程执行完毕    </span>
w-><span class="hljs-built_in">env</span>()-><span class="hljs-built_in">SetImmediateThreadsafe</span>(    
    [w = std::unique_ptr&#x3C;Worker>(w)](Environment* env) {       
      w-><span class="hljs-built_in">JoinThread</span>();      
    });    
}, static_cast&#x3C;void*>(w)), <span class="hljs-number">0</span>);    
</code></pre>
<p>SetImmediateThreadsafe 用于给另一个线程插入一个任务，这里是子线程给父线程插入一个任务，然后在父线程中执行 JoinThread 等待子线程退出。</p>
<pre><code class="hljs language-scss">void Worker::JoinThread() {  
    <span class="hljs-comment">// 阻塞等待子线程结束 </span>
    <span class="hljs-built_in">uv_thread_join</span>(&#x26;tid_);  
    thread_joined_ = true;   
    <span class="hljs-comment">// 执行 JS 层回调，触发 exit 事件  </span>
    <span class="hljs-built_in">MakeCallback</span>(env()-><span class="hljs-built_in">onexit_string</span>(), ...); 
}  
</code></pre>
<p>JoinThread 是对 uv_thread_join 的封装，uv_thread_join 用于阻塞式等待子线程退出，当子线程退出后 uv_thread_join 返回，最后执行 JS 的 onexit 回调触发 exit 事件。</p>
<p>接着，我们再来看<strong>在主线程里执行 terminate 函数时</strong>是如何停止子线程的。</p>
<pre><code class="hljs language-scss"><span class="hljs-built_in">terminate</span>(callback) {  
    this<span class="hljs-selector-attr">[kHandle]</span><span class="hljs-selector-class">.stopThread</span>();  
}  

<span class="hljs-comment">// Terminate是对C++模块stopThread的封装。</span>
void Worker::StopThread(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {  
  Worker* w;  
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;w, args.This());  
  w-><span class="hljs-built_in">Exit</span>(<span class="hljs-number">1</span>);  
}  
  
void Worker::Exit(int code) {  
  <span class="hljs-comment">// env_ 是子线程执行的 env </span>
  <span class="hljs-built_in">Stop</span>(env_);  
}  
  
  
int <span class="hljs-built_in">Stop</span>(Environment* env) {  
  env-><span class="hljs-built_in">ExitEnv</span>();  
  return <span class="hljs-number">0</span>;  
}  
  
void Environment::ExitEnv() {  
  <span class="hljs-built_in">set_can_call_into_js</span>(false);  
  <span class="hljs-built_in">set_stopping</span>(true);  
  <span class="hljs-comment">// 停止执行代码</span>
  isolate_-><span class="hljs-built_in">TerminateExecution</span>();  
  <span class="hljs-comment">// 给子线程提交一个任务</span>
  <span class="hljs-built_in">SetImmediateThreadsafe</span>([](Environment* env) { <span class="hljs-built_in">uv_stop</span>(env->event_loop()); });  
}  
</code></pre>
<p>主线程首先执行 TerminateExecution 终止 JS 的执行，然后通过 SetImmediateThreadsafe 给子线程提交了一个任务，接着在子线程中执行 uv_stop 设置事件循环为结束状态，等到下一次事件循环开始时，就会跳出事件循环从而结束子线程的执行。</p>
<h1>总结</h1>
<p>Node.js 的单线程使开发者使用起来比较简单，但是也带来了很多限制，比如执行的代码不能耗时太久，否则后面的代码就会被延迟很久才能知执行。虽然 Node.js 底层已经通过 Libuv 线程池处理了一部分耗时和阻塞式的任务，但是用户只能在 C、C++ 层使用 Libuv 线程池，如果想把耗时的 JS 代码放到线程池里执行则是行不通的。因此，还需要一种方案来支持执行耗时的 JS 代码，这就是 worker_threads 模块的作用。当然，我们也可以在 worker_threads 里执行其它代码。</p>
<p>随着 worker_threads 的成熟，我们在日常开发中可能会用到 worker_threads 来解决遇到的问题，所以这节课详细讲解了 worker_threads 的内容。</p>
<ol>
<li>多线程的使用：worker_threads 有多种使用方式，可以通过 new Worker(__filename) 创建一个子线程，然后通过 isMainThread 变量判断当前是否是主线程，再决定执行主线程还是子线程的代码，也可以通过 new Worker(filename) 的方式执行一个单独 JS 文件，还可以通过 new Worker(code, {eval: true}) 的方式直接执行一段代码。 随着 worker_threads 的成熟，支持的特性也越来越多，比如环境变量、数据转移等等，线程间还可以通过 MessageChannel 机制进行数据通信。</li>
<li>线程间通信的实现：worker_threads 中通过一种 MessageChannel 机制实现线程间通信。我们需要了解相关的基础数据结构才能更好地理解线程间通信的实现， Message 表示一个序列化的消息，MessagePortData 负责管理消息，MessagePort 负责处理消息，MessageChannel 是对 MessagePort 的封装，两个 MessagePort 就是一个 MessageChannel。</li>
<li>子线程的实现：这是这节课最重要的内容，子线程的实现底层基础是 uv_thread_create_ex 函数，该函数可以创建一个新的线程，父线程会通过内部的通信端口给新创建的线程发送 LOAD_SCRIPT 命令和一些参数，子线程启动后会从通信端口中获取父线程发送过来的消息，然后执行用户设置的 JS 文件或 JS 代码。另外，子线程还会保存父线程传递过来的一些数据，比如 workData 和通信端口等，后续可以在代码里使用。</li>
</ol></div>
</body></html>