<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>setImmediate、nextTick 和 setTimeout 的实现</h1>
<p>在 Node.js 中，可以通过 setImmediate、nextTick 和 setTimeout 产生一个任务，然后这个任务会在未来的某个时机被执行。那么这些 API 有什么区别呢？它们又是什么时候、如何被处理的呢？这节课我们会深入讲解这些 API 的实现，它可以帮助我们更全面地理解 Node.js。</p>
<h1>setImmediate</h1>
<p>首先看一下 setImmediate，setImmediate 用于注册任务到事件循环的 check 阶段，注册的任务会在 check 阶段被执行。下面看看实现。</p>
<h2>设置处理 immediate 任务的函数</h2>
<p>在 Node.js 初始化的时候，设置了处理 immediate 任务的函数：</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// runNextTicks 用于处理 nextTick 产生的任务，这里不关注  </span>
const { processImmediate } = <span class="hljs-built_in">getTimerCallbacks</span>(runNextTicks);  
<span class="hljs-built_in">setupTimers</span>(processImmediate, ...); 
</code></pre>
<p>setupTimers 是 C++ 层导出的函数 SetupTimers。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">SetupTimers</span>(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {  
  auto env = Environment::GetCurrent(args);  
  env-><span class="hljs-built_in">set_immediate_callback_function</span>(args[<span class="hljs-number">0</span>].As&#x3C;Function>());  
}  
</code></pre>
<p>SetupTimers 在 env 中保存了 processImmediate，下面会看到具体的调用时机。</p>
<h2>注册 check 阶段的回调</h2>
<p>除了注册任务处理函数，Node.js 初始化时，同时初始化了 immediate 任务相关的数据结构和逻辑。</p>
<pre><code class="hljs language-scss">void Environment::InitializeLibuv(bool start_profiler_idle_notifier) { 
  <span class="hljs-comment">// 初始化 immediate 相关的 handle </span>
  <span class="hljs-built_in">uv_check_init</span>(event_loop(), <span class="hljs-built_in">immediate_check_handle</span>());  
  <span class="hljs-comment">// 修改状态为 unref，避免没有任务的时候，影响事件循环的退出  </span>
  <span class="hljs-built_in">uv_unref</span>(reinterpret_cast&#x3C;uv_handle_t*>(immediate_check_handle()));  
  <span class="hljs-comment">// 激活 handle，设置回调</span>
  <span class="hljs-built_in">uv_check_start</span>(immediate_check_handle(), CheckImmediate);   
  <span class="hljs-comment">// 初始化一个 idle 阶段的节点</span>
  <span class="hljs-built_in">uv_idle_init</span>(event_loop(), <span class="hljs-built_in">immediate_idle_handle</span>());
}  
</code></pre>
<p>上面的代码虽然只有几句，却涉及很多 Libuv 的内容，下面详细讲解下。</p>
<p>Node.js 初始化时会往 check 阶段插入一个 handle 节点，并设置回调为 CheckImmediate，但状态是 unref，unref 状态的 handle 不会影响事件循环的退出，这样就会带来一个问题，那就是如果 Node.js 里有 immediate 任务，但事件循环却退出了，这是不符合预期的。</p>
<p>大家可能会觉得可以根据是否有 immediate 任务修改 handle 状态，这的确是一个思路，但这里还有一个问题和 Libuv 的设计有关，Libuv 判断是否需要阻塞在 Poll IO 阶段时，没有把 check 阶段的任务考虑在内，我们可以看看下面用于计算 Poll IO 阶段是否需要阻塞或阻塞多久的逻辑。</p>
<pre><code class="hljs language-rust">int <span class="hljs-title function_ invoke__">uv_backend_timeout</span>(<span class="hljs-keyword">const</span> uv_loop_t* <span class="hljs-keyword">loop</span>) {
  <span class="hljs-title function_ invoke__">if</span> (<span class="hljs-keyword">loop</span><span class="hljs-punctuation">-></span>stop_flag != <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-title function_ invoke__">if</span> (!<span class="hljs-title function_ invoke__">uv__has_active_handles</span>(<span class="hljs-keyword">loop</span>) &#x26;&#x26; !<span class="hljs-title function_ invoke__">uv__has_active_reqs</span>(<span class="hljs-keyword">loop</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-title function_ invoke__">if</span> (!<span class="hljs-title function_ invoke__">QUEUE_EMPTY</span>(&#x26;<span class="hljs-keyword">loop</span><span class="hljs-punctuation">-></span>idle_handles))
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-title function_ invoke__">if</span> (!<span class="hljs-title function_ invoke__">QUEUE_EMPTY</span>(&#x26;<span class="hljs-keyword">loop</span><span class="hljs-punctuation">-></span>pending_queue))
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-title function_ invoke__">if</span> (<span class="hljs-keyword">loop</span><span class="hljs-punctuation">-></span>closing_handles)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">uv__next_timeout</span>(<span class="hljs-keyword">loop</span>);
}
</code></pre>
<p>可以看到，哪怕有 check 阶段的任务，Poll IO 阶段还是可能会一直阻塞，这样一来 check 任务就无法按时执行了。这是 Libuv 的设计，但 Node.js 并不希望这样，它希望用户通过 setImmediate 产生一个任务之后可以尽快执行。</p>
<p>针对这个问题，Node.js 使用的解决办法是在设置一个 unref 状态的 check handle 的前提下，再通过增加一个 idle handle 来控制 Poll IO 阶段是否可以阻塞以及是否允许事件循环的退出（根据是否有 immediate 任务）。从上面代码中可以看到，idle 阶段的任务可以控制 Poll IO 会不会发生阻塞，这就是为什么 Node.js 会初始化一个 idle 节点，后面我们可以看到它的用处。</p>
<p>初始化完毕后，接下来看看创建一个 Immediate 任务的逻辑。</p>
<h2>创建任务</h2>
<p>我们可以通过 setImmediate 生成一个任务。</p>
<pre><code class="hljs language-ini">function setImmediate(callback, arg1, arg2, arg3) {  
  let i, args<span class="hljs-comment">;  </span>
  switch (arguments.length) {  
    case 1:  
      break<span class="hljs-comment">;  </span>
    case 2:  
      <span class="hljs-attr">args</span> = [arg1]<span class="hljs-comment">;  </span>
      break<span class="hljs-comment">;  </span>
    case 3:  
      <span class="hljs-attr">args</span> = [arg1, arg2]<span class="hljs-comment">;  </span>
      break<span class="hljs-comment">;  </span>
    default:  
      <span class="hljs-attr">args</span> = [arg1, arg2, arg3]<span class="hljs-comment">;  </span>
      for (<span class="hljs-attr">i</span> = <span class="hljs-number">4</span><span class="hljs-comment">; i &#x3C; arguments.length; i++) {  </span>
        args<span class="hljs-section">[i - 1]</span> = arguments<span class="hljs-section">[i]</span><span class="hljs-comment">;  </span>
      }  
      break<span class="hljs-comment">;  </span>
  }  
  
  return new Immediate(callback, args)<span class="hljs-comment">;  </span>
}          
</code></pre>
<p>setImmediate的代码比较简单，新建一个Immediate，下面是 Immediate 的类。</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">const</span> Immediate = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Immediate</span> </span>{  
  <span class="hljs-keyword">constructor</span>(callback, args) {  
    <span class="hljs-keyword">this</span>._idleNext = <span class="hljs-literal">null</span>;  
    <span class="hljs-keyword">this</span>._idlePrev = <span class="hljs-literal">null</span>;  
    <span class="hljs-keyword">this</span>._onImmediate = callback;  
    <span class="hljs-keyword">this</span>._argv = args;  
    <span class="hljs-keyword">this</span>._destroyed = <span class="hljs-literal">false</span>;  
    <span class="hljs-keyword">this</span>[kRefed] = <span class="hljs-literal">false</span>;    
    <span class="hljs-keyword">this</span>.ref();  
    <span class="hljs-comment">// Immediate 链表的节点个数，包括 ref 和 unref 状态  </span>
    immediateInfo[kCount]++;  
    <span class="hljs-comment">// 加入链表中  </span>
    immediateQueue.append(<span class="hljs-keyword">this</span>);  
  }  
  <span class="hljs-comment">// 打上 ref 标记，往 Libuv 的 idle 链表插入一个激活状态的节点，如果还没有的话  </span>
  ref() {    
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[kRefed] === <span class="hljs-literal">false</span>) {  
      <span class="hljs-keyword">this</span>[kRefed] = <span class="hljs-literal">true</span>;  
      <span class="hljs-keyword">if</span> (immediateInfo[kRefCount]++ === <span class="hljs-number">0</span>)  
        toggleImmediateRef(<span class="hljs-literal">true</span>);  
    }  
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;  
  }  
  <span class="hljs-comment">// 和上面相反  </span>
  unref() {  
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[kRefed] === <span class="hljs-literal">true</span>) {  
      <span class="hljs-keyword">this</span>[kRefed] = <span class="hljs-literal">false</span>;  
      <span class="hljs-keyword">if</span> (--immediateInfo[kRefCount] === <span class="hljs-number">0</span>)  
        toggleImmediateRef(<span class="hljs-literal">false</span>);  
    }  
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;  
  }  
  
  hasRef() {  
    <span class="hljs-keyword">return</span> !!<span class="hljs-keyword">this</span>[kRefed];  
  }  
};  
</code></pre>
<p>Immediate 类主要做了两件事儿。首先生成一个节点插入到链表，链表结构如下。</p>
<pre><code class="hljs language-ini">const <span class="hljs-attr">immediateQueue</span> = new ImmediateList()<span class="hljs-comment">;  </span>
  
// 双向非循环的链表  
function ImmediateList() {  
  <span class="hljs-attr">this.head</span> = null<span class="hljs-comment">;  </span>
  <span class="hljs-attr">this.tail</span> = null<span class="hljs-comment">;  </span>
}  

<span class="hljs-attr">ImmediateList.prototype.append</span> = function(item) {  
  // 尾指针非空，说明链表非空，直接追加在尾节点后面  
  if (this.tail !== null) {  
    <span class="hljs-attr">this.tail._idleNext</span> = item<span class="hljs-comment">;  </span>
    <span class="hljs-attr">item._idlePrev</span> = this.tail<span class="hljs-comment">;  </span>
  } else {  
    // 尾指针是空说明链表是空的，头尾指针都指向item  
    <span class="hljs-attr">this.head</span> = item<span class="hljs-comment">;  </span>
  }  
  <span class="hljs-attr">this.tail</span> = item<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
  
<span class="hljs-attr">ImmediateList.prototype.remove</span> = function(item) {  
  // 如果item在中间则自己全身而退，前后两个节点连上  
  if (item._idleNext !== null) {  
    <span class="hljs-attr">item._idleNext._idlePrev</span> = item._idlePrev<span class="hljs-comment">;  </span>
  }  
  
  if (item._idlePrev !== null) {  
    <span class="hljs-attr">item._idlePrev._idleNext</span> = item._idleNext<span class="hljs-comment">;  </span>
  }  
  // 是头指针，则需要更新头指针指向item的下一个，因为item被删除了，尾指针同理  
  if (<span class="hljs-attr">item</span> === this.head)  
    <span class="hljs-attr">this.head</span> = item._idleNext<span class="hljs-comment">;  </span>
  if (<span class="hljs-attr">item</span> === this.tail)  
    <span class="hljs-attr">this.tail</span> = item._idlePrev<span class="hljs-comment">;  </span>
  // 重置前后指针  
  <span class="hljs-attr">item._idleNext</span> = null<span class="hljs-comment">;  </span>
  <span class="hljs-attr">item._idlePrev</span> = null<span class="hljs-comment">;  </span>
}<span class="hljs-comment">;  </span>
</code></pre>
<p>其次，更新任务个数相关的数据结构。如果 immediateInfo[kRefCount] 为 0，则说明还没有往 Libuv 的 idle 链表里插入 idle 节点，从之前的分析可以知道，Poll IO 阶段计算阻塞事件时，不会考虑 check 阶段的任务，但会考虑 idle 阶段的任务，所以当插入第一个 immediate 任务时，Node.js 会把这个 idle 节点插入 idle 阶段中，表示有任务处理，不能阻塞 Poll IO 阶段。没有 immediate 任务时，则移除 idle 节点。</p>
<p>总的来说，idle 节点的意义是<strong>标记是否有 immediate 任务需要处理</strong>，有的话就不能阻塞 Poll IO 阶段，并且不能退出事件循环，下面是 idle 节点的管理逻辑。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">ToggleImmediateRef</span>(const FunctionCallbackInfo&#x3C;Value>&#x26; args) { 
  Environment::GetCurrent(args)->ToggleImmediateRef(args[<span class="hljs-number">0</span>]->IsTrue())
}  
  
void Environment::ToggleImmediateRef(bool ref) {  
  if (started_cleanup_) return;  
  <span class="hljs-comment">// 插入 idle 队列，设置为 active 状态，防止在 Poll IO 阶段阻塞和事件循环的退出  </span>
  if (ref) { 
    <span class="hljs-built_in">uv_idle_start</span>(immediate_idle_handle(), <span class="hljs-selector-attr">[]</span>(uv_idle_t*){ });  
  } else {  
    <span class="hljs-comment">// 不阻塞 Poll IO，允许事件循环退出</span>
    <span class="hljs-built_in">uv_idle_stop</span>(immediate_idle_handle());  
  }  
}  
</code></pre>
<h2>处理任务</h2>
<p>最后，我们再来看看 check 阶段是如何处理 immediate 任务的，具体的内容在 CheckImmediate 函数中。</p>
<pre><code class="hljs language-scss">void Environment::CheckImmediate(uv_check_t* handle) {  
  <span class="hljs-comment">// 省略部分代码  </span>
  <span class="hljs-comment">// 没有 Immediate 任务需要处理  </span>
  if (env->immediate_info()-><span class="hljs-built_in">count</span>() == <span class="hljs-number">0</span> ||  !env-><span class="hljs-built_in">can_call_into_js</span>())  
    return;  
  do {  
    <span class="hljs-comment">// 执行 JS 层回调 immediate_callback_function  </span>
    <span class="hljs-built_in">MakeCallback</span>(env->isolate(),  
                 env-><span class="hljs-built_in">process_object</span>(),  
                 <span class="hljs-comment">// 初始化时设置的 env->immediate_callback_function() 函数</span>
                 env-><span class="hljs-built_in">immediate_callback_function</span>(), 
                 <span class="hljs-number">0</span>,  
                 nullptr,  
                 {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>})<span class="hljs-selector-class">.ToLocalChecked</span>();  
  } while (env->immediate_info()-><span class="hljs-built_in">has_outstanding</span>() &#x26;&#x26; env-><span class="hljs-built_in">can_call_into_js</span>());  
  <span class="hljs-comment">/* 
        所有 immediate 节点都处理完了，置 idle 阶段对应节点为非激活状态，
        允许 Poll IO 阶段阻塞和事件循环退出  
  */</span>
  if (env->immediate_info()-><span class="hljs-built_in">ref_count</span>() == <span class="hljs-number">0</span>)  
    env-><span class="hljs-built_in">ToggleImmediateRef</span>(false);  
}  
</code></pre>
<p>由前面分析我们可以知道，env->immediate_callback_function() 是 processImmediate 函数，下面是processImmediate 函数的逻辑。</p>
<pre><code class="hljs language-ini">function processImmediate() {  
  /*
      执行 processImmediate 时，会先把 immediateInfo<span class="hljs-section">[kHasOutstanding]</span> 置 1，
      就是设置执行 processImmediate 会有未捕获的异常，当有异常时 outstandingQueue 
      保存了未执行的节点，C++ 的 CheckImmediate 函数里会判断 
      env->immediate_info()->has_outstanding() 的值，为 true 则
      再次执行 processImmediate 处理 outstandingQueue 队列的节点  
  */
  const <span class="hljs-attr">queue</span> = outstandingQueue.head !== null ? outstandingQueue : immediateQueue<span class="hljs-comment">;  </span>
  let <span class="hljs-attr">immediate</span> = queue.head<span class="hljs-comment">;  </span>
  /* 
      在执行 immediateQueue 队列的话，先置空队列，避免执行回调
      的时候一直往队列加节点，死循环。所以新加的节点会插入新的队列， 不会在本次被执行。
      
      immediateInfo<span class="hljs-section">[kHasOutstanding]</span> 置 1，如果顺利执行完 processImmediate 则置 0，
      如果发生异常，则 CheckImmediate 中 env->immediate_info()->has_outstanding() 
      为 1， 会再次执行 processImmediate 处理剩余的任务（记录在 outstandingQueue 队列）
  */  
  if (queue !== outstandingQueue) {  
    <span class="hljs-attr">queue.head</span> = queue.tail = null<span class="hljs-comment">;  </span>
    immediateInfo<span class="hljs-section">[kHasOutstanding]</span> = 1<span class="hljs-comment">;  </span>
  }  
 
  let prevImmediate<span class="hljs-comment">;  </span>
  let <span class="hljs-attr">ranAtLeastOneImmediate</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;  </span>
  while (immediate !== null) {  
    // 执行微任务  
    if (ranAtLeastOneImmediate)  
      runNextTicks()<span class="hljs-comment">;  </span>
    else  
      <span class="hljs-attr">ranAtLeastOneImmediate</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;  </span>
 
    // 前面的任务或微任务把该节点删除了，则不需要执行它的回调了，继续下一个  
    // 任务被删除时会脱离链表，所以需要一个 prevImmediate 记录前一个节点，才能找到
    // 被销毁节点后面的一个节点
    if (immediate._destroyed) {  
      <span class="hljs-attr">outstandingQueue.head</span> = immediate = prevImmediate._idleNext<span class="hljs-comment">;  </span>
      continue<span class="hljs-comment">;  </span>
    }  
 
    <span class="hljs-attr">immediate._destroyed</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;  </span>
    // 执行完要修改个数  
    immediateInfo<span class="hljs-section">[kCount]</span>--<span class="hljs-comment">;  </span>
    if (immediate<span class="hljs-section">[kRefed]</span>)  
      immediateInfo<span class="hljs-section">[kRefCount]</span>--<span class="hljs-comment">;  </span>
    immediate<span class="hljs-section">[kRefed]</span> = null<span class="hljs-comment">;  </span>
    // 见上面if (immediate._destroyed)的注释  
    <span class="hljs-attr">prevImmediate</span> = immediate<span class="hljs-comment">;  </span>
    // 执行回调，指向下一个节点  
    try {  
      const <span class="hljs-attr">argv</span> = immediate._argv<span class="hljs-comment">;  </span>
      immediate._onImmediate(...argv)<span class="hljs-comment">;  </span>
    } finally {  
      <span class="hljs-attr">immediate._onImmediate</span> = null<span class="hljs-comment">;  </span>
      // immediate 指向下一个，下一轮 while 循环执行
      // outstandingQueue.head 也实时指向下一个节点，保证 processImmediate
      // 处理报错时，下次继续处理剩余的任务
      <span class="hljs-attr">outstandingQueue.head</span> = immediate = immediate._idleNext<span class="hljs-comment">;  </span>
    }  
  }  
  // 当前执行的是 outstandingQueue 的话则把它清空  
  if (<span class="hljs-attr">queue</span> === outstandingQueue)  
    <span class="hljs-attr">outstandingQueue.head</span> = null<span class="hljs-comment">;  </span>
  // 全部节点顺利执行完  
  immediateInfo<span class="hljs-section">[kHasOutstanding]</span> = 0<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>processImmediate 的逻辑就是逐个执行 immediate 任务队列的节点。setImmediate 函数把 immediate 任务插入到 immediateQueue 队列，正常情况下会被顺利执行完。如果执行时发生异常也需要保证后续任务可以继续执行，所以开始处理时，immediateInfo[kHasOutstanding] 为 1，且每次处理 immediate 后会把下一个剩余节点同时记录在 outstandingQueue 队列中。如果 immediate 任务执行异常，则会直接退出 processImmediate 函数，接着回到 C++ 的 CheckImmediate 中，这时候 env->immediate_info()->has_outstanding() 为 1，会继续处理剩余的任务。例如以下场景。</p>
<pre><code class="hljs language-javascript"><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();
});

<span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);
});

process.<span class="hljs-title function_">on</span>(<span class="hljs-string">'uncaughtException'</span>, <span class="hljs-function">() =></span>{})
</code></pre>
<h2>setTimeout(fn,0) 和 setImmediate</h2>
<p>setTimeout(fn, 0) 和 setImmediate 谁先执行的问题是一个比较热门的话题，我们首先看看下面这段代码：</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=></span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'setTimeout'</span>); },<span class="hljs-number">0</span>)  
<span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">()=></span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'setImmedate'</span>);})  
</code></pre>
<p>我们执行上面这段代码后，会发现输出是不确定的，这是为什么呢？</p>
<p>Node.js 的事件循环分为几个阶段( phase )。setTimeout 属于定时器阶段，setImmediate 属于 check 阶段。从顺序上来说，定时器阶段会比 check 阶段更早被执行。需要注意的是， setTimeout 的实现代码里有一个很重要的细节，我们一起来看下。</p>
<pre><code class="hljs language-ini">after *= 1<span class="hljs-comment">;</span>
if (!(after >= 1 &#x26;&#x26; after &#x3C;= TIMEOUT_MAX)) {  
  if (after > TIMEOUT_MAX) {  
    process.emitWarning(`错误提示`)<span class="hljs-comment">;  </span>
  }  
  <span class="hljs-attr">after</span> = <span class="hljs-number">1</span><span class="hljs-comment">; // schedule on next tick, follows browser behavior  </span>
}  
</code></pre>
<p>我们发现，虽然传的超时时间是 0，但是 0 不是合法值，Node.js 会把超时时间变成 1。这就导致了上面的代码输出不确定。Node.js 启动的时候，执行上面的代码，首先启动一个定时器，然后创建一个 setImmediate 任务，再进入Libuv 的事件循环。在执行定时器阶段，Libuv 判断从开启定时器到现在是否已经过去了 1 毫秒，是就执行定时器回调，否则会执行 check 阶段。从而执行 setImmediate 的回调。所以，一开始的那段代码的输出结果是取决于开始启动定时器到 Libuv 执行定时器阶段的时间是否过去了 1 毫秒。</p>
<h1>nextTick</h1>
<p>了解 setImmediate 后，接着来看另一个创建异步任务的 API nextTick。nextTick 用于异步执行一个回调函数，和 setTimeout、setImmediate 类似，但它们的执行时机不同。setTimeout 和 setImmediate 的任务属于事件循环的一部分，而 nextTick 的任务不属于事件循环的一部分，具体的执行细节我们会在后面分析。</p>
<h2>初始化</h2>
<p>nextTick 函数是在 Node.js 启动过程中挂载到 process 对象中的。</p>
<pre><code class="hljs language-ini">function setupTaskQueue() {   
  setTickCallback(processTicksAndRejections)<span class="hljs-comment">;  </span>
  return {  
    nextTick,  
  }<span class="hljs-comment">;  </span>
}
const { nextTick, runNextTicks } = setupTaskQueue()<span class="hljs-comment">;  </span>
<span class="hljs-attr">process.nextTick</span> = nextTick<span class="hljs-comment">;  </span>
</code></pre>
<p>setupTaskQueue 中除了返回 nextTick 函数外，还执行 setTickCallback 注册了处理 tick 任务的函数。</p>
<pre><code class="hljs language-scss">static void <span class="hljs-built_in">SetTickCallback</span>(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {  
  Environment* env = Environment::GetCurrent(args);  
  env-><span class="hljs-built_in">set_tick_callback_function</span>(args[<span class="hljs-number">0</span>].As&#x3C;Function>());  
}  
</code></pre>
<p>SetTickCallback 只是简单地保存处理 tick 任务的函数到 env 中，后续会用到。</p>
<h2>创建任务</h2>
<p>接着看一下 nextTick 是如何创建一个 tick 任务的。</p>
<pre><code class="hljs language-ini">function nextTick(callback) {  
  let args<span class="hljs-comment">;  </span>
  switch (arguments.length) {  
    case 1: break<span class="hljs-comment">;  </span>
    case 2: <span class="hljs-attr">args</span> = [arguments[<span class="hljs-number">1</span>]]<span class="hljs-comment">; break;  </span>
    case 3: <span class="hljs-attr">args</span> = [arguments[<span class="hljs-number">1</span>], arguments[<span class="hljs-number">2</span>]]<span class="hljs-comment">; break;  </span>
    case 4: <span class="hljs-attr">args</span> = [arguments[<span class="hljs-number">1</span>], arguments[<span class="hljs-number">2</span>], arguments[<span class="hljs-number">3</span>]]<span class="hljs-comment">; break;  </span>
    default:  
      <span class="hljs-attr">args</span> = new Array(arguments.length - <span class="hljs-number">1</span>)<span class="hljs-comment">;  </span>
      for (let <span class="hljs-attr">i</span> = <span class="hljs-number">1</span><span class="hljs-comment">; i &#x3C; arguments.length; i++)  </span>
        args<span class="hljs-section">[i - 1]</span> = arguments<span class="hljs-section">[i]</span><span class="hljs-comment">;  </span>
  }  
  // 第一个任务，开启 tick 处理逻辑，用于 C++ 层判断是否有 tick 任务需要处理  
  if (queue.isEmpty())  
    setHasTickScheduled(true)<span class="hljs-comment">;  </span>
  // 一个任务对应的上下文
  const <span class="hljs-attr">tickObject</span> = {  
    <span class="hljs-section">[async_id_symbol]</span>: asyncId,  
    <span class="hljs-section">[trigger_async_id_symbol]</span>: triggerAsyncId,  
    callback,  
    args  
  }<span class="hljs-comment">;  </span>
  // 插入队列  
  queue.push(tickObject)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>这就是我们执行 nextTick 时的逻辑，每次调用 nextTick 都会往队列中追加一个节点。</p>
<h2>处理任务</h2>
<p>我们再看一下处理的 tick 任务的逻辑。Nodejs 在初始化时，通过执行 setTickCallback(processTicksAndRejections) 注册了处理 tick 任务的函数。那什么时候会处理 tick 任务呢？一共有 3 个时机。</p>
<ol>
<li>每次执行完 JS 回调时。</li>
</ol>
<p>执行 JS 回调的函数是 MakeCallback。</p>
<pre><code class="hljs language-sql">MaybeLocal<span class="hljs-operator">&#x3C;</span><span class="hljs-keyword">Value</span><span class="hljs-operator">></span> AsyncWrap::MakeCallback(const <span class="hljs-keyword">Local</span><span class="hljs-operator">&#x3C;</span><span class="hljs-keyword">Function</span><span class="hljs-operator">></span> cb,
                                          <span class="hljs-type">int</span> argc,
                                          <span class="hljs-keyword">Local</span><span class="hljs-operator">&#x3C;</span><span class="hljs-keyword">Value</span><span class="hljs-operator">></span><span class="hljs-operator">*</span> argv) {
  
  MaybeLocal<span class="hljs-operator">&#x3C;</span><span class="hljs-keyword">Value</span><span class="hljs-operator">></span> ret <span class="hljs-operator">=</span> InternalMakeCallback(...);
}
</code></pre>
<p>MakeCallback 会调用 InternalCallbackScope。</p>
<pre><code class="hljs language-scss">MaybeLocal&#x3C;Value> <span class="hljs-built_in">InternalMakeCallback</span>(...) {  
  InternalCallbackScope <span class="hljs-built_in">scope</span>(env, recv, asyncContext);  
  <span class="hljs-comment">// 执行用户层 JS 回调  </span>
  scope<span class="hljs-selector-class">.Close</span>();  
  
  return ret;  
}  
</code></pre>
<p>InternalMakeCallback 里定义了一个 InternalCallbackScope 对象，并在执行完 JS 回调后执行 InternalCallbackScope 的 Close 函数。</p>
<pre><code class="hljs language-scss">void InternalCallbackScope::Close() {  
  <span class="hljs-comment">// 省略部分代码  </span>
  TickInfo* tick_info = env_-><span class="hljs-built_in">tick_info</span>();  
  <span class="hljs-comment">// 没有 tick 任务则不需要往下走，在插入 tick 任务的时候会设置这个为 true，</span>
  <span class="hljs-comment">// 没有任务时变成 false  </span>
  if (!tick_info->has_tick_scheduled() &#x26;&#x26; !tick_info-><span class="hljs-built_in">has_rejection_to_warn</span>()) {  
    return;  
  }  
  
  HandleScope <span class="hljs-built_in">handle_scope</span>(env_->isolate());  
  Local&#x3C;<span class="hljs-selector-tag">Object</span>> process = env_-><span class="hljs-built_in">process_object</span>();  
  
  <span class="hljs-comment">// 获取处理 tick 任务的函数  </span>
  Local&#x3C;Function> tick_callback = env_-><span class="hljs-built_in">tick_callback_function</span>();  
  <span class="hljs-comment">// 处理 tick 任务  </span>
  if (tick_callback->Call(env_->context(), process, <span class="hljs-number">0</span>, nullptr)<span class="hljs-selector-class">.IsEmpty</span>()) {  
    failed_ = true;  
  }  
}  
</code></pre>
<p>Close 函数中会判断是否有 tick 任务需要处理，有到话执行 tick 的处理函数 env_->tick_callback_function，也就是初始化时设置的 JS 函数 processTicksAndRejections，所以每次执行 JS 层的回调时就会处理 tick 任务，流程如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/696e01eb07044eb185995df7d95baa33~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<ol start="2">
<li>Node.js 启动时，执行完用户 JS 后。 在 InternalCallbackScope 对象析构时也会调用 Close 函数，下面是 Node.js 启动的部分代码。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/009f6c3dc07a49a882a6ffc4346f1dd1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>在第一个花括号结束后，InternalCallbackScope 对象就会被析构。</p>
<pre><code class="hljs language-scss">InternalCallbackScope::~InternalCallbackScope() {
  <span class="hljs-built_in">Close</span>();
}
</code></pre>
<p>析构函数里会调用 Close，从而处理 tick 任务，我们在主入口 JS 文件里执行 nextTick 函数生成的任务就会在这时候被执行。</p>
<ol start="3">
<li>补偿处理 因为 tick 属于微任务，根据规范，每执行完一个宏任务就会清空微任务。上面的 1 和 2 都符合这个规范，但也有些特例。首先我们看一下一般处理 JS 回调时的流程。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db6a513461444065b2be16b6c2b8abde~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>可以看到，通常一个底层任务完成时，会执行一个 JS 回调，并且是一对一的，比如异步读文件完成后执行用户的 JS 回调，如果回调里产生 tick 任务，则执行完回调后就会被执行。但是定时器和 setImmediate 比较特殊，因为这两个类型的任务做了一些优化，每次执行一次 JS 回调（Node.js 内置的 JS 函数）时会执行多个用户的 JS 回调，如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/444850b7594840a5b89684b68c33e30d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这样就会导致用户 JS 回调里产生的 tick 任务需要等待所有同类型的任务处理完后才能被处理（callback1 回调里产生的tick 任务没有在下一个宏任务（callback2）执行前被处理），而不是执行完一个用户 JS 回调后就被处理，这不符合规范，所以这一部分需要补偿处理一下。具体是通过 runNextTicks 实现的，我们可以看一下相关代码。</p>
<pre><code class="hljs language-ini">// Immediate 任务处理函数        
function processImmediate() {
  while (immediate !== null) {
    // 执行第一个任务时不需要执行 runNextTicks，执行后面的任务才需要
    if (ranAtLeastOneImmediate)
      runNextTicks()<span class="hljs-comment">;</span>
    else
      <span class="hljs-attr">ranAtLeastOneImmediate</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>

  }
}
        
// 定时器任务处理函数
function processTimers(now) {
   
   let <span class="hljs-attr">ranAtLeastOneList</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
   while (<span class="hljs-attr">list</span> = timerListQueue.peek()) {
     if (ranAtLeastOneList)
       runNextTicks()<span class="hljs-comment">;</span>
     else
       <span class="hljs-attr">ranAtLeastOneList</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
     listOnTimeout(list, now)<span class="hljs-comment">;</span>
   }
   return 0<span class="hljs-comment">;</span>
}

function listOnTimeout(list, now) {
    while (<span class="hljs-attr">timer</span> = L.peek(list)) {
      if (ranAtLeastOneTimer)
        runNextTicks()<span class="hljs-comment">;</span>
      else
        <span class="hljs-attr">ranAtLeastOneTimer</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
  }  
</code></pre>
<p>处理逻辑是类似的，就是除了处理第一个任务不需要执行 runNextTicks 外，处理剩下的任务都需要执行 runNextTicks，因为前一个任务可能会产生 tick 任务。最后看一下处理 tick 任务的具体逻辑，具体实现在 processTicksAndRejections 函数中。</p>
<pre><code class="hljs language-ini">function processTicksAndRejections() {  
  let tock<span class="hljs-comment">;  </span>
  do {  
    while (<span class="hljs-attr">tock</span> = queue.shift()) {  
      try {  
        const <span class="hljs-attr">callback</span> = tock.callback<span class="hljs-comment">;  </span>
        if (<span class="hljs-attr">tock.args</span> === undefined) {  
          callback()<span class="hljs-comment">;  </span>
        } else {  
          const <span class="hljs-attr">args</span> = tock.args<span class="hljs-comment">;  </span>
          switch (args.length) {  
            case 1: callback(args<span class="hljs-section">[0]</span>)<span class="hljs-comment">; break;  </span>
            case 2: callback(args<span class="hljs-section">[0]</span>, args<span class="hljs-section">[1]</span>)<span class="hljs-comment">; break;  </span>
            case 3: callback(args<span class="hljs-section">[0]</span>, args<span class="hljs-section">[1]</span>, args<span class="hljs-section">[2]</span>)<span class="hljs-comment">; break;  </span>
            case 4: callback(args<span class="hljs-section">[0]</span>, args<span class="hljs-section">[1]</span>, args<span class="hljs-section">[2]</span>, args<span class="hljs-section">[3]</span>)<span class="hljs-comment">; break;  </span>
            default: callback(...args)<span class="hljs-comment">;  </span>
          }  
        }  
      } finally {  
        //  。。。
      }   
    }  
    // 执行微任务，比如 Promise
    runMicrotasks()<span class="hljs-comment">;  </span>
  } while (!queue.isEmpty() || processPromiseRejections())<span class="hljs-comment">; </span>
  // 处理完设置标记 
  setHasTickScheduled(false)<span class="hljs-comment">;  </span>
  setHasRejectionToWarn(false)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>从 processTicksAndRejections 代码中我们可以看到，除了处理了 tick 任务外，还处理了其他微任务，比如 Promise。但有一个问题需要处理，就是 Node.js 是实时从任务队列里取节点执行的，如果我们在 nextTick 的回调里一直调用 nextTick 的话，就会导致死循环。</p>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">test</span>() {  
  process<span class="hljs-selector-class">.nextTick</span>(() => {  
    console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">1</span>);  
    <span class="hljs-built_in">test</span>()  
  });  
}  
<span class="hljs-built_in">test</span>();  
  
<span class="hljs-built_in">setTimeout</span>(() => {  
 console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">2</span>)  
}, <span class="hljs-number">10</span>);
</code></pre>
<p>上面的代码中，会一直输出 1，不会输出 2，所以我们需要防止 nextTick 的嵌套调用。</p>
<h2>使用</h2>
<p>我们知道 nextTick 可用于延迟执行一些逻辑，我们看一下哪些场景下可以使用 nextTick。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">EventEmitter</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);  
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoEvents</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> {  
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {  
    <span class="hljs-variable language_">super</span>();  
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'start'</span>);  
  }  
}  
  
<span class="hljs-keyword">const</span> demoEvents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoEvents</span>();  
demoEvents.<span class="hljs-title function_">on</span>(<span class="hljs-string">'start'</span>, <span class="hljs-function">() =></span> {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'start'</span>);  
});  
</code></pre>
<p>以上代码在构造函数中会触发 start 事件，但是事件的注册却在构造函数之后执行，而在构造函数之前我们还没有拿到 DemoEvents 对象，无法完成事件的注册。这时候，我们就可以使用nextTick。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">EventEmitter</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);  
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoEvents</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> {  
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {  
    <span class="hljs-variable language_">super</span>();  
    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =></span> {  
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'start'</span>);  
    })  
  }  
}  
  
<span class="hljs-keyword">const</span> demoEvents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoEvents</span>();  
demoEvents.<span class="hljs-title function_">on</span>(<span class="hljs-string">'start'</span>, <span class="hljs-function">() =></span> {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'start'</span>);  
});  
</code></pre>
<h1>定时器</h1>
<p>Node.js V14 对定时器模块进行了重构，之前版本的实现是用一个 map，以超时时间为键，每个键对应一个队列，即有同样相对超时时间的节点在同一个队列，每个队列对应 Libuv 的一个定时器节点（二叉堆里的节点）。Node.js 在事件循环的 timer 阶段会从二叉堆里找出超时的节点，然后执行回调，回调里会遍历队列，判断哪个节点超时了。</p>
<p>因为定时器是高频操作，JS 到 C、C++ 层数据转换的开销、内存申请 / 回收的开销等都会影响性能，所以重构后，Node.js 只使用了一个二叉堆的节点。我们看一下它的实现，首先是定时器模块的整体关系图，如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf56007efed3434096c48dfbd98dc20a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我们可以看到：</p>
<ol>
<li>Node.js在 JS 层维护了一个二叉堆；</li>
<li>堆的每个节点维护了一个链表，这个链表中最久超时的排到后面；</li>
<li>此外，Node.js 还维护了一个 map，map 的 key 是相对超时时间，值就是对应的二叉堆节点；</li>
<li>堆的所有节点对应底层的一个超时节点。</li>
</ol>
<p>当我们调用 setTimeout 的时候，首先根据 setTimeout 的入参，从 map 中找到二叉堆节点，然后插入链表的尾部。必要的时候，Node.js 会根据 JS 二叉堆的最快超时时间来更新底层节点的超时时间。当事件循环处理定时器阶段的时候，Node.js 会遍历 JS 二叉堆，然后拿到过期的节点，再遍历过期节点中的链表，逐个判断是否需要执行回调。必要的时候调整 JS 二叉堆和底层的超时时间。以上就是定时器的大致原理，深入讲解实现前，我们首先了解下定时器相关的几个核心数据结构。</p>
<h2>核心数据结构</h2>
<p>核心数据结构主要包括 TimersList 和优先队列，下面我们分别来看。首先，我们来说说 TimersList。</p>
<p>相对超时时间一样的定时器会被放到同一个队列，比如当前执行 setTimeout(()=>{}, 10000}) 和 5 秒后执行 setTimeout(()=>{}, 10000})，这两个任务就会在同一个 List 中，这个队列由TimersList 来管理。</p>
<pre><code class="hljs language-kotlin">function TimersList(expiry, msecs) {  
  <span class="hljs-comment">// 用于链表  </span>
  <span class="hljs-keyword">this</span>._idleNext = <span class="hljs-keyword">this</span>;   
  <span class="hljs-keyword">this</span>._idlePrev = <span class="hljs-keyword">this</span>;   
  <span class="hljs-comment">// 绝对时间</span>
  <span class="hljs-keyword">this</span>.expiry = expiry;  
  <span class="hljs-keyword">this</span>.id = timerListId++; 
  <span class="hljs-comment">// 相对时间</span>
  <span class="hljs-keyword">this</span>.msecs = msecs;  
  <span class="hljs-comment">// 在优先队列里的位置  </span>
  <span class="hljs-keyword">this</span>.priorityQueuePosition = <span class="hljs-literal">null</span>;  
}  
</code></pre>
<p>expiry 记录的是链表中最快超时的节点的绝对时间。每次执行定时器阶段时会动态更新，msecs 是超时时间的相对值（相对插入时的当前时间），用于计算该链表中的节点是否超时。后续我们会看到具体的用处。</p>
<ol>
<li>优先队列</li>
</ol>
<pre><code class="hljs language-arduino"><span class="hljs-type">const</span> timerListQueue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">PriorityQueue</span>(compareTimersLists, setPosition)  
</code></pre>
<p>Node.js 用优先队列对所有 TimersList 链表进行管理，优先队列本质是一个二叉堆（小根堆），每个 TimersList 链表在二叉堆里对应一个节点。根据 TimersList 的结构，我们知道每个链表都保存链表中最快到期的节点的过期时间。二叉堆以该时间为依据，即最快到期的 list 对应二叉堆中的根节点。根节点的到期时间就是整个 Node.js 定时器最快到期的时间，Node.js 把 Libuv 中定时器节点的超时时间设置为该值，在事件循环的定时器阶段就会处理定时的节点，并且不断遍历优先队列，判断当前节点是否超时，如果超时就需要处理，否则就说明整个二叉堆的节点都没有超时。然后重新设置 Libuv 定时器节点新的到期时间。</p>
<p>另外，Node.js 中用一个 map 保存了超时时间到 TimersList 链表的映射关系。 这样可以根据相对超时时间快速找到对应的列表，利用空间来换时间。了解完定时器整体的组织和核心数据结构，我们可以开始进入真正的分析了。</p>
<h2>初始化</h2>
<p>Node.js 在初始化的时候设置了处理定时器的函数。</p>
<pre><code class="hljs language-scss"><span class="hljs-built_in">setupTimers</span>(..., processTimers);  
</code></pre>
<p>setupTimers 对应的 C++ 函数是 SetupTimers。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">SetupTimers</span>(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {  
  auto env = Environment::GetCurrent(args);  
  env-><span class="hljs-built_in">set_timers_callback_function</span>(args[<span class="hljs-number">1</span>].As&#x3C;Function>());  
} 
</code></pre>
<p>除了设置处理函数外，还需要设置超时的回调函数。Node.js 会每次调用 setTimeout 时会计算当前最快超时时间，然后执行 scheduleTimer 设置 Libuv 中对应节点的超时时间。</p>
<pre><code class="hljs language-scss">void <span class="hljs-built_in">ScheduleTimer</span>(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {  
  auto env = Environment::GetCurrent(args);  
  env-><span class="hljs-built_in">ScheduleTimer</span>(args[<span class="hljs-number">0</span>]->IntegerValue(env->context())<span class="hljs-selector-class">.FromJust</span>());  
}  
  
void Environment::ScheduleTimer(int64_t duration_ms) {  
  if (started_cleanup_) return;  
  <span class="hljs-built_in">uv_timer_start</span>(timer_handle(), RunTimers, duration_ms, <span class="hljs-number">0</span>);  
}  
</code></pre>
<p>ScheduleTimer 用于设置 Libuv 中定时器的超时时间，回调函数是 RunTimers。当有节点超时的时候，Node.js 会执行 RunTimers 函数处理超时的节点，后续会看到该函数的具体处理逻辑。那么，如何设置一个定时器呢？</p>
<h2>创建定时器</h2>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setTimeout</span>(<span class="hljs-params">callback, after, arg1, arg2, arg3</span>) {  
  <span class="hljs-comment">// 忽略处理参数args逻辑</span>
    <span class="hljs-comment">// 新建一个Timeout对象</span>
  <span class="hljs-keyword">const</span> timeout = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timeout</span>(callback, 
                              after, 
                              args, 
                              <span class="hljs-literal">false</span>, 
                              <span class="hljs-literal">true</span>);  
  <span class="hljs-title function_">insert</span>(timeout, timeout.<span class="hljs-property">_idleTimeout</span>);  
  <span class="hljs-keyword">return</span> timeout;  
}  
</code></pre>
<p>setTimeout 主要包含两个操作，new Timeout 和 insert，我们逐个来分析。</p>
<pre><code class="hljs language-kotlin">function Timeout(callback, after, args, isRepeat, isRefed) {  
  after *= <span class="hljs-number">1</span>;
  <span class="hljs-keyword">if</span> (!(after >= <span class="hljs-number">1</span> &#x26;&#x26; after &#x3C;= TIMEOUT_MAX)) { 
    after = <span class="hljs-number">1</span>; 
  }  
  <span class="hljs-comment">// 超时时间相对值  </span>
  <span class="hljs-keyword">this</span>._idleTimeout = after;  
  <span class="hljs-comment">// 前后指针，用于链表  </span>
  <span class="hljs-keyword">this</span>._idlePrev = <span class="hljs-keyword">this</span>;  
  <span class="hljs-keyword">this</span>._idleNext = <span class="hljs-keyword">this</span>;  
  <span class="hljs-comment">// 定时器的开始时间  </span>
  <span class="hljs-keyword">this</span>._idleStart = <span class="hljs-literal">null</span>; 
  <span class="hljs-comment">// 超时回调    </span>
  <span class="hljs-keyword">this</span>._onTimeout = callback;  
  <span class="hljs-comment">// 执行回调时传入的参数  </span>
  <span class="hljs-keyword">this</span>._timerArgs = args;  
  <span class="hljs-comment">// 是否定期触发超时，用于 setInterval  </span>
  <span class="hljs-keyword">this</span>._repeat = isRepeat ? after : <span class="hljs-literal">null</span>;  
  <span class="hljs-keyword">this</span>._destroyed = <span class="hljs-literal">false</span>;  
  <span class="hljs-comment">// 激活底层的定时器节点（二叉堆的节点），说明有定时节点需要处理  </span>
  <span class="hljs-keyword">if</span> (isRefed)  
    incRefCount(); 
  <span class="hljs-comment">// 记录状态 </span>
  <span class="hljs-keyword">this</span>[kRefed] = isRefed;  
 }  
</code></pre>
<p>Timeout 主要是新建一个对象记录一些定时器的上下文信息，这里有一个关键的逻辑是 isRefed的值。Node.js 支持 ref 和 unref 状态的定时器（setTimeout 和 setUnrefTimeout），unref 状态的定时器不会影响事件循环的退出。即只有 unref 状态的定时器时，事件循环会结束，当 isRefed 为 true 时会执行 incRefCount();</p>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">incRefCount</span>() {  
  if (refCount++ === <span class="hljs-number">0</span>)  
    <span class="hljs-built_in">toggleTimerRef</span>(true);  
}  
  
void <span class="hljs-built_in">ToggleTimerRef</span>(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {  
  Environment::GetCurrent(args)->ToggleTimerRef(args[<span class="hljs-number">0</span>]->IsTrue());  
}  
  
void Environment::ToggleTimerRef(bool ref) {  
  if (started_cleanup_) return;  
  <span class="hljs-comment">// 打上 ref 标记，  </span>
  if (ref) {  
    <span class="hljs-built_in">uv_ref</span>(reinterpret_cast&#x3C;uv_handle_t*>(timer_handle()));  
  } else {  
    <span class="hljs-built_in">uv_unref</span>(reinterpret_cast&#x3C;uv_handle_t*>(timer_handle()));  
  }  
}  
</code></pre>
<p>我们看到最终会调用 Libuv 的 uv_ref 或 uv_unref 修改定时器相关 handle 的状态，因为 Node.js 只会在 Libuv 中注册一个定时器 handle 并且是常驻的，如果 JS 层当前没有设置定时器，则需要修改定时器 handle 的状态为 unref，否则会影响事件循环的退出。</p>
<p>refCount 值便是记录 JS 层 ref 状态的定时器个数的，所以当我们第一次执行 setTimeou t的时候，Node.js 会激活 Libuv 的定时器节点，为 0 时就会清除 ref 状态。接着，我们看一下 insert。</p>
<pre><code class="hljs language-ini">let <span class="hljs-attr">nextExpiry</span>= Infinity<span class="hljs-comment">;</span>
// item 为刚才创建的 Timeout 对象，msecs 为相对超时时间
function insert(item, msecs, <span class="hljs-attr">start</span> = getLibuvNow()) {  
  <span class="hljs-attr">msecs</span> = MathTrunc(msecs)<span class="hljs-comment">;  </span>
  // 记录定时器的开始时间 
  <span class="hljs-attr">item._idleStart</span> = start<span class="hljs-comment">;  </span>
  // 该相对超时时间是否已经存在对应的链表  
  let <span class="hljs-attr">list</span> = timerListMap[msecs]<span class="hljs-comment">;  </span>
  // 还没有  
  if (<span class="hljs-attr">list</span> === undefined) {  
    // 算出绝对超时时间，第一个节点是该链表中最早到期的节点  
    const <span class="hljs-attr">expiry</span> = start + msecs<span class="hljs-comment">;  </span>
    // 新建一个链表  
    timerListMap<span class="hljs-section">[msecs]</span> = <span class="hljs-attr">list</span> = new TimersList(expiry, msecs)<span class="hljs-comment">;  </span>
    // 插入优先队列  
    timerListQueue.insert(list)<span class="hljs-comment">;  </span>
    /*
      nextExpiry 记录所有超时节点中最快到期的节点，
      如果有更快到期的，则修改底层定时器节点的过期时间  
    */
    if (nextExpiry > expiry) {  
      // 修改底层超时节点的超时时间  
      scheduleTimer(msecs)<span class="hljs-comment">;  </span>
      <span class="hljs-attr">nextExpiry</span> = expiry<span class="hljs-comment">;  </span>
    }  
  }  
  // 把当前节点加到链表里  
  L.append(list, item)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>Insert 的主要逻辑如下。</p>
<ol>
<li>如果该超时时间还没有对应的链表，则新建一个链表，每个链表都会记录该链表中最快到期的节点的值，即第一个插入的值。然后把链表插入优先队列，优先队列会根据该链表的最快过期时间的值，把链表对应的节点调整到相应的位置。</li>
<li>如果当前设置的定时器比之前所有的定时器都快到期，则需要修改底层的定时器节点，使得更快触发超时。</li>
<li>把当前的定时器节点插入对应的链表尾部，即该链表中最久超时的节点。</li>
</ol>
<p>接着，来看一下不同情况下对应的结构图。</p>
<p>假设我们在 0s 的时候插入一个节点，下面是插入第一个节点时的结构图如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7018bf5fab50422395cc969e7f851bbe~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我们再来看看多个节点的情况。假设 0s 的时候插入两个节点 10s 过期和 11s 过期。如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca9be3b0247c493086011317b86e2824~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>然后在 1s 的时候，插入一个新的 11s 过期的节点，9s 的时候插入一个新的 10s 过期节点。这时候的关系图如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eff9a3a23e541238c8ef55d39bab58e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我们看到优先队列中，每一个节点是 TimeList，它是一个链表，父节点对应链表的第一个元素比子节点链表的第一个元素先超时，但链表中后续节点的超时就不一定，比如子节点 1s 开始的节点就比父节点 9s 开始的节点先超时，因为同一队列只是相对超时时间一样，但是开始的时间也是一个重要的因素，即使节点的相对超时时间长，只要开始得早，那么就有可能先超时。</p>
<h2>处理定时器</h2>
<p>从前面的分析中我们可以知道，定时器处理函数是 RunTimers，RunTimers 会执行 timers_callback_function，timers_callback_function 是在 Node.js 初始化的时候设置的 processTimers 函数。</p>
<pre><code class="hljs language-scss">void Environment::RunTimers(uv_timer_t* handle) {  
    Local&#x3C;Function> cb = env-><span class="hljs-built_in">timers_callback_function</span>();  
    MaybeLocal&#x3C;Value> ret;  
    Local&#x3C;Value> arg = env-><span class="hljs-built_in">GetNow</span>();  
    
    do {  
        <span class="hljs-comment">// 执行 JS processTimers 函数  </span>
        ret = cb-><span class="hljs-built_in">Call</span>(env->context(), process, <span class="hljs-number">1</span>, &#x26;arg);  
    } while (ret.IsEmpty() &#x26;&#x26; env-><span class="hljs-built_in">can_call_into_js</span>());  
    
    <span class="hljs-comment">// 如果还有未超时的节点，则 ret 为第一个未超时的节点的超时时间</span>
    int64_t expiry_ms = ret<span class="hljs-selector-class">.ToLocalChecked</span>()-><span class="hljs-built_in">IntegerValue</span>(env->context())<span class="hljs-selector-class">.FromJust</span>();  
    uv_handle_t* h = reinterpret_cast&#x3C;uv_handle_t*>(handle);  
  
    <span class="hljs-comment">/*  
      1 等于 0 说明所有节点都执行完了，但是定时器节点还是在 Libuv 中， 
        需要改成 unref 状态，让 Libuv 可以退出。
        
      2 不等于 0 说明没有还要节点需要处理，这种情况又分为两种 
        1 还有激活状态的定时器，即不允许事件循环退出 
        2 定时器都是非激活状态的，允许事件循环退出
    */</span>  
    if (expiry_ms != <span class="hljs-number">0</span>) {  
        <span class="hljs-comment">// 算出下次超时的相对值  </span>
        int64_t duration_ms = <span class="hljs-built_in">llabs</span>(expiry_ms) - (uv_now(env->event_loop()) - env-><span class="hljs-built_in">timer_base</span>());  
        <span class="hljs-comment">// 重新把 handle 插入 Libuv 的二叉堆 ，更新定时器超时时间 </span>
        env-><span class="hljs-built_in">ScheduleTimer</span>(duration_ms > <span class="hljs-number">0</span> ? duration_ms : <span class="hljs-number">1</span>);  
        <span class="hljs-comment">/* 
          见 internal/timer.js 的 processTimers 
          1 大于 0 说明还有节点没超时，并且不允许事件循环退出， 
            需要保持定时器的 ref 状态（如果之前是 ref 状态则不影响）， 
          2 小于 0 说明定时器不影响 Libuv 的事件循环的结束，改成 unref 状态 
        */</span>  
        if (expiry_ms > <span class="hljs-number">0</span>)  
          <span class="hljs-built_in">uv_ref</span>(h);  
        else  
          <span class="hljs-built_in">uv_unref</span>(h);  
    } else {  
      <span class="hljs-built_in">uv_unref</span>(h);  
    }  
}
</code></pre>
<p>RunTimers 函数主要是执行 JS 回调函数处理定时器，并重新设置 Libuv 定时器的时间和状态。下面是 JS 处理函数 processTimers 的逻辑。</p>
<pre><code class="hljs language-ini">function processTimers(now) {  
   <span class="hljs-attr">nextExpiry</span> = Infinity<span class="hljs-comment">;  </span>
   let list<span class="hljs-comment">;  </span>
   let <span class="hljs-attr">ranAtLeastOneList</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;  </span>
   // 取出优先队列的根节点，即最快到期的节点  
   while (<span class="hljs-attr">list</span> = timerListQueue.peek()) {  
     // 还没过期，则取得下次到期的时间，重新设置超时时间  
     if (list.expiry > now) {  
       <span class="hljs-attr">nextExpiry</span> = list.expiry<span class="hljs-comment">;  </span>
       // 返回下一次过期的时间，负的说明允许事件循环退出  
       return refCount > 0 ? nextExpiry : -nextExpiry<span class="hljs-comment">;  </span>
     }  
 
     // 处理超时节点
     listOnTimeout(list, now)<span class="hljs-comment">;  </span>
   }  
   // 所有节点都处理完了
   return 0<span class="hljs-comment">;  </span>
 }  
 
 // 处理一个 list 里的节点
 function listOnTimeout(list, now) {  
   const <span class="hljs-attr">msecs</span> = list.msecs<span class="hljs-comment">;  </span>
   let <span class="hljs-attr">ranAtLeastOneTimer</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;  </span>
   let timer<span class="hljs-comment">;  </span>
   // 遍历具有统一相对过期时间的队列  
   while (<span class="hljs-attr">timer</span> = L.peek(list)) {  
     // 算出已经过去的时间  
     const <span class="hljs-attr">diff</span> = now - timer._idleStart<span class="hljs-comment">;  </span>
     // 过期的时间比超时时间小，还没过期  
     if (diff &#x3C; msecs) {  
       /* 
           整个链表节点的最快过期时间等于当前
           还没过期节点的值，链表是有序的  
       */
       <span class="hljs-attr">list.expiry</span> = MathMax(timer._idleStart + msecs, now + <span class="hljs-number">1</span>)<span class="hljs-comment">;  </span>
       // 更新 id，用于决定在优先队列里的位置  
       <span class="hljs-attr">list.id</span> = timerListId++<span class="hljs-comment">;  </span>
       /*
           调整过期时间后，当前链表对应的节点不一定是优先队列
           里的根节点了，可能有它更快到期，即当前链表对应的节
           点可能需要往下沉
       */  
       timerListQueue.percolateDown(1)<span class="hljs-comment">;  </span>
       return<span class="hljs-comment">;  </span>
     }  
 
     // 准备执行用户设置的回调，删除这个节点  
     L.remove(timer)<span class="hljs-comment">;  </span>
 
     let start<span class="hljs-comment">;  </span>
     if (timer._repeat)  
       <span class="hljs-attr">start</span> = getLibuvNow()<span class="hljs-comment">; </span>
     try {  
       const <span class="hljs-attr">args</span> = timer._timerArgs<span class="hljs-comment">;  </span>
       // 执行用户设置的回调  
       timer._onTimeout(...args)<span class="hljs-comment">;  </span>
     } finally {  
       /* 
           设置了重复执行回调，即来自 setInterval。
           则需要重新加入链表。  
       */
       if (timer._repeat &#x26;&#x26; timer._idleTimeout !== -1) {  
         // 更新超时时间，一样的时间间隔  
         <span class="hljs-attr">timer._idleTimeout</span> = timer._repeat<span class="hljs-comment">;  </span>
         // 重新插入链表  
         insert(timer, timer._idleTimeout, start)<span class="hljs-comment">;  </span>
       } else if (!timer._idleNext &#x26;&#x26; 
                  !timer._idlePrev &#x26;&#x26; 
                  !timer._destroyed) {          
             <span class="hljs-attr">timer._destroyed</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
             // 是 ref 类型，则减去一个，防止阻止事件循环退出  
         if (timer<span class="hljs-section">[kRefed]</span>)  
           refCount--<span class="hljs-comment">;  </span>
   }  
   // 为空则删除  
   if (<span class="hljs-attr">list</span> === timerListMap[msecs]) {  
     delete timerListMap<span class="hljs-section">[msecs]</span><span class="hljs-comment">;  </span>
     // 从优先队列中删除该节点，并调整队列结构
     timerListQueue.shift()<span class="hljs-comment">;  </span>
   }  
 }  
</code></pre>
<p>上面的代码主要是遍历优先队列，处理逻辑如下。</p>
<ol>
<li>如果当前节点超时，则遍历它对应的链表，遍历链表的时候如果遇到超时的节点则执行，如果遇到没有超时的节点，则说明后面的节点也不会超时了，因为链表是有序的。接着重新计算出最快超时时间，修改链表的 expiry 字段，调整在优先队列的位置，因为修改后的 expiry 可能会导致位置发生变化。如果链表的节点全部都超时了，则从优先队列中删除链表对应的节点，重新调整优先队列的节点。</li>
<li>如果当前节点没有超时则说明后面的节点也不会超时了，因为当前节点是优先队列中最快到期（最小的）的节点。接着设置 Libuv 的定时器时间为当前节点的时间，等待下一次超时处理。</li>
</ol>
<h1>总结</h1>
<p>这节课详细讲解了 Node.js 的三个产生异步任务的 API，分别是 setImmediate、nextTick 和 setTimeout。这些 API 的使用很简单，但我们依然需要花时间去理解它们的原理和实现，因为这些知识在面试中经常会被问到，比如 nextTick 相关的知识点，以及 setImmediate 和 setTimeout 谁先执行这样的问题。面试官不仅想要知道你的答案，他更想知道你的分析过程。</p>
<p>此外，从 nextTick 的实现中我们也可以深刻理解宏任务和微任务的执行机制。这节课的最后我们再来简单回顾下重点知识。</p>
<ol>
<li>setImmediate 通过队列维护了所有的任务，然后在 check 阶段进行处理。值得注意的是 immediate，还通过一个额外的 idle 节点来控制事件循环是否可以阻塞，从而保证 immediate 任务可以尽快执行。</li>
<li>nextTick 也是通过队列维护了所有的任务，然后在每次执行完宏任务后处理所有的 tick 任务和 Promise 任务。这个执行时机一共有三种：第一种是从 Libuv 回调 C++ 再到 JS 之后；第二种是 Node.js 启动后进入事件循环之前；第三种是来自处理 immediate 和 timeout 任务时的补偿处理，使得 Node.js 符合宏任务和微任务的处理规范。</li>
<li>setTimeout 的实现比较复杂，主要是因为定时器的操作频繁，所以 Node.js 做了很多性能优化。setTimeout 是基于 Libuv 定时器的，但只使用了 Libuv 的一个定时器节点，具体的任务是在 JS 层通过 map 和一个优先队列管理的，并且实现了复杂的算法和逻辑管理了 JS 层的数据结构。从中可以看到一个简单的 API 在 Node.js 中的实现也不一定简单。</li>
</ol></div>
</body></html>