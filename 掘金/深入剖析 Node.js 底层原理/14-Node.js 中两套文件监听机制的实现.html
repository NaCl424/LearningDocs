<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Node.js 中两套文件监听机制的实现</h1>
<p>上节课我们讲解了文件系统的概念和 Node.js 中文件操作 API 的实现。Node.js 中，除了提供文件操作的功能之外，还有另一个功能，那就是<strong>文件监听</strong>。文件监听是非常常用的功能，比如我们修改了文件后， 要使用 Webpack 重新打包代码或者重启 Node.js 服务都会用到这个功能。那么，Node.js 中的文件监听是如何实现的呢？</p>
<p>在 Node.js 中，实现监听的方式有两种，第一种就是定时轮询文件元信息是否有变化，第二种是通过订阅 / 发布机制订阅事件，当文件有变化时主动通知。显然，第二种实现方式更高效，就像前面讲的事件驱动模块一样，观察者订阅事件，当事件触发时，操作系统通知观察者，而不是观察者以不断轮询的方式去判断，这样会浪费资源。但是不像事件驱动模块那样，事件驱动模块虽然各个操作系统有自己的实现，但是大多数主流操作系统都支持，而基于订阅 / 发布机制的文件监听机制在不同操作系统中支持的情况不一样，具体可以参考<a href="https://nodejs.org/dist/latest-v19.x/docs/api/fs.html#fswatchfilename-options-listener" target="_blank" rel="nofollow noopener noreferrer">文档</a>。正是因为基于轮询的方式不依赖于平台，所以 Node.js 里才会实现两套文件监听机制供用户选择。</p>
<p>这一节课，我们就来具体分析下 Node.js 中这两种文件监听方式的实现。</p>
<h3>基于轮询的文件监听机制</h3>
<p>首先来看基于轮询机制的方式，对应的 API 是 watchFile。它的实现原理是<strong>定时获取文件</strong> <strong>元信息</strong> <strong>，然后判断当前的元信息和上次的元信息有没有变化，有</strong> <strong>的</strong> <strong>话执行回调通知用户</strong>，以下是具体实现。</p>
<pre><code class="hljs language-ini">function watchFile(filename, options, listener) {  
  <span class="hljs-attr">filename</span> = getValidatedPath(filename)<span class="hljs-comment">;  </span>
  <span class="hljs-attr">filename</span> = pathModule.resolve(filename)<span class="hljs-comment">;  </span>
  let stat<span class="hljs-comment">;  </span>
  // 省略部分参数处理逻辑  
  <span class="hljs-attr">options</span> = {  
    interval: 5007,  
    // 是否阻止事件循环的退出 
    persistent: true,  
    ...options  
  }<span class="hljs-comment">;  </span>
  
  // 缓存处理，filename 是否已经开启过监听  
  <span class="hljs-attr">stat</span> = statWatchers.get(filename)<span class="hljs-comment">;  </span>
  
  if (<span class="hljs-attr">stat</span> === undefined) {  
    if (!watchers)  
      <span class="hljs-attr">watchers</span> = require(<span class="hljs-string">'internal/fs/watchers'</span>)<span class="hljs-comment">;  </span>
    <span class="hljs-attr">stat</span> = new watchers.StatWatcher(options.bigint)<span class="hljs-comment">;  </span>
    // 开启监听  
    stat<span class="hljs-section">[watchers.kFSStatWatcherStart]</span>(filename,        
                                           options.persistent, 
                                           options.interval)<span class="hljs-comment">;  </span>
    // 更新缓存            
    statWatchers.set(filename, stat)<span class="hljs-comment">;  </span>
  }    
  stat.addListener('change', listener)<span class="hljs-comment">;  </span>
  return stat<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>在上面的实现中，watchFile 通过缓存的方式做了一些性能优化，因为当我们多次监听同一个文件时，Node.js 并不是在底层开启多个定时器，而是在 JS 层保存了多个订阅者，然后开启一个定时器进行轮询，当内容发生变化时，Node.js 会通知多个订阅者。除了缓存处理外，真正监听的功能由 internal/fs/watchers 模块的 StatWatcher 实现。watchFile 函数创建一个 StatWatcher 对象后，接着调用它的 watchers.kFSStatWatcherStart 方法开启监听。下面，我们来看看如何实现。</p>
<pre><code class="hljs language-ini">StatWatcher.prototype<span class="hljs-section">[kFSStatWatcherStart]</span> = function(filename,persistent, interval) {  
  <span class="hljs-attr">this._handle</span> = new _StatWatcher(this[kUseBigint])<span class="hljs-comment">;  </span>
  // 文件监听是否会阻止事件循环的退出
  if (!persistent)
    this._handle.unref()<span class="hljs-comment">;</span>
  // 文件变化执行的回调
  <span class="hljs-attr">this._handle.onchange</span> = <span class="hljs-literal">on</span>change<span class="hljs-comment">;  </span>
  <span class="hljs-attr">filename</span> = getValidatedPath(filename, <span class="hljs-string">'filename'</span>)<span class="hljs-comment">; </span>
  this._handle.start(toNamespacedPath(filename), interval)<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>上面 kFSStatWatcherStart 函数中首先新建一个_StatWatcher对象，_StatWatcher 是 C++ 模块提供的 StatWatcher 对象，实现如下。</p>
<pre><code class="hljs language-scss">StatWatcher::StatWatcher(fs::BindingData* binding_data,
                         Local&#x3C;Object> wrap,
                         bool use_bigint)
    : HandleWrap(...) {
  <span class="hljs-comment">// uv_fs_poll_t watcher_;    </span>
  <span class="hljs-built_in">uv_fs_poll_init</span>(env()-><span class="hljs-built_in">event_loop</span>(), &#x26;watcher_);
}
</code></pre>
<p>StatWatcher 是对 Libuv uv_fs_poll_t 的封装，uv_fs_poll_t 用来管理一个文件监听结构体，StatWatcher 构造函数里调用 uv_fs_poll_init 对 uv_fs_poll_t 结构体进行了初始化。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uv_fs_poll_init</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop, <span class="hljs-type">uv_fs_poll_t</span>* handle)</span> </span>{
  <span class="hljs-built_in">uv__handle_init</span>(loop, (<span class="hljs-type">uv_handle_t</span>*)handle, UV_FS_POLL);
  handle->poll_ctx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>从上面的代码中可以看到，uv_fs_poll_init 只是做了一些简单的初始化工作。</p>
<p>那创建了 StatWatcher 后，我们接着调用了它的 start 方法，对应 C++ 函数为 StatWatcher::Start。</p>
<pre><code class="hljs language-scss">void StatWatcher::Start(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {
  StatWatcher* wrap;
  <span class="hljs-built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&#x26;wrap, args.Holder());
  <span class="hljs-comment">// 监听的文件</span>
  node::Utf8Value path(args.GetIsolate(), args[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 轮询时间</span>
  const uint32_t interval = args<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.As</span>&#x3C;Uint32>()-><span class="hljs-built_in">Value</span>();
  <span class="hljs-comment">// 开始定时轮询</span>
  <span class="hljs-built_in">uv_fs_poll_start</span>(&#x26;wrap->watcher_, Callback, *path, interval);
}
</code></pre>
<p>StatWatcher::Start 里做了简单的参数处理后，接着调用 uv_fs_poll_start 开始了文件的监听。</p>
<pre><code class="hljs language-ini">int uv_fs_poll_start(uv_fs_poll_t* handle,
                     uv_fs_poll_cb cb,
                     const char* path,
                     unsigned int interval) {
  struct poll_ctx* ctx<span class="hljs-comment">;</span>
  uv_loop_t* loop<span class="hljs-comment">;</span>
  size_t len<span class="hljs-comment">;</span>
  int err<span class="hljs-comment">;</span>

  <span class="hljs-attr">loop</span> = handle->loop<span class="hljs-comment">;</span>
  <span class="hljs-attr">len</span> = strlen(path)<span class="hljs-comment">;</span>
  // 创建 struct poll_ctx 管理文件监听
  <span class="hljs-attr">ctx</span> = uv__calloc(<span class="hljs-number">1</span>, sizeof(*ctx) + len)<span class="hljs-comment">;</span>
  ctx-><span class="hljs-attr">loop</span> = loop<span class="hljs-comment">;</span>
  // 调用者回调，文件变化时执行
  ctx-><span class="hljs-attr">poll_cb</span> = cb<span class="hljs-comment">;</span>
  // 轮询时间
  ctx-><span class="hljs-attr">interval</span> = interval ? interval : <span class="hljs-number">1</span><span class="hljs-comment">;</span>
  // 上次轮询的开始时间
  ctx-><span class="hljs-attr">start_time</span> = uv_now(loop)<span class="hljs-comment">;</span>
  // 关联的 hande（uv_fs_poll_t）
  ctx-><span class="hljs-attr">parent_handle</span> = handle<span class="hljs-comment">;</span>
  memcpy(ctx->path, path, len + 1)<span class="hljs-comment">;</span>
  // 初始化定时器
  uv_timer_init(loop, &#x26;ctx->timer_handle)<span class="hljs-comment">;</span>
  ctx->timer_handle.flags |= UV_HANDLE_INTERNAL<span class="hljs-comment">;</span>
  // 这个定时器不影响事件循环退出
  uv__handle_unref(&#x26;ctx->timer_handle)<span class="hljs-comment">;</span>
  // 异步读取文件元信息
  uv_fs_stat(loop, &#x26;ctx->fs_req, ctx->path, poll_cb)<span class="hljs-comment">;</span>
  // handle 和 ctx 互相关联
  handle-><span class="hljs-attr">poll_ctx</span> = ctx<span class="hljs-comment">;</span>
  uv__handle_start(handle)<span class="hljs-comment">;</span>
  return 0<span class="hljs-comment">;</span>
}
</code></pre>
<p>uv_fs_poll_start 初始化了轮询相关的上下文，然后执行 uv_fs_stat 获取文件的元信息，因为轮询机制的原理是对比前后两次文件的元信息是否发生变化，获取成功后执行 poll_cb。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">static</span> void <span class="hljs-title function_ invoke__">poll_cb</span>(uv_fs_t* req) {
  uv_stat_t* statbuf;
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">poll_ctx</span>* ctx;
  uint64_t interval;
  uv_fs_poll_t* handle;

  ctx = <span class="hljs-title function_ invoke__">container_of</span>(req, <span class="hljs-keyword">struct</span> <span class="hljs-title class_">poll_ctx</span>, fs_req);
  handle = ctx<span class="hljs-punctuation">-></span>parent_handle;
  <span class="hljs-comment">// 获取元信息</span>
  statbuf = &#x26;req<span class="hljs-punctuation">-></span>statbuf;
  <span class="hljs-comment">// busy_polling 等于 0 说明是第一次回调，第一次时不需要判断文件是否有变化</span>
  <span class="hljs-comment">// busy_polling 不等于 0 说明不是第一次回调，通过 statbuf_eq 判断文件</span>
  <span class="hljs-comment">// 元信息是否发生了变化，是则通知调用方</span>
  <span class="hljs-title function_ invoke__">if</span> (ctx<span class="hljs-punctuation">-></span>busy_polling != <span class="hljs-number">0</span>)
    <span class="hljs-title function_ invoke__">if</span> (ctx<span class="hljs-punctuation">-></span>busy_polling &#x3C; <span class="hljs-number">0</span> || !<span class="hljs-title function_ invoke__">statbuf_eq</span>(&#x26;ctx<span class="hljs-punctuation">-></span>statbuf, statbuf))
      ctx<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">poll_cb</span>(ctx<span class="hljs-punctuation">-></span>parent_handle, <span class="hljs-number">0</span>, &#x26;ctx<span class="hljs-punctuation">-></span>statbuf, statbuf);
  <span class="hljs-comment">// 记录文件当前的元信息</span>
  ctx<span class="hljs-punctuation">-></span>statbuf = *statbuf;
  <span class="hljs-comment">// 设置标记</span>
  ctx<span class="hljs-punctuation">-></span>busy_polling = <span class="hljs-number">1</span>;
  <span class="hljs-comment">// 轮询间隔</span>
  interval = ctx<span class="hljs-punctuation">-></span>interval;
  <span class="hljs-comment">// 超时回调可能有延迟，比如被其他代码执行比较耗时或者阻塞了一段时间，</span>
  <span class="hljs-comment">// 这里计算延迟时间，并减去延迟的时间，下次超时时间会小于 interval</span>
  interval -= (<span class="hljs-title function_ invoke__">uv_now</span>(ctx<span class="hljs-punctuation">-></span><span class="hljs-keyword">loop</span>) - ctx<span class="hljs-punctuation">-></span>start_time) % interval;
  <span class="hljs-comment">// 重启定时器</span>
  <span class="hljs-title function_ invoke__">uv_timer_start</span>(&#x26;ctx<span class="hljs-punctuation">-></span>timer_handle, timer_cb, interval, <span class="hljs-number">0</span>);
}
</code></pre>
<p>poll_cb 中主要的逻辑是判断文件的元信息是否发生了变化，比如修改时间、文件大小的话，具体判断在 statbuf_eq 函数中。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">static</span> int <span class="hljs-title function_ invoke__">statbuf_eq</span>(<span class="hljs-keyword">const</span> uv_stat_t* a, <span class="hljs-keyword">const</span> uv_stat_t* b) {
  <span class="hljs-keyword">return</span> a<span class="hljs-punctuation">-></span>st_ctim.tv_nsec == b<span class="hljs-punctuation">-></span>st_ctim.tv_nsec
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_mtim.tv_nsec == b<span class="hljs-punctuation">-></span>st_mtim.tv_nsec
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_birthtim.tv_nsec == b<span class="hljs-punctuation">-></span>st_birthtim.tv_nsec
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_ctim.tv_sec == b<span class="hljs-punctuation">-></span>st_ctim.tv_sec
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_mtim.tv_sec == b<span class="hljs-punctuation">-></span>st_mtim.tv_sec
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_birthtim.tv_sec == b<span class="hljs-punctuation">-></span>st_birthtim.tv_sec
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_size == b<span class="hljs-punctuation">-></span>st_size
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_mode == b<span class="hljs-punctuation">-></span>st_mode
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_uid == b<span class="hljs-punctuation">-></span>st_uid
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_gid == b<span class="hljs-punctuation">-></span>st_gid
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_ino == b<span class="hljs-punctuation">-></span>st_ino
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_dev == b<span class="hljs-punctuation">-></span>st_dev
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_flags == b<span class="hljs-punctuation">-></span>st_flags
      &#x26;&#x26; a<span class="hljs-punctuation">-></span>st_gen == b<span class="hljs-punctuation">-></span>st_gen;
}
</code></pre>
<p>如果文件元信息有变化则通知订阅者，对应的是 C++ 的 Callback 函数。</p>
<pre><code class="hljs language-rust">void StatWatcher::<span class="hljs-title function_ invoke__">Callback</span>(uv_fs_poll_t* handle,
                           int status,
                           <span class="hljs-keyword">const</span> uv_stat_t* prev,
                           <span class="hljs-keyword">const</span> uv_stat_t* curr) {
  StatWatcher* wrap = <span class="hljs-title function_ invoke__">ContainerOf</span>(&#x26;StatWatcher::watcher_, handle);
  Environment* env = wrap<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">env</span>();
  Local&#x3C;Value> arr = fs::<span class="hljs-title function_ invoke__">FillGlobalStatsArray</span>(env, wrap<span class="hljs-punctuation">-></span>use_bigint_, curr);
  <span class="hljs-title function_ invoke__">USE</span>(fs::<span class="hljs-title function_ invoke__">FillGlobalStatsArray</span>(env, wrap<span class="hljs-punctuation">-></span>use_bigint_, prev, <span class="hljs-literal">true</span>));

  Local&#x3C;Value> argv[<span class="hljs-number">2</span>] = { Integer::<span class="hljs-title function_ invoke__">New</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">isolate</span>(), status), arr };
  <span class="hljs-comment">// 回调 JS 层的 onchange 函数</span>
  wrap<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">MakeCallback</span>(env<span class="hljs-punctuation">-></span><span class="hljs-title function_ invoke__">onchange_string</span>(), <span class="hljs-title function_ invoke__">arraysize</span>(argv), argv);
}
</code></pre>
<p>C++ 层会执行 JS 层的 onchange 函数。</p>
<pre><code class="hljs language-scss">function <span class="hljs-built_in">onchange</span>(newStatus, stats) {
  const self = this<span class="hljs-selector-attr">[owner_symbol]</span>;
  self<span class="hljs-selector-class">.emit</span>('change', getStatsFromBinding(stats),
            <span class="hljs-built_in">getStatsFromBinding</span>(stats, kFsStatsFieldsNumber));
}
</code></pre>
<p>最终触发 onchange 事件，执行用户订阅的回调。</p>
<p>Libuv 处理完一轮轮询后，接着重新计算下次超时时间，因为 Libuv 是在单线程内执行事件循环的。如果有一个任务耗时比较长或者引起了线程阻塞，则会导致定时器没有按时执行超时回调，这被称为事件循环延时。如果存在延时，则下一次超时的时间会变短。计算出下一次超时时间后，接着执行 uv_timer_start 重启定时器等待下一次超时。这就是基于轮询的文件监听机制。</p>
<h3>基于 inotify 的文件监听机制（Linux）</h3>
<p>从上面的分析中可以看到，基于轮询的监听机制效率是很低的，因为 Node.js 需要不断地去获取文件的元数据，判断元信息是否有变化。如果文件大部分时间里都没有变化，就会白白浪费 CPU 和其他资源。那文件改变了操作后，系统能不能主动通知我们呢？当然可以，这就要用到基于 inotify 的文件监听机制。inotify 是 Linux 操作系统提供机制，使用方式如下。</p>
<ol>
<li>首先通过 init_inotify 创建一个 inotify 的实例，然后拿到一个文件描述符（Linux 万物皆文件）。</li>
<li>当需要监听一个文件时，执行 inotify_add_watch 系统调用注册一个需监听的文件，拿到一个唯一的 id。</li>
<li>当不再需要监听一个文件时，执行 inotify_rm_watch 系统调用告诉操作系统不再监听这个文件。</li>
<li>注册可读事件，当可读事件触发时，执行 read 系统调用，拿到数据和数据的字节数，数据中保存了哪些文件发生了变化。</li>
</ol>
<h4>Libuv 中的 inotify 机制</h4>
<p>下面来看一下如何使用 Libuv 提供的 inotify 监听机制，首先创建两个文件 test.c 和 test.js，test.c 代码如下。</p>
<pre><code class="hljs language-arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;uv.h></span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onchange</span><span class="hljs-params">(...)</span> </span>{
    <span class="hljs-comment">// 文件发生了变化</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>{    
    <span class="hljs-type">uv_fs_event_t</span> req;
    <span class="hljs-comment">// 初始化 fs_event_req 结构体  </span>
    <span class="hljs-built_in">uv_fs_event_init</span>(<span class="hljs-built_in">uv_default_loop</span>(), &#x26;req);
    <span class="hljs-comment">// 向底层注册监听文件 argv[1], onchange 是回调</span>
    <span class="hljs-built_in">uv_fs_event_start</span>(&#x26;req, onchange, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);  
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">uv_run</span>(<span class="hljs-built_in">uv_default_loop</span>(), UV_RUN_DEFAULT);  
} 
</code></pre>
<p>通过 gcc test.c -luv -o test &#x26;&#x26; ./test test.js 命令编译执行以上代码，然后修改 test.js 的内容，可以看到输出 change，说明内容发生了变化。</p>
<p>了解了 inotify 的基础后，接着分析 Libuv 中的实现。在第一次监听文件时，Libuv 会执行 init_inotify 初始化 inotify 相关的数据结构。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">static</span> int <span class="hljs-title function_ invoke__">init_inotify</span>(uv_loop_t* <span class="hljs-keyword">loop</span>) {
  <span class="hljs-comment">// 执行系统调用 inotify_init 创建一个 inotify 实例，然后把返回的 fd 保存到 loop 中</span>
  <span class="hljs-keyword">loop</span><span class="hljs-punctuation">-></span>inotify_fd = <span class="hljs-title function_ invoke__">new_inotify_fd</span>();
  <span class="hljs-comment">// 初始化 IO 观察者 inotify_read_watcher，有文件发生变化时，执行 uv__inotify_read 回调</span>
  <span class="hljs-title function_ invoke__">uv__io_init</span>(&#x26;<span class="hljs-keyword">loop</span><span class="hljs-punctuation">-></span>inotify_read_watcher, uv__inotify_read, <span class="hljs-keyword">loop</span><span class="hljs-punctuation">-></span>inotify_fd);
  <span class="hljs-comment">// 设置 IO 观察者感兴趣的事件为可读，在 Poll IO 阶段注册到操作系统的事件驱动模块</span>
  <span class="hljs-title function_ invoke__">uv__io_start</span>(<span class="hljs-keyword">loop</span>, &#x26;<span class="hljs-keyword">loop</span><span class="hljs-punctuation">-></span>inotify_read_watcher, POLLIN);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>init_inotify 首先通过系统调用创建了一个 inotify 示例并拿到一个 fd，然后注册该 fd 的可读事件并等待事件触发。</p>
<p>了解了 inotify 的初始化逻辑后，我们接着看注册监听文件信息的逻辑。</p>
<pre><code class="hljs language-ini">nt uv_fs_event_start(uv_fs_event_t* handle,
                      uv_fs_event_cb cb,
                      const char* path,
                      unsigned int flags) {
  struct watcher_list* w<span class="hljs-comment">;</span>
  int events<span class="hljs-comment">;</span>
  int err<span class="hljs-comment">;</span>
  int wd<span class="hljs-comment">;</span>

  // 初始化 inotify
  init_inotify(handle->loop)<span class="hljs-comment">;</span>
  // 感兴趣的事件
  <span class="hljs-attr">events</span> = UV__IN_ATTRIB
         | UV__IN_CREATE
         | UV__IN_MODIFY
         | UV__IN_DELETE
         | UV__IN_DELETE_SELF
         | UV__IN_MOVE_SELF
         | UV__IN_MOVED_FROM
         | UV__IN_MOVED_TO<span class="hljs-comment">;</span>
  // 如果这个文件之前没有注册过，则把文件注册到 inotify 实例中，拿到这个文件对应的 id
  // 如果这个文件之前已经注册过了，则直接返回对应的 id
  <span class="hljs-attr">wd</span> = uv__inotify_add_watch(handle->loop->inotify_fd, path, events)<span class="hljs-comment">;</span>
  // Libuv 维护了一棵红黑树，通过 id 判断该文件是否存在 Libuv 的红黑树中
  <span class="hljs-attr">w</span> = find_watcher(handle->loop, wd)<span class="hljs-comment">;</span>
  // 如果已经存在红黑树中则不再插入
  if (w)
    goto no_insert<span class="hljs-comment">;</span>
  // 还没有注册过则插入 Libuv 维护的红黑树
  <span class="hljs-attr">w</span> = uv__malloc(sizeof(*w) + strlen(path) + <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
  // 如果不在红黑树中，则创建一个 struct watcher_list 结构体，
  // 并记录相关信息到该结构体，然后把它插入红黑树
  w-><span class="hljs-attr">wd</span> = wd<span class="hljs-comment">;</span>
  w-><span class="hljs-attr">path</span> = strcpy((char*)(w + <span class="hljs-number">1</span>), path)<span class="hljs-comment">;</span>
  // 初始化订阅者队列
  QUEUE_INIT(&#x26;w->watchers)<span class="hljs-comment">;</span>
  w-><span class="hljs-attr">iterating</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
  // 插入 Libuv 的红黑树, inotify_watchers 是根节点，
  // 一个文件对应红黑树一个节点，一个节点对应管理多个订阅者
  RB_INSERT(watcher_root, CAST(&#x26;handle->loop->inotify_watchers), w)<span class="hljs-comment">;</span>

no_insert:
  // 激活该handle
  uv__handle_start(handle)<span class="hljs-comment">;</span>
  // 因为可能有多个订阅者对同一个文件感兴趣，所以一个红黑树节点维护了一个订阅者队列
  QUEUE_INSERT_TAIL(&#x26;w->watchers, &#x26;handle->watchers)<span class="hljs-comment">;</span>
  // 保存上下文
  handle-><span class="hljs-attr">path</span> = w->path<span class="hljs-comment">;</span>
  handle-><span class="hljs-attr">cb</span> = cb<span class="hljs-comment">;</span>
  handle-><span class="hljs-attr">wd</span> = wd<span class="hljs-comment">;</span>

  return 0<span class="hljs-comment">;</span>
}
</code></pre>
<p>操作系统只支持当文件发生变化时通知调用方，在这个基础上，调用方需要自己维护订阅者，Libuv 中使用红黑树维护了文件和订阅者的关系，结构体如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a069c1792db64263a8df1388f9d3cff3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>当文件发生变化时，Libuv 会在 Poll IO 阶段进行处理，处理函数是 uv__inotify_read 。</p>
<pre><code class="hljs language-arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">uv__inotify_read</span><span class="hljs-params">(<span class="hljs-type">uv_loop_t</span>* loop,
                             <span class="hljs-type">uv__io_t</span>* dummy,
                             <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> events)</span> </span>{
  <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">uv__inotify_event</span>* e;
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">watcher_list</span>* w;
  <span class="hljs-type">uv_fs_event_t</span>* h;
  QUEUE queue;
  QUEUE* q;
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path;
  <span class="hljs-type">ssize_t</span> size;
  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p;
  <span class="hljs-comment">/* needs to be large enough for sizeof(inotify_event) + strlen(path) */</span>
  <span class="hljs-type">char</span> buf[<span class="hljs-number">4096</span>];
  <span class="hljs-comment">// 每次只读 4096 字节，如果数据过多则需要读多次</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">do</span>
      <span class="hljs-comment">// 读取数据，size 是读取到的数据的字节数，buffer 保存了具体的数据</span>
      size = <span class="hljs-built_in">read</span>(loop->inotify_fd, buf, <span class="hljs-built_in">sizeof</span>(buf));
    <span class="hljs-keyword">while</span> (size == <span class="hljs-number">-1</span> &#x26;&#x26; errno == EINTR);
    <span class="hljs-comment">// 没有数据可取了，跳出循环</span>
    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">-1</span>) {
      <span class="hljs-comment">// 错误码必须的是繁忙（没有数据可读了），而不是其他错误</span>
      <span class="hljs-built_in">assert</span>(errno == EAGAIN || errno == EWOULDBLOCK);
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-comment">// 解析 buffer 的数据</span>
    <span class="hljs-keyword">for</span> (p = buf; p &#x3C; buf + size; p += <span class="hljs-built_in">sizeof</span>(*e) + e->len) {
      <span class="hljs-comment">// buffer 里是多个 uv__inotify_event 结构体，</span>
      <span class="hljs-comment">// uv__inotify_event 结构体里是触发的事件信息和文件对应的 id</span>
      e = (<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> uv__inotify_event*)p;
      <span class="hljs-comment">// 判断触发的事件</span>
      events = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (e->mask &#x26; (UV__IN_ATTRIB|UV__IN_MODIFY))
        events |= UV_CHANGE;
      <span class="hljs-keyword">if</span> (e->mask &#x26; ~(UV__IN_ATTRIB|UV__IN_MODIFY))
        events |= UV_RENAME;
      <span class="hljs-comment">// 根据文件对应的 id（wd 字段）从红黑树中找到对应的 struct watcher_list 节点</span>
      w = <span class="hljs-built_in">find_watcher</span>(loop, e->wd);
      
      path = e->len ? (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*) (e + <span class="hljs-number">1</span>) : <span class="hljs-built_in">uv__basename_r</span>(w->path);
      w->iterating = <span class="hljs-number">1</span>;
      <span class="hljs-comment">// 每个红黑树节点对应一个订阅者队列，开始通知每个订阅者</span>
      <span class="hljs-built_in">QUEUE_MOVE</span>(&#x26;w->watchers, &#x26;queue);
      <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">QUEUE_EMPTY</span>(&#x26;queue)) {
        <span class="hljs-comment">// 头结点</span>
        q = <span class="hljs-built_in">QUEUE_HEAD</span>(&#x26;queue);
        <span class="hljs-comment">// 通过结构体偏移拿到首地址</span>
        h = <span class="hljs-built_in">QUEUE_DATA</span>(q, <span class="hljs-type">uv_fs_event_t</span>, watchers);
        <span class="hljs-comment">// 从处理队列中移除</span>
        <span class="hljs-built_in">QUEUE_REMOVE</span>(q);
        <span class="hljs-comment">// 放回原队列</span>
        <span class="hljs-built_in">QUEUE_INSERT_TAIL</span>(&#x26;w->watchers, q);
        <span class="hljs-comment">// 执行回调</span>
        h-><span class="hljs-built_in">cb</span>(h, path, events, <span class="hljs-number">0</span>);
      }
    }
  }
}
</code></pre>
<p>uv__inotify_read 首先调用 read 把数据从操作系统中读取出来，这些数据是一个个 struct uv__inotify_event 结构体，每个结构体保存了哪些文件触发了哪些事件，接着根据 struct uv__inotify_event 的 wd 字段，也就是文件对应的 id，从红黑树中找到对应的节点，最终拿到该节点维护的订阅者队列并执行订阅者的回调。</p>
<h4>inotify 机制的使用</h4>
<p>在 Libuv 的 inotify 机制的基础上，Node.js 提供了 fs.watch API 实现文件监听功能。</p>
<pre><code class="hljs language-ini">function watch(filename, options, listener) {  
  <span class="hljs-attr">options</span> = copyObject(options)<span class="hljs-comment">;  </span>
  // 是否阻止事件循环的退出
  if (<span class="hljs-attr">options.persistent</span> === undefined) 
      <span class="hljs-attr">options.persistent</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;  </span>
  // 如果是目录，是否监听所有子目录和文件的变化
  if (<span class="hljs-attr">options.recursive</span> === undefined) 
      <span class="hljs-attr">options.recursive</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;  </span>
  // 有些平台不支持
  if (options.recursive &#x26;&#x26; !(isOSX || isWindows))  
    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively')<span class="hljs-comment">;  </span>
  if (!watchers)  
    <span class="hljs-attr">watchers</span> = require(<span class="hljs-string">'internal/fs/watchers'</span>)<span class="hljs-comment">;  </span>
  // 新建一个 FSWatcher 对象管理文件监听，然后开启监听
  const <span class="hljs-attr">watcher</span> = new watchers.FSWatcher()<span class="hljs-comment">;  </span>
  watcher<span class="hljs-section">[watchers.kFSWatchStart]</span>(filename,  
                                  options.persistent,  
                                  options.recursive,  
                                  options.encoding)<span class="hljs-comment">;  </span>
  
  if (listener) {  
    watcher.addListener('change', listener)<span class="hljs-comment">;  </span>
  }  
  
  return watcher<span class="hljs-comment">;  </span>
}  
</code></pre>
<p>watch 没有在 JS 层支持多个订阅者的功能，因为底层的 Libuv 实现了该功能。watch 有两个特性需要注意，一个是 persistent，另一个是 recursive。前者表示文件监听操作是否会阻止事件循环的退出，后面表示是否监听的文件是目录时（Linux 中目录也是文件，叫目录文件），是否监听子目录的变化。接着看一下核心逻辑，具体由 internal/fs/watchers 的 FSWatcher 实现。</p>
<pre><code class="hljs language-ini">function FSWatcher() {
  EventEmitter.call(this)<span class="hljs-comment">;</span>

  <span class="hljs-attr">this._handle</span> = new FSEvent()<span class="hljs-comment">;</span>
  this._handle<span class="hljs-section">[owner_symbol]</span> = this<span class="hljs-comment">;</span>
  <span class="hljs-attr">this._handle.onchange</span> = (status, eventType, filename) => {
    // C++ 层执行的回调，下面具体分析
  }<span class="hljs-comment">;</span>
}

FSWatcher.prototype<span class="hljs-section">[kFSWatchStart]</span> = function(filename,
                                              persistent,
                                              recursive,
                                              encoding) {
  <span class="hljs-attr">filename</span> = getValidatedPath(filename, <span class="hljs-string">'filename'</span>)<span class="hljs-comment">;</span>
  this._handle.start(toNamespacedPath(filename),
                     persistent,
                     recursive,
                     encoding)<span class="hljs-comment">;</span>

}<span class="hljs-comment">;</span>
</code></pre>
<p>FSWatcher 函数是对 C++ 层 FSEvent 模块的封装。FSWatcher 中创建了一个 FSEvent 对象并执行了它的 start 函数，看看 FSEvent 的 start 函数的逻辑。</p>
<pre><code class="hljs language-ini">void FSEventWrap::Start(const FunctionCallbackInfo&#x3C;Value>&#x26; args) {
  Environment* <span class="hljs-attr">env</span> = Environment::GetCurrent(args)<span class="hljs-comment">;</span>

  FSEventWrap* <span class="hljs-attr">wrap</span> = Unwrap&#x3C;FSEventWrap>(args.This())<span class="hljs-comment">;</span>
  
  const int <span class="hljs-attr">argc</span> = args.Length()<span class="hljs-comment">;</span>
  
  BufferValue path(env->isolate(), args<span class="hljs-section">[0]</span>)<span class="hljs-comment">;</span>
  
  unsigned int <span class="hljs-attr">flags</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
  if (args<span class="hljs-section">[2]</span>->IsTrue())
    flags |= UV_FS_EVENT_RECURSIVE<span class="hljs-comment">;</span>

  wrap-><span class="hljs-attr">encoding_</span> = ParseEncoding(env->isolate(), args[<span class="hljs-number">3</span>], kDefaultEncoding)<span class="hljs-comment">;</span>
  // 初始化 uv_fs_event_t 结构体
  int <span class="hljs-attr">err</span> = uv_fs_event_init(wrap->env()->event_loop(), &#x26;wrap->handle_)<span class="hljs-comment">;</span>
  // 注册文件，开始监听，回调是 OnEvent
  <span class="hljs-attr">err</span> = uv_fs_event_start(&#x26;wrap->handle_, <span class="hljs-literal">On</span>Event, *path, flags)<span class="hljs-comment">;</span>
  // 是否影响事件循环的退出
  if (!args<span class="hljs-section">[1]</span>->IsTrue()) {
    uv_unref(reinterpret_cast&#x3C;uv_handle_t*>(&#x26;wrap->handle_))<span class="hljs-comment">;</span>
  }

  args.GetReturnValue().Set(err)<span class="hljs-comment">;</span>
}
</code></pre>
<p>Start 函数透过 C++ 层调用了 Libuv 的 uv_fs_event_start 函数往 inotify 实例中注册文件的信息。当文件发生变化时，就会执行 OnEvent 回调。</p>
<pre><code class="hljs language-scss">void FSEventWrap::OnEvent(...) {
  FSEventWrap* wrap = static_cast&#x3C;FSEventWrap*>(handle->data);
  Environment* env = wrap-><span class="hljs-built_in">env</span>();
  <span class="hljs-comment">// 忽略参数处理</span>
  Local&#x3C;Value> argv<span class="hljs-selector-attr">[]</span> = {
    Integer::New(env->isolate(), status),
    event_string,
    Null(env->isolate())
  };
  <span class="hljs-comment">// 执行 onchange 回调</span>
  wrap-><span class="hljs-built_in">MakeCallback</span>(env->onchange_string(), <span class="hljs-built_in">arraysize</span>(argv), argv);
}
</code></pre>
<p>OnEvent 执行了 JS 的 onchange 回调，最后 JS 层触发 onchange 事件。</p>
<h3>总结</h3>
<p>这节课详细介绍了 Node.js 两种文件监听机制的使用和实现原理。文件监听是非常常用的功能，我们了解了底层原理后，可以知道两种机制的使用场景和效率是不一样的。</p>
<ol>
<li>基于轮询机制的效率是比较低的，因为它的原理是通过定时器实现的，如果文件在大多数情况下没有发生变化，则白白浪费资源。这种方式的好处是系统兼容性比较好，</li>
<li>基于订阅 / 发布机制的效率比较高的，因为当文件没有发生变化时，应用没有额外的开销，当文件发生变化后，操作系统会自动通知应用，这种方式的问题是可能在某些操作系统中无法支持得很好。</li>
</ol>
<p>我们可以根据自己的场景选择不同的机制，根据 Node.js 官方建议，可以用基于订阅 / 发布机制时尽量使用这种方式。</p></div>
</body></html>