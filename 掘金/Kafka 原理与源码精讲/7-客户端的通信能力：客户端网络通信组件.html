<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>客户端的通信能力：客户端网络通信组件</h1>
<blockquote>
<p>这节课我提供了视频讲解，在源码讲解的基础上增加了原理解析和架构学习的部分，对应的视频地址如下：
<a href="https://www.bilibili.com/video/BV1eR4y1w7Pa" target="_blank" rel="nofollow noopener noreferrer">https://www.bilibili.com/video/BV1eR4y1w7Pa</a></p>
</blockquote>
<p>在前面两讲中我们一起学习了Kafka对NIO的封装，这一讲我们继续讲解NetworkClient类。</p>
<p><strong>NetworkClient为上层业务提供了网络IO的功能，其中上层业务包括生产者、消费者和服务端</strong>。NetworkClient里使用了前面两讲我们介绍的Kafka对NIO的封装组件，同时做了一定的封装，实现了网络IO。<strong>NetworkClient类不仅用于客户端与服务端通信，还用于服务端之间的通信</strong>。</p>
<p>在正式讲解之前，我们还是先了解一下这一讲的大体内容，思维导图如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d8ed0f81a6541ffaa2f60f25155f9dd~tplv-k3u1fbpfcp-watermark.image?" alt="54848D5D-3512-4649-9DF3-1AC2914D0428.png"></p>
<h2>字段</h2>
<p><strong>NetworkClient类是KafkaClient接口的实现，它内部的重要字段有实现网络请求的Selectable、InFlightRequest，以及内部类MetadataUpdate</strong>，相关类图如下图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80aa9bfbc8764d958ddc53b9d99a0333~tplv-k3u1fbpfcp-watermark.image?" alt="DD91322D-12A0-43E6-A932-53D872CB3CFA.png"></p>
<p>NetworkClient这个类的字段比较多，你可以参考下面的示例代码：</p>
<pre><code>public class NetworkClient implements KafkaClient {
    //用于网络IO的选择器
    private final Selectable selector;
    //用于元数据的更新
    private final MetadataUpdater metadataUpdater;

    // 集群所有连接的状态都在这里管理
    private final ClusterConnectionStates connectionStates;
    
    //发送后还没有响应的请求集合
    private final InFlightRequests inFlightRequests;

    //表示发送数据的缓冲区的大小
    private final int socketSendBuffer;

    //表示接收数据的缓冲区的大小
    private final int socketReceiveBuffer;

    //client端的id
    private final String clientId;

    //重连的退避时间
    private final long reconnectBackoffMs;
  
    /**
     * True：当第一次连接一个broker的时候，我们应当发送一个version的请求，用来得知broker的版本
       false：不发version的请求
     */
    private final boolean discoverBrokerVersions;

    //broker的版本
    private final ApiVersions apiVersions;
    //key为node id,value为ApiVersionsRequest.Builder的键值对
    private final Map&#x3C;String, ApiVersionsRequest.Builder> nodesNeedingApiVersionsFetch = new HashMap&#x3C;>();
    //取消的请求
    private final List&#x3C;ClientResponse> abortedSends = new LinkedList&#x3C;>();
</code></pre>
<p>这里我们介绍几个比较重要的字段。</p>
<ul>
<li><code>selector</code>：这个字段就是我们上一讲介绍的Kafka封装的Selector，网络IO的选择器负责监听网络IO事件，以及网络连接、读写等操作。</li>
<li><code>metadataUpdater</code>：对应的是内部类，目的是更新元数据。</li>
<li><code>connectionStates</code>：所有连接的状态都在这里管理。底层使用Map&#x3C;String，NodeConnectionState>实现，key是node id，value是NodeConnectionState对象，其中使用NodeConnectionState枚举表示连接状态，还记录了最后一次连接的时间戳。</li>
<li><code>inFlightRequests</code>：用以保存已经发出去了但是还没收到响应的Request的集合。</li>
<li><code>socketSendBuffer</code>：表示发送数据的缓冲区的大小。</li>
<li><code>socketReceiveBuffer</code>：表示接收数据的缓冲区的大小。</li>
<li><code>clientId</code>：client 端的 id，用来标识客户端身份。</li>
<li><code>reconnectBackoffMs</code>：重连的退避。为了防止短时间内重连造成的网络压力，设计了一个时间段，在这个时间段内不得重连。</li>
</ul>
<p>这里我们重点看下NetworkClient的内部类InFlightRequests，<strong>InFlightRequests是用来存储和操作待发送消息的缓存区</strong>。我们首先看一下它的字段和构造方法：</p>
<pre><code>final class InFlightRequests {
    //某个node连接上最多的请求数，默认5个
    private final int maxInFlightRequestsPerConnection;
    //key是nodeid,value是对于某个node的InFlightRequest集合
    private final Map&#x3C;String, Deque&#x3C;NetworkClient.InFlightRequest>> requests = new HashMap&#x3C;>();
    private final AtomicInteger inFlightRequestCount = new AtomicInteger(0);

    public InFlightRequests(int maxInFlightRequestsPerConnection) {
        this.maxInFlightRequestsPerConnection = maxInFlightRequestsPerConnection;
    }
</code></pre>
<p>那 InFlightRequests 的核心字段又是哪些呢？这里我简单介绍下。</p>
<ul>
<li>requests：Map&#x3C;String, Deque&#x3C;NetworkClient.InFlightRequest>>类对象，是一个 key 为 nodeid、value 为 Deque&#x3C;NetworkClient.InFlightRequest> 的键值对组成的 map。</li>
<li>maxInFlightRequestsPerConnection：某个node连接上最多的请求数，也就是队列的长度，默认是5。</li>
<li>inFlightRequestCount：所保存请求的个数。</li>
</ul>
<p>作为待发送请求的缓冲区，InFlightRequests是如何存储请求的呢？其存储结构如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a85d0cb656bd46cdbf55b1b8eb13250c~tplv-k3u1fbpfcp-watermark.image?" alt="D9C0A00A-4335-4457-96F4-00E35CFCA78B.png"></p>
<p>这里我们就结合这张图简单介绍一下inFlightRequests的结构：inFlightRequests是个map集合，每个node会对应一个请求队列；每次请求进入 InFlightRequests前，会先判断请求属于哪个node，然后再进入对应的队列。</p>
<p>不过，这容易出现一个<strong>发送消息乱序</strong>的问题。我们知道，所谓发送消息就是指真正发送消息成功的顺序，并不是按队列的顺序。</p>
<p>那为什么发送请求会产生乱序呢？因为maxInFlightRequestsPerConnection默认是5，也就是说每个node都可以最多保存5个请求。如果某个请求长时间没有响应，我们会认为响应超时，同时如果我们设置重试次数大于0，就会发生重试，而且重试的请求会重新排在队列的后面，这就破坏了一开始的发送顺序，造成了乱序。</p>
<p>那如何去避免这种乱序呢？这里我总结出两种方式，你可以结合自己实际工作场景选择合适的方案。</p>
<ol>
<li>把重试次数设置为0，这样即使出现超时情况也不会造成乱序。不过这种方式也有一个弊端：会丢消息。</li>
<li>把maxInFlightRequestsPerConnection设置为1，这样一个请求没有发送成功就会根据重试次数不断地重试。不过，这样会导致发送的效率变低。</li>
</ol>
<h2><strong>重要方法</strong></h2>
<p>inFlightRequests这个类的入队、出队的方法比较容易，你可以自己研究，这里我重点讲解以下几个方法。</p>
<h3>1.  <strong>canSendMore()</strong></h3>
<p>canSendMore() 方法的示例代码如下：</p>
<pre><code>public boolean canSendMore(String node) {
    Deque&#x3C;NetworkClient.InFlightRequest> queue = requests.get(node);
    return queue == null || queue.isEmpty() ||
           (queue.peekFirst().send.completed() &#x26;&#x26; queue.size() &#x3C; this.maxInFlightRequestsPerConnection);
}
</code></pre>
<p><strong>canSendMore()方法用来判断是否还能往对应的node发送更多的请求</strong>，以下三个条件中满足一个就能满足发送条件。</p>
<ol>
<li>queue == null，说明这个节点还没有对应的发送队列，也就是客户端对这个节点没有发送过请求。</li>
<li>queue.isEmpty()为true：队列里是空的，请求都发送完了。</li>
<li>queue.peekFirst().send.completed() &#x26;&#x26; queue.size() &#x3C; this.maxInFlightRequestsPerConnection成立，这个判断条件要想成立，“&#x26;&#x26;”前后两部分需要同时满足：①queue.peekFirst().send.completed()表示<strong>头结点的send必须发送完</strong>，如果还没发送完就发送，会覆盖KafkaChannel.send这个字段，进而造成没发送完的请求被覆盖；②queue.size() &#x3C; this.maxInFlightRequestsPerConnection表示<strong>节点的请求数量要小于规定的每个连接的最大请求数</strong>，因为堆积过多说明节点的网络有问题，继续发会造成超时。</li>
</ol>
<h3>2.  <strong>ready()</strong></h3>
<p><strong>ready()方法表示某个节点是否可以发送请求</strong>，对应的代码如下所示：</p>
<pre><code>public boolean ready(Node node, long now) {
    if (node.isEmpty())
        throw new IllegalArgumentException("Cannot connect to empty node " + node);
    //同时满足三个条件就认为可以连接
    if (isReady(node, now))
        return true;
    //   发起连接同时满足两个条件
    //   1.连接必须是isDisconnected。
    //   2.由于连接不能太频繁，两次重试之间时间差要大于重试退避时间。
    if (connectionStates.canConnect(node.idString(), now))
        //发起连接，不一定连接成功了
        initiateConnect(node, now);

    return false;
}
</code></pre>
<p>ready() 方法的执行流程是这样的，<strong>第一步先判断节点是否准备好接收请求了</strong>，同时满足以下三个条件就说明可以接收请求了。</p>
<ul>
<li>不能正在更新元数据，而且元数据不能过期；</li>
<li>node的连接处于ready状态；</li>
<li>inFlightRequests里能放更多的请求（上面解释inFlightRequests字段的时候说过，这里就不赘述了）。</li>
</ul>
<p><strong>如果上步判断没做好接收请求，</strong> 会尝试与对应的node连接，与node连接的条件也有两个：</p>
<ul>
<li>连接必须是isDisconnected，也就是说客户端和服务端的连接状态是没有连接上；</li>
<li>两次重试之间时间差要大于重试退避时间，目的是防止重连过于频繁而造成网络压力过大。</li>
</ul>
<p><strong>最后一步是初始化连接</strong>initiateConnect(node, now)，具体细节是修改channel的连接状态为正在连接，然后调用selector的connect()方法进行连接。注意，这时不一定连接上了，selector.poll()会监听连接是否准备好并完成连接。
 </p>
<h3>3.  <strong>发送数据相关的方法</strong></h3>
<p><strong>这里的发送数据是把数据发送到缓存里，并不是真正的网络发送</strong>，相关的方法如下：</p>
<pre><code>public void send(ClientRequest request, long now) {
    doSend(request, false, now);
}

private void doSend(ClientRequest clientRequest, boolean isInternalRequest, long now) {
    ensureActive();
    String nodeId = clientRequest.destination();
    if (!isInternalRequest) {
        //1.这个服务端节点能不能接收请求。
        // 1)连接是否正常。2）channel连接是否建立。3）inFlightRequests.canSendMore(node)：inFlightRequests是否还能接收请求。
        if (!canSendRequest(nodeId, now))
            throw new IllegalStateException("Attempt to send a request to node " + nodeId + " which is not ready.");
    }
       ......忽略
        //
        doSend(clientRequest, isInternalRequest, now, builder.build(version));
    } catch (UnsupportedVersionException unsupportedVersionException) {
       
       ......忽略
    }
}

private void doSend(ClientRequest clientRequest, boolean isInternalRequest, long now, AbstractRequest request) 
   ......忽略
    
    //1.构建NetworkSend对象
    Send send = request.toSend(destination, header);
    //2.构建inFlightRequest对象
    InFlightRequest inFlightRequest = new InFlightRequest(
            clientRequest,
            header,
            isInternalRequest,
            request,
            send,
            now);
    //3.把inFlightRequest加入inFlightRequest的集合里
    this.inFlightRequests.add(inFlightRequest);
    //4.把NetworkSend对象设置到selector的send字段
    selector.send(send);
}
</code></pre>
<p>首先，send()方法是最外层的方法，调用了doSend(ClientRequest clientRequest, boolean isInternalRequest, long now)方法，这个方法主要作用是<strong>判断inFlightRequests上对应的节点是不是能发送请求</strong>，条件有三个，必须同时满足。</p>
<ul>
<li>客户端和node连接正常。</li>
<li>客户端和node的channel连接建立。</li>
<li>inFlightRequests.canSendMore(node)：inFlightRequests对应的node还能接收请求。</li>
</ul>
<p>最后一步是调用doSend(ClientRequest clientRequest, boolean isInternalRequest, long now, AbstractRequest )这个方法，<strong>用于最终的请求发送</strong>，步骤如下：</p>
<ul>
<li>构建NetworkSend对象；</li>
<li>构建inFlightRequest对象；</li>
<li>把inFlightRequest加入inFlightRequests的集合里；</li>
<li>把NetworkSend对象设置到selector的send字段，等待下一步真正的网络发送。</li>
</ul>
<p>这一发送过程其实是把要发送的请求封装成inFlightRequest放到inFlightRequests的集合，然后放到对应channel的字段NetworkSend里缓存起来，而NetworkSend是对NIOBuffer的封装。总体来看，<strong>这个发送过程就是为下一步真正的网络IO发送而服务的</strong>。</p>
<h3>4.  <strong>poll()</strong></h3>
<p><strong>poll()方法是核心方法</strong>，它会对注册在selector上的网络事件进行监听和处理，然后再根据处理后的集合做进一步的整合，最后封装response并调用消息的回调方法，完成一次从request到response的过程。代码如下所示：</p>
<pre><code>public List&#x3C;ClientResponse> poll(long timeout, long now) {
    ensureActive();

    if (!abortedSends.isEmpty()) {
     
        List&#x3C;ClientResponse> responses = new ArrayList&#x3C;>();
        handleAbortedSends(responses);
        completeResponses(responses);
        return responses;
    }
    //1.尝试更新元数据
    long metadataTimeout = metadataUpdater.maybeUpdate(now);
    try {
        //2.执行IO操作
        this.selector.poll(Utils.min(timeout, metadataTimeout, defaultRequestTimeoutMs));
    } catch (IOException e) {
        log.error("Unexpected error during I/O", e);
    }

    // process completed actions
    long updatedNow = this.time.milliseconds();
    List&#x3C;ClientResponse> responses = new ArrayList&#x3C;>();
    //3.处理completedSends队列
    handleCompletedSends(responses, updatedNow);
    //4.处理completedReceives队列
    handleCompletedReceives(responses, updatedNow);
    // 5.处理 disconnected列表
    handleDisconnections(responses, updatedNow);
    // 6.处理connected列表
    handleConnections();
    handleInitiateApiVersionRequests(updatedNow);
    //7.处理超时连接：
    // 关闭与node连接超时的连接
    // 删除InFlightRequests中的超时请求
    handleTimedOutConnections(responses, updatedNow);
    //8.处理超时请求
    handleTimedOutRequests(responses, updatedNow);
    //9.调用每个消息自定义的回调
    completeResponses(responses);

    return responses;
}
</code></pre>
<p>poll() 方法的执行步骤还是比较复杂的，下面我们就按照先后顺序讲解下这各个步骤。</p>
<p><strong>第一步，尝试更新元数据</strong>。元数据的变化会影响到消息发送的行为，比如有些主题删除了，这些消息就没必要发了。</p>
<p><strong>第二步，调用Selector.select()执行IO操作</strong>，这是调用我们上一讲介绍的Selector组件去真正地执行IO操作，这个操作会产生以下 3 个集合。</p>
<ul>
<li>connected集合：已经完成连接的node集合。</li>
<li>completedReceives集合：接收完成的集合，意味着KafkaChannel上的NetworkReceive写满后放入这个集合里。</li>
<li>completedSends集合：发送完成的集合，channel上的NetworkSend读完后会放入这个集合里。</li>
</ul>
<p><strong>第三步，调用handleCompletedSends()方法，处理completedSends集合</strong>。completedSends 集合与 inFlightRequests集合是<strong>协作</strong>的关系。completedSends是指发送成功但是没有返回的请求集合，<strong>completedSends的元素对应着inFlightRequests里对应队列的最后一个元素</strong>，两者关系如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f51378426dc4b91a76a5eecce31d856~tplv-k3u1fbpfcp-watermark.image?" alt="F96682C7-1F50-4ED7-A865-88E7E0B605EC.png"></p>
<p>搞清completedSends集合与inFlightRequests的关系后，我们接着分析poll()方法内部调用的<code>handleCompletedSends()</code> 方法代码：</p>
<pre><code>
private void handleCompletedSends(List&#x3C;ClientResponse> responses, long now) {
    //1.遍历completedSends集合
    for (Send send : this.selector.completedSends()) {
        //2.获取队列最后一个元素
        InFlightRequest request = this.inFlightRequests.lastSent(send.destination());
        //3.是否需要响应
        if (!request.expectResponse) {//
            //4.不需要响应就删除inFlightRequests对应node请求队列的第一个元素
           this.inFlightRequests.completeLastSent(send.destination());
            //5.把请求添加到responses集合
            responses.add(request.completed(null, now));
        }
    }
}
</code></pre>
<p>可以看到，方法通过遍历completedSends集合，取出对应队列的最后一个元素，然后再判断请求是否需要响应。<strong>在Kafka中，有的请求是不需要响应的，对应发送完了不用考虑是否发送成功的场景</strong>。如果不需要响应，就构建callback为null的response对象，并把对象加到responses集合中。（需要响应的请求在下面步骤会讲解的。）</p>
<p><strong>第四步，调用handleCompletedReceives()方法，这个方法用来处理CompletedReceives队列</strong>。CompletedReceives队列是接收到的响应的集合，CompletedReceives集合与inFlightRequests集合同样有<strong>协作</strong>的关系，两个集合关系如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f08b7d903c014baca2baeb792f002a2f~tplv-k3u1fbpfcp-watermark.image?" alt="3528594B-3E47-4F4B-A569-40419DA44832.png"></p>
<p>与completedSends正好相反，CompletedReceives集合的元素对应inFlightRequest队列的队头元素。selector.poll()方法会把接收到的响应对应的请求从inFlightRequests集合中删除。对应的handleCompletedReceives()方法代码如下所示：</p>
<pre><code>/**
 * 处理CompletedReceives队列,根据返回的响应信息实例化ClientResponse,并加到响应集合里
 */
private void handleCompletedReceives(List&#x3C;ClientResponse> responses, long now) {
    for (NetworkReceive receive : this.selector.completedReceives()) {
        //1.取出发送请求的node id
        String source = receive.source();
        // 2.从inFlightRequests取出对应的InFlightRequest对象，并从inFlightRequests删除
        InFlightRequest req = inFlightRequests.completeNext(source);
        // 3.解析响应
        Struct responseStruct = parseStructMaybeUpdateThrottleTimeMetrics(receive.payload(), req.header,
            throttleTimeSensor, now);
        AbstractResponse response = AbstractResponse.
            parseResponse(req.header.apiKey(), responseStruct, req.header.apiVersion());
   ......忽略
        //流控方法
        maybeThrottle(response, req.header.apiVersion(), req.destination, now);
        
        if (req.isInternalRequest &#x26;&#x26; response instanceof MetadataResponse)
            // 4.1 判断返回类型，如果是请求元数据的返回调用metadataUpdater,handleSuccessfulResponse处理
            metadataUpdater.handleSuccessfulResponse(req.header, now, (MetadataResponse) response);
            // 4.2 如果是请求broker api 版本的,调用handleApiVersionsResponse处理
        else if (req.isInternalRequest &#x26;&#x26; response instanceof ApiVersionsResponse)
            handleApiVersionsResponse(responses, req, now, (ApiVersionsResponse) response);
        else
            //5.常规的发送消息的响应，ClientResponse并加到response集合中。
            responses.add(req.completed(response, now));
    }
}
</code></pre>
<p><strong>第五步，调用handleDisconnections()方法，处理与node断开连接的请求</strong>。大体过程是，遍历disConnections列表删除inFlightRequests里对应node的队列，同时取消对这个node的api version的请求，因为连接断了，请求这个node也就没有意义了。</p>
<p><strong>第六步，调用handleConnections()方法，处理connected列表</strong>。主要功能是把node放入connectionStates集合里。</p>
<p><strong>第七步，调用handleTimedOutConnections()方法，处理连接超时的node集合</strong>。逻辑和handleDisconnections()方法相似，这里就不详细说明了，你若感兴趣的话，可以看源码了解下。</p>
<p><strong>第八步，调用handleTimedOutRequests()方法</strong>，找到inFlightRequests里超时的请求，然后把相应节点连接的状态改为DISCONNECTED。</p>
<p><strong>第九步，调用completeResponses(responses)方法</strong>，用来调用每个消息自定义的回调。</p>
<p>至此，<strong>poll()方法就讲解完了，这个方法比较长，也很重要，是<code>网络通信的核心主干方法</code></strong>，涵盖了元数据获取、网络IO，然后对应各种情况去填充响应集合<strong>responses</strong>，希望你能把这个流程梳理清楚。</p>
<h2>总结</h2>
<p>这一讲我们主要介绍了NetworkClient类的重要字段和方法。<strong>NetworkClient 类是客户端连接所有外部节点的管理类，实现了对KafkaChannel的管理，同时利用底层通信类实现网络连接、网络读写的功能。</strong></p>
<p>首先，我们讲解了NetworkClient 类几个重要的字段：</p>
<ul>
<li><code>inFlightRequests</code>是用来保存已经发送但是还没响应的请求；</li>
<li><code>connectionStates</code>用来保存客户端和所有服务端的连接状态。</li>
</ul>
<p>然后，我们还分析了NetworkClient 类几个重要的方法：</p>
<ul>
<li><code>ready()</code>方法用来判断哪些channel连接是正常的；</li>
<li><code>doSend()</code>方法实例化NetworkSend类对象，并把其赋给KafkaChannel的send字段，然后实例化InFlightRequest类对象并把它加到inFlightRequests集合里；</li>
<li><code>poll()</code>方法可实现网络连接、读写，同时会收集读写到的数据，最后包装成响应集合responses，并且调用上层定义的回调方法完成对响应的处理。</li>
</ul>
<p>在学习过程中，如果有什么问题或者不懂的地方，欢迎你在留言区与我分享交流，或者扫描下方二维码加入我们的学习交流群，进群口令是：<code>kafka源码2022</code>。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed72fa7d07024a1fb979f2ebc36ffca9~tplv-k3u1fbpfcp-watermark.image?" alt="小册姐企业号.png"></p></div>
</body></html>