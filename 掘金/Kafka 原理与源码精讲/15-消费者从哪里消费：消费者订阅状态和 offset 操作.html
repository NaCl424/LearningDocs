<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>消费者从哪里消费：消费者订阅状态和 offset 操作</h1>
<p>前面两节课我们讨论了消费者加入GroupCoordinator并获取到分区方案的源码。那么我们既然知道了消费者的分区是不是就能直接消费了呢？不是的，因为<code>我们还不知道消费者的订阅状态信</code>息，比如，消费者订阅的主题是否有变化，消费到分区的哪个offset了……这些订阅信息我们需要管理。</p>
<p>同时，根据我们前几节课讲到的消费组重平衡的原理，在消费者开始消费的过程中和Rebalance操作之前都要提交一次offset。在消费者刚开始消费某个partition的时候也需要获取分区的offset。这就涉及到了offset的提交和获取操作。</p>
<p>因此，这节课我们讨论消费者订阅状态和消费者如何提交和获取offset的。</p>
<h2>消费者订阅状态：SubscriptionState 类</h2>
<p>Kafka消费者使用SubscriptionState类来<strong>保存消费者订阅的主题，并追踪TopicPartition与offset的对应关系</strong>。这里，我们需要学习一下 SubscriptionState 类的字段和方法。</p>
<h3>字段</h3>
<pre><code>public class SubscriptionState {
    private static final String SUBSCRIPTION_EXCEPTION_MESSAGE =
            "Subscription to topics, partitions and pattern are mutually exclusive";

    private final Logger log;
    //表示订阅Topic的模式，分四类：
    private enum SubscriptionType {
        NONE, //初始值。
        AUTO_TOPICS, //按指定的Topic进行订阅，自动分配分区。
        AUTO_PATTERN, //按正则表达式匹配的topic进行订阅，自动分配分区。
        USER_ASSIGNED //用户自己定制消费者要消费的topic和分区。
    }

    private SubscriptionType subscriptionType;

    //用来过滤topic的正则表达式
    private Pattern subscribedPattern;

    //用户手动写的要订阅的topic
    private Set&#x3C;String> subscription;

    //消费组订阅的所有topic
    private Set&#x3C;String> groupSubscription;

    //记录消费者里主题分区的状态集合。
    private final PartitionStates&#x3C;TopicPartitionState> assignment;
    private final OffsetResetStrategy defaultResetStrategy;
    private ConsumerRebalanceListener rebalanceListener;
    private int assignmentId = 0;
</code></pre>
<ul>
<li><code>SubscriptionType</code>：枚举类。表示订阅Topic的模式，有以下四类。</li>
</ul>
<ol>
<li>NONE：初始值。</li>
<li>AUTO_TOPICS：按指定的Topic进行订阅，自动分配分区。</li>
<li>AUTO_PATTERN：按正则表达式匹配的topic进行订阅，自动分配分区。</li>
<li>USER_ASSIGNED：用户自己指定消费者要消费的topic和分区。</li>
</ol>
<ul>
<li>
<p><code>subscribedPattern</code>：用来过滤主题的正则表达式。符合这个正则表达式的主题都会成为订阅主题。</p>
</li>
<li>
<p><code>subscription</code>：Set集合。用户手动指定的订阅主题。</p>
</li>
<li>
<p><code>groupSubscription</code>：消费组订阅的所有topic。当这个消费者被服务端groupCoordinator选为leader consumer的时候，这个字段是消费组所有消费者订阅的主题，用于监控消费组主题相关的元数据的变化，以满足消费组重平衡时为消费组制定分区方案的需要。而如果是follower consumer，由于不涉及为消费组全体消费者指定分区方案，这个字段只会保存本消费者订阅的主题。</p>
</li>
<li>
<p><code>assignment</code>：记录消费者里主题分区的状态集合。集合元素是TopicPartitionState，记录着每一个主题分区的消费情况，包括消费到分区的哪个位置了。</p>
</li>
<li>
<p><code>defaultResetStrategy</code>：默认重置策略。所谓重置策略就是当消费者重启的时候会使用什么策略进行消费，消费策略有两种：<code>LATEST</code>，从分区最后位置消费；<code>EARLIEST</code>，从分区最一开始的位置消费。</p>
</li>
<li>
<p><code>rebalanceListener</code>：ConsumerRebalanceListener类的对象。用于监听重平衡后消费者要消费的分区的变化。</p>
</li>
</ul>
<h3>方法</h3>
<p>类的方法都比较简单，这里我就挑选其中一个方法给你讲解一下。</p>
<p><strong>subscribe()，这个方法功能是用户指定要订阅的主题。</strong></p>
<pre><code>public synchronized boolean subscribe(Set&#x3C;String> topics, ConsumerRebalanceListener listener) {
    registerRebalanceListener(listener);
    setSubscriptionType(SubscriptionType.AUTO_TOPICS);
    return changeSubscription(topics);
}
</code></pre>
<p>首先，配置监控重平衡事件的监听器；然后设置订阅分区类型为AUTO_TOPICS，也就是自动配置分区；最后，配置要订阅的主题。</p>
<p>好，订阅状态基本讲完了，下面讲解 offset 的提交和获取。</p>
<h2>消费者提交和获取 offset</h2>
<p>前面几节课我们学习消费组的重平衡的时候，我们提到在重平衡消费组之前，消费者要向从属的Group Coordinator提交offset记录当前消费的位置。其实不仅仅是重平衡这个场景要提交offset，消费组在正常消费的过程中也是要向服务端提交offset的，因为如果消费者挂掉了，别的消费者会根据分区现在的offset继续消费。</p>
<h3>消费者提交 offset</h3>
<p>我们先了解一下 OffsetCommitRequest 和 OffsetCommitResponse 的消息体格式。</p>
<p><strong>OffsetCommitRequest 消息体格式</strong>示意图如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e837df5fa1e04f31837aa2f62f512735~tplv-k3u1fbpfcp-watermark.image?" alt="E016F3AC-289E-41BA-BA2F-A35424622D9B.png"></p>
<p>其各字段含义如下表：</p>


















































<table><thead><tr><th>名称</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>group_id</td><td>String</td><td>Consumer Group的Id</td></tr><tr><td>group_generation_id</td><td>int</td><td>消费者保存的年代信息</td></tr><tr><td>member_id</td><td>String</td><td>GroupCoordinator分配给消费者的id</td></tr><tr><td>retention_time</td><td>long</td><td>此offset的最长保存时间</td></tr><tr><td>topic</td><td>String</td><td>topic名称</td></tr><tr><td>partition</td><td>int</td><td>分区编号</td></tr><tr><td>offset</td><td>long</td><td>提交的信息offset</td></tr><tr><td>metadata</td><td>String</td><td>任何希望与offset一起保存的自定义数据</td></tr></tbody></table>
<p><strong>OffsetCommitResponse 消息体格式</strong>如下示意图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90347c443f4344bfb092ce9f660f1b73~tplv-k3u1fbpfcp-watermark.image?" alt="E4C837C3-749B-4DE6-83F5-896221E8B768.png"></p>
<p>其各字段含义如下表：</p>

























<table><thead><tr><th>名称</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>topic</td><td>String</td><td>topic名称</td></tr><tr><td>partition</td><td>int</td><td>分区编号</td></tr><tr><td>error_code</td><td>short</td><td>错误码</td></tr></tbody></table>
<p>接下来，我们重点说说提交offset涉及的相关方法。提交offset有两个。</p>
<p><strong>一个是异步提交</strong>。异步提交是指业务线程提交offset的时候不用等待服务端发来的响应，业务线程可以继续做接下来的工作，而响应结果由回调对象处理。好处是：由于线程没有阻塞，提升线程的并发度有所提升。但是如果线程后面的逻辑对于消费者是否成功消费敏感就不适用了。</p>
<p><strong>另一个是同步提交</strong>。与异步提交相反，业务线程必须等待offset提交完才能往下执行。这种场景会造成线程的阻塞，影响线程的并发性，但是适用于线程后面的逻辑对消费者是否成功消费敏感。</p>
<p>这节课我们只讨论异步提交的方法，同步提交的逻辑差不多，你可以自己学习。</p>
<p>我们首先看一下上次逻辑调用自动提交offset的入口方法<strong>maybeAutoCommitOffsetsAsync()</strong>：</p>
<pre><code>public void maybeAutoCommitOffsetsAsync(long now) {
    //是否开启了偏移量。
    if (autoCommitEnabled) {
        //记录当前提交偏移量的时间，目的是为了计时。
        nextAutoCommitTimer.update(now);
        //超时判断，超时时间是autoCommitIntervalMs。
        if (nextAutoCommitTimer.isExpired()) {
            //重置下次过期时间
            nextAutoCommitTimer.reset(autoCommitIntervalMs);
            doAutoCommitOffsetsAsync();
        }
    }
}
</code></pre>
<p>首先根据参数autoCommitEnabled判断是否是自动提交，autoCommitEnabled对应配置文件的参数是auto.commit.interval.ms，默认是5000ms。如果是自动提交就更新提交偏移量的时间，然后判断当定时器过时的时候重置下次提交offset的时间，最后调用方法doCommitOffsetsAsync()。</p>
<p>我们继续看一下对应的方法 <strong>doCommitOffsetsAsync()</strong> 的源码：</p>
<pre><code>private void doCommitOffsetsAsync(final Map&#x3C;TopicPartition, OffsetAndMetadata> offsets, final OffsetCommitCallback callback) {
    //1.创建并缓存OffsetCommiteRequest请求
    RequestFuture&#x3C;Void> future = sendOffsetCommitRequest(offsets);
    //2.得到回调对象
    final OffsetCommitCallback cb = callback == null ? defaultOffsetCommitCallback : callback;
    //3.给异步请求加监听器。
    future.addListener(new RequestFutureListener&#x3C;Void>() {
        @Override
        public void onSuccess(Void value) {
            if (interceptors != null)
                interceptors.onCommit(offsets);
            //把完成的offset提交加到完成队列中
            completedOffsetCommits.add(new OffsetCommitCompletion(cb, offsets, null));
        }

        @Override
        public void onFailure(RuntimeException e) {
            Exception commitException = e;

            if (e instanceof RetriableException) {
                commitException = new RetriableCommitFailedException(e);
            }
            completedOffsetCommits.add(new OffsetCommitCompletion(cb, offsets, commitException));
            if (commitException instanceof FencedInstanceIdException) {
                asyncCommitFenced.set(true);
            }
        }
    });
}
</code></pre>
<p>还是简单说说这个方法的步骤。</p>
<p>第一步，调用方法sendOffsetCommitRequest()创建OffsetCommiteRequest请求，并把请求缓存到ConsumerNetworkClient的unsent集合里。</p>
<p>第二步，获取完成提交offset的回调对象。</p>
<p>第三步，给异步请求加监听器，值得注意的是，跟前面一些异步请求的监听器不同。这里的监听器对应成功的响应的处理是把回调方法放到一个队列里让上层逻辑调用。</p>
<p>好，我们再分析一下创建并缓存OffsetCommiteRequest请求的方法 <strong>sendOffsetCommitRequest()</strong>。</p>
<pre><code>RequestFuture&#x3C;Void> sendOffsetCommitRequest(final Map&#x3C;TopicPartition, OffsetAndMetadata> offsets) {
    if (offsets.isEmpty())
        return RequestFuture.voidSuccess();
    //1.获取 Group Coordinator。
    Node coordinator = checkAndGetCoordinator();
    if (coordinator == null)
        return RequestFuture.coordinatorNotAvailable();
    //开始创建offset提交的请求。
    //2.创建要发送的key为主题，value为这个主题下的分区要提交offset信息 的map集合，
    Map&#x3C;String, OffsetCommitRequestData.OffsetCommitRequestTopic> requestTopicDataMap = new HashMap&#x3C;>();
    for (Map.Entry&#x3C;TopicPartition, OffsetAndMetadata> entry : offsets.entrySet()) {
        ......忽略
        //3.填充集合
        requestTopicDataMap.put(topicPartition.topic(), topic);
    }

    final Generation generation;
    //4.如果是自动分配分区方案
    if (subscriptions.hasAutoAssignedPartitions()) {
        generation = generationIfStable();
        // 如果generation为空，就认为这个消费者没有加入一个激活的消费组。
        // 要做的事情是提交offset失败，然后让消费者重新加入组。
        if (generation == null) {
            log.info("Failing OffsetCommit request since the consumer is not part of an active group");

            if (rebalanceInProgress()) {
                //如果消费者在重平衡的过程中，那么就返回正在重平衡的异常
                return RequestFuture.failure(new RebalanceInProgressException("Offset commit cannot be completed since the " +
                    "consumer is undergoing a rebalance for auto partition assignment. You can try completing the rebalance " +
                    "by calling poll() and then retry the operation."));
            } else {
                //如果消费者不在重平衡的过程中，那么就返回消费者不在激活的消费组异常。
                return RequestFuture.failure(new CommitFailedException("Offset commit cannot be completed since the " +
                    "consumer is not part of an active group for auto partition assignment; it is likely that the consumer " +
                    "was kicked out of the group."));
            }
        }
        //如果是指定消费分区就不考虑
    } else {
        generation = Generation.NO_GENERATION;
    }
    //5.构造提交offset的请求。
    OffsetCommitRequest.Builder builder = new OffsetCommitRequest.Builder(
            new OffsetCommitRequestData()
                    .setGroupId(this.rebalanceConfig.groupId)
                    .setGenerationId(generation.generationId)
                    .setMemberId(generation.memberId)
                    .setGroupInstanceId(rebalanceConfig.groupInstanceId.orElse(null))
                    .setTopics(new ArrayList&#x3C;>(requestTopicDataMap.values()))
    );


    log.trace("Sending OffsetCommit request with {} to coordinator {}", offsets, coordinator);
    //6.把请求保存在client的缓存中，同时配置回调对象。
    return client.send(coordinator, builder)
            .compose(new OffsetCommitResponseHandler(offsets, generation));
}
</code></pre>
<p>我再给你简单介绍一下这个方法的步骤。</p>
<p>第一步，获取 Group Coordinator。当Group Coordinator为null时，我们认为消费者连从属的Group Coordinator都找不到，那么提交offset就无从谈起了，于是返回Group Coordinator不可用的结果。</p>
<p>第二步，创建map集合requestTopicDataMap，里面的entry的key为主题，value为主题下分区的提交offset的信息。</p>
<p>第三步，填充集合requestTopicDataMap。</p>
<p>第四步，判断消费者的分区方案是自动的还是手动的。如果是自动的，要判断generation是否为空，如果为空我们认为消费者没有加入到活跃的group coordinator中，如果一个消费者没有加入到活跃的group coordinator中那么我们认为它的分区分配方案是有问题的。那么提交offset请求也应该拦截，对于提交offset请求的拦截有两个场景：</p>
<ol>
<li>
<p>加入的消费组在重平衡过程中，这是我们可以把这种情况合并为消费组正在重平衡的异常，并抛出消费组正在重平衡的异常。</p>
</li>
<li>
<p>加入的消费组不在重平衡过程中，我们抛出提交offset的异常。</p>
</li>
</ol>
<p>第五步，构建提交offset的请求。</p>
<p>第六步，把请求保存在client的缓存中，同时配置offset提交请求回调对象。</p>
<p>我们来看下，回调对象的类方法<strong>OffsetCommitResponseHandler.handle()</strong>：</p>
<pre><code>public void handle(OffsetCommitResponse commitResponse, RequestFuture&#x3C;Void> future) {
    sensors.commitSensor.record(response.requestLatencyMs());
    Set&#x3C;String> unauthorizedTopics = new HashSet&#x3C;>();
    //1.遍历已提交的所有offset的信息。
    for (OffsetCommitResponseData.OffsetCommitResponseTopic topic : commitResponse.data().topics()) {
        for (OffsetCommitResponseData.OffsetCommitResponsePartition partition : topic.partitions()) {
            TopicPartition tp = new TopicPartition(topic.name(), partition.partitionIndex());
            OffsetAndMetadata offsetAndMetadata = this.offsets.get(tp);

            long offset = offsetAndMetadata.offset();

            Errors error = Errors.forCode(partition.errorCode());
            if (error == Errors.NONE) {
                log.debug("Committed offset {} for partition {}", offset, tp);
            } else {
               ......各种错误的处理
    }
    //
    if (!unauthorizedTopics.isEmpty()) {
        log.error("Not authorized to commit to topics {}", unauthorizedTopics);
        future.raise(new TopicAuthorizationException(unauthorizedTopics));
    } else {
        //2.把成功提交的事件传播出去。
        future.complete(null);
    }
}
</code></pre>
<p>这个方法很简单，就是遍历提交offset请求的响应，如果有错误就根据错误类型分别处理，如何没有错误就把提交offset成功的事件传播出去。</p>
<h3>消费者获取 offset</h3>
<p><strong>消费者获取offset的目的是获取新分配的分区的消费offset</strong>。比如，消费者刚刚启动后Group Coordinator给它分配了要消费的分区，但是消费者不知道从哪个offset消费。这就需要消费者向Group Coordinator发送请求获取分区对应的offset。</p>
<p>我们还是要先看下消费者获取offset的请求体和响应体。</p>
<p><strong>请求体 OffsetFetch Request</strong> 如下图：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e08e183d96d2495a87294ebc584b7ca1~tplv-k3u1fbpfcp-watermark.image?" alt="9B1BAD78-293B-43CE-8181-0823EEB86B06.png"></p>
<p><strong>响应体 OffsetFetch Response</strong> 如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f60bfefa76a14ebfaa9d947e1c498ce2~tplv-k3u1fbpfcp-watermark.image?" alt="88D7553E-00DB-41CE-9CAB-8807D4CD0D27.png"></p>
<p>然后我们学习获取offset的相关方法的源码。获取offset的方法还是在ConsumerCoordinator中，<strong>入口方法是refreshCommittedOffsetsIfNeeded()</strong>：</p>
<pre><code>public boolean refreshCommittedOffsetsIfNeeded(Timer timer) {
    //1.获取处于初始化阶段的分区。
    final Set&#x3C;TopicPartition> initializingPartitions = subscriptions.initializingPartitions();
    //2.向group coordinator阻塞发送获取offset的请求
    final Map&#x3C;TopicPartition, OffsetAndMetadata> offsets = fetchCommittedOffsets(initializingPartitions, timer);
    if (offsets == null) return false;
    //3.循环获取分区对应的offset
    for (final Map.Entry&#x3C;TopicPartition, OffsetAndMetadata> entry : offsets.entrySet()) {
        final TopicPartition tp = entry.getKey();
        final OffsetAndMetadata offsetAndMetadata = entry.getValue();
        if (offsetAndMetadata != null) {
              entry.getValue().leaderEpoch().ifPresent(epoch -> this.metadata.updateLastSeenEpochIfNewer(entry.getKey(), epoch));
            //4.判断这个分区是否给这个消费者分配了。
            if (this.subscriptions.isAssigned(tp)) {
                final ConsumerMetadata.LeaderAndEpoch leaderAndEpoch = metadata.currentLeader(tp);
                final SubscriptionState.FetchPosition position = new SubscriptionState.FetchPosition(
                        offsetAndMetadata.offset(), offsetAndMetadata.leaderEpoch(),
                        leaderAndEpoch);
                //更新subscriptions对应的分区offset
                this.subscriptions.seekUnvalidated(tp, position);

                log.info("Setting offset for partition {} to the committed offset {}", tp, position);
            } else {
                log.info("Ignoring the returned {} since its partition {} is no longer assigned",
                    offsetAndMetadata, tp);
            }
        }
    }
    return true;
}
</code></pre>
<p>我们简单描述下该方法的步骤。</p>
<p>第一步，获得获取offset状态是初始化状态的分区集合，因为只有初始化状态的分区获取已提交offset才有意义。</p>
<p>第二步，调用方法fetchCommittedOffsets()向group coordinator发送获取offset的请求，并返回分区对应的已提交offset的map集合。</p>
<p>第三步，循环获取每个分区对应的offset元数据信息，更新subscriptions里分区已经提交的offset。</p>
<p>第四步，判断这个分区是否是消费者要消费的分区。因为如果重平衡后这个消费者不在消费这个分区，那就没有意义再更新分区的已提交offset了。</p>
<p>第五步，如果这个分区是消费者要消费的分区，就在subscriptions里更新分区已提交offset。</p>
<p>这里<code>第二步</code>中用于发送获取已提交offset请求的 <strong>fetchCommittedOffsets()</strong> 我需要再给你讲解一下，源码如下：</p>
<pre><code>public Map&#x3C;TopicPartition, OffsetAndMetadata> fetchCommittedOffsets(final Set&#x3C;TopicPartition> partitions,
                                                                    final Timer timer) {
    if (partitions.isEmpty()) return Collections.emptyMap();
    
    final Generation generationForOffsetRequest = generationIfStable();
    //1.判断是否已经发送过了同样的请求。
    if (pendingCommittedOffsetRequest != null &#x26;&#x26;
        !pendingCommittedOffsetRequest.sameRequest(partitions, generationForOffsetRequest)) {
        pendingCommittedOffsetRequest = null;
    }

    do {
        //2.判断Coordinator是否可用。
        if (!ensureCoordinatorReady(timer)) return null;

        final RequestFuture&#x3C;Map&#x3C;TopicPartition, OffsetAndMetadata>> future;
        if (pendingCommittedOffsetRequest != null) {
            future = pendingCommittedOffsetRequest.response;
        } else {
            //3.缓存获取offset的请求，并配置回调对象。
            future = sendOffsetFetchRequest(partitions);
            pendingCommittedOffsetRequest = new PendingCommittedOffsetRequest(partitions, generationForOffsetRequest, future);
        }
        //4.网络发送获取offset的请求。
        client.poll(future, timer);
        //5.阻塞等待响应处理完成。
        if (future.isDone()) {
            //把pendingCommittedOffsetRequest置为空，这样下个获取已提交offset的请求就能执行了
            pendingCommittedOffsetRequest = null;

            if (future.succeeded()) {
                return future.value();
            } else if (!future.isRetriable()) {
                throw future.exception();
            } else {
                timer.sleep(rebalanceConfig.retryBackoffMs);
            }
        } else {
            return null;
        }
    } while (timer.notExpired());
    return null;
}
</code></pre>
<p>简单描述下发送请求的过程。</p>
<p>第一步，判断是否已经发送过了同样的请求。因为有可能已经发送了获取已提交offset的请求但还没有返回。如果为ture，我们就把pendingCommittedOffsetRequest赋值为null。判断为ture的条件是下面两个条件必须同时满足：</p>
<ul>
<li>pendingCommittedOffsetRequest != null ：pendingCommittedOffsetRequest不为空。pendingCommittedOffsetRequest是正在获取但还没返回的已提交offset的请求。</li>
<li>!pendingCommittedOffsetRequest.sameRequest(partitions, generationForOffsetRequest)：判断现在的请求是否和上次的一样。</li>
</ul>
<p>第二步，确保Group Coordinator是否可用，如果可用直接返回，如果不可用就要查找Group Coordinator并创建连接。</p>
<p>第三步，根据pendingCommittedOffsetRequest的值是否为空采用不同的处理逻辑。如果不为空，说明跟上次的请求是一个请求，就不用再发送网络请求了，直接把上个请求future赋给现在的请求future。如果为空，我们再缓存获取offset的请求，并配置回调。</p>
<p>第四步，网络发送获取已提交offset的请求。</p>
<p>第五步，阻塞等待已提交offset的请求的响应。如果future完成了，则pendingCommittedOffsetRequest置为null。这样下个相同获取已提交offset的请求就不用在缓存获取offset的请求了。</p>
<p>好，讲完了发送消息，我们再来看一下处理响应的回调方法的代码，回调方法是OffsetFetchResponseHandler类的handle()方法。具体步骤是处理错误响应。构建分区和已提交offset的map集合offsets。最后如果响应正常的话就调用future.complete(offsets)完成异步请求。</p>
<h2>总结</h2>
<p>这节课我给你详细讲解了消费者的订阅状态。消费者的订阅状态保存的是订阅的主题，同时维护着订阅主题下所有分区以及分区对应的已提交offset的集合。我们还介绍了消费者提交和获取已提交offset，消费者提交和获取已提交offset都是要和服务端Group Coordinator发送通信。我们分析了消费者提交offset请求和获取已提交offset请求的请求体和响应体，还有发送请求的方法和处理响应的回调方法。</p>
<p>下节课我们继续讲解消费者如何从 broker 获取消息的内容。</p></div>
</body></html>