<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>对NIO的优雅封装（上）：封装SocketChannel、Buffer</h1>
<blockquote>
<p>这节课我提供了视频讲解，在源码讲解的基础上增加了原理解析和架构学习的部分，对应的视频地址如下
<a href="https://www.bilibili.com/video/BV1ZT4y167Jg" target="_blank" rel="nofollow noopener noreferrer">https://www.bilibili.com/video/BV1ZT4y167Jg</a>
Kafka 是一个分布式系统，生产者和服务端在不同的机器上，这就会涉及网络通信，Java 系统的网络通信一般会用 Java 多路复用的实现库 NIO，同时 <code>Kafka 内部对 Java NIO 封装了统一的框架，实现了多路复用的网络 IO 操作</code>。之所以 Kafka 要自己实现 Java NIO 的封装，而不采用类似 Netty 那样 NIO 封装好的类库，就是因为自己实现的更加适合 Kafka 的一些特性。</p>
</blockquote>
<p>为便于你更好地理解，这里我用一个思维导图大体描述下这一讲我们要讲的知识点：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1519289bf3d4ca18193b9cc90eb38c5~tplv-k3u1fbpfcp-watermark.image?" alt="5A604D68-A6D3-44E4-8167-461663C3D414.png"></p>
<h2>Java NIO 简单介绍</h2>
<p>这里我们介绍几个 Java NIO 的组件。</p>
<ul>
<li><code>Buffer：缓冲区</code>。这是一个接口，Kafka 用它的 ByteBuffer 实现类，配合 SocketChannel 实现读写操作。读的时候，调用 channel.read(buffer) 把 SocketChannel 的数据读到 ByteBuffer 内；写的时候，调用 channel.write(buffer) 把 Buffer 中的数据写到 SocketChannel 内。</li>
<li><code>SocketChannel：网络连接通道</code>。字节数据的读写都发生在这个通道上，包括从通道中读出数据、将数据写入通道。</li>
<li><code>SelectionKey：选择键</code>。每个 Channel 向 Selector 注册标识时，都将会创建一个 SelectionKey。SelectionKey 里可以定义 Selector 监听 SocketChannel 的事件，包括连接、读、写事件。</li>
<li><code>Selector：选择器</code>。SelectionKey 先把 SocketChannel 注册到 Selector 上，然后就能监听网络连接、读、写事件。</li>
</ul>
<h2>Kafka 对 Java NIO 的封装</h2>
<p>下面我列出了 Kafka 对 Java NIO 封装后的组件，以及和 NIO 组件的对应关系。</p>
<ul>
<li><code>Kafka 自己的 Selector 类</code>：对 NIO 中 Selector 的封装。</li>
<li><code>TransportLayer</code>：对 NIO 中 SocketChannel 和 SelectionKey 的封装。TransportLayer 是一个接口，实现类有 PlaintextTransportLayer 和 SslTransportLayer，其中，PlaintextTransportLayer 是明文网络传输，SslTransportLayer 是 SSL 加密网络传输，这一讲我们只涉及明文网络传输的讲解。</li>
<li><code>NetworkReceive</code>：对 NIO 中读 Buffer 的封装。</li>
<li><code>NetworkSend</code>：对 NIO 中写 Buffer 的封装。</li>
<li><code>KafkaChannel</code>：把 TransportLayer、NetworkReceive 和 NetworkSend 又做了一次封装，这样用起来比较方便，就不用关心底层的组件了。</li>
</ul>
<p>Kafka 对 NIO 中的 SelectionKey 并没有封装，而是直接使用。</p>
<p>它们之间的关系如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8421550c59be46da9ccd02559176edf0~tplv-k3u1fbpfcp-watermark.image?" alt="6B28DE84-60F6-47AC-8EE1-28DAE5EAC2F2.png">
 </p>
<p>我简单给你介绍一下 <code>Kafka 封装 Java NIO 后处理读写的流程</code>：Selector 监听到客户端的读写事件后，会获取绑定在选择键上的 KafkaChannel；KafkaChannel 会把读写操作交给 TransportLayer，TransportLayer 进一步会把读写操作交给 SocketChannel 完成数据的发送。数据的接收步骤也是类似的，你可以结合操作图对比了解一下。</p>
<p>接下来我主要为你介绍 TransportLayer、NetworkReceive、NetworkSend、KafkaChannel 这几个组件，另外一个 Selector 的封装会在下一讲重点讲解。</p>
<h3>TransportLayer</h3>
<p><strong>TransportLayer 是对 NIO 中 SocketChannel 的封装</strong>。它的实现类有 2 个：</p>
<ul>
<li>PlaintextTransportLayer 类，对接口 TransportLayer 的明文传输的实现；</li>
<li>SslTransportLayer 类，对接口 TransportLayer 的 SSL 加密传输的实现。</li>
</ul>
<p>其中 PlaintextTransportLayer 是比较有代表性的，我们主要学习这个类。如果你对另一个实现感兴趣，可以自己去源码中找到 SslTransportLayer 类去研究相关代码。</p>
<p>PlaintextTransportLayer 这个类的字段和定义比较简单，代码如下：</p>
<pre><code>public class PlaintextTransportLayer implements TransportLayer {
    private final SelectionKey key; //java nio 中的事件
    //java nio 中的SocketChannel
    private final SocketChannel socketChannel;
    //Kafka的安全相关字段
    private final Principal principal = KafkaPrincipal.ANONYMOUS;
    public PlaintextTransportLayer(SelectionKey key) throws     IOException {
    this.key = key;
    this.socketChannel = (SocketChannel) key.channel();
}
</code></pre>
<p>我们先了解下其中的字段。</p>
<ul>
<li>key：NIO 中 SelectionKey 类的对象引用。</li>
<li>socketChannel：NIO 中 SocketChannel 类的对象引用。</li>
</ul>
<p>由此可以看出，<strong>PlaintextTransportLayer 就是对 NIO 中 SelectionKey 和 SocketChannel 的封装</strong>。</p>
<p>在类的定义中，我们可以构造方法参数 SelectionKey 的类对象，构造方法会把 SelectionKey 的类对象赋给 key，然后从 key 中取出对应的 SocketChannel 给 socketChannel，这样就完成了初始化。</p>
<p>类初始化完成以后，下面我们看看相关的重要方法是怎么使用这两个 NIO 组件的。这里我将讲解 finishConnect()、read() 和 write() 这三种方法。</p>
<p><code>finishConnect() 方法用于完成网络连接</code>，代码如下所示：</p>
<pre><code>//连接是否完成，如果完成就关注OP_READ事件并取消OP_CONNECT事件
@Override
public boolean finishConnect() throws IOException {
    //调用nio通道的finishConnect()方法，方法会返回连接是否已经连接好
    boolean connected = socketChannel.finishConnect();
    //如果建立好就取消对连接事件的监听，同时增加对读事件的监听
    if (connected)
        key.interestOps(key.interestOps() &#x26; ~SelectionKey.OP_CONNECT | SelectionKey.OP_READ);
    return connected;
}
</code></pre>
<p>这个方法首先调用 NIO 组件 socketChannel 的 finishConnect() 方法看是否连接成功，如果连接成功就取消对连接事件的监听，同时增加对读事件的监听（因为连接好以后就有可能接收到数据了），最后方法返回网络连接是否成功。</p>
<p><code>read() 方法是把 socketChannel 里的数据读到缓冲区 ByteBuffer 中</code>，具体是调用 NIO 的socketChannel 的 read 方法，代码如下所示：</p>
<pre><code>/**
 * 从channel中读一个byte序列到给定的 ByteBuffer中
*/
@Override
public int read(ByteBuffer dst) throws IOException {
    //调用nio的通道实现数据的读取
    return socketChannel.read(dst);
}
</code></pre>
<p><code>write() 方法是把缓冲区 ByteBuffer 的数据写到 SocketChannel 里</code>，具体是调用 NIO 的 socketChannel 的 Write 方法，代码如下所示：</p>
<pre><code>/**
把ByteBuffer中Byte序列写到socketChannel中
*/
@Override
public int write(ByteBuffer src) throws IOException {
    return socketChannel.write(src);
}
</code></pre>
<p>对于 Java NIO 来说，一次读写不一定能把数据读写完，这样就需要判断读写是否完成，没有读写完的数据还需要继续执行读写操作，这样的操作涉及的步骤过于烦琐，显然对上层逻辑不是很友好。</p>
<p>于是 Kafka 内部把 ByteBuffer 进行了封装，并按读和写封装成 NetworkReceive 和 NetworkSend，上层调用方不用关心读写是否完成，NetworkReceive 和 NetworkSend 自己会做判断和处理。</p>
<h3>NetworkReceive</h3>
<p>NIO 中网络数据的读取要通过 Buffer 来实现，NetworkReceive 这个类就是对读取时的 Buffer 的封装。</p>
<p>其中，NetworkReceive 类的字段如下所示：</p>
<pre><code>public class NetworkReceive implements Receive {


    private final String source;//channel id
    private final ByteBuffer size;//存储数据长度的ByteBuffer
    private final int maxSize;//数据的最大长度
    private final MemoryPool memoryPool;//ByteBuffer池
    private ByteBuffer buffer;//存储数据体的ByteBuffer
</code></pre>
<ul>
<li>source：channnel id，用来确定这个 NetworkReceive 是和哪个 channel 配套使用的。</li>
<li>size：存储数据长度的 ByteBuffer。</li>
<li>maxSize：数据的最大长度，这里的数据长度是指接收数据的最大字节数。</li>
<li>memoryPool：用来分配和管理数据体 ByteBuffer 的组件。</li>
<li>buffer：存储数据体的 ByteBuffer。</li>
</ul>
<p>NetworkReceive 类的定义如下代码所示：</p>
<pre><code>public NetworkReceive(int maxSize, // 能接收的最大消息
                      String source, // channel id
                      MemoryPool memoryPool // 内存池
) {
    this.source = source;
    this.size = ByteBuffer.allocate(4); // 分配4个字节大小的数据长度
    this.buffer = null;
    this.maxSize = maxSize;
    this.memoryPool = memoryPool;
}
</code></pre>
<p>这里我重点说一下 <code>size 字段的初始化</code>，其中存储数据长度的 ByteBuffer 是由 4 个字节的 ByteBuffer 定义的，也就是 32 位，和 Java int 类型占用的字节相同，取值最大约等于 21G，足以满足表示消息长度的数值。</p>
<p>说完这个类的字段和定义，下面我们再来分析下其包含的 readFrom() 方法。</p>
<p><code>readFrom() 方法表示把 channel 中的数据读到 NetworkReceive 中的字段</code>，包括表示消息长度的字段 size 和表示消息体本身的字段 buffer，代码如下所示：</p>
<pre><code>//把channel里的数据读到ByteBuffer中
public long readFrom(ScatteringByteChannel channel) throws IOException {
    //总读取数据大小
    int read = 0;
    // 1. 判断数据长度的缓存是否读完，没有读完接着读
    if (size.hasRemaining()) {
        //2.读取数据的长度
        int bytesRead = channel.read(size);
        if (bytesRead &#x3C; 0)
            throw new EOFException();
        //每次读取后，读取长度加到总读取长度里
        read += bytesRead;
        //3.如果数据长度的缓存读完了
        if (!size.hasRemaining()) {
            size.rewind();
            //4.读取数据长度
            int receiveSize = size.getInt();
            //5.如果有异常就抛出
            if (receiveSize &#x3C; 0)
                throw new InvalidReceiveException("Invalid receive (size = " + receiveSize + ")");
            if (maxSize != UNLIMITED &#x26;&#x26; receiveSize > maxSize)
                throw new InvalidReceiveException("Invalid receive (size = " + receiveSize + " larger than " + maxSize + ")");


            requestedBufferSize = receiveSize; 
            if (receiveSize == 0) {
                buffer = EMPTY_BUFFER;
            }
        }
    }
    //6.如果数据体ByteBuffer还没有分配，且requestedBufferSize赋值，就分配requestedBufferSize字节大小的内存空间
    if (buffer == null &#x26;&#x26; requestedBufferSize != -1) { //we know the size we want but havent been able to allocate it yet
        buffer = memoryPool.tryAllocate(requestedBufferSize);
        if (buffer == null)
            log.trace("Broker low on memory - could not allocate buffer of size {} for source {}", requestedBufferSize, source);
    }
    // 7.如果ByteBuffer分配成功就把channel里的数据读到buffer中
    if (buffer != null) {
        int bytesRead = channel.read(buffer);
        if (bytesRead &#x3C; 0)
            throw new EOFException();
        read += bytesRead;
    }


    return read;
}
</code></pre>
<p>可以看到，readFrom() 方法主要是把对应 channel 中的数据读到 ByteBuffer 中，具体的步骤如下。</p>
<ol>
<li>判断 size 是否读完了，如果没读完就接着读。因为接收数据的前 4 个字节表示响应头，而 size 长度也是 4 个字节，所以正好读完响应头，响应头表示的是数据体的长度。</li>
<li>通过调用 Java NIO 底层的方法 channel.read(size)，把数据体的大小读到 size 中。</li>
<li>把读取的长度累加到总长度中。</li>
<li>如果表示 size 的数据读完了，就把 size 的 int 数值赋给 receiveSize，receiveSize 表示响应体的长度。</li>
<li>如果有异常就抛出，包括数据体的长度大于最大长度、数据体的长度无效等。</li>
<li>如果数据体 ByteBuffer 还没有分配，且 requestedBufferSize 没有赋值，就分配 requestedBufferSize 字节大小的内存空间。</li>
<li>如果 ByteBuffer 分配成功，就把 channel 里的数据读到表示响应体的 buffer 中。</li>
</ol>
<h3>NetworkSend</h3>
<p>读 Buffer 的封装讲完了，我们接着讲讲用来写的 Buffer。下图是写 Buffer 的相关接口和类的关系图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12e48a36f0e94037a0b4b12c54f94f6e~tplv-k3u1fbpfcp-watermark.image?" alt="43ACE93F-5FBE-44D1-B5DB-8DC0AE09E77D.png"></p>
<p>我们先看一下接口 Send 都定义了哪些方法。</p>
<p><code>接口 Send 定义了发送数据 buffer 的方法</code>，如下所示：</p>
<pre><code>public interface Send {


    /**
     * channel id
     */
    String destination();


    /**
     * 数据是否发送完成
     */
    boolean completed();


    /**
     * 把数据写到channel中
     */
    long writeTo(GatheringByteChannel channel) throws IOException;


    /**
     * 发送数据的大小
     */
    long size();


}
</code></pre>
<p>这里我简单介绍下代码中所包含方法的含义。</p>
<ul>
<li>destination()：要把数据写入 channel id。</li>
<li>completed()：要发送的数据是否发送完了。</li>
<li>writeTo()：把数据往指定的 channel 里写。</li>
<li>size()：发送数据的大小。</li>
</ul>
<p><code>ByteBufferSend 这个抽象类实现了上面的接口 Send，也实现了数据从 ByteBuffer 数组发送到 channel</code>，对应字段如下所示：</p>
<pre><code>private final String destination; //channel id
private final int size; //一共要写多少字节
protected final ByteBuffer[] buffers;//用于写入channel里的ByteBuffer数组
private int remaining;//一共还剩多少字节没有写完
private boolean pending = false;
public ByteBufferSend(String destination, ByteBuffer... buffers) {
    this.destination = destination;
    this.buffers = buffers;
    for (ByteBuffer buffer : buffers)
        remaining += buffer.remaining();
    this.size = remaining;//计算需要写入字节的总和
}
</code></pre>
<p>其中，重要的字段有以下几个。</p>
<ul>
<li>buffers：ByteBuffer 数组，承载了要写进 channel 的数据。</li>
<li>remaining：表示 ByteBuffer 数组内所有 ByteBuffer 还剩多少字节没有写。</li>
<li>size：需要往 channel 中写入多少字节。</li>
<li>destination：这里指 channel id，就是数据写到哪里。</li>
</ul>
<p>下面我重点介绍下 writeTo() 方法，这是负责真正写数据的方法，与 readFrom() 读数据是对应的。其他方法比较简单，你可以自行学习。</p>
<p><code>writeTo() 方法是把 buffer 数组写入 SocketChannel 中</code>，代码如下所示：</p>
<pre><code>//把buffer数组写入传输层中
@Override
public long writeTo(GatheringByteChannel channel) throws IOException {
    //1.调用java nio底层方法把buffers写入传输层，并返回写入的字节数
    long written = channel.write(buffers);
    
    if (written &#x3C; 0)
        throw new EOFException("Wrote negative bytes to channel. This shouldn't happen.");
    //2.修改还剩多少字节没有写进传输层
    remaining -= written;
    pending = TransportLayers.hasPendingWrites(channel);
    return written;
}
</code></pre>
<p>可以看到，writeTo() 方法首先把 buffers 写入 channel 中，我前面说过，写一次不一定能把数据全都写成功，底层 channel.write() 会返回一个“写成功了多少字节”的返回值，我们利用这个返回值就能知道调用一次写操作究竟写入了多少字节。</p>
<p><code>NetworkSend 这个类继承了 ByteBufferSend，是我们真正用于写 Buffer 的类</code>，字段如下所示：</p>
<pre><code>public class NetworkSend extends ByteBufferSend {
    //实例化
    public NetworkSend(String destination, ByteBuffer buffer) {
        super(destination, sizeBuffer(buffer.remaining()), buffer);
    }
    //构造4个字节的sizeBuffer
    private static ByteBuffer sizeBuffer(int size) {
        //声明4个字节的ByteBuffer
        ByteBuffer sizeBuffer = ByteBuffer.allocate(4);
        sizeBuffer.putInt(size);
        //写结束，更新postion的位置
        sizeBuffer.rewind();
        return sizeBuffer;
    }


}
</code></pre>
<p>NetworkSend 类实例化的过程是：先分配长度为 4 个字节的 ByteBuffer 的变量 sizeBuffer，再把要发送的数据长度赋值给 sizeBuffer。这样 sizeBuffer 的字节数和 sizeBuffer 的数据就都有了，<code>正好对应了前面 NetworkReceive 类对 ByteBuffer 的处理</code>。</p>
<h3>KafkaChannel</h3>
<p>到这里，读写缓存区的内容我们就讲完了，接下来我再给你分析一下 KafkaChannel，这个类封装了我们上面讲的 TransportLayer、NetworkReceive、NetworkSend 的使用，代码如下所示：</p>
<pre><code>public class KafkaChannel implements AutoCloseable {
    ......忽略


    private final String id;// channel id
    private final TransportLayer transportLayer;//传输层对象
    private final Supplier&#x3C;Authenticator> authenticatorCreator;
    private final int maxReceiveSize; //能收到请求的最大字节数
    private final MemoryPool memoryPool;//负责分配指定大小的ByteBuffer
    //读时的缓存
    private NetworkReceive receive;
    //写时的缓存
    private Send send;
    private boolean disconnected;//是否连接关闭
    private ChannelState state;//连接状态
    private SocketAddress remoteAddress;//要连接的远端地址


    public KafkaChannel(String id, TransportLayer transportLayer, Supplier&#x3C;Authenticator> authenticatorCreator,
                        int maxReceiveSize, MemoryPool memoryPool, ChannelMetadataRegistry metadataRegistry) {
        this.id = id;
        this.transportLayer = transportLayer;
        this.authenticatorCreator = authenticatorCreator;
        this.authenticator = authenticatorCreator.get();
        this.networkThreadTimeNanos = 0L;
        this.maxReceiveSize = maxReceiveSize;//可接收的最大字节数
        this.memoryPool = memoryPool;
        this.metadataRegistry = metadataRegistry;
        this.disconnected = false;
        this.muteState = ChannelMuteState.NOT_MUTED;
        this.state = ChannelState.NOT_CONNECTED;
    }
</code></pre>
<p>其中包含的字段如下。</p>
<ul>
<li>id：channel id。</li>
<li>transportLayer：传输层对象，用于调用 SocketChannel 的方法。</li>
<li>maxReceiveSize：能收到请求的最大字节数。</li>
<li>memoryPool：负责分配指定大小的 ByteBuffer，对 ByteBuffer 进行管理。</li>
<li>receive：NetworkReceive 类的实例。读时的缓存，上面介绍过，就不重复说明了。</li>
<li>send：NetworkSend 类的实例。写时的缓存，上面介绍过，就不重复说明了。</li>
<li>disconnected：channel 连接是否关闭。</li>
<li>state：ChannelState 类的实例，表示 KafkaChannel 的状态。</li>
<li>remoteAddress：要连接的远端地址。</li>
</ul>
<p>KafkaChannel 的状态有以下 6 种。</p>
<ul>
<li>NOT_CONNECTED：表示远端服务器不可用。</li>
<li>AUTHENTICATE：处于 SSL 验证状态。这是 SSL 等加密连接时的状态，用于 SSL 握手时的状态描述，明文连接不会有这个状态。</li>
<li>READY：表示连接成功。</li>
<li>EXPIRED：表示连接超时而关闭。</li>
<li>FAILED_SEND：表示连接因为发送失败而关闭。</li>
<li>LOCAL_CLOSE：表示主动把连接关闭。</li>
</ul>
<p>接下来我们继续讲解 KafkaChannel 这个类包含的方法，主要有四种：setSend()、write()、read() 和 maybeCompleteReceive()。</p>
<p>我们先来看一下 <code>setSend()</code> 这个方法：</p>
<pre><code>//正式发送请求前，先把请求放入send字段
public void setSend(Send send) {
    if (this.send != null)
        throw new IllegalStateException("Attempt to begin a send operation with prior send operation still in progress, connection id is " + id);
    //设置要发送消息的字段
    this.send = send;
    //调用传输层关注写事件
    this.transportLayer.addInterestOps(SelectionKey.OP_WRITE);
}
</code></pre>
<p>这个方法的主要用处就是在真正发送网络请求前，<code>把要发送的数据保存在 send 字段里</code>，然后调用传输层增加对这个 channel 上写事件的关注。当真正执行发送的时候，会读取 send 里的数据。</p>
<p><code>write() 方法是把保存在 send 字段上的数据真正发送出去</code>，如下所示：</p>
<pre><code>//调用写操作
public long write() throws IOException {
    if (send == null)
        return 0;


    midWrite = true;
    //调用传输层把数据真正发送出去
    return send.writeTo(transportLayer);
}
</code></pre>
<p>首先判断要发送的 send 字段是否为零，为零说明缓存在 KafkaChannel 的 Buffer 都发送出去了，就不用再发送了；如果不为零就调用上面我们讲的 NetworkSend 类中的 writeTo() 方法把数据通过网络 IO 发送出去。</p>
<p><code>read() 方法是把从网络 IO 中读出的数据保存到字段 NetworkReceive 中</code>，我们通过代码了解下这个方法：</p>
<pre><code>//接收数据
public long read() throws IOException {
    if (receive == null) {
        receive = new NetworkReceive(maxReceiveSize, id, memoryPool);
    }
    long bytesReceived = receive(this.receive);
    ......忽略
    return bytesReceived;
}
</code></pre>
<p>首先实例化一个 NetworkReceive 对象，再调用 receive() 方法把 channel 的数据读到 NetworkReceive 对象中，最后返回读到的字节数。如果没有读完下次还是读这个NetworkReceive 对象，如果读完了就新创建一个 NetworkReceive 对象。</p>
<p><code>maybeCompleteReceive() 这个方法用来判断读 Buffer 是否读完</code>，我们同样结合代码了解其方法逻辑：</p>
<pre><code>public NetworkReceive maybeCompleteReceive() {
    if (receive != null &#x26;&#x26; receive.complete()) {
        receive.payload().rewind();
        NetworkReceive result = receive;
        receive = null;
        return result;
    }
    return null;
}
</code></pre>
<p>判断是否读完的条件是 NetworkReceive 里的 buffer 是否用完，包括上面说过的表示 buffer 长度的 ByteBuffer 和请求本身的 ByteBuffer。这两个都读完才算真正读完了。</p>
<h2>总结</h2>
<p>这一讲我们介绍了 Kafka 对 Java NIO 的封装，包括 SocketChannel 和 ByteBuffer。</p>
<ul>
<li>SocketChannel 封装类 TransportLayer 实现了最基础的网络连接、网络读、网络写操作。其中，负责明文传输的是 PlaintextTransportLayer 类。</li>
<li>对 ByteBuffer 的封装主要是分为两块：写 Buffer 的封装 NetworkSend 和读 Buffer 的封装 NetworkReceive。通过与 PlaintextTransportLayer 类的配合，实现从 Channel 把数据读到 NetworkReceive 缓存类，以及把数据从 NetworkSend 缓存类写到 Channel。</li>
</ul>
<p>最后，KafkaChannel 针对上述封装为上层提供了更加友好的网络连接、读写。从这里我们能看到 Kafka 对底层封装的效果，KafkaChannel 的代码更加适合 Kafka 的实际业务，同时代码有层次、扩展性也非常好。</p></div>
</body></html>