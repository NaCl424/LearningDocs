<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>消费者挂了怎么办？消费组重平衡（上）</h1>
<p>今天这节课我们开始学习消费组的重平衡。由于消费组重平衡内容比较多，所以我会将内容拆分成上、下两节给你讲解。</p>
<p>这节课我们主要讲解消费组重平衡的<code>前两个步骤</code>，课程大纲如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5736d5b3612045148ef562efe4593946~tplv-k3u1fbpfcp-watermark.image?" alt="F176543B-A584-4CFF-B36C-8DAEBFAF8E36.png"></p>
<h2>引发重平衡的场景</h2>
<p>引发重平衡主要有以下 5 个场景。</p>
<ol>
<li>有新的消费者加入消费组。</li>
<li>有消费者宕机下线。消费者并不一定需要真正下线，例如遇到长时间的GC、网络迟导致消费者长时间未向 GroupCoordinator 发送心跳等情况时，GroupCoordinator 会认为消费者已经下线。</li>
<li>有消费者主动退出消费组（发送LeaveGroupRequest 请求）。比如，客户端调用子 unsubscrible()方法取消对某些主题的订阅。</li>
<li>消费组所对应的 GroupCoorinator 节点发生了变更。</li>
<li>消费组内所订阅的任一个主题或主题分区数量发生了变化。</li>
</ol>
<p>消费组的重平衡主要分下面四步。</p>
<ol>
<li>消费者向集群中任一broker发送获取GroupCoordinator的请求FindCoordinatorRequest，服务端返回GroupCoordinator信息包括GroupCoordinator所在的broker的node_id、host和port信息。</li>
<li>成功找到消费组对应的GroupCoordinator后，消费者进入加入消费组的阶段。消费者会向GroupCoordinator发送JoinGroupRequest请求，GroupCoordinator返回响应告诉消费者是否加入消费组成功了，并选出leader consumer，同时把分区策略和其他消费者的订阅信息发送给leader consumer。</li>
<li>leader consumer根据GroupCoordinator提供的分区策略和所有消费者的订阅信息确定分区消费方案并发送给GroupCoordinator，然后GroupCoordinator根据收到的分区消费方案把每个消费者要消费的分区信息发送给每个消费者。</li>
<li>消费者收到分区消费方案后，向GroupCoordinator所在的broker发送心跳维持从属关系。</li>
</ol>
<h2>消费组的重平衡第一阶段：查找 GroupCoordinator</h2>
<p>查找GroupCoordinator的入口方法是抽象类AbstractCoordinator的方法，源码如下。</p>
<h3>ensureCoordinatorReady()</h3>
<pre><code>protected synchronized boolean ensureCoordinatorReady(final Timer timer) {
    //1.判断 GroupCoordinator 是否已经存在
    if (!coordinatorUnknown())
        return true;

    do {
        if (findCoordinatorException != null &#x26;&#x26; !(findCoordinatorException instanceof RetriableException)) {
            final RuntimeException fatalException = findCoordinatorException;
            findCoordinatorException = null;
            throw fatalException;
        }
        //2.如果不存在，查找GroupCoordinator的预处理
        final RequestFuture&#x3C;Void> future = lookupCoordinator();
        //3.不断请求集群中任一节点直到返回GroupCoordinator的信息
        client.poll(future, timer);
        //4.判断是否超时
        if (!future.isDone()) {
            // ran out of time
            //说明超时了
            break;
        }
        //4.异常处理
        if (future.failed()) {
            if (future.isRetriable()) {
                log.debug("Coordinator discovery failed, refreshing metadata", future.exception());
                client.awaitMetadataUpdate(timer);
            } else
                throw future.exception();
        } else if (coordinator != null &#x26;&#x26; client.isUnavailable(coordinator)) {
            markCoordinatorUnknown("coordinator unavailable");
            timer.sleep(rebalanceConfig.retryBackoffMs);
        }
        //5.不断尝试获取GroupCoordinator直到获得GroupCoordinator信息或超时。
    } while (coordinatorUnknown() &#x26;&#x26; timer.notExpired());

    return !coordinatorUnknown();
}
</code></pre>
<p>我分步骤讲解一下。</p>
<ol>
<li>判断消费者获取的GroupCoordinator是否可用，源码如下：</li>
</ol>
<pre><code>protected synchronized Node checkAndGetCoordinator() {
    //coordinator不为空且消费者与GroupCoordinator连接是否正常。
    if (coordinator != null &#x26;&#x26; client.isUnavailable(coordinator)) {
        markCoordinatorUnknown(true, "coordinator unavailable");
        return null;
    }
    return this.coordinator;
}
</code></pre>
<p>主要是判断字段coordinator是否为空，且消费者与GroupCoordinator连接是否正常。</p>
<ol start="2">
<li>如果不存在，查找GroupCoordinator的请求预发送方法lookupCoordinator()。这个方法是把请求放入NetworkClient的send缓存字段，等待真正的网络发送</li>
<li>调用ConsumerNetworkClient的poll()方法，同时传入future和定时器，调用的方法如下：</li>
</ol>
<pre><code>public boolean poll(RequestFuture&#x3C;?> future, Timer timer) {
    do {
        poll(timer, future);
    } while (!future.isDone() &#x26;&#x26; timer.notExpired());
    return future.isDone();
}
</code></pre>
<p>ConsumerNetworkClient会不断调用底层组件NetworkClient把FindCoordinatorRequest请求发送出去，直到发送成功或超时。</p>
<ol start="4">
<li>判断异步请求失败，如果失败就根据失败的原因做以下处理：</li>
</ol>
<ul>
<li>有异常，如果是future.isRetriable()异常意味着可以重试。处理方式是等待更新元数据后再次发起请求。否则就抛出异常。</li>
<li>coordinator不为null，说明获得了GroupCoordinator，但是网络连接有问题，那么则等待一段时间后元数据更新了再重试。</li>
</ul>
<ol start="5">
<li>判断是否超时，如果超时就跳出循环。</li>
</ol>
<p>下图更形象地解释了消费者发送获取GroupCoordinator的过程步骤：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a45367c8fd144649b061b510eddc09f7~tplv-k3u1fbpfcp-watermark.image?" alt="82E8DD24-1EF8-4D2D-98C6-3F108724837F.png"></p>
<p>这里，我们重点学习一下查找GroupCoordinator的预处理方法lookupCoordinator()。</p>
<h3>发送请求 lookupCoordinator()</h3>
<pre><code>//寻找GroupCoordinator
protected synchronized RequestFuture&#x3C;Void> lookupCoordinator() {
    if (findCoordinatorFuture == null) {
        // find a node to ask about the coordinator
        //1.找到负载最小的node
        Node node = this.client.leastLoadedNode();
        if (node == null) {
            log.debug("No broker available to send FindCoordinator request");
            return RequestFuture.noBrokersAvailable();
        } else {
            //2.向node预发送查找GroupCoordinator的请求，
            findCoordinatorFuture = sendFindCoordinatorRequest(node);
            // remember the exception even after the future is cleared so that
            // it can still be thrown by the ensureCoordinatorReady caller
            //3.向RequestFuture&#x3C;Void>添加监听器。
            findCoordinatorFuture.addListener(new RequestFutureListener&#x3C;Void>() {
                @Override
                public void onSuccess(Void value) {} // do nothing


                @Override
                public void onFailure(RuntimeException e) {
                    findCoordinatorException = e;
                }
            });
        }
    }
    return findCoordinatorFuture;
}
</code></pre>
<p>我给你讲解下这个方法的步骤。</p>
<ol>
<li>找到负载最小的节点。所有的集群节点都保存着集群元数据，我们只要选择一个负载最小的节点获取GroupCoordinator就好。</li>
<li>向找到的node预发送查找GroupCoordinator的请求。</li>
</ol>
<pre><code>private RequestFuture&#x3C;Void> sendFindCoordinatorRequest(Node node) {
    // initiate the group metadata request
    log.debug("Sending FindCoordinator request to broker {}", node);
    //1.构建查找Group Coordinator节点的请求
    FindCoordinatorRequest.Builder requestBuilder =
            new FindCoordinatorRequest.Builder(
                    new FindCoordinatorRequestData()
                        .setKeyType(CoordinatorType.GROUP.id())
                        .setKey(this.rebalanceConfig.groupId));
    //2.发送请求，并用FindCoordinatorResponseHandler类对象来处理响应
    return client.send(node, requestBuilder)
            .compose(new FindCoordinatorResponseHandler());
}
</code></pre>
<ol>
<li>构建获取GroupCoordinator的请求FindCoordinatorRequest，请求结构体格式如下：</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b342858d4d06486ca69f7722024595c8~tplv-k3u1fbpfcp-watermark.image?" alt="030006CF-7974-47B3-A6C1-1BA6A8907649.png"></p>
<ol start="2">
<li>预发送FindCoordinatorRequest请求，把FindCoordinatorRequest放入底层组件NetworkClient的send字段里。而且当消费者收到响应后，通过RequestFuture的compose()方法设置FindCoordinatorResponseHandler的类对象进行处理。</li>
</ol>
<p>好，我们下面再介绍一下处理响应的类 FindCoordinatorResponseHandler。</p>
<h3>处理响应 FindCoordinatorResponseHandler</h3>
<pre><code>private class FindCoordinatorResponseHandler extends RequestFutureAdapter&#x3C;ClientResponse, Void> {

    @Override
    public void onSuccess(ClientResponse resp, RequestFuture&#x3C;Void> future) {
        log.debug("Received FindCoordinator response {}", resp);
        clearFindCoordinatorFuture();
        //1.得到找到Group Coordinator 节点的响应
        FindCoordinatorResponse findCoordinatorResponse = (FindCoordinatorResponse) resp.responseBody();
        Errors error = findCoordinatorResponse.error();
        if (error == Errors.NONE) {
            synchronized (AbstractCoordinator.this) {
                // use MAX_VALUE - node.id as the coordinator id to allow separate connections
                // for the coordinator in the underlying network client layer
                int coordinatorConnectionId = Integer.MAX_VALUE - findCoordinatorResponse.data().nodeId();
                //2. 构建Group Coordinator对象
                AbstractCoordinator.this.coordinator = new Node(
                        coordinatorConnectionId,
                        findCoordinatorResponse.data().host(),
                        findCoordinatorResponse.data().port());
                log.info("Discovered group coordinator {}", coordinator);
                //3.尝试与Group Coordinator所在节点连接
                client.tryConnect(coordinator);
                heartbeat.resetSessionTimeout();
            }
            //4.调用RequestFuture&#x3C;Void>上的监听器
            future.complete(null);
        } else if (error == Errors.GROUP_AUTHORIZATION_FAILED) {
            future.raise(GroupAuthorizationException.forGroupId(rebalanceConfig.groupId));
        } else {
            log.debug("Group coordinator lookup failed: {}", findCoordinatorResponse.data().errorMessage());
            future.raise(error);
        }
    }

    @Override
    public void onFailure(RuntimeException e, RequestFuture&#x3C;Void> future) {
        clearFindCoordinatorFuture();
        super.onFailure(e, future);
    }
}
</code></pre>
<p>如果成功获得响应的处理过程如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fb9688f1ee144a2a8e701e753bd818b~tplv-k3u1fbpfcp-watermark.image?" alt="030006CF-7974-47B3-A6C1-1BA6A8907649.png"></p>
<ol>
<li>得到找到 Group Coordinator 节点的响应并解析。</li>
<li>如果没有异常就根据响应构建coordinator字段。</li>
<li>尝试与GroupCoordinator的节点连接。</li>
<li>调用<code>RequestFuture&#x3C;Void></code>上的监听器，完成响应事件的传播。</li>
</ol>
<p>好了，到这里第一阶段的内容就讲解完了，下面开始第二阶段的讲解。</p>
<h2>消费组的重平衡第二阶段：消费者向 GroupCoordinator 注册</h2>
<p>在成功找到对应的GroupCoordinator之后，进入了向GroupCoordinator注册阶段。这个阶段，消费者会向GroupCoordinator发送JoinGroupRequest请求，并处理响应。</p>
<p>请求结构体格式如下：
 
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cccf66f215b641d9b3d524aeaf49f3fa~tplv-k3u1fbpfcp-watermark.image?" alt="B6C1ABB4-1B9D-4764-B946-C5D9B8B9E8B6.png"></p>
<p><strong>JoinGroupRequest 中各个字段含义</strong>如下表所示：</p>













































<table><thead><tr><th>名称</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>group_id</td><td>String</td><td>Consumer Group的Id</td></tr><tr><td>session_timeout</td><td>int</td><td>GroupCoordinator超过session_time指定的时间，没有收到心跳，认为消费者下线</td></tr><tr><td>member_id</td><td>String</td><td>GroupCoordinator分配给消费者的id</td></tr><tr><td>protocol_type</td><td>String</td><td>Consumer Group实现的协议，默认是“consumer”</td></tr><tr><td>group_protocols</td><td>List</td><td>包含此消费者支持的全部PartitionAssignor类型</td></tr><tr><td>protocol_ name</td><td>String</td><td>PartitionAssignor的名称</td></tr><tr><td>protocol_ metadata</td><td>byte数组</td><td>针对不同的PartitionAssignor，序列化后的消费者的订阅信息，其中包括用户自定义数据的userData</td></tr></tbody></table>
<p>响应结构体格式如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15251abfc26f47d9aab75df29937210f~tplv-k3u1fbpfcp-watermark.image?" alt="87A2ADA5-3512-4DCF-B0C7-534EAC7AAAB7.png"></p>
<p><strong>JoinGroupResponse 中各个字段含义</strong>如下表所示：</p>













































<table><thead><tr><th>名称</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>error_code</td><td>short</td><td>错误码</td></tr><tr><td>generation_id</td><td>int</td><td>GroupCoordinator分配的年代信息</td></tr><tr><td>group_protocol</td><td>String</td><td>GroupCoordinator选择的PartitionAssignor</td></tr><tr><td>leader_id</td><td>String</td><td>leader的member_id</td></tr><tr><td>member_id</td><td>String</td><td>GroupCoordinator分配给消费者的Id</td></tr><tr><td>members</td><td>Map集合</td><td>PartitionAssignor的名称</td></tr><tr><td>member_ metadata</td><td>byte数组</td><td>对应消费者定义的信息</td></tr></tbody></table>
<p>抽象类AbstractCoordinator的joinGroupIfNeeded()方法是入口方法。源码如下：</p>
<pre><code>boolean joinGroupIfNeeded(final Timer timer) {
    while (rejoinNeededOrPending()) {
        //1.再一次检查是否获得了groupCoordinator
        if (!ensureCoordinatorReady(timer)) {
            return false;
        }
        //2.加入组之前的准备工作。
        if (needsJoinPrepare) {
            needsJoinPrepare = false;
            onJoinPrepare(generation.generationId, generation.memberId);
        }
        //3.发送注册到Group Coordinator里的JoinGroup请求前的工作，
        final RequestFuture&#x3C;ByteBuffer> future = initiateJoinGroup();
        //4.网络阻塞发送
        client.poll(future, timer);
        if (!future.isDone()) {
            // we ran out of time
            return false;
        }
        ......忽略
</code></pre>
<p>简单给你讲讲这个方法的步骤。</p>
<ol>
<li>再一次检查是否获得了groupCoordinator。目的是担心与groupCoordinator的连接出问题，这样方法能及时再获取一次groupCoordinator。</li>
<li>加入组之前的准备工作。准备工作包括：</li>
</ol>
<ul>
<li>如果是自动提交offset，则提交offset。目的是防止已经消费的partition的offset由于换了消费者造成重复消费消息。</li>
<li>调用注册在SubscriptionState中的ConsumerRebalanceListener上的回调方法。</li>
</ul>
<ol start="3">
<li>初始化加入消费组。包括构建JoinGroupRequest请求，预发送JoinGroupRequest请求，异步请求上加监听器。</li>
<li>网络阻塞发送。</li>
</ol>
<h3>初始化加入消费组 initiateJoinGroup()</h3>
<pre><code>private synchronized RequestFuture&#x3C;ByteBuffer> initiateJoinGroup() {
    if (joinFuture == null) {
        //1.设置consumer的状态为预重平衡
        state = MemberState.PREPARING_REBALANCE;
        if (lastRebalanceStartMs == -1L)
            lastRebalanceStartMs = time.milliseconds();
        //2.做发送JoinGroupRequest请求的准备工作。
        joinFuture = sendJoinGroupRequest();
        //3.给异步请求加监听器
        joinFuture.addListener(new RequestFutureListener&#x3C;ByteBuffer>() {
            @Override
            public void onSuccess(ByteBuffer value) {
               
            }

            @Override
            public void onFailure(RuntimeException e) {
                synchronized (AbstractCoordinator.this) {
                    sensors.failedRebalanceSensor.record();
                }
            }
        });
    }
    return joinFuture;
}
</code></pre>
<p>第一步，设置消费者的状态为PREPARING_REBALANCE，表示准备重平衡了。</p>
<p>第二步，做发送JoinGroupRequest请求的准备工作。</p>
<p>第三步，给异步请求加监听器，对应失败会做异常处理。对于成功没做任何事，因为发送JoinGroupRequest请求的准备工作的回调对象会完成回调处理。</p>
<p>这里，我们还需要重点说说做发送JoinGroupRequest请求的准备工作 <strong>sendJoinGroupRequest() 方法</strong>的代码。</p>
<pre><code>RequestFuture&#x3C;ByteBuffer> sendJoinGroupRequest() {
    if (coordinatorUnknown())
        return RequestFuture.coordinatorNotAvailable();
    log.info("(Re-)joining group");
    //1.构建加入Group Coordinator的请求
    JoinGroupRequest.Builder requestBuilder = new JoinGroupRequest.Builder(
            new JoinGroupRequestData()
                    .setGroupId(rebalanceConfig.groupId)
                    .setSessionTimeoutMs(this.rebalanceConfig.sessionTimeoutMs)
                    .setMemberId(this.generation.memberId)
                    .setGroupInstanceId(this.rebalanceConfig.groupInstanceId.orElse(null))
                    .setProtocolType(protocolType())
                    .setProtocols(metadata())
                    .setRebalanceTimeoutMs(this.rebalanceConfig.rebalanceTimeoutMs)
    );

    log.debug("Sending JoinGroup ({}) to coordinator {}", requestBuilder, this.coordinator);
    int joinGroupTimeoutMs = Math.max(client.defaultRequestTimeoutMs(),
        rebalanceConfig.rebalanceTimeoutMs + JOIN_GROUP_TIMEOUT_LAPSE);
    //2.发送请求，并设置处理ClientResponse的对象JoinGroupResponseHandler
    return client.send(coordinator, requestBuilder, joinGroupTimeoutMs)
            .compose(new JoinGroupResponseHandler(generation));
}
</code></pre>
<p>第一步，构造JoinGroupRequest请求。</p>
<p>第二步，预发送请求，并通过给RequestFuture.compose()方法配置回调对象的方式增加监听器。</p>
<p>到这里发送的源码就分析完成了，我们再来看一下用来处理响应的类JoinGroupResponseHandler。</p>
<h3>处理响应的类 JoinGroupResponseHandler</h3>
<p>我们重点学习 <strong>handle()方法</strong>：</p>
<pre><code>public void handle(JoinGroupResponse joinResponse, RequestFuture&#x3C;ByteBuffer> future) {
        ......忽略
                synchronized (AbstractCoordinator.this) {
                     //1.解析joinResponse
                    if (state != MemberState.PREPARING_REBALANCE) {
                        future.raise(new UnjoinedGroupException());
                    } else {
                        //2.更新状态为正在执行重平衡
                        state = MemberState.COMPLETING_REBALANCE;

                        if (heartbeatThread != null)
                            heartbeatThread.enable();

                        AbstractCoordinator.this.generation = new Generation(
                            joinResponse.data().generationId(),
                            joinResponse.data().memberId(), joinResponse.data().protocolName());

                        log.info("Successfully joined group with generation {}", AbstractCoordinator.this.generation);
                        //3.判断是否为leader
                        if (joinResponse.isLeader()) {
                            onJoinLeader(joinResponse).chain(future);
                        } else {
                            onJoinFollower().chain(future);
                        }
                    }
                }
            }
        } else if (error == Errors.COORDINATOR_LOAD_IN_PROGRESS) {
            ......忽略
}
</code></pre>
<p>第一步，解析joinResponse。</p>
<p>第二步，更新状态为正在执行重平衡。</p>
<p>第三步，根据响应判断这个消费者是否被选为消费组的leader，如果是leader就走onJoinLeader()的逻辑，否则如果是follower就走onJoinFollower()的逻辑。如果是leader consumer会收到消费组所有消费者的订阅信息已经GroupCoordinator选择好的分区策略，而follower consumer不会收到，所以follower consumer不会有太多的逻辑。</p>
<p>我们重点研究onJoinLeader()的逻辑。</p>
<p><strong>onJoinLeader()</strong> 相关源码如下：</p>
<pre><code>private RequestFuture&#x3C;ByteBuffer> onJoinLeader(JoinGroupResponse joinResponse) {
    try {
        //1.基于响应返回的分区策略和消费组里所有消费者的元数据计算出分区方案。
        Map&#x3C;String, ByteBuffer> groupAssignment = performAssignment(joinResponse.data().leader(), joinResponse.data().protocolName(),
                joinResponse.data().members());

        List&#x3C;SyncGroupRequestData.SyncGroupRequestAssignment> groupAssignmentList = new ArrayList&#x3C;>();
        for (Map.Entry&#x3C;String, ByteBuffer> assignment : groupAssignment.entrySet()) {
            groupAssignmentList.add(new SyncGroupRequestData.SyncGroupRequestAssignment()
                    .setMemberId(assignment.getKey())
                    .setAssignment(Utils.toArray(assignment.getValue()))
            );
        }
        //2.构建发送分区消费方案的请求
        SyncGroupRequest.Builder requestBuilder =
                new SyncGroupRequest.Builder(
                        new SyncGroupRequestData()
                                .setGroupId(rebalanceConfig.groupId)
                                .setMemberId(generation.memberId)
                                .setProtocolType(protocolType())
                                .setProtocolName(generation.protocolName)
                                .setGroupInstanceId(this.rebalanceConfig.groupInstanceId.orElse(null))
                                .setGenerationId(generation.generationId)
                                .setAssignments(groupAssignmentList)
                );
        log.debug("Sending leader SyncGroup to coordinator {} at generation {}: {}", this.coordinator, this.generation, requestBuilder);
        //3.发送分区消费方案的请求
        return sendSyncGroupRequest(requestBuilder);
    } catch (RuntimeException e) {
        return RequestFuture.failure(e);
    }
}
</code></pre>
<p>第一步，基于响应返回的分区策略和消费组里所有消费者的元数据计算出分区方案。</p>
<p>第二步，构建向GroupCoordinator发送分区消费方案的请求SyncGroupRequest。</p>
<p>第三步，向GroupCoordinator发送分区方案。</p>
<p>我们再重点关注下分区方案的制定，<strong>方法performAssignment()</strong>：</p>
<pre><code>protected Map&#x3C;String, ByteBuffer> performAssignment(String leaderId,
                                                    String assignmentStrategy,
                                                    List&#x3C;JoinGroupResponseData.JoinGroupResponseMember> allSubscriptions) {
    //1.根据GroupCoordinator选出的分区策略名称查找分区策略。
    ConsumerPartitionAssignor assignor = lookupAssignor(assignmentStrategy);
    if (assignor == null)
        throw new IllegalStateException("Coordinator selected invalid assignment protocol: " + assignmentStrategy);


    Set&#x3C;String> allSubscribedTopics = new HashSet&#x3C;>();
    Map&#x3C;String, Subscription> subscriptions = new HashMap&#x3C;>();
    Map&#x3C;String, List&#x3C;TopicPartition>> ownedPartitions = new HashMap&#x3C;>();
    //2.收集消费组中全部消费组的订阅，订阅的主题，消费者和订阅分区的关系集合。
    for (JoinGroupResponseData.JoinGroupResponseMember memberSubscription : allSubscriptions) {
        Subscription subscription = ConsumerProtocol.deserializeSubscription(ByteBuffer.wrap(memberSubscription.metadata()));
        subscription.setGroupInstanceId(Optional.ofNullable(memberSubscription.groupInstanceId()));
        subscriptions.put(memberSubscription.memberId(), subscription);
        allSubscribedTopics.addAll(subscription.topics());
        ownedPartitions.put(memberSubscription.memberId(), subscription.ownedPartitions());
    }

    // 3.作为leader要开始关注任何消费组订阅主题的变化，确保能及时获取这些主题相关的元数据
    updateGroupSubscription(allSubscribedTopics);

    isLeader = true;

    log.debug("Performing assignment using strategy {} with subscriptions {}", assignor.name(), subscriptions);
    // 4.开始分区分配
    Map&#x3C;String, Assignment> assignments = assignor.assign(metadata.fetch(), new GroupSubscription(subscriptions)).groupAssignment();

    if (protocol == RebalanceProtocol.COOPERATIVE) {
        validateCooperativeAssignment(ownedPartitions, assignments);
    }

    ......忽略
    //5.分区结果序列化并保存在groupAssignment map集合里
    Map&#x3C;String, ByteBuffer> groupAssignment = new HashMap&#x3C;>();
    for (Map.Entry&#x3C;String, Assignment> assignmentEntry : assignments.entrySet()) {
        ByteBuffer buffer = 
        //序列化        ConsumerProtocol.serializeAssignment(assignmentEntry.getValue());
        groupAssignment.put(assignmentEntry.getKey(), buffer);
    }

    return groupAssignment;
}
</code></pre>
<ol>
<li>leader consumer根据GroupCoordinator选出的分区策略名称查找分区策略。因为GroupCoordinator是在所有消费者都有的分区策略中选出的一个分区策略，所以leader consumer本地也肯定有这个策略。</li>
<li>收集消费组中全部消费组的订阅、订阅的主题、消费者和订阅分区的关系集合，为制定分区消费方案做数据准备。</li>
<li>leader consumer扩充订阅信息并获取消费组中所有要消费的主题相关的元数据。因为leader consumer是要给所有消费者分配分区消费的，主题是基础数据之一。跟获取元数据的步骤一样，会发生请求的阻塞。</li>
<li>调用assignor.assign()，根据基础数据获取每个消费者对应的分区消费方案。</li>
<li>分区结果序列化并保存在groupAssignment map里，为发送给GroupCoordinator做准备。</li>
</ol>
<p>下图是处理响应JoinGroupResponse的步骤，你可以梳理一下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c548fbfae08a4ec2a9afd85412abc790~tplv-k3u1fbpfcp-watermark.image?" alt="784E651B-5387-4C4B-91E0-F705754742A9.png"></p>
<h2>总结</h2>
<p>今天这节课我给你讲解了引起消费组重平衡的 5 个场景，并且还重点剖析了消费组重平衡的前两个步骤。</p>
<p><strong>第一个步骤查找 GroupCoordinator</strong>。过程简单来说就是消费者往负载最小的node节点发送请求得到GroupCoordinator的地址，然后消费者尝试跟这个节点建立网络连接。核心方法和类包括发送请求的lookupCoordinator()方法和处理响应的FindCoodinatorResponseHandle回调类。</p>
<p><strong>第二个步骤是消费者向注册 GroupCoordinator</strong>。消费者把member_id和支持的分区策略发送给GroupCoordinator，GroupCoordinator收到后会选出一个消费者作为consumer leader，同时会选出一个所有消费者都支持的分区策略，然后把选出的分区策略和消费组里的所有消费者的订阅发送给consumer leader，consumer leader收到响应后，先获取消费组订阅的所有主题的元数据，然后根据元数据数据和响应的数据给所有的消费者分配要消费的分区。</p>
<p>下一节课，我们继续学习消费组重平衡的后两个步骤。</p></div>
</body></html>