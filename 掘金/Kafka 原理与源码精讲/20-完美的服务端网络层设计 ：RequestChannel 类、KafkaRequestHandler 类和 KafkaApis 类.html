<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>完美的服务端网络层设计 ：RequestChannel 类、KafkaRequestHandler 类和 KafkaApis 类</h1>
<p>上节课我们学习了Acceptor和Processor这两个类，这两个负责的是网络操作并不涉及业务执行，比如消息的存储等，那么业务执行是由哪个组件执行的呢？其实是通过KafkaRequestHandler线程类的线程池完成的，但是KafkaRequestHandler并没有直接与Processor类接触，而是通过RequestChannel类作为一个桥梁沟通的。</p>
<p>好，我们今天主要介绍RequestChannel类和KafkaRequestHandler线程类。</p>
<h2>RequestChannel 类</h2>
<p>同样，我们先了解一下这个类的重要的字段。以下是源码以及相应的注释。</p>
<h3>重要字段</h3>
<pre><code>class RequestChannel(val queueSize: Int, val metricNamePrefix : String,
time: Time) extends KafkaMetricsGroup {
import RequestChannel._   
val metrics = new RequestChannel.Metrics   
//请求队列,queueSize为队列大小。默认500   
private val requestQueue = new ArrayBlockingQueue[BaseRequest](queueSize)
//RequestChannel下辖的Processor线程池。默认8个线程。   
private val processors = new ConcurrentHashMap[Int, Processor]()
</code></pre>
<ul>
<li><code>requestQueue</code>：元素为Request对象的阻塞队列。队列长度大小为500。这个队列的作用是Processor类接收到请求后会把请求放入这个队列里。requestQueue里的元素的消费方是KafkaRequestHandler线程类。</li>
<li><code>processors </code>：RequestChannel下辖的Processor线程池。默认8个线程，Kafka 允许你动态地修改此参数值。Broker 启动时指定 num.network.threads 为 8，之后你通过 kafka-configs 命令修改。</li>
</ul>
<p>好，接下来我们学习重要的方法。</p>
<h3>重要方法</h3>
<p>首先，我们学习一下RequestChannel类怎么把Processor类对象添加到Processors集合的。</p>
<h4>方法 addProcessor(）</h4>
<pre><code>def addProcessor(processor: Processor): Unit = {     
// 添加Processor到Processor线程池     
if (processors.putIfAbsent(processor.id, processor) != null)
warn(s"Unexpected processor with processorId ${processor.id}")     
// 为给定Processor对象创建对应的监控指标
newGauge(responseQueueSizeMetricName, 
() => processor.responseQueueSize,       
Map(ProcessorMetricTag -> processor.id.toString)) 
}
</code></pre>
<p>这个方法很简单就是把processor放入processors集合里，只是新放入之前会判断processor.id是否已经有了。</p>
<h4>方法 sendRequest()</h4>
<p>这个方法很重要，是用来暂时存储请求的。</p>
<pre><code>def sendRequest(request: RequestChannel.Request): Unit = {     requestQueue.put(request) }
</code></pre>
<p>Porcessor类对象接收到请求后，会调用这个方法把请求放入requestQueue阻塞队列里。等待KafkaRequestHandler线程类获取请求。</p>
<h4>方法 receiveRequest()</h4>
<p>表示从requestQueue队列中取出请求。</p>
<pre><code>  def receiveRequest(timeout: Long): RequestChannel.BaseRequest =     requestQueue.poll(timeout, TimeUnit.MILLISECONDS)
</code></pre>
<p>KafkaRequestHandler线程类会调用这个方法取出request对象，再根据request对象调用底层对应的api。</p>
<h4>方法 sendResponse()</h4>
<p>KafkaRequestHandler线程类处理完request对象后，会封装response,调用这个方法把response放入对应的Precessor的response队列里。</p>
<pre><code>def sendResponse(response: RequestChannel.Response): Unit = {
// 构造Trace日志输出字符串     
if (isTraceEnabled) {       
val requestHeader = response.request.header       
val message = response match {
case sendResponse: SendResponse =>
s"Sending ${requestHeader.apiKey} response to client ${requestHeader.clientId} of
${sendResponse.responseSend.size} bytes."         
case _: NoOpResponse =>
s"Not sending ${requestHeader.apiKey} response to client
${requestHeader.clientId} as it's not required."         
case _: CloseConnectionResponse =>           
s"Closing connection for client ${requestHeader.clientId} due to error
during ${requestHeader.apiKey}."         
case _: StartThrottlingResponse =>
s"Notifying channel throttling has started for client
${requestHeader.clientId} for ${requestHeader.apiKey}"
case _: EndThrottlingResponse =>
s"Notifying channel throttling has ended for client
${requestHeader.clientId} for ${requestHeader.apiKey}"
}       
trace(message)     
}     
response match {       
      case _: SendResponse | _: NoOpResponse | _: CloseConnectionResponse
      =>         
      val request = response.request         
      val timeNanos = time.nanoseconds()
      request.responseCompleteTimeNanos = timeNanos         
      if (request.apiLocalCompleteTimeNanos == -1L)
      request.apiLocalCompleteTimeNanos = timeNanos        
      case _: StartThRemoteTimeMsrottlingResponse | _:
      EndThrottlingResponse => ()     
      }     
      // 找出response对应的Processor线程，即request当初是由哪个Processor线程处理的。     
      // 原因是请求是由哪个processor线程接收的，还由哪个processor线程进行响应。
      val processor = processors.get(response.processor)     
      // 将response对象放置到对应Processor线程的Response队列中     
      if (processor != null) {       
      processor.enqueueResponse(response)     
      } 
      }
</code></pre>
<p>方法会根据response的processorId找到对应的processor，这个processor正是接收对应request对象的processor。也就是说，一个processor接受到客户端一个request，那么对应的response也会由这个processor发送给客户端。</p>
<p>好，RequestChannel介绍完了，接下来我们继续学习KafkaRequestHandler线程类。</p>
<h2>KafkaRequestHandler 类</h2>
<p>KafkaRequestHandler类是真正的io线程类，主要任务是从RequestChannel获取请求并调用KafkaApis.handle()方法处理请求。我们接下来看一下这个类的源码和注释：</p>
<pre><code>class KafkaRequestHandler(id: Int,brokerId: Int, val aggregateIdleMeter:
Meter,val totalHandlerThreads: AtomicInteger, val requestChannel:
RequestChannel,apis: ApiRequestHandler,time: Time) 
extends Runnable with Logging {   
this.logIdent = "[Kafka Request Handler " + id + " on Broker " + brokerId + "], "   
private val shutdownComplete = new CountDownLatch(1)   
@volatile private var stopped = false   
def run(): Unit = {
// 1.只要该线程尚未关闭，循环运行处理逻辑     
while (!stopped) {       
val startSelectTime = time.nanoseconds       
// 2.每隔300ms从RequestChannel.requestQueue队列获取请求。       
val req = requestChannel.receiveRequest(300)       
val endTime = time.nanoseconds       
// 统计线程空闲时间       
val idleTime = endTime - startSelectTime       
// 更新线程空闲百分比指标       
aggregateIdleMeter.mark(idleTime / totalHandlerThreads.get)       
req match {           
// 关闭kakfa节点服务的操作。         
case RequestChannel.ShutdownRequest =>debug(s"Kafka request handler $id on broker $brokerId received shut down command")
shutdownComplete.countDown()           
return         
case request: RequestChannel.Request =>           
try {             
request.requestDequeueTimeNanos = endTime             
trace(s"Kafka request handler $id on broker $brokerId handling request $request")             
//通过KafkaApis对Request对象进行最终的处理，apis类实现了处理请求的逻辑，同时还负责将响应写回             
//对应的RequestChannel.responseQueue中，唤醒Processor处理
apis.handle(request)           
} catch {
case e: FatalExitError => 
shutdownComplete.countDown()
Exit.exit(e.statusCode)
case e: Throwable => error("Exception when handling request", e) 
} finally {
request.releaseBuffer()
}         
case null => // continue       
}     
}     
shutdownComplete.countDown()   
}   
def stop(): Unit = {     
stopped = true   
}   
def initiateShutdown(): Unit = requestChannel.sendShutdownRequest()   
def awaitShutdown(): Unit = shutdownComplete.await() 
}
</code></pre>
<p>我们重点分析下run()方法里的步骤：</p>
<ol>
<li>只要该线程尚未关闭，while(true)循环运行处理逻辑。</li>
<li>每隔300ms从RequestChannel.requestQueue队列获取请求。</li>
<li>如果请求类型是ShutdownRequest，那么就通过调用shutdownComplete.countDown()关闭KafkaRequestHandler线程。如果请求类型是Request就调用apis.handle(request)完成对底层组件的调用。</li>
</ol>
<p>KafkaRequestHandler线程类是放在线程池KafkaRequestHandlerPool里执行的。接下来，我们再研究一下KafkaRequestHandlerPool类是怎么设计的。</p>
<h3>KafkaRequestHandlerPool 类</h3>
<p>我们先学习一下这个类的重要字段和对象初始化方法。代码和注释如下：</p>
<pre><code>class KafkaRequestHandlerPool(val brokerId: Int,val requestChannel:
RequestChannel,val apis: ApiRequestHandler,time: Time,numThreads: Int,
requestHandlerAvgIdleMetricName: String,logAndThreadNamePrefix : String)
extends Logging with KafkaMetricsGroup {   
// I/O线程池大小，默认8个线程，支持动态变更。   
private val threadPoolSize: AtomicInteger = new AtomicInteger(numThreads)
private val aggregateIdleMeter = newMeter(requestHandlerAvgIdleMetricName,
"percent", TimeUnit.NANOSECONDS)   
this.logIdent = "[" + logAndThreadNamePrefix + " Kafka Request Handler on Broker " + brokerId + "], "   
//kafkaRequestHandler集合,I/O线程池   
val runnables = new mutable.ArrayBuffer[KafkaRequestHandler](numThreads) 
// 创建numThreads个KafkaRequestHandler线程，KafkaRequestHandler线程就是负责io的线程。   
for (i &#x3C;- 0 until numThreads) {
createHandler(i)
}
</code></pre>
<h3>重要字段</h3>
<ul>
<li>threadPoolSize：线程池的线程数，默认8个线程，支持动态变更。对应配置参数是num.io.threads</li>
<li>runnables：kafkaRequestHandler集合，集合元素都是KafkaRequestHandler线程类对象。</li>
</ul>
<p>对象初始化过程中会通过循环创建kafkaRequestHandler对象并把对象放到集合runnables里，还会启动kafkaRequestHandler线程类对象，代码和注释如下：</p>
<pre><code>for (i &#x3C;- 0 until numThreads) {
createHandler(i)   
}   
// 创建序号为指定id的I/O线程对象，并启动该线程   
def createHandler(id: Int): Unit = synchronized {     
// 创建 KafkaRequestHandler 实例并加入到 runnables 中     
runnables += new KafkaRequestHandler(id, brokerId, aggregateIdleMeter, threadPoolSize, requestChannel, apis, time)     
// 后台启动 KafkaRequestHandler 线程
KafkaThread.daemon(logAndThreadNamePrefix + "-kafka-request-handler-" + id, runnables(id)).start()   
}
</code></pre>
<p>好，请求如何处理我们了解了，但是响应如何返回给Processor线程类的过程我们还不知道，这就是要涉及类KafkaApis了，接下来我们研究一下这个类的基本情况，以及跟处理响应相关的逻辑。</p>
<h2>类 KafkaApis</h2>
<p>类KafkaApis里最重要的方法是handle(),这个方法是调用服务端组件的入口方法。这个方法根据请求的类型调用不同的方法，我们看一下这个方法：</p>
<h3>方法 handle()</h3>
<p>源码和注释如下：</p>
<pre><code>override def handle(request: RequestChannel.Request): Unit = {
try {       
// 根据请求头部信息中的apiKey字段判断属于哪类请求       
// 然后调用响应的handle***方法       
// 如果新增RPC协议类型，则：       
// 1. 添加新的apiKey标识新请求类型       
// 2. 添加新的case分支       
// 3. 添加对应的handle***方法       
trace(s"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};" +
s"securityProtocol:${request.context.securityProtocol},principal:${request.context.principal}")       
//负责将KafkaRequestHandler传递过来的请求分发到不同的handl*()处理方法中，apiKey 是分发的依据，       
//不同的apiKey的值代表不同请求的类型。       
request.header.apiKey match {         
//生产者生产消息的请求         
case ApiKeys.PRODUCE => handleProduceRequest(request)
//消费者拉取消息的请求         
case ApiKeys.FETCH => handleFetchRequest(request)
......
</code></pre>
<p>这个方法根据request的头部信息判断请求的类型，不同的类型匹配。假如我们还要加入一个RPC协议那么我们需要做三个事情：</p>
<ol>
<li>添加新的apiKey标识新请求类型。</li>
<li>添加新的case分支。</li>
<li>添加对应的handle***方法。</li>
</ol>
<p>下面我们分析 handleProduceRequest(request) 这个方法，这个方法是处理生产者生产消息的请求。</p>
<h3>方法 handleProduceRequest()</h3>
<p>方法的源码及对应的注释在下面，方法比较长，非关键的代码我就省略了。我会简单给大家讲解一下处理的步骤：</p>
<pre><code>
def handleProduceRequest(request: RequestChannel.Request): Unit = { 
//1.获取生产者发送的请求体信息     
val produceRequest = request.body[ProduceRequest] ......       
//2.如果请求不关心响应       
if (produceRequest.acks == 0) {         
// 如果request.required.acks = 0，无需做任何操作。但是，因为生产者不需要任何响应，如果在处理请求的过程中有任何异常，         
// 服务端将关闭socket连接，这样生产者端将会感知到连接错误并刷新元数据。         
if (errorInResponse) {           
val exceptionsSummary = mergedResponseStatus.map { case (topicPartition, status) =>             
topicPartition -> status.error.exceptionName
}.mkString(", ")           
//           info(             s"Closing connection due to error during produce request with correlation id ${request.header.correlationId} " +               s"from client id ${request.header.clientId} with ack=0\n" +               s"Topic and partition to exceptions: $exceptionsSummary"           )           
//关闭连接           
closeConnection(request, new ProduceResponse(mergedResponseStatus.asJava).errorCounts)         
} else {                     
//发送无响应的response,注意虽然请求限流对acks == 0豁免；
//但是channel可能由于宽带额度超限而被限流           
sendNoOpResponseExemptThrottle(request)         
}       
} else { 
//3.发送有响应的response
sendResponse(request, Some(new
ProduceResponse(mergedResponseStatus.asJava, maxThrottleTimeMs)), None) 
} 
}
</code></pre>
<p>第一步，获取生产者发送的请求体信息。</p>
<p>第二步，如果produceRequest.acks为零，我们就认为请求不需要响应，如果在处理请求的过程中有任何异常，服务端就关闭socket连接，这样生产者端将会感知到连接错误并刷新元数据。如果没有错误，发送无响应的response。</p>
<p>第三步，produceRequest.acks不为零，就发送有响应的response。这时逻辑就到了sendResponse()方法里。</p>
<p>接下来，我们研究sendResponse()方法。</p>
<h3>sendResponse() 方法</h3>
<p>这个方法调用requestChannel.sendResponse()这个方法已经在上面说明了。这里就不再重复讲了。</p>
<pre><code>private def sendResponse(request: RequestChannel.Request,
responseOpt: Option[AbstractResponse], 
onComplete: Option[Send => Unit]): Unit = {
responseOpt.foreach(response =>
requestChannel.updateErrorMetrics(request.header.apiKey,
response.errorCounts.asScala))     
val response = responseOpt match {       
case Some(response) =>         
val responseSend = request.context.buildResponse(response)         
val responseString = 
if (RequestChannel.isRequestLoggingEnabled) Some(response.toString(request.context.apiVersion))
else None         
new RequestChannel.SendResponse(request, responseSend, responseString, onComplete)
case None =>         
new RequestChannel.NoOpResponse(request)     } 
//把响应放入响应队列中     
requestChannel.sendResponse(response) }
</code></pre>
<h2>总结</h2>
<p>又到了总结的环节，今天我们讲解了三个重要的类，RequestChannel，KafkaRequestHandler，KafkaApis。RequestChannel类用于接收Processor线程类处理的请求对象，同时接收响应。KafkaRequestHandler类负责从RequestChannel类的请求队列拿到请求并调用服务端底层组件完成IO操作。同时。KafkaApis是访问服务端底层组件的api层，会把响应放入对应的Processor线程类的响应集合里。</p>
<p>下面我总结了一个思维导图，帮助你概括这节的内容：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83477145e45f4129ae5512f00df348a8~tplv-k3u1fbpfcp-watermark.image?" alt="服务端通信层（3）.png"></p></div>
</body></html>