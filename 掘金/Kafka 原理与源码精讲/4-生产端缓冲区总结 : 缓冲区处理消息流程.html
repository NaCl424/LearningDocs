<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>生产端缓冲区总结 : 缓冲区处理消息流程</h1>
<p>这节课我提供了视频讲解，在源码讲解的基础上增加了原理解析和架构学习的部分，对应的视频地址如下
<a href="https://www.bilibili.com/video/BV1cZ4y1y7C5" target="_blank" rel="nofollow noopener noreferrer">https://www.bilibili.com/video/BV1cZ4y1y7C5</a></p>
<p>前面两节课我们一起学习了RecordAccumulator依赖的组件，这节课学习RecordAccumulator。在讲之前，我们需要先了解下相关的背景。</p>
<p>我们知道Kafka是一个吞吐量很高的消息队列，在生产者这里也有体现。其实，<strong>高吞吐最普遍的实现是压缩、批量、异步</strong>。今天就一起来聊聊 Kafka生产端如何实现批量发送的。</p>
<p><strong>KafkaProducer有同步和异步两种方式来发送消息，但底层都是通过异步方式实现的</strong>。也就是说生产者主线程发送后不会阻塞，而是继续发送下条消息，但是可以通过回调函数收到发送结果。KafkaProducer会把消息暂时保存在内存中，然后满足一定条件时，会唤醒一个名叫Sender的子线程把消息发送给Kafka服务端。批量发送的好处是能够减少网络请求的次数，进而提升网络吞吐。</p>
<p>那暂存的消息都在哪里呢？又是怎样被管理的呢？<code>它们位于RecordAccumulator类中</code>。我们还是通过思维导图了解一下这个类都有哪些知识点：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ee3088a4a2044899e4b17179e09ecad~tplv-k3u1fbpfcp-watermark.image?" alt="48527A08-AE8A-475D-8F62-8279138FFA91.png"></p>
<h2><strong>类定义和字段</strong></h2>
<p>该类中最重要的字段如下所示：</p>
<pre><code>public RecordAccumulator(LogContext logContext,
                         int batchSize,
                         CompressionType compression,
                         int lingerMs,
                         long retryBackoffMs,
                         int deliveryTimeoutMs,
                         Metrics metrics,
                         String metricGrpName,
                         Time time,
                         ApiVersions apiVersions,
                         TransactionManager transactionManager,
                         BufferPool bufferPool) 
</code></pre>
<ul>
<li><code>batchSize</code>：ProducerBatch的最大字节数。</li>
<li><code>compression</code>：消息压缩方式，有none、gzip、snappy、lz4、zstd。<strong>默认是不进行压缩，如果你的位移主题占用的磁盘空间比较多的话，可以考虑启用压缩，以节省资源</strong>。</li>
<li><code>retryBackoffMs</code>：重试退避时间。</li>
<li><code>free</code>：BufferPool类型，<strong>目的是实现内存的高效利用</strong>。因为ByteBuffer的创建和销毁都是比较消耗资源的，Kafka底层提供了BufferPool实现ByteBuffer的复用和管理。</li>
<li><code>transactionManager</code>：事务管理器，我们不涉及事务的讨论，这里可以忽略。</li>
</ul>
<p>除了构造方法的参数外，有几个字段也需要关注：</p>
<pre><code>public final class RecordAccumulator {

    private volatile boolean closed; //生产者是否关闭
    private final AtomicInteger flushesInProgress; // 要求暂存的消息要立即发送的线程数
    private final AtomicInteger appendsInProgress; // 发送消息的线程数
    private final int batchSize; // ProducerBatch 的最大值
    private final CompressionType compression;// 消息压缩格式 的最大值
    private final int lingerMs;
    private final long retryBackoffMs; //重试退避时间
    private final int deliveryTimeoutMs;
    private final BufferPool free; // ByteByte池
    private final Time time;
    private final ApiVersions apiVersions;
    private final ConcurrentMap&#x3C;TopicPartition, Deque&#x3C;ProducerBatch>> batches; //保存消息的集合
    private final IncompleteBatches incomplete;//未完成消息集合
    // The following variables are only accessed by the sender thread, so we don't need to protect them.
    private final Set&#x3C;TopicPartition> muted;
    private int drainIndex;
    private final TransactionManager transactionManager; // 事务管理器
    private long nextBatchExpiryTimeMs = Long.MAX_VALUE; // ProducerBatch 超时时间the earliest time (absolute) a batch will expire.
</code></pre>
<ul>
<li><code>closed</code>：值为true表示生产者已经关闭了，通知正在工作的线程停止暂存消息的动作，由于要支持多线程，这个参数用了volatile来修饰。</li>
<li><code>flushesInProgress</code>：要求暂存的消息要立即发送的线程数，调用一次加 1。</li>
<li><code>appendsInProgress</code>：记录往RecordAccumulator发送消息的线程数。</li>
<li><code>batches</code>：实例化的类型是<code>CopyOnWriteMap&#x3C;TopicPartition,Deque&#x3C;ProducerBatch>></code>，<strong>这是真正消息暂存的集合</strong>，key是一个主题分区，<code>Deque&#x3C;ProducerBatch></code>是元素是ProducerBatch的queue。ProducerBatch底层维护着一个ByteBuffer，一个ByteBuffer里会缓存一个或多个消息。</li>
<li><code>incomplete</code>：Set类型，当一个ProducerBatch创建时，会加到这个Set里。只有真正发送完成才会把ProducerBatch从incomplete集合中删除。</li>
<li><code>nextBatchExpiryTimeMs</code>：下一次ProducerBatch的超时时间，如果很久都没有被Send线程发送就会超时销毁。</li>
</ul>
<h2><strong>方法</strong></h2>
<p>该类下的方法主要满足两个线程的需要。</p>
<ul>
<li><strong>生产者主线程</strong>：比如发送消息。</li>
<li><strong>Sender子线程</strong>：包括Sender可以发送的node有哪些，以及node对应要发送消息。</li>
</ul>
<p>我们先学习主线程使用的方法。</p>
<h3>1. append()</h3>
<p>我们先讲解下添加消息的方法，该方法的代码很长，我先画一张图来展示下它的完整流程，帮助你建立起对这个方法的整体认知。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/225a3b88d5b7428782c8161cd029ec25~tplv-k3u1fbpfcp-watermark.image?" alt="7B3561DB-CF81-4208-9013-905E2C1353E1.png"></p>
<p>接下来，我们再从它的<strong>方法签名和具体代码</strong>两个维度，来具体了解一下它的执行逻辑。</p>
<p><code>append()方法签名</code>有几个重点参数，我们一起看下：</p>
<pre><code>public RecordAppendResult append(TopicPartition tp,//要发送的主题分区
      long timestamp,//发送时的时间戳
      byte[] key,//消息的key
      byte[] value,//消息的value
      Header[] headers,//消息的头
      Callback callback,//生产者的回调方法
      long maxTimeToBlock,
      boolean abortOnNewBatch,//终止新的消息批次
      long nowMs//发送的时间
                                  )

</code></pre>
<p>解释一下上面我们没提过的参数。</p>
<ul>
<li>timestamp：要发送的实际戳。</li>
<li>key：发送消息的key。</li>
<li>value：发送消息的value。</li>
<li>callback：生产者的回调方法，回调方法是生产者生产消息的时候传进来的，用于实现消息生产成功后执行的逻辑。</li>
</ul>
<p>我们再看一下<code>append()方法体</code>的代码，如下所示：</p>
<pre><code>// 第一部分：
// 1. 从batches得到tp对应的ProducerBatch队列，如果没有就新建。
Deque&#x3C;ProducerBatch> dq = getOrCreateDeque(tp);
// 2. 第一次加锁，相同的Deque&#x3C;ProducerBatch>都会竞争这个锁。
synchronized (dq) {
    //判断生产者是否已经关闭了。
    if (closed)
        throw new KafkaException("Producer closed while send in progress");
    //3.正式往batches里添加消息
    RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq, nowMs);
    //4. 如果Deque&#x3C;ProducerBatch>最后一个ProducerBatch空间够用，一般情况下会添加成功，返回结果
    if (appendResult != null)
        return appendResult;
}
</code></pre>
<p>消息追加的代码比较多，我分为两大部分来讲解。</p>
<p><strong>第一部分是第一次往batches里追加消息</strong>，如果batches里有空间，一般会追加成功，步骤如下。</p>
<ul>
<li>从batches得到tp对应的ProducerBatch队列，如果没有就新建。这个很简单，就是根据topic partition的组合获取ProducerBatch队列。</li>
<li>第一次加锁，相同的dq都会竞争这个锁，不同的dq不会干扰，<strong>把锁的粒度变小有利于提升线程的并发度</strong>。</li>
<li>调用tryAppend()方法正式往batches里添加消息，如果空间dq最后一个ProducerBatch空间满足消息体大小的存储，一般会把消息追加上的。</li>
<li>返回消息追加的结果。</li>
</ul>
<p><strong>代码的第一大部分主要就是通过找到tp对应的dq，然后对dq加锁防止别的线程影响，最后调用tryAppend()正式追加消息</strong>。</p>
<p>代码的<strong>第二部分是如果batcher空间不够，就要新创建ByteBuffer</strong>，步骤如下代码所示：</p>
<pre><code>// 第二部分：如果不创建新的批次
if (abortOnNewBatch) {
    // Return a result that will cause another call to append.
    // 5.返回给KafakProducer.doSend()方法后，会引起二次调用append(),同时abortOnNewBatch=false
    return new RecordAppendResult(null, false, false, true);
}
// 6. KafakProducer.doSend()方法第二次调用append
byte maxUsableMagic = apiVersions.maxUsableProduceMagic();
int size = Math.max(this.batchSize, AbstractRecords.estimateSizeInBytesUpperBound(maxUsableMagic, compression, key, value, headers));
log.trace("Allocating a new {} byte message buffer for topic {} partition {} with remaining timeout {}ms", size, tp.topic(), tp.partition(), maxTimeToBlock);
// 7. Deque&#x3C;ProducerBatch>最后一个ProducerBatch不够用时，使用BufferPool申请新的ByteBuffer
buffer = free.allocate(size, maxTimeToBlock);
// Update the current time in case the buffer allocation blocked above.
nowMs = time.milliseconds();
// 8.第二次加锁
synchronized (dq) {
    // Need to check if producer is closed again after grabbing the dequeue lock.
    if (closed)
        throw new KafkaException("Producer closed while send in progress");
    //9.第二次往batches里添加消息
    RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq, nowMs);
    if (appendResult != null) {
        // Somebody else found us a batch, return the one we waited for! Hopefully this doesn't happen often...
        return appendResult;
    }
    // 10.使用BufferPool新申请的ByteBuffer构建ProducerBatch
    MemoryRecordsBuilder recordsBuilder = recordsBuilder(buffer, maxUsableMagic);
    ProducerBatch batch = new ProducerBatch(tp, recordsBuilder, nowMs);
    // 11.使用BufferPool新申请的ByteBuffer构建ProducerBatch
    FutureRecordMetadata future = Objects.requireNonNull(batch.tryAppend(timestamp, key, value, headers,
            callback, nowMs));
    // 12.新构建ProducerBatch加入到dq里。
    dq.addLast(batch);
    incomplete.add(batch);
    // Don't deallocate this buffer in the finally block as it's being used in the record batch
    buffer = null;
    return new RecordAppendResult(future, dq.size() > 1 || batch.isFull(), true, false);
}
</code></pre>
<p>可以看到如下步骤。</p>
<ul>
<li>如果不创建新的批次，就返回给上层调用方KafakProducer.doSend()方法，就会引起二次调用append()，同时abortOnNewBatch=false，这时代码还是会从第一部分调用。为什么都没空间了还是会append()方法呢? 我下面会讲。</li>
<li>KafakProducer.doSend()方法第二次调用append，因为这时abortOnNewBatch=false，代码逻辑就会走到这步。</li>
<li><code>Deque&#x3C;ProducerBatch></code>最后一个ProducerBatch不够用时，使用BufferPool申请新的ByteBuffer。这个操作比较耗时，同时注意这里并没有锁。</li>
<li>第二次加dq锁。</li>
<li>第二次往batches里添加消息。</li>
<li>如果还是没有空间就使用BufferPool新申请的ByteBuffer构建ProducerBatch。</li>
<li>新构建ProducerBatch加入到dq里。</li>
</ul>
<p><strong>这一部分代码主要是当batches空间不足需要增加新的空间的时候，如何申请新的空间</strong>。不过，这里需要注意两个方面。</p>
<p><strong>（1）为什么加入两个锁，而不是所有的代码就加一个dp锁？</strong></p>
<p>首先明确下，申请新的空间的代码没在锁里，这里可以关注一下。</p>
<p>因为即使是一个tp的消息，也会存在消息体大小不一的情况。如果线程1这个大消息体的空间不满足，就会去生成新的ByteBuffer，这个过程比较慢，如果在锁里会产生阻塞。如果这时有个线程2小消息体的消息需要追加到batches，并且dq里最后一个ProducerBatch空间能够满足，但是这时被阻塞了。如果都用一个锁包住就会降低并发度，同时线程1创建新的ProducerBatch成功后，线程2会往新创建ProducerBatch追加消息，这样就浪费了内存空间。</p>
<p><strong>（2）为什么第二部分代码在创建新的ProducerBatch前又调用了一次追加操作（调用方法tryAppend()）？</strong></p>
<p>当Deque最后一个ProducerBatch空间不足时，会申请新的ProducerBatch。如果这个时候有两个或多个线程都在申请，就会造成内存的使用不充分，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4395cc31680c48b9a127dd8bc94ae0c2~tplv-k3u1fbpfcp-watermark.image?" alt="94DD0B76-25A6-47B8-B56C-8AEB12BF35AA.png"></p>
<p>从图中可以看到，当线程一申请的ProducerBatch没有用完时，下次再追加消息会使用线程二创建的ProducerBatch，因为消息只会追加队尾的ProducerBatch，这样就浪费了内存空间。</p>
<p>主线程主要就是调用append方法，接下来我们学习Sender线程调用的方法。</p>
<h3>2. ready()</h3>
<p><strong>这个方法的作用是获取能发送消息的节点集合</strong>，Sender线程会关心哪几个node节点可以发消息，该方法对应的代码如下所示：</p>
<pre><code>public ReadyCheckResult ready(Cluster cluster, long nowMs) {
    //哪些服务端节点可以发送消息
    Set&#x3C;Node> readyNodes = new HashSet&#x3C;>();
    long nextReadyCheckDelayMs = Long.MAX_VALUE;
    //找不到Leader副本的分区的主题
    Set&#x3C;String> unknownLeaderTopics = new HashSet&#x3C;>();
    //是否有线程在等待BufferPool释放空间，
    boolean exhausted = this.free.queued() > 0;
    //1.遍历batches集合中的所有元素
    for (Map.Entry&#x3C;TopicPartition, Deque&#x3C;ProducerBatch>> entry : this.batches.entrySet()) {
        Deque&#x3C;ProducerBatch> deque = entry.getValue();
        synchronized (deque) {
            // When producing to a large number of partitions, this path is hot and deques are often empty.
            // We check whether a batch exists first to avoid the more expensive checks whenever possible.
            //2.取deque第一个ProducerBatch，判断deque是否为空
            ProducerBatch batch = deque.peekFirst();
            if (batch != null) {
                TopicPartition part = entry.getKey();
                //3.查找分区的leader所在的node
                Node leader = cluster.leaderFor(part);
                //leader不存在则就无法发送
                if (leader == null) {
                  
                    unknownLeaderTopics.add(part.topic());
                } else if (!readyNodes.contains(leader) &#x26;&#x26; !isMuted(part)) {
                    long waitedTimeMs = batch.waitedTimeMs(nowMs);
                    boolean backingOff = batch.attempts() > 0 &#x26;&#x26; waitedTimeMs &#x3C; retryBackoffMs;
                    long timeToWaitMs = backingOff ? retryBackoffMs : lingerMs;
                    //deque大于1或第一个batch是否满了
                    boolean full = deque.size() > 1 || batch.isFull();
                    //消息在暂存队列里是否超时了
                    boolean expired = waitedTimeMs >= timeToWaitMs;
                    //4.五个判断条件决定是否是能发送的node
                    boolean sendable = full || expired || exhausted || closed || flushInProgress();
                    if (sendable &#x26;&#x26; !backingOff) {
                        //5.如果是能发送就加入readyNodes集合。
                        readyNodes.add(leader);
                    } else {
                        long timeLeftMs = Math.max(timeToWaitMs - waitedTimeMs, 0);
                        nextReadyCheckDelayMs = Math.min(timeLeftMs, nextReadyCheckDelayMs);
                    }
                }
            }
        }
    }
    return new ReadyCheckResult(readyNodes, nextReadyCheckDelayMs, unknownLeaderTopics);
}
</code></pre>
<p>简单描述下这个方法的步骤。</p>
<p>（1）遍历batches集合中的所有元素。</p>
<p>（2）取deque第一个ProducerBatch，判断deque是否为空。如果为空，就没有发送的必要了，因为这个主题分区没有要发送的消息。</p>
<p>（3）查找分区的leader所在的node，如果leader所在的node不存在就没有发送的必要。但是会放到unknownLeaderTopics集合里，<strong>让Sender线程去激发更新元数据的请求</strong>。</p>
<p>（4）五个判断条件决定是否是能发送的node，解释下其中的5个Bool类型。</p>
<ul>
<li><code>full</code>：deque是否大于1，或deque的第一个ProducerBatch是否满了。</li>
<li><code>expired</code>：ProducerBatch在deque里是否超时。</li>
<li><code>exhausted</code>：BufferPool是否正在释放空间。</li>
<li><code>closed</code>：生产者是否准备正常关闭了。</li>
<li><code>flushInProgress</code>：是否在flush操作，这个flush是把暂存消息要立即发送的标记。</li>
</ul>
<p>这样，Sender线程就知道可以往哪些node发送消息了，当然Sender线程还需要知道对应的node要发送哪些消息，由下面要讲解的drain()方法实现的。</p>
<h3>3. drain()</h3>
<p>Sender线程拿到上面的node集合后，会用这个方法<strong>获得每个node需要待发送消息的集合</strong>，主要是调用方法drainBatchesForOneNode来获取每个node的待发送消息，我带你分析下这个方法：</p>
<pre><code>private List&#x3C;ProducerBatch> drainBatchesForOneNode(Cluster cluster, Node node, int maxSize, long now) {
    int size = 0;
    //1.获取node上所有分区的集合
    List&#x3C;PartitionInfo> parts = cluster.partitionsForNode(node.id());
    //初始化要给这个node发送ProducerBatch的集合
    List&#x3C;ProducerBatch> ready = new ArrayList&#x3C;>();
    /* to make starvation less likely this loop doesn't start at 0 */
    //记录上次停止的位置，这样每次不会从0开始，否则会造成总是发送前几个分区的情况，造成后面的分区饥饿。
    int start = drainIndex = drainIndex % parts.size();
    do {
        //2.获取分区的详情
        PartitionInfo part = parts.get(drainIndex);
        TopicPartition tp = new TopicPartition(part.topic(), part.partition());
        this.drainIndex = (this.drainIndex + 1) % parts.size();
        // Only proceed if the partition has no in-flight batches.
        if (isMuted(tp))
            continue;
        //3.获取主题分区对应的Deque
        Deque&#x3C;ProducerBatch> deque = getDeque(tp);
        ......忽略 
                //4.每个主题分区只取一个ProducerBatch
                ProducerBatch batch = deque.pollFirst();
                ......忽略
                batch.close();
                size += batch.records().sizeInBytes();
                //5.加入到reade集合里
                ready.add(batch);
                batch.drained(now);
            }
        }
    } while (start != drainIndex);
    return ready;
}
</code></pre>
<p>方法步骤如下：</p>
<ul>
<li>获取node上所有分区的集合；</li>
<li>获取分区的详情；</li>
<li>获取主题分区对应的Deque；</li>
<li>每个主题分区只取一个ProducerBatch；</li>
<li>加入reade集合里。</li>
</ul>
<p>这里有两点需要注意下。</p>
<ul>
<li>通过drainIndex 来避免总是取前面几个主题分区的消息发送，而后面的分区轮不到发送任务，从而避免了饥饿的发生。</li>
<li>每次只会取Deque的第一个ProducerBatch放到ready集合里，这样就会进一步打散每次发送的主题分区的消息。因为上层Sender会用while循环一直调用这个方法，所以不用担心Deque消费不完的问题。</li>
</ul>
<h2>总结</h2>
<p>这节课我们主要分析了RecordAccumulator.scala这个类对消息暂存的处理。主要功能是通过<code>CopyOnWriteMap&#x3C;TopicPartition，Deque&#x3C;ProducerBatch>></code>这个类型的集合对主题分区对应的消息的存储，一个主题分区对应一个deque，deque里的元素是ProducerBatch，ProducerBatch底层维护着一个ByteBuffer，ByteBuffer是真正存储消息的地方。</p>
<p>同时，RecordAccumulator.scala这个类还提供了ready()和drain()这两个方法，这两个方法都是Sender线程使用的：</p>
<ul>
<li>前者是Sender线程获取要发送消息的服务端node；</li>
<li>后者是Sender线程获得node对应的<code>Deque&#x3C;ProducerBatch>></code>集合的方法。</li>
</ul>
<h2>源码收获</h2>
<p>我们在做多线程编程的时候，把锁的粒度减小以增加多线程的并发能力，RecordAccumulator.scala类中的append()方法把最消耗资源的申请ByteBuffer的操作不加锁，这样能最大限度地提升并发性。</p>
<p>但是，这样会造成多个线程同时申请ByteBuffer，导致ByteBuffer空间利用的不充分，于是在第二次加锁的时候先不把新申请的ByteBuffer加到Deque里，而是直接调用tryAppend()中Deque的最后一个ProducerBatch，如果写成功说明有别的线程已经成功申请了新的ByteBuffer，避免二次申请造成的浪费。<strong>这样的设计告诉我们，既要想到控制锁的粒度，也要考虑到并发造成的问题</strong>。</p></div>
</body></html>