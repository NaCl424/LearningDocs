<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>服务端的核心：SocketServer 类和 Reactor 模式简介</h1>
<p>从今天我们就开始了服务端代码的学习。</p>
<p>服务端代码是kafka的核心和精华，而且代码量比较大，我根据功能模块划分了几个部分，分别为：网络通信模块，存储模块，副本模块，控制模块，延迟模块，消费组协调器模块。</p>
<p>今天我们开始学习网络通信模块，整个服务端的主类是SocketServer类，跟网络通信层相关的组件主要是SocketServer.scala、KafkaApis.scala和KafkaRequesthandler.scala。今天我们主要研究SocketServer.scala文件的概况和Reactor模式。</p>
<h2>SocketServer.scala 文件</h2>
<p>SocketServer类是接收客户端socket请求连接、处理服务端和客户端网络IO的核心类。我们先了解一下这个类的基本情况和重要字段。</p>
<p>SocketServer.scala 文件分为8个部分，这里我用一张图展示一下。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8697d250a543473e836003a9d3a97849~tplv-k3u1fbpfcp-watermark.image?" alt="SocketServer类结构.png"></p>
<p>可以看到，共有8个组件，这节课和下节课我会给你介绍几个重点组件。</p>
<p>首先我们讲解<strong>类 SocketServer</strong>。</p>
<p>类 SocketServer的主要字段如下：</p>
<pre><code>class SocketServer(val config: KafkaConfig,
                   val metrics: Metrics,
                   val time: Time,
                   val credentialProvider: CredentialProvider)
  extends Logging with KafkaMetricsGroup with BrokerReconfigurable {
  // SocketServer 实现 BrokerReconfigurable trait表明SocketServer的一些参数配置是允许动态修改的
  // 即在Broker不停机的情况下修改它们
  // SocketServer的请求队列长度，由Broker端参数queued.max.requests值而定，默认值是500
  private val maxQueuedRequests = config.queuedMaxRequests
  //数据面的Processor线程类集合。
  private val dataPlaneProcessors = new ConcurrentHashMap[Int, Processor()
  // 处理数据类请求的Acceptor线程集合，每套监听器对应一个Acceptor线程
  private[network] val dataPlaneAcceptors = new ConcurrentHashMap[EndPoint, Acceptor]()
  // 处理数据类请求专属的RequestChannel对象，多个Processor会共享一个RequestChannel，请求队列长度为500.
  val dataPlaneRequestChannel = new RequestChannel(maxQueuedRequests, DataPlaneMetricPrefix, time)
  // 用于处理控制类请求的Processor线程
  // 注意：目前定义了专属的Processor线程而非线程池处理控制类请求
  private var controlPlaneProcessorOpt : Option[Processor] = None
  private[network] var controlPlaneAcceptorOpt : Option[Acceptor] = None
  // 处理控制类请求专属的RequestChannel对象，请求队列长度为20，远远小于数据类请求，因为控制类不需要这么多
  val controlPlaneRequestChannelOpt: Option[RequestChannel] = config.controlPlaneListenerName.map(_ =>
  new RequestChannel(20, ControlPlaneMetricPrefix, time))
</code></pre>
<p>SocketServer实现了BrokerReconfigurable，说明SocketServer是支持动态配置参数的。哪些参数可以动态配置呢？这些参数都在SocketServer Object保存着，你有兴趣可以了解下。</p>
<p>接下来，我们来讲解其中的重点字段。</p>
<ul>
<li><code>maxQueuedRequests</code>：服务端对于新来的请求，Processor会放到请求队列里等待真正的业务线程处理，队列的长度就是由这个参数决定的，默认是500。</li>
<li><code>dataPlaneProcessors</code>：数据面的Processor线程集合，默认3个线程。</li>
<li><code>dataPlaneAcceptors</code>：数据面Acceptor线程的map集合，key是EndPoint，value是Acceptor线程类对象。一个broker可能会有多个EndPoint，一个EndPoint只会有一个Acceptor线程。</li>
<li><code>dataPlaneRequestChannel</code>：数据面的RequestChannel类对象。RequestChannel类定义了请求和响应类，并定义了请求集合等功能。</li>
<li><code>controlPlaneProcessorOpt</code>：控制面的Processor线程类，由于控制面的请求量不高，所以一个Processor线程类就应该够用了。</li>
<li><code>controlPlaneAcceptorOpt</code>：控制面的Acceptor线程类。</li>
<li><code>controlPlaneRequestChannelOpt</code>：控制面的RequestChannel类对象，跟数据面的RequestChannel类对象功能类似。</li>
</ul>
<p>字段我们了解完了，现在着重学习一下SocketServer类相关的方法。</p>
<p>SocketServer类的启动方法是startup()，所以我们先看一下这个方法都做了什么。</p>
<h3>方法 startup()</h3>
<p>startup()方法源码如下：</p>
<pre><code>//核心流程:创建各类线程，包括Acceptor,Processor,然后启动
def startup(startProcessingRequests: Boolean = true): Unit = {
  this.synchronized {
    connectionQuotas = new ConnectionQuotas(config, time, metrics)
    //1.创建控制面Acceptor和Processor。包括一个Acceptor线程和一个Processor线程，
    createControlPlaneAcceptorAndProcessor(config.controlPlaneListener)
    //2.创建数据面Acceptor和Processor。创建一个Acceptor线程，和创建默认3个Processor线程，由配置项num.network.threads决定Processor的线程数，默认3个线程
    createDataPlaneAcceptorsAndProcessors(config.numNetworkThreads, config.dataPlaneListeners)
    if (startProcessingRequests) {
    //3.启动控制面和数据面各自的Acceptor和Processor线程
    this.startProcessingRequests()
    }
  }
  …… 省略
}
</code></pre>
<p>首先给你介绍下服务端请求的一些分类和概念。kafka服务端给外部请求分为了两个大类：控制面请求和数据面请求。</p>
<ul>
<li><strong>控制面请求</strong>指的是用于控制服务端或协调同步类的请求，比如，关闭broker节点，follower partition所在的节点向leader partition所在的节点拉取消息。   </li>
<li><strong>数据面请求</strong>是指真正业务数据相关的请求，如生产者生产消息时向broker发送消息的请求，消费者拉取消息时向broker拉取消息的请求等。</li>
</ul>
<p>好，我们看一下这个方法都做了什么工作。</p>
<ol>
<li>创建控制面Acceptor和Processor。包括一个Acceptor线程和一个Processor线程。</li>
<li>创建数据面Acceptor和Processor。创建一个Acceptor线程，和创建默认3个Processor线程，由配置项<a href="http://num.network.threads/" target="_blank" rel="nofollow noopener noreferrer">num.network.threads</a>决定Processor的线程数，默认3个线程。</li>
<li>启动控制面和数据面各自的Acceptor和Processor线程。</li>
</ol>
<p>这里你可能会有一个疑问：<code>为什么要分为控制面请求和数据面请求呢？</code></p>
<p>原因是如果不把请求分为控制面和数据面，而数据类请求一般量级很大甚至造成大量请求排队等待处理，比如，生产者生产消息的请求，消费者拉取消息的请求。这时如果出现控制类的请求，就会使控制类亲戚在数据类请求后面排队，这样就会造成控制面请求处理的不及时，而控制类请求又是比较重要的，比如通知某个leader分区变为follower分区等。最终会造成数据的不一致，甚至数据类请求失败。而分成两类就不会大量出现这样的问题，因为毕竟是把两类请求分开处理了。</p>
<p>startup()方法内部创建了控制面和数据面的线程，这两个控制面和数据面的相关线程的创建基本就一样，这里我们讲解一下数据面的相关线程的创建。</p>
<h3>方法 createDataPlaneAcceptorsAndProcessors()</h3>
<p>其源码如下：</p>
<pre><code>private def createDataPlaneAcceptorsAndProcessors(
dataProcessorsPerListener: Int,endpoints: Seq[EndPoint]): Unit = {
  // 遍历监听器endpoints集合
  // endpoints:一台服务器可以配置多个kafka实例,通过port区分开来。
  // node01:9092,node01:9093,node01:9094
  endpoints.foreach { endpoint =>
    // 将监听器纳入到连接配额管理之下
    connectionQuotas.addListener(config, endpoint.listenerName)
    // 为监听器创建对应的Acceptor线程
    val dataPlaneAcceptor = createAcceptor(endpoint,DataPlaneMetricPrefix)
    // 为监听器创建多个Processor线程。具体数目由num.network.threads决定
    addDataPlaneProcessors(dataPlaneAcceptor, endpoint, dataProcessorsPerListener)
    // 将&#x3C;监听器，Acceptor线程>对保存起来统一管理
    dataPlaneAcceptors.put(endpoint, dataPlaneAcceptor)
    info(s"Created data-plane acceptor and processors for endpoint : ${endpoint.listenerName}")
  }
}
</code></pre>
<p>首先遍历这个broker设置的所有监听器（endpoint），一台服务器可以配置多个kafka实例，通过port区分开来，一个kafka实例就是一个监听器，比如一个机器名为node1的broker，在这个broker上可以配置多个监听器：node01:9092、node01:9093、node01:9094。</p>
<p>我们再看看遍历循环的内部都做了什么。</p>
<ul>
<li>首先把监听器纳入连接配额管理之下，kafka服务端为了保证网络质量对每个监听器的连接配额是有限制的。</li>
<li>然后创建一个Acceptor线程，Acceptor线程是专门负责与外部建立连接的线程，一个监听器只会分配一个Acceptor线程。</li>
<li>下一步建立多个为监听器创建多个Processor线程，Processor线程是用来处理网络读写操作的，具体线程数由<a href="http://num.network.threads/" target="_blank" rel="nofollow noopener noreferrer">num.network.threads</a>决定，默认是3个线程。</li>
<li>最后把&#x3C;监听器，Acceptor线程>对保存在map集合dataPlaneAcceptors中统一管理。</li>
</ul>
<p>接下来我们分别看一下，Acceptor线程和Processor线程是如何创建的。</p>
<h3>方法 createAcceptor()</h3>
<p>其源码如下：</p>
<pre><code>private def createAcceptor(endPoint: EndPoint, metricPrefix: String) : Acceptor = {
  //配置socket发出和接受数据缓冲区大小，默认128kb。
  val sendBufferSize = config.socketSendBufferBytes
  val recvBufferSize = config.socketReceiveBufferBytes
  //获取broker节点id。
  val brokerId = config.brokerId
  new Acceptor(endPoint, sendBufferSize, recvBufferSize, brokerId,    connectionQuotas, metricPrefix)
}
</code></pre>
<p>首先配置socket发出和接受数据缓冲区大小，默认为128kb，但在实际生产环境中，128kb肯定是不够的，可以根据实际请求进行修改。对应的参数分别是 socket.send.buffer.bytes和socket.receive.buffer.bytes，同时获取brokerId作为节点表示，最后创建Acceptor对象。</p>
<h3>方法 addDataPlaneProcessors()</h3>
<p>接下来我们学习数据面的Processor线程的创建过程：</p>
<pre><code>private def addDataPlaneProcessors(acceptor: Acceptor, endpoint: EndPoint, newProcessorsPerListener: Int): Unit = {
  //监听器名称
  val listenerName = endpoint.listenerName
  //协议
  val securityProtocol = endpoint.securityProtocol
  //Processor数组。
  val listenerProcessors = new ArrayBuffer[Processor]()
  //遍历newProcessorsPerListener，默认为3
  for (_ &#x3C;- 0 until newProcessorsPerListener) {
    //创建Processor对象
    val processor = newProcessor(nextProcessorId, dataPlaneRequestChannel, connectionQuotas, listenerName, securityProtocol, memoryPool)
    //把processor添加到数组中。
    listenerProcessors += processor
    //把processor加入到dataPlaneRequestChannel内的集合中，用来监控processor对象
    dataPlaneRequestChannel.addProcessor(processor)
    //线程id加一。
    nextProcessorId += 1
  }
  //把processId和processor通过map集合存储起来
  listenerProcessors.foreach(p => dataPlaneProcessors.put(p.id, p))
  //为acceptor加对应的processor
  acceptor.addProcessors(listenerProcessors, DataPlaneThreadPrefix)
}
</code></pre>
<p>首先获取监听器的名称、支持的安全协议。安全协议具体有PLAINTEXT、SSL、SASL_PLAINTEXT、SASL_PLAINTEXT、SASL_SSL。</p>
<p>然后根据要创建的processor数量，循环创建processor对象，把新创建的processor对象加到集合listenerProcessors中。还要把processor对象加到 dataPlaneRequestChannel对象的集合内，dataPlaneRequestChannel对象的类是RequestChannel，这个类我会在下节课中给你讲解。</p>
<p>循环最后一步是nextProcessorId加一，nextProcessorId表示当前processor线程的id。循环结束后，Processor对象会加到集合dataPlaneProcessors中，dataPlaneProcessors是类SocketServer的字段，表示SocketServer类下所有监听器的Processor集合。</p>
<p>最后，processor对象会加到acceptor对象里的集合里。也就是说，processor线程创建结束后会加到三个集合中，包括dataPlaneRequestChannel对象内的processor集合，dataPlaneProcessors集合，acceptor对象下的集合。</p>
<p>为了更好地让你理解acceptor和processor的对应关系，可参考下面的关系图：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49f8ebe325524a8c90e9d580875fcda5~tplv-k3u1fbpfcp-watermark.image?" alt="Acceptors集合和Processors集合对应关系.png"></p>
<p>SocketServer类对线程的创建就介绍完了，但是线程还没有启动呢？这就是方法startProcessingRequests()的工作了。这个方法启动了控制面的线程和数据面的线程，最终都调用了startAcceptorAndProcessors()去启动线程。</p>
<h3>方法 startAcceptorAndProcessors()</h3>
<p>以下是源码并附有注释：</p>
<pre><code>private def startAcceptorAndProcessors(threadPrefix: String,
                                       endpoint: EndPoint,
                                       acceptor: Acceptor,
                                       authorizerFutures: Map[Endpoint, CompletableFuture[Void]] = Map.empty): Unit = {
  debug(s"Wait for authorizer to complete start up on listener ${endpoint.listenerName}")
  waitForAuthorizerFuture(acceptor, authorizerFutures)
  debug(s"Start processors on listener ${endpoint.listenerName}")
  //通过后台线程启动acceptor下的Processors线程。
  acceptor.startProcessors(threadPrefix)
  debug(s"Start acceptor thread on listener ${endpoint.listenerName}")
  //通过后台线程启动acceptor线程。
  if (!acceptor.isStarted()) {
    KafkaThread.nonDaemon(
      s"${threadPrefix}-kafka-socket-acceptor-${endpoint.listenerName}-${endpoint.securityProtocol}-${endpoint.port}",
      acceptor
    ).start()
    acceptor.awaitStartup()
  }
  info(s"Started $threadPrefix acceptor and processor(s) for endpoint : ${endpoint.listenerName}")
}
private[network] def startProcessors(processorThreadPrefix: String): Unit = synchronized {
  if (!processorsStarted.getAndSet(true)) {
    startProcessors(processors, processorThreadPrefix)
  }
}
private def startProcessors(processors: Seq[Processor], processorThreadPrefix: String): Unit = synchronized {
  // 线程命名规范：processor线程前缀-kafka-network-thread-broker序号-监听器名称-安全协议-Processor序号
  // 假设为序号为0的Broker设置PLAINTEXT://localhost:9092作为连接信息，那么3个Processor线程名称分别为：
  processors.foreach { processor =>
    KafkaThread.nonDaemon(
      s"${processorThreadPrefix}-kafka-network-thread-$brokerId-${endPoint.listenerName}-${endPoint.securityProtocol}-${processor.id}",
      processor
    ).start()
  }
}
</code></pre>
<p>方法步骤如下：</p>
<ol>
<li>启动acceptor下的Processors线程。创建Processor线程代码讲解提到过，Processor线程创建完成后要放入对应Acceptor线程的对应集合里。一个监听器对应一个Acceptor线程，一个Acceptor对应默认3个Processor线程。具体启动方法是：调用Acceptor类的方法startProcessors()，以后台线程的形式启动所有的Acceptor下所有的Processor线程。</li>
<li>通过后台线程启动acceptor线程。注意是先创建处理网络读写的线程再创建建立连接的线程，这样当Acceptor线程接到请求后能够把读写操作交给Processor线程完成。</li>
</ol>
<p>好了，SocketServer类基本上学习完了，你可能对SocketServer类的设计有疑问：处理网络请求的时候为什么要分为两类线程，分别是Acceptor和Processor？为什么不能用一类线程然后用多线程处理呢？这里我们就要聊聊Reactor的设计模式了。</p>
<h2>Reactor 的设计模式</h2>
<p>Reactor是反应的意思，反应指的是「对事件反应」，也就是来了一个事件，Reactor 就有相对应的反应/响应。</p>
<p>Reactor设计模式也叫Dispatcher 模式，用于监听事件的Reactor线程监听到事件后，根据事件的类型分配给相应的处理逻辑。</p>
<p>Reactor设计模式分为3种：</p>
<ul>
<li>单 Reactor 单业务进程；</li>
<li>单 Reactor 多业务线程；</li>
<li>多 Reactor 多业务线程。</li>
</ul>
<h3>单 Reactor 单业务进程</h3>
<p>这种模式有三个对象：Selector、Acceptor、Handler（业务处理对象）。Handler 又细分为 Reader Handler（用于处理读）和 Writer Handler（用于处理写）。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30bb917190b04a7e98ff3324433a3e13~tplv-k3u1fbpfcp-watermark.image?" alt="Reactor模式 -2-.png"></p>
<p>简单介绍其工作原理。</p>
<ol>
<li>首先创建ServerSocketChannel 对象并在 Selector上注册OP_ACCEPT事件，ServerSocketChannel 负责监听指定端口上的连接请求。</li>
<li>当客户端发起到服务端的网络连接时，服务端的Selector 监听到此 OP_ACCEPT事件，会触发 Acceptor 来处理OP_ACCEPT。</li>
<li>当 Acceptor接收到来自客户端的 Socket连接请求时，会为这个连接创建相应的SocketChannel，将SocketChannel设置为非阻塞模式，并在Selector上注册其关注的I/O事件，例如，OP_READ OPWRITE。此时，客户端与服务端之间的Socket 连接正式建完成。</li>
<li>当客户端通过上面建立的Socket连接向服务端发送请求时，服务端的Selector会监听到OP_READ事件，并触发执行相应的处理逻辑（图中的 Reader Handler 业务线程）。当服务端可以向客户端写数据时，服务端的Selector会监听到 OP_WRITE事件，并触发执行相应的处理逻辑（图中的 Writer Handler 业务线程）。</li>
</ol>
<p><code>注意</code>：上述的一系列操作都是在一个线程中完成的。好处是逻辑简单，你可以回顾一下生产者的设计，用的就是一个线程处理所有的任务。这种设计比较适合数据量小的情况，因为生产者作为客户端仅仅是向一个服务端或几个服务端发送数据，而服务端就不一样了，生产环境中几百、上万的客户端连接都有可能的，数据量会很大。如果还用这种设计显然是不合理的。比如，一个线程处理请求处理是，遇到一个很复杂的业务造成了阻塞，这样其他的请求就处理不了了。同时，现在的服务器都是多核的，只运行一个线程是资源的浪费。</p>
<p>这样就出现了单 Reactor 多业务线程的模式。</p>
<h3>单 Reactor 多业务线程</h3>
<p>下图描述了单 Reactor 多业务线程模式的设计原理：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3313bf76f1bb4d9fa5cae0c68aa63a73~tplv-k3u1fbpfcp-watermark.image?" alt="多线程Reactor模式 -1-.png"></p>
<p>Acceptor 单独运行在一个线程中。Reader ThreadPool 线程池中的所有线程都会在 Selector上注册OP_READ事件，负责服务端读取请求的逻辑，当然也是一个线程对应处理多个Socket连接。Reader ThreadPool中的线程成功读取请求后，将请求放入MessageQueue，等待HandlerThreadPool消费MessageQueue 这个队列。</p>
<p>Hander ThreadPool 线程池中的线程会从MessageQueue中取出请求，然后执行业务逻辑对请求进行处理。这种模式下，即使处理某个请求的线程阻塞了，池中还有其他线程继续从 MessageQueue 中获取请求并进行处理，从而避免了个服务端阻塞。</p>
<p>当请求处理完成后，Handler 线程还负责产生响应并发送给客户端。 Handler ThreadPool 中的线程会在 Selector 中注册 OP_WRITE事件，实现发送响应的功能。</p>
<p>最后需要注意的是，当读取请求与业务处理之间的速度不匹配时，MessageQueue列长度的选择就显得尤为重要，尤其是 MessageQueue 队列是固定的大小的时候。如果的列长度太小，就会出现拒绝请求的情况；如果不限制 MessageQucue 队列的长度，则可能因为堆积过多未处理请求而导致内存溢出。这就需要设计人员根据实际的业务需求进行权衡和设计。</p>
<p>通过将网络处理与业务逻辑进行<code>切分</code>后实现了上述设计，此设计中读取、写入、业务处理都实现了多线程处理，不再存在性能瓶颈。但是，如果同一时间出现大量 I/O 事件单个 Selector 就可能在分发事件时阻塞（或延时）而成为瓶颈。我们可以将上述设计中单独的 Selector 对象扩展成多个，让它们监听不同的 I/O 事件，这样就可以避免单个 Selector带来的瓶颈问题。这就引出了下面的多 Reactor 多业务线程。</p>
<h3>多 Reactor 多业务线程</h3>
<p>如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5b98372fd344507880bfd69f4f3ddb4~tplv-k3u1fbpfcp-watermark.image?" alt="多线程Reactor模式--多个Selector.png"></p>
<p>一般情况下，Acceptor单独占用一个Selector。当Acceptor Selector监听到OP_ ACCEPT时，会创建相应的 SocketChannel，在上图设计中，我们使用一定的策略，例如轮训 Selector 集合或选择注册连接数最少的 Selector，让不同的连接在不同的 Selector上注册 I/O事件。之后就由此Selector 负责监听此 SocketChannel 上的事件。</p>
<p>这样，就可以缓解单个Seletor带来的瓶颈问题。</p>
<h2>总结</h2>
<p>今天我们学习了SocketServer.scala文件。这个文件有8个部分，我们重点学习了其中的 <strong>SocketServer类</strong>，SocketServer类是服务端网络通信的基础和入口，同时还负责创建和启动服务端网络层的两个线程类Acceptor和Processor。Acceptor负责建立网络连接，Processor负责网络读写。</p>
<p>然后，我们还介绍了<strong>Reactor设计模式</strong>，Reactor设计模式总的来说是为了处理服务端高并发的场景，基于事件驱动的模式高效完成网络处理。Reactor设计模式分为三类：单 Reactor 单业务进程、单 Reactor 多业务线程、多 Reactor 多业务线程。</p></div>
</body></html>