<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>分而治之：网络层 Reactor 设计模型</h1>
<p>今天我们学习通信层最重要的两个线程类：Acceptor线程类和Processor线程类。</p>
<p>Acceptor类是负责接收外部请求并与外部建立网络连接，随后Acceptor线程类会把建立好的连接交给集合内的Processor线程类，Processor线程类负责在连接上读取或写入数据。</p>
<h2>Acceptor线程类</h2>
<p>Acceptor线程类会构建单独一个Selector和一个serverChannel处理外部请求，并构建一个线程监控Accept事件。我们首先讲解类的参数和重要的字段。</p>
<h3>参数和重要的字段</h3>
<p>Acceptor类的参数和重要字段参见下面的代码：</p>
<pre><code>private[kafka] class Acceptor(val endPoint: EndPoint,//终端
                              val sendBufferSize: Int,//出栈网络io底层缓冲区大小，默认100k
                              val recvBufferSize: Int,//入栈网络io底层缓冲区大小,默认100k
                              brokerId: Int,//broker id
                              connectionQuotas: ConnectionQuotas,//连接配额
                              metricPrefix: String) extends AbstractServerThread(connectionQuotas) with KafkaMetricsGroup {
  // 创建底层的NIO Selector对象
  // Selector对象负责执行底层实际I/O操作，如监听连接创建请求、读写请求等，注意不是KSelector
  private val nioSelector = NSelector.open()
  // Broker端创建对应的ServerSocketChannel实例


  val serverChannel = openServerSocket(endPoint.host, endPoint.port)
  // 创建此Acceptor对应的Processor线程池，实际上是Processor线程数组
  private val processors = new ArrayBuffer[Processor]()
</code></pre>
<p>Acceptor线程类继承了抽象类AbstractServerThread，AbstractServerThread封装了一些为线程服务的公共的方法和参数，比如，线程启动和停止要做的一些额外的工作等。</p>
<p>其<strong>类参数</strong>如下。</p>
<ul>
<li><code>endPoint</code>：终端。包括ip、port等数据。</li>
<li><code>sendBufferSize</code>：出栈网络io底层缓冲区大小，默认100k。</li>
<li><code>recvBufferSize</code>：入栈网络io底层缓冲区大小，默认100k。</li>
<li><code>brokerId</code>：所在的broker的编号id。</li>
<li><code>connectionQuotas</code>：连接配额，为了保证已成功连接正常工作，要通过连接配额控制连接的数量。</li>
</ul>
<p><strong>字段</strong>可总结为如下。</p>
<ul>
<li><code>nioSelector</code>：Acceptor线程类的java nio selector对象，一个Acceptor线程类拥有一个selector对象。</li>
<li><code>serverChannel</code>：java nio 的ServerSocketChannel类对象。</li>
<li><code>processors</code>：processor线程类集合，一个Acceptor类对象都有一个processor线程类集合，当Acceptor类建立好一个网络连接后，会从集合里取出一个processor线程类处理这个网络连接上的网络操作。</li>
</ul>
<p>介绍完了类的参数和类的字段，我们来学习一下方法，首先给大家讲解建立连接的方法accept(key)。</p>
<h3>accept()</h3>
<p>这个方法接收请求并建立连接，然后返回对应的SocketChannel，也就是我们所说的连接。具体方法代码如下：</p>
<pre><code>private def accept(key: SelectionKey): Option[SocketChannel] = {
  val serverSocketChannel = key.channel().asInstanceOf[ServerSocketChannel]
  //1.客户端和服务端建立起了连接。
  val socketChannel = serverSocketChannel.accept()
  try {
    //2.连接统计
    connectionQuotas.inc(endPoint.listenerName, socketChannel.socket.getInetAddress, blockedPercentMeter)
    //3.配置相关属性，如非阻塞，keepAlive,sendBufferSize的大小等。
    socketChannel.configureBlocking(false)
    socketChannel.socket().setTcpNoDelay(true)
    socketChannel.socket().setKeepAlive(true)
    if (sendBufferSize != Selectable.USE_DEFAULT_BUFFER_SIZE)
      socketChannel.socket().setSendBufferSize(sendBufferSize)
    Some(socketChannel)
  } catch {
    case e: TooManyConnectionsException =>
      info(s"Rejected connection from ${e.ip}, address already has the configured maximum of ${e.count} connections.")
      close(endPoint.listenerName, socketChannel)
      None
  }
}
</code></pre>
<p>好，接下来我们重点分析线程类Acceptor的run()方法。</p>
<p>第一步，从SelectionKey类对象参数key中取得serverSocketChannel，然后从serverSocketChannel中获取连接socketChannel。</p>
<p>第二步，更新连接统计，连接数加一。</p>
<p>第三步，配置相关属性，如非阻塞、keepAlive、sendBufferSize的大小等。</p>
<p>第四步，返回socketChannel。</p>
<p>好，我们接下来学习线程类的核心方法run()方法。</p>
<h3>run() 方法</h3>
<p>源码如下：</p>
<pre><code>def run(): Unit = {
  //1.向 nioSelector 注册 serverChannel 并监控serverChannel上的OP_ACCEPT 事件，等待客户端的请求
  serverChannel.register(nioSelector, SelectionKey.OP_ACCEPT)
  //2.标识Acceptor 线程启动完成，并唤醒阻塞的线程。
  startupComplete()
  try {
    // 3.当前使用的Processor序号，从0开始，最大值是num.network.threads - 1
    var currentProcessorIndex = 0
    while (isRunning) {
      try {
        // 4.每500毫秒获取一次就绪I/O事件
        val ready = nioSelector.select(500)
        if (ready > 0) {
          //5.获取所有监听到的注册的key
          val keys = nioSelector.selectedKeys()
          val iter = keys.iterator()
          while (iter.hasNext &#x26;&#x26; isRunning) {
            try {
              val key = iter.next
              iter.remove()
              // 6.只监控Accept事件。
              if (key.isAcceptable) {
                //调用accept方法创建Socket连接
                //轮询处理socketChannel
                accept(key).foreach { socketChannel =>
                  
                  var retriesLeft = synchronized(processors.length)
                  var processor: Processor = null
                  do {
                    retriesLeft -= 1
                    // 7.轮询选择哪个 Processor线程进行处理，目的是负载均衡
                    processor = synchronized {
                      currentProcessorIndex = currentProcessorIndex % processors.length
                      //取出对应的processor
                      processors(currentProcessorIndex)
                    }
                    // 8.更新Processor线程序号,这样下次就能用下一个Processor了。
                    currentProcessorIndex += 1
                    //9.Acceptor线程把建立好的socketChannel交给对应选出的processor
                  } while (!assignNewConnection(socketChannel, processor, retriesLeft == 0))
                }
                //因为只注册了OP_ACCEPT事件，如果是别的事件就应该抛出异常。
              } else
                throw new IllegalStateException("Unrecognized key state for acceptor thread.")
            } catch {
              case e: Throwable => error("Error while accepting connection", e)
            }
          }
        }
      }
      catch {
        case e: ControlThrowable => throw e
        case e: Throwable => error("Error occurred", e)
      }
    }
  } finally {
    // 执行各种资源关闭逻辑
    debug("Closing server socket and selector.")
    //关闭连接
    CoreUtils.swallow(serverChannel.close(), this, Level.ERROR)
    //关闭连接对应的Selector
    CoreUtils.swallow(nioSelector.close(), this, Level.ERROR)
    //标识关闭完成，并唤醒对应的执行关闭的被阻塞的线程
    shutdownComplete()
  }
}
</code></pre>
<p>给你介绍下这个执行步骤。</p>
<p>第一步，serverChannel向nioSelector注册，并监控serverChannel上的OP_ACCEPT 事件，等待客户端的请求。</p>
<p>第二步，标识Acceptor 线程启动完成，并唤醒阻塞的线程。因为线程的启动是在别的类里，当启动后并不知道是否启动成功所以会阻塞，而是否能启动成功的判断在这一步，这样到这步就应该给解除线程的阻塞了。</p>
<p>第三步，进入while(true)轮询代码，标识当前轮询到的Processor线程的序号。</p>
<p>第四步，调用Selector的select()方法，监听是否有网络连接事件。每500毫秒轮询一次。收到监听事件后把key拿出来，然后判断是否是Accept事件，只有Accept事件才会处理。</p>
<p>第五步，获取所有监听到的注册的key。</p>
<p>第六步，判断是否是Accept事件，因为Acceptor线程类只处理Accept事件。如果是Accept事件就调用accept()方法，建立连接并开始轮询处理socketChannel。</p>
<p>第七步，从Acceptor类字段processors集合轮询选择出一个Processor线程。这样能够把任务平均分配到processors集合内Processor线程里。这样能确保某个Processor线程的负担不至于很重。</p>
<p>第八步，当前Processor索引加一。这样下次分配的Processor线程就是processors集合的下一个Processor线程。</p>
<p>第九步，把新创建的socketChannel分配给选到的Processor线程。</p>
<p>这个过程有点复杂，我下面画了个流程图帮助你理解：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0015ecc4e5ef456e9480afaf7d539abb~tplv-k3u1fbpfcp-watermark.image?" alt="2F11F0E6-7E6E-4828-9930-3735007F9B6F.png"></p>
<p>好，Acceptor线程类基本就介绍完了，接下来我们介绍Processor线程类。</p>
<h2>Processor线程类</h2>
<p>Acceptor线程类负责创建连接并把代表连接的socketChannel交给Processor线程类处理。Processor线程类得到socketChannel后，会处理这个socketChannel上的网络读写请求。</p>
<h3>重要字段</h3>
<p>接下来我们先学习一下重要的字段。源码如下：</p>
<pre><code>private[kafka] class Processor(val id: Int,
                               time: Time,
                               maxRequestSize: Int,
                               requestChannel: RequestChannel,
                               connectionQuotas: ConnectionQuotas,
                               connectionsMaxIdleMs: Long,
                               failedAuthenticationDelayMs: Int,
                               listenerName: ListenerName,
                               securityProtocol: SecurityProtocol,
                               config: KafkaConfig,
                               metrics: Metrics,
                               credentialProvider: CredentialProvider,
                               memoryPool: MemoryPool,
                               logContext: LogContext,
                               connectionQueueSize: Int = ConnectionQueueSize) extends AbstractServerThread(connectionQuotas) with KafkaMetricsGroup {

  //每个Processor线程都有自己的SocketChannel队列，用来保存连接的信息
  //当Acceptor线程接收新的连接请求时，会把连接放入Processor线程对应的SocketChannel队列中。
  private val newConnections = new ArrayBlockingQueue[SocketChannel](connectionQueueSize)
  //inflightResponses里的集合元数是：返回给客户端途中的响应。
  private val inflightResponses = mutable.Map[String, RequestChannel.Response]()
  //Response队列
  private val responseQueue = new LinkedBlockingDeque[RequestChannel.Response]()
//注意这里创建的是KSelector
private val selector = createSelector(
  ChannelBuilders.serverChannelBuilder(listenerName,
    listenerName == config.interBrokerListenerName,
    securityProtocol,
    config,
    credentialProvider.credentialCache,
    credentialProvider.tokenCache,
    time,
    logContext))
</code></pre>
<ul>
<li><code>newConnections</code>：类型为<code>ArrayBlockingQueue[SocketChannel]</code>的队列，保存的元素是SocketChannel，Acceptor创建SocketChannel后把SocketChannel放到这个集合里。</li>
<li><code>inflightResponses</code>：类型为<code>mutable.Map[String, RequestChannel.Response]</code>的map集合，这是个临时 Response 集合。里面保存是每个连接对应的返回给客户端途中的响应。有些 Response 回调逻辑要在 Response 被发送回发送方之后，才能执行，比如：response成功发送后要执行的回调逻辑，因此需要暂存在一个临时队列里面。这就是 inflightResponses 存在的意义。</li>
<li><code>responseQueue</code>：Response队列，Response队列里面保存着要返回给客户端的响应。</li>
<li><code>selector</code>：用作监听网络事件的KSelector类对象，KSelector类是kafka基于nio 的Selector封装的类，讲解生产者的时候就已经讲解过了，这里就不再展开讨论。</li>
</ul>
<p>讲完重要的字段后，接下来我们继续讲解这个类里重要的方法。Processor线程类的方法比较多，因为这个类是真正处理网络读写的类，我会给你一个个讲解。</p>
<h3>accept()方法</h3>
<p>这个方法是由Acceptor类调用的，用于把新建的socketChannel分配给Processor线程类。方法的源码如下：</p>
<pre><code>/**  * 把 socketChannel 加入 newConnections 集合里，等待Processor线程的处理  */ 
def accept(socketChannel: SocketChannel,mayBlock: Boolean,
    acceptorIdlePercentMeter: com.yammer.metrics.core.Meter): Boolean = {
val accepted = {     
if (newConnections.offer(socketChannel))
    true     
else if (mayBlock) { 
    val startNs = time.nanoseconds
    newConnections.put(socketChannel)
    acceptorIdlePercentMeter.mark(time.nanoseconds() - startNs)
    true     
} else       
    false   
}   
if (accepted)     
    wakeup()   
accepted 
}
</code></pre>
<p>这个方法其实很简单，就是把socketChannel放入Processor类字段newConnections集合里。也就是说Processor线程类并没有直接处理socketChannel，而是Acceptor类把socketChannel先存放在newConnections集合里，等待Processor线程类处理。</p>
<p>好，接下来我们看看Processor线程类是如何处理newConnections集合里的socketChannel的。</p>
<h3>方法 configureNewConnections()</h3>
<p>源码在下面，我给你一步步讲解下：</p>
<pre><code>/**
 * 注册在队列里的新连接。每次迭代处理连接的数量是被限制的，目的是保证已存在的连接通信顺畅。
 */
private def configureNewConnections(): Unit = {
  var connectionsProcessed = 0// 当前已配置的连接数计数器
  //一次迭代要处理的连接要小于connectionQueueSize=20个，并且连接集合不能为空
  while (connectionsProcessed &#x3C; connectionQueueSize &#x26;&#x26; !newConnections.isEmpty) {
    val channel = newConnections.poll()// 从连接队列中取出SocketChannel
    try {
      debug(s"Processor $id listening to new connection from ${channel.socket.getRemoteSocketAddress}")
      // 用给定Channel注册到指定的Selector，并监听OP_READ事件
      // 底层就是调用Java NIO的SocketChannel.register(selector, SelectionKey.OP_READ)
      selector.register(connectionId(channel.socket), channel)
      connectionsProcessed += 1// 更新计数器
    } catch {
      case e: Throwable =>
        val remoteAddress = channel.socket.getRemoteSocketAddress
        close(listenerName, channel)
        processException(s"Processor $id closed connection from $remoteAddress", e)
    }
  }
}
</code></pre>
<p>第一步，首先代码会进入一个while循环，必须同时满足下面两个条件才能进入while循环。</p>
<ul>
<li>connectionsProcessed &#x3C; connectionQueueSize：connectionsProcessed是while循环内处理的连接数，connectionQueueSize是处理连接队列的长度，默认值是20。也就是说，方法configureNewConnections调用一次，只能处理20个连接。每次迭代处理连接的数量是被限制的，目的是保证已存在的连接通信通畅。</li>
<li>!newConnections.isEmpty: 连接队列集合newConnections不为空，没有新的连接就不会进入while循环。</li>
</ul>
<p>第二步，进入while循环后，从连接队列newConnections中取出一个SocketChannel。</p>
<p>第三步，把这个SocketChannel注册到Processor线程类的selector，并监听网络读事件。</p>
<p>第四步，connectionsProcessed += 1：更新计数器加一。</p>
<p>好，下面我们来看看给客户端的响应是如何发送的。相关方法有两个processNewResponses()和sendResponse()。</p>
<h3>方法 processNewResponses()</h3>
<p>首先我们看看processNewResponses()做了什么。下面是源码，并附加注释，我会分步骤给你讲解。</p>
<pre><code>private def processNewResponses(): Unit = {
  //声明一个response变量。
  var currentResponse: RequestChannel.Response = null
  //从响应队列中取出response
  while ({currentResponse = dequeueResponse(); currentResponse != null}) {
    // 获取 channel_id
    val channelId = currentResponse.request.context.connectionId
    try {
      currentResponse match {
          //不需要给客户端响应的Response类型,无需做太多的操作。
          //acks=0
        case response: NoOpResponse =>
          updateRequestMetrics(response)
          trace(s"Socket server received empty response to send, registering for read: $response")
          handleChannelMuteEvent(channelId, ChannelMuteEvent.RESPONSE_SENT)
          // 没有响应需要发送给客户端，需要读取更多的请求，于是，channel 再次绑定OP_READ事件。
          tryUnmuteChannel(channelId)
        // 真正的发送Response，并将Response放入inflightResponses用于发送响应成功或响应失败后执行回调逻辑。
        case response: SendResponse =>
          sendResponse(response, response.responseSend)
        case response: CloseConnectionResponse =>
          updateRequestMetrics(response)
          trace("Closing socket connection actively according to the response code.")
          close(channelId)
        case _: StartThrottlingResponse =>
          handleChannelMuteEvent(channelId, ChannelMuteEvent.THROTTLE_STARTED)
        case _: EndThrottlingResponse =>
          handleChannelMuteEvent(channelId, ChannelMuteEvent.THROTTLE_ENDED)
          tryUnmuteChannel(channelId)
        case _ =>
          throw new IllegalArgumentException(s"Unknown response type: ${currentResponse.getClass}")
      }
    } catch {
      case e: Throwable =>
        processChannelException(channelId, s"Exception while processing response for $channelId", e)
    }
  }
}
</code></pre>
<p>第一步，声明一个response变量，这个变量用来保存要发送的response对象。从响应队列中取出。然后从响应队列里取出一个response，响应队列是阻塞的队列里没有响应对象就一直会阻塞在这里。</p>
<p>第二步，从队列中取出response后，判断response的类型，我们这里分析最重要也是出现最多的两种情况。</p>
<ul>
<li>NoOpResponse：表示不需要给客户端响应的Response类型。这种情况的原因一般是生产端设置了acks=0，acks=0表示无需服务端的响应。由于不需要把响应发给客户端，同时对应的SocketChannel要继续处理读事件。调用方法tryUnmuteChannel(channelId)，channel会再次绑定OP_READ事件。</li>
<li>SendResponse：表示客户端需要服务端的响应。这时会调用方法sendResponse()向客户端发送响应。</li>
</ul>
<h3>方法 sendResponse()</h3>
<p>接下来我们看看方法sendResponse()做了哪些事情。</p>
<p>这个方法主要是完成了发送响应的准备工作，并把response对象放入inFlightResponses集合中临时存放response对象。代码在下面，我会分步骤给你讲解。</p>
<pre><code>protected[network] def sendResponse(response: RequestChannel.Response, responseSend: Send): Unit = {
  //获取得到对应的channelId。
  val connectionId = response.request.context.connectionId
  trace(s"Socket server received response to send to $connectionId, registering for write and sending data: $response")
 
  //查找对应的kafkaChannel，判断是否为空
  if (channel(connectionId).isEmpty) {
    warn(s"Attempting to send response via channel for which there is no open connection, connection id $connectionId")
    response.request.updateRequestMetrics(0L, response)
  }
  
  // 连接是否可以用
  if (openOrClosingChannel(connectionId).isDefined) {
    //向客户端返回响应，本质是缓存在了对应的KafkaChannel里，将响应通过Selector先标记为Send,
    // 下次轮询时把响应发送给客户端。
    //并且selector会在SocketChannel上注册OP_WRITE事件等待写事件发生。
    selector.send(responseSend)
    //把响应放入inflightResponses map集合里。
    inflightResponses += (connectionId -> response)
  }
}
</code></pre>
<p>第一步，获取response对应连接的id，并查找对应的kafkaChannel，并判断是否为空。</p>
<p>第二步，判断连接是否可以，如果可用就调用selector.send(responseSend)方法去做发送响应的准备工作。</p>
<p>第三步，把channelid和返回的response放入map集合inflightResponses里。inflightResponses里的响应是指是要发送但还没确定发送成功过的响应。目的是，inflightResponses里的response有回调方法，根据响应发送的结果会调用回调方法。</p>
<p>好，发送响应的准备工作做完了，我们来看看响应是怎么发送客户端的。</p>
<h3>方法 poll()</h3>
<p><strong>poll()方法是真正做了发送response到客户端的工作</strong>。我们看下这个方法的代码：</p>
<pre><code>private def poll(): Unit = {
  val pollTimeout = if (newConnections.isEmpty) 300 else 0
  try selector.poll(pollTimeout)
  catch {
    case e @ (_: IllegalStateException | _: IOException) =>
      error(s"Processor $id poll failed", e)
  }
}
</code></pre>
<p>这个方法很简单就是调用selector.poll()方法，这个方法获取对应SocketChannel上准备就绪的I/O操作并执行对应操作的方法。对应已经发送消息成功的响应会把发送的响应放入集合completedSends里。</p>
<p>好，接下来我们看一下处理成功响应的方法processCompletedSends(）。</p>
<h3>方法 processCompletedSends(）</h3>
<p>这个方法的源码以及注释在下面：</p>
<pre><code>private def processCompletedSends(): Unit = {
  //遍历SocketChannel已经发送的Response。
  selector.completedSends.forEach { send =>
    try {
      //因为Response已经发送出去了，这时需要把表示正在处理的响应集合inflightResponses对应的响应删除
      val response = inflightResponses.remove(send.destination).getOrElse {
        throw new IllegalStateException(s"Send for ${send.destination} completed, but not in `inflightResponses`")
      }
      //更新统计指标
      updateRequestMetrics(response)
      // 调用发送完成的回调方法，服务端完成发送后也是要调用对应的回调方法的。
      response.onComplete.foreach(onComplete => onComplete(send))
      handleChannelMuteEvent(send.destination, ChannelMuteEvent.RESPONSE_SENT)
      //重新注册OP_READ，这样又可以监听客户端请求了。也就是说一个channel处理完了才会继续监听，不存在一个channel同时处理两个请求的情况。
      tryUnmuteChannel(send.destination)
    } catch {
      case e: Throwable => processChannelException(send.destination,
        s"Exception while processing completed send to ${send.destination}", e)
    }
  }
  selector.clearCompletedSends()
}
</code></pre>
<p>第一步，遍历SocketChannel已经发送成功的Response。已经发送成功的Response在KSelector的集合completedSends内。只要遍历这个集合就能够获得已经发送成功的Response。</p>
<p>第二步，删除并获取inflightResponses已经发送成功的response对象。已经发送成功的响应就不应该在临时响应集合里。</p>
<p>第三步，调用临时集合中的response对象的回调方法。（注意这里不是发送成功的response对象。）</p>
<p>第四步，重新注册这个channel的OP_READ事件。这样又可以监听客户端请求了。也就是说一个channel处理完了才会继续监听，不存在一个channel同时处理两个请求的情况。</p>
<p>好，如何处理发送成功的响应讲解完了，接下来我们来学习一下已经接收完成的请求是如何处理的，对应的方法是processCompletedReceives()。</p>
<h3>方法 processCompletedReceives()</h3>
<p>以下是该方法的源码和注释：
 </p>
<pre><code>private def processCompletedReceives(): Unit = {
  // 1.遍历所有已接收的Request
  selector.completedReceives.forEach { receive =>
    try {
      // 2.保证对应连接通道已经建立，同时获取KafkaChannel的id。
      openOrClosingChannel(receive.source) match {
        case Some(channel) =>
          //获取header
          val header = parseRequestHeader(receive.payload)
          if (header.apiKey == ApiKeys.SASL_HANDSHAKE &#x26;&#x26; channel.maybeBeginServerReauthentication(receive,
            () => time.nanoseconds()))
            trace(s"Begin re-authentication: $channel")
          else {
            val nowNanos = time.nanoseconds()
            // 如果认证会话已过期，则关闭连接
            if (channel.serverAuthenticationSessionExpired(nowNanos)) {
              debug(s"Disconnecting expired channel: $channel : $header")
              close(channel.id)
              expiredConnectionsKilledCount.record(null, 1, 0)
            } else {
              //获取连接id
              val connectionId = receive.source
              val context = new RequestContext(header, connectionId, channel.socketAddress,
                channel.principal, listenerName, securityProtocol,
                channel.channelMetadataRegistry.clientInformation)
              //3.构建 request 对象：包括按协议解析请求，解析成一个request对象,包括processorId,
              //header,body等字段，供Handler使用
              val req = new RequestChannel.Request(processor = id, context = context,
                startTimeNanos = nowNanos, memoryPool, receive.payload, requestChannel.metrics)

              if (header.apiKey == ApiKeys.API_VERSIONS) {
                val apiVersionsRequest = req.body[ApiVersionsRequest]
                if (apiVersionsRequest.isValid) {
                  channel.channelMetadataRegistry.registerClientInformation(new ClientInformation(
                    apiVersionsRequest.data.clientSoftwareName,
                    apiVersionsRequest.data.clientSoftwareVersion))
                }
              }
              // 4.核心代码：将Request添加到requestQueue队列中，等待处理
              requestChannel.sendRequest(req)
              //把op_read事件移除掉：已经把这个channel上的 read事件处理了并缓存了request,就要把read事件抹除。
              //下一轮再去注册这个事件,目的是什么呢？

              /*
                为什么 Processor.run（）方法内会有多处注册/取消OP_READ事件和OP_Write事件？
                因为当Processor把请求放入RequestChannel.requestQueue队列后会有多个的Hander线程去消费，
                为了保证顺序性用多处注册/取消OP_READ事件和OP_Write事件保证这一个时间只有一个请求被处理，知道这个请求处理了
                才会处理下一个。保证了请求的顺序性。

               */
              selector.mute(connectionId)
              handleChannelMuteEvent(connectionId, ChannelMuteEvent.REQUEST_RECEIVED)
            }
          }
        case None =>
          throw new IllegalStateException(s"Channel ${receive.source} removed from selector before processing completed receive")
      }
    } catch {
      case e: Throwable =>
        processChannelException(receive.source, s"Exception while processing request from ${receive.source}", e)
    }
  }
  selector.clearCompletedReceives()
}
</code></pre>
<p>第一步，遍历SocketChannel已经接收成功的Request对象。已经接收成功的Request在KSelector的集合completedReceives内。只要遍历这个集合就能够获得已经发送成功的Request对象。</p>
<p>第二步，判断对应连接通道是否已经建立，同时获取KafkaChannel的id。</p>
<p>第三步，构建 request 对象，包括按协议解析请求，解析成一个request对象，包括processorId、header、body等字段，供Handler使用。</p>
<p>第四步，将Request添加到requestQueue队列中，等待处理。Processor接收到Request对象后，并没有进一步处理而是通过调用requestChannel.sendRequest(req)方法把Request对象放入requestChannel对象里的requestQueue队列里等待业务线程处理。（RequestChannel和业务线程相关学习会在下节给你介绍。）</p>
<p>第五步，调用selector.mute(connectionId)把连接上的op_read事件移除掉。这时已经把这个channel上的 read事件处理了并缓存了request，同时再把连接上的op_read事件移除掉就不会有新的请求读进来，这样业务线程池可以先处理这里连接的请求，而不用担心有两个请求同时处理造成顺序不一致。</p>
<p>我再进一步给你解释一下为什么要这么设计。因为当Processor把请求放入RequestChannel.requestQueue队列后会有多个的Hander线程去消费，为了保证顺序性，就用多处注册/取消OP_READ事件和OP_Write事件保证这一个时间只有一个请求被处理，知道这个请求处理了才会处理下一个。</p>
<p>好，Processor类的主要方法介绍完了，现在我们看看作为线程类，run()方法都做了些什么事情。</p>
<h3>方法run()</h3>
<p>run()方法是一个while(true)的循环，里面执行的内容基本是我上面讲解的方法。源码和注释在下面，我给你一步步讲解一下这个代码过程。</p>
<pre><code>override def run(): Unit = {
  // 标识Processor线程启动完成
  startupComplete()
  try {
    while (isRunning) {
      try {
        // 1.遍历SocketChannel集合
        configureNewConnections()
        //2.注册写事件，用于发送响应给客户端,同时把要发送的response放入inflightResponses这个临时队列里。
        processNewResponses()
        poll()// 真正的发送response到客户端。执行NIO poll()方法，获取对应SocketChannel上准备就绪的I/O操作
        processCompletedReceives()// 处理KSelector.completedReceives队列，处理成功接收到的请求。将Request放入RequestQueue队列
        processCompletedSends()// 处理KSelector.completedSends队列，处理成功发送的响应。对每个Response执行回调逻辑
        processDisconnected()// 处理KSelector.disconnected队列，处理发送失败而导致断开的连接。
        closeExcessConnections()// 关闭超过配额限制部分的连接
      } catch {
        case e: Throwable => processException("Processor got uncaught exception.", e)
      }
    }
  } finally {// 关闭底层资源
    debug(s"Closing selector - processor $id")
    CoreUtils.swallow(closeAll(), this, Level.ERROR)
    shutdownComplete()
  }
}
</code></pre>
<p>第一步，标识Processor线程启动。</p>
<p>第二步，调用方法configureNewConnections()。遍历SocketChannel集合，SocketChannel注册到selector上,然后Selector监听SocketChannel上的OP_READ事件。</p>
<p>第三步，调用方法processNewResponses()。从响应队列里拿出一个response。根据response的类型，做响应的处理。如果response需要发送给客户端，做好发送Response前的准备，并将Response放入到inflightResponses临时队列。</p>
<p>第四步，调用方法poll()：这是真正接收请求和发送响应的方法。执行NIO poll()方法，获取对应SocketChannel上准备就绪的I/O操作并执行对应的处理方法。</p>
<p>第五步，调用方法processCompletedReceives()：处理收到的请求。具体是轮询KSelector.completedReceives队列，处理成功接收到的请求。将Request放入RequestQueue队列。</p>
<p>第六步，调用processCompletedSends()方法：处理KSelector.completedSends队列。目的是处理成功发送的响应。对每个Response执行回调逻辑。</p>
<p>第七步，调用processDisconnected()方法：从KSelector.disconnected队列获取发送失败而导致断开的连接，然后处理这些连接。</p>
<p>第八步，调用closeExcessConnections()方法。关闭超过配额限制部分的连接。</p>
<p>下面我画了张流程图，简单描述一下run()方法执行流程。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a3b48fb84264f12985b61e05f8af76b~tplv-k3u1fbpfcp-watermark.image?" alt="5CF9F2C6-1E61-4F1F-95DC-4685D6585C32.png"></p>
<p>好了，Accept类和Processor类都介绍完了，两者之间的关系我用下面的一张图来简单展示一下，你也可以对照着图回顾下今天的课程。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00e65a3c67964a17bf9a8aaaa1700f1f~tplv-k3u1fbpfcp-watermark.image?" alt="ABD1BEDC-7F82-4FC2-817D-9C11E31E0910.png"></p>
<h2>总结</h2>
<p>这节我们主要讨论了Acceptor类和Processor类。</p>
<p>首先这两个类都是线程类，<strong>都是通过run()方法启动的</strong>。</p>
<p>Acceptor类主要负责接收外部的连接请求并建立连接，把建立好的连接交给processor类处理。Processor类主要负责连接中发生的读写事件。run()方法是这两个类的启动方法，Acceptor类的run()方法负责创建连接并把连接给Processor类，注意并不是直接把连接给Processor类处理，而是把连接放入Processor类的一个连接集合里。Processor类的run()方法从连接集合里获取连接，并处理连接发送的读写操作。</p>
<p>Processor类只负责网络读写，那么具体的业务执行是谁做了呢？下一节我将给你详细分析和讲解。</p></div>
</body></html>