<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Message 的家是什么样？：文件存储介绍和日志分段管理</h1>
<p>在上节课中，我已经给你介绍了日志分段和日志索引的相关内容。其实，broker端的文件主要以日志分段文件和日志索引文件为主，当然还有其他一些辅助用的文件，但消息数据相关的文件就这两个。那么日志分段和日志索引是如何管理的呢？这就是上层Log和日志管理的工作了，这一节我们先学习Log。</p>
<p>在broker端，Log是指存放日志分段、日志索引及其他辅助文件的文件夹，而对于同一个broker服务端而言会有多个文件夹来保存数据。这样做的目的是<strong>提升读写吞吐，同时如果一个磁盘挂了，另一个磁盘还能工作，这样能提升可用性</strong>。</p>
<h2>Kafka Broker 文件路径和文件概览</h2>
<p>我们先看看Broker端的文件路径和文件是如何组织的，看下图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b09c540309df4718a9992f405f405e80~tplv-k3u1fbpfcp-watermark.image?" alt="broker存储文件与路径 (1).png"></p>
<p>可以看到第一层是某一台 <strong>Kafka Broker 服务器</strong>，在它下面可以配置多个 <strong>Log 文件夹</strong>来存储日志文件，如<code>logdir1:/kafka/log0</code>和<code>logdir2: /kafka/log1</code>，这是第二层。logdir1和logdir2分开工作互不影响，每个Log文件夹下又有多个<strong>分区文件夹</strong>，如<code>Partition0:/kafka/log0/testA-0</code>和<code>Partition1:/kafka/log0/testA-1</code>，这是第三层。接下来第四层，也就是最后一层保存的才是<strong>文件</strong>，包括log文件、index文件及其他辅助管理的文件。</p>
<p>前面几节课我们学习了日志分段、日志文件、日志索引，这节课我们学习第三层Log。这一层主要功能是<strong>管理分段日志文件，以及对外提供日志读写功能</strong>。</p>
<p>因为这节课会涉及高水位和LEO的知识，所以这里我需要先介绍下这两个概念。</p>
<ul>
<li><strong>LEO</strong>：log end offset。在分区尾部为下一个日志分配的偏移量，也就是说LEO这个偏移量还没有日志。</li>
<li><strong>HW</strong>：high watermark。消费者可见的最大偏移量，也就是说比high watermark大的偏移量消费者是不可见的。</li>
</ul>
<h2>Log 类</h2>
<p>这个类用来表示一个仅仅能追加的用来存储消息的日志。日志是一组日志分段文件，每个日志分段文件以分段文件内第一个消息的偏移量为基础偏移量，并以基础偏移量给日志分段文件命名。</p>
<h3>重要字段</h3>
<p>这里我们首先学习下这个类的重要字段。</p>
<ul>
<li>
<p>_dir：分区所在的磁盘目录。</p>
</li>
<li>
<p>logStartOffset：日志当前最早位移。当前最早位移的作用是：第一，为了删除文件，baseOffset小于logStartOffset的日志分段应该删除；第二，返回客户端最早的偏移量，避免了高水位的位移比日志当前最早位移还早。</p>
</li>
<li>
<p>recoveryPoint：恢复点。</p>
</li>
<li>
<p>lock：会有多个handler线程并发写入一个Log去追加消息，需要锁确保安全。</p>
</li>
<li>
<p>isMemoryMappedBufferClosed：索引文件的内存映射缓冲区是否关闭了。</p>
</li>
</ul>
<blockquote>
<p>那什么时候需要关闭呢？有以下两种情况会关闭：</p>
<p>1）当映射的文件删除了。这时就不需要文件的映射了，也就避免浪费缓存了。</p>
<p>2）关闭文件句柄。因为关闭文件句柄后就无法访问文件了，所以内存映射也就没有意义了。</p>
</blockquote>
<ul>
<li>
<p>nextOffsetMetadata：分配给下一条append消息的位移，也是当前副本的LEO。</p>
</li>
<li>
<p>highWatermarkMetadata：这个字段也是个类对象，包括几个字段，比如高水位的偏移量，高水位所在分段文件的基础偏移量，分段文件的偏移量数量，也就是消息数量。作用是追踪当前高水位，以保证包含高水位位移或高于高水位位移的segments不被删除。</p>
</li>
<li>
<p>segments：日志段的容器类型<code>ConcurrentNavigableMap[java.lang.Long, LogSegment]</code>，这个容器是线程安全而且是排序的，保证安全而且有利于查找相邻的日志段，是基于跳表实现的并发安全的集合。文件名为key，即baseOffset，LogSegment对象是value。目的就是根据offset快速定位到LogSegment。下图就形象地描述了segments的跳表结构同时体现了高效的查找效率。</p>
</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958f52e8639e4a1b8285a69aa3d3a729~tplv-k3u1fbpfcp-watermark.image?" alt="LogSegment的跳表结构.png"></p>
<p>如图所示，比如我们要找偏移量为1753的消息，会发生什么样的事情呢？先从level3中找到比1753小的logSegment集合里面最大的logSegment，于是找到了1450；然后再到level2中用同样的方式找到1750，同理最后到level1中找到对应的base offset为1750的LogSegemnt。然后再利用上两节课学习的索引文件和日志文件具体进行查找。</p>
<h3>重要方法</h3>
<p>Log 类方法比较多，我们先从静态代码块学习，<strong>所谓静态块就是 locally关键字里包含的代码内容</strong>。</p>
<pre><code class="hljs language-scss">
locally {

<span class="hljs-comment">// create the log directory if it doesn't exist</span>

<span class="hljs-comment">// 1. 如果对应的路径不存在就创建</span>

Files<span class="hljs-selector-class">.createDirectories</span>(dir.toPath)

<span class="hljs-comment">// 2. 初始化Leader Epoch缓存</span>

<span class="hljs-built_in">initializeLeaderEpochCache</span>()

<span class="hljs-comment">// 3. 加载所有日志段对象，并返回该Log对象下一条消息的位移值</span>

val nextOffset = <span class="hljs-built_in">loadSegments</span>()

<span class="hljs-comment">// 4. 初始化LEO元数据对象，LEO值为上一步获取的位移值，起始位移值是Active Segment的起始位移值，日志段大小是Active Segment的大小</span>

<span class="hljs-comment">/* Calculate the offset of the next message */</span>

nextOffsetMetadata = <span class="hljs-built_in">LogOffsetMetadata</span>(nextOffset, activeSegment.baseOffset, activeSegment.size)

<span class="hljs-comment">// 5.更新Leader Epoch缓存，去除LEO值之上的所有无效缓存项</span>

leaderEpochCache<span class="hljs-selector-class">.foreach</span>(_.truncateFromEnd(nextOffsetMetadata.messageOffset))

<span class="hljs-comment">//更新 Log Start Offset</span>

<span class="hljs-built_in">updateLogStartOffset</span>(math.max(logStartOffset, segments.firstEntry.getValue.baseOffset))

<span class="hljs-comment">// The earliest leader epoch may not be flushed during a hard failure. Recover it here.</span>

leaderEpochCache<span class="hljs-selector-class">.foreach</span>(_.truncateFromStart(logStartOffset))

<span class="hljs-comment">// Any segment loading or recovery code must not use producerStateManager, so that we can build the full state here</span>

<span class="hljs-comment">// from scratch.</span>

if (!producerStateManager.isEmpty)

throw new <span class="hljs-built_in">IllegalStateException</span>("Producer state must be empty during log initialization")

<span class="hljs-built_in">loadProducerState</span>(logEndOffset, reloadFromCleanShutdown = hasCleanShutdownFile)

}

</code></pre>
<p>第一步：创建Log对象对应的路径。以后所有的日志文件、日志索引文件及其他文件都会保存在这个路径里。</p>
<p>第二步：初始化Leader Epoch并缓存。Leader Epoch是用来保证副本间的一致性的，后面讲到副本管理的时候再跟大家细聊。</p>
<p>第三步：调用方法loadSegments()加载所有日志段对象，并返回该Log对象下一条消息的位移值。我们可以看一下这个方法是如何把logSegment加载进来的。</p>
<pre><code class="hljs language-scss">* 从磁盘文件上的日志文件加载log segment并返回下一个offset。

* 会对日志路径遍历两次。we find an unexpected number of <span class="hljs-selector-class">.log</span> files with <span class="hljs-attribute">overflow</span>

*/

private def <span class="hljs-built_in">loadSegments</span>(): Long = {

<span class="hljs-comment">// 1.第一次遍历：首先遍历日志目录下的文件，并删除所有临时文件(包括以".delete"和".cleaned" .cleaned 结尾的文件，)，还要找到所有中断的swap的操作。</span>

val swapFiles = <span class="hljs-built_in">removeTempFilesAndCollectSwapFiles</span>()

<span class="hljs-comment">// Now do a second pass and load all the log and index files.</span>

<span class="hljs-comment">// We might encounter legacy log segments with offset overflow (KAFKA-6264). We need to split such segments. When</span>

<span class="hljs-comment">// this happens, restart loading segment files from scratch.</span>

<span class="hljs-comment">// 2.加载全部的日志文件和索引文件。</span>

retryOnOffsetOverflow {

logSegments<span class="hljs-selector-class">.foreach</span>(_.close())

segments<span class="hljs-selector-class">.clear</span>()

<span class="hljs-built_in">loadSegmentFiles</span>()

}

<span class="hljs-comment">//3.完成恢复过程中发现的.swap结尾的文件，继续做以前没完成的工作</span>

<span class="hljs-built_in">completeSwapOperations</span>(swapFiles)

if (!dir.getAbsolutePath.endsWith(Log.DeleteDirSuffix)) {

val nextOffset = retryOnOffsetOverflow {

<span class="hljs-built_in">recoverLog</span>()

}

activeSegment<span class="hljs-selector-class">.resizeIndexes</span>(config.maxIndexSize)

nextOffset

} else {

<span class="hljs-comment">//如果日志目录下没有segment文件，就创建一个activeSegment，需要保证Log中至少有一个LogSegment。</span>

if (logSegments.isEmpty) {

<span class="hljs-built_in">addSegment</span>(LogSegment.open(dir = dir,

baseOffset = <span class="hljs-number">0</span>,

config,

time = time,

fileAlreadyExists = false,

initFileSize = this.initFileSize,

preallocate = false))

}

<span class="hljs-number">0</span>

}

}

</code></pre>
<p><strong>方法loadSegments()的功能是从磁盘文件上的日志文件加载log segment并返回下一个offset</strong>。首先对日志目录下的文件进行第一次遍历，并删除所有临时文件（包括以".delete"、".cleaned” 结尾的文件），还要找到收集所有以".swap"结尾的文件。所谓".cleaned"、".swap" 结尾的文件是日志压缩的过程中衍生出来的文件类型，".delete"是待删除的文件。然后加载全部的日志文件和索引文件。最后完成恢复过程中发现的以".swap"结尾的文件，继续完成没有结束的工作。</p>
<p>第四步：初始化LEO元数据对象，LEO值为上一步获取的位移值，起始位移值是Active Segment的起始位移值，日志段大小是Active Segment的大小。所谓Active Segment是分区最后一个logSegment文件，也是当前日志追加的文件。</p>
<p>第五步：更新Leader Epoch缓存，去除LEO值之上的所有无效缓存项。</p>
<p>第六步：更新Log Start Offset。Log Start Offset在上面已经讲过了，现在讨论下Log Start Offset的更新时机。</p>
<ul>
<li>
<p>Log 对象初始化时：和 LEO 类似，Log 对象初始化时要给 Log Start Offset 赋值，一般是将第一个日志段的起始位移值赋值给它。</p>
</li>
<li>
<p>日志截断时：同理，一旦日志中的部分消息被删除，可能会导致 Log Start Offset 发生变化，因此有必要更新该值。</p>
</li>
<li>
<p>Follower 副本同步时：一旦 Leader 副本的 Log 对象的 Log Start Offset 值发生变化。为了维持和 Leader 副本的一致性，Follower 副本也需要尝试去更新该值。</p>
</li>
<li>
<p>删除日志段时：这个和日志截断是类似的。凡是涉及消息删除的操作都有可能导致 Log Start Offset 值的变化。</p>
</li>
<li>
<p>删除消息时：严格来说，这个更新时机有点本末倒置了。在 Kafka 中，删除消息就是通过抬高 Log Start Offset 值来实现的，因此，删除消息时必须要更新该值。</p>
</li>
</ul>
<p>好，静态方法给你分析完了，接下来分析对象方法。对象方法比较多，主要有三类：</p>
<ol>
<li>segment文件管理相关方法；</li>
<li>log文件读写相关方法；</li>
<li>其他文件管理方法。</li>
</ol>
<p>我们首先讲解第一类，segment文件管理相关方法。在讲解logSegment文件管理相关方法前，我先介绍一下相关的机制。</p>
<h3>maybeRoll</h3>
<p>这个方法的功能是：<strong>如果需要的话，就滚动建立一个日志分段文件，无论是否新建文件都返回当前的segment</strong>。具体代码如下：</p>
<pre><code class="hljs language-scala">
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maybeRoll</span></span>(messagesSize: <span class="hljs-type">Int</span>, appendInfo: <span class="hljs-type">LogAppendInfo</span>): <span class="hljs-type">LogSegment</span> = {

<span class="hljs-comment">//1.活跃的Segment，也就是最后一个Segment。</span>

<span class="hljs-keyword">val</span> segment = activeSegment

<span class="hljs-keyword">val</span> now = time.milliseconds

<span class="hljs-keyword">val</span> maxTimestampInMessages = appendInfo.maxTimestamp

<span class="hljs-keyword">val</span> maxOffsetInMessages = appendInfo.lastOffset

<span class="hljs-comment">//2.是否需要新建一个LogSegment对象。</span>

<span class="hljs-keyword">if</span> (segment.shouldRoll(<span class="hljs-type">RollParams</span>(config, appendInfo, messagesSize, now))) {

debug(<span class="hljs-string">s"Rolling new log segment (log_size = <span class="hljs-subst">${segment.size}</span>/<span class="hljs-subst">${config.segmentSize}</span>}, "</span> +

<span class="hljs-string">s"offset_index_size = <span class="hljs-subst">${segment.offsetIndex.entries}</span>/<span class="hljs-subst">${segment.offsetIndex.maxEntries}</span>, "</span> +

<span class="hljs-string">s"time_index_size = <span class="hljs-subst">${segment.timeIndex.entries}</span>/<span class="hljs-subst">${segment.timeIndex.maxEntries}</span>, "</span> +

<span class="hljs-string">s"inactive_time_ms = <span class="hljs-subst">${segment.timeWaitedForRoll(now, maxTimestampInMessages)}</span>/<span class="hljs-subst">${config.segmentMs - segment.rollJitterMs}</span>)."</span>)

appendInfo.firstOffset <span class="hljs-keyword">match</span> {

<span class="hljs-comment">//3.新建LogSegment。</span>

<span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(firstOffset) => roll(<span class="hljs-type">Some</span>(firstOffset))

<span class="hljs-keyword">case</span> <span class="hljs-type">None</span> => roll(<span class="hljs-type">Some</span>(maxOffsetInMessages - <span class="hljs-type">Integer</span>.<span class="hljs-type">MAX_VALUE</span>))

}

} <span class="hljs-keyword">else</span> {

<span class="hljs-comment">//4.如果不用新建就用现在的日志分段文件。</span>

segment

}

}

</code></pre>
<p>第一步：取到当前活跃的Segment，也就是最后一个Segment。如果不需要新建segment，就放回当前的segment。</p>
<p>第二步：是否需要新建一个LogSegment对象。具体是怎么判断的呢？这就要看<code>shouldRoll()</code>的代码了：</p>
<pre><code class="hljs language-scss">
def <span class="hljs-built_in">shouldRoll</span>(rollParams: RollParams): Boolean = {

val reachedRollMs = <span class="hljs-built_in">timeWaitedForRoll</span>(rollParams.now, rollParams.maxTimestampInMessages) > rollParams<span class="hljs-selector-class">.maxSegmentMs</span> - rollJitterMs

<span class="hljs-comment">//1.如果加上现在消息的大小这个 segment 超过1个G，就需要新建一个segment。</span>

size > rollParams<span class="hljs-selector-class">.maxSegmentBytes</span> - rollParams<span class="hljs-selector-class">.messagesSize</span> ||

<span class="hljs-comment">//2.距离上次创建日志段的时间达到了一个阈值（log.roll.hours默认7天），并且日志段有数据。</span>

(size > <span class="hljs-number">0</span> &#x26;&#x26; reachedRollMs) ||

<span class="hljs-comment">//3.索引文件满了（默认10m）log.index.size.max.bytes。</span>

offsetIndex<span class="hljs-selector-class">.isFull</span> ||

<span class="hljs-comment">//4.时间索引文件满了（默认10m）。</span>

timeIndex<span class="hljs-selector-class">.isFull</span> ||

<span class="hljs-comment">//5.根据最大的offset</span>

!<span class="hljs-built_in">canConvertToRelativeOffset</span>(rollParams.maxOffsetInMessages)

}

</code></pre>
<p>这个方法是<code>判断是否要新建logSegment</code>。</p>
<ul>
<li>首先根据<code>大小</code>判断：如果加上现在消息的大小，这个 segment 超过1个G，就需要新建一个segment。</li>
<li>然后根据<code>时间</code>判断：距离上次创建日志段的时间达到了一个阈值（log.roll.hours默认7天），并且日志段有数据。</li>
<li>根据<code>偏移量索引文件大小</code>判断：偏移量索引文件到一定大小的时候也需要做分段，默认10m。</li>
<li>根据<code>时间索引文件大小</code>判断：时间索引文件到一定大小的时候也需要做分段，默认10m。</li>
<li>根据<code>最大的offset</code>。其相对偏移量超过了正整数的阈值，追加的消息的偏移量与当前日志段的偏移量之间的差值大于Integer.MAX_VALUE。因为相对偏移量是 4 个字节，对应int类型也是4个字节，这样再大就超出了，就不能满足了。</li>
</ul>
<p>第三步：如果满足条件就调用roll()方法新建LogSegment。接下来我们再看看<code>roll()</code>方法是如何新建日志分段文件的。</p>
<pre><code class="hljs language-scala">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">roll</span></span>(expectedNextOffset: <span class="hljs-type">Option</span>[<span class="hljs-type">Long</span>] = <span class="hljs-type">None</span>): <span class="hljs-type">LogSegment</span> = {

maybeHandleIOException(<span class="hljs-string">s"Error while rolling log segment for <span class="hljs-subst">$topicPartition</span> in dir <span class="hljs-subst">${dir.getParent}</span>"</span>) {

<span class="hljs-keyword">val</span> start = time.hiResClockMs()

lock synchronized {

checkIfMemoryMappedBufferClosed()

<span class="hljs-comment">//1.获取LEO值。</span>

<span class="hljs-keyword">val</span> newOffset = math.max(expectedNextOffset.getOrElse(<span class="hljs-number">0</span>L), logEndOffset)

<span class="hljs-comment">//2.基于LEO值生成日志分段文件。</span>

<span class="hljs-keyword">val</span> logFile = <span class="hljs-type">Log</span>.logFile(dir, newOffset)

<span class="hljs-comment">//3.判断是否存在。</span>

<span class="hljs-keyword">if</span> (segments.containsKey(newOffset)) {

<span class="hljs-comment">// segment with the same base offset already exists and loaded</span>

<span class="hljs-comment">//4.判断是否有相同base offset的segment已经加载进内存了。</span>

<span class="hljs-keyword">if</span> (activeSegment.baseOffset == newOffset &#x26;&#x26; activeSegment.size == <span class="hljs-number">0</span>) {

<span class="hljs-comment">// We have seen this happen (see KAFKA-6388) after shouldRoll() returns true for an</span>

<span class="hljs-comment">// active segment of size zero because of one of the indexes is "full" (due to _maxEntries == 0).</span>

warn(<span class="hljs-string">s"Trying to roll a new log segment with start offset <span class="hljs-subst">$newOffset</span> "</span> +

<span class="hljs-string">s"=max(provided offset = <span class="hljs-subst">$expectedNextOffset</span>, LEO = <span class="hljs-subst">$logEndOffset</span>) while it already "</span> +

<span class="hljs-string">s"exists and is active with size 0. Size of time index: <span class="hljs-subst">${activeSegment.timeIndex.entries}</span>,"</span> +

<span class="hljs-string">s" size of offset index: <span class="hljs-subst">${activeSegment.offsetIndex.entries}</span>."</span>)

<span class="hljs-comment">//存在就删除</span>

removeAndDeleteSegments(<span class="hljs-type">Seq</span>(activeSegment), asyncDelete = <span class="hljs-literal">true</span>, <span class="hljs-type">LogRoll</span>)

} <span class="hljs-keyword">else</span> {

<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">KafkaException</span>(<span class="hljs-string">s"Trying to roll a new log segment for topic partition <span class="hljs-subst">$topicPartition</span> with start offset <span class="hljs-subst">$newOffset</span>"</span> +

<span class="hljs-string">s" =max(provided offset = <span class="hljs-subst">$expectedNextOffset</span>, LEO = <span class="hljs-subst">$logEndOffset</span>) while it already exists. Existing "</span> +

<span class="hljs-string">s"segment is <span class="hljs-subst">${segments.get(newOffset)}</span>."</span>)

}

} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!segments.isEmpty &#x26;&#x26; newOffset &#x3C; activeSegment.baseOffset) {

<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">KafkaException</span>(

<span class="hljs-string">s"Trying to roll a new log segment for topic partition <span class="hljs-subst">$topicPartition</span> with "</span> +

<span class="hljs-string">s"start offset <span class="hljs-subst">$newOffset</span> =max(provided offset = <span class="hljs-subst">$expectedNextOffset</span>, LEO = <span class="hljs-subst">$logEndOffset</span>) lower than start offset of the active segment <span class="hljs-subst">$activeSegment</span>"</span>)

} <span class="hljs-keyword">else</span> {

<span class="hljs-comment">//5.基于LEO值生成一个日志索引文件</span>

<span class="hljs-keyword">val</span> offsetIdxFile = offsetIndexFile(dir, newOffset)

<span class="hljs-comment">//6.基于LEO值生成一个时间索引文件</span>

<span class="hljs-keyword">val</span> timeIdxFile = timeIndexFile(dir, newOffset)

<span class="hljs-keyword">val</span> txnIdxFile = transactionIndexFile(dir, newOffset)

<span class="hljs-keyword">for</span> (file &#x3C;- <span class="hljs-type">List</span>(logFile, offsetIdxFile, timeIdxFile, txnIdxFile) <span class="hljs-keyword">if</span> file.exists) {

warn(<span class="hljs-string">s"Newly rolled segment file <span class="hljs-subst">${file.getAbsolutePath}</span> already exists; deleting it first"</span>)

<span class="hljs-type">Files</span>.delete(file.toPath)

}

<span class="hljs-type">Option</span>(segments.lastEntry).foreach(_.getValue.onBecomeInactiveSegment())

}

producerStateManager.updateMapEndOffset(newOffset)

producerStateManager.takeSnapshot()

<span class="hljs-comment">//7.新建一个LogSegment对象并加入集合中</span>

<span class="hljs-keyword">val</span> segment = <span class="hljs-type">LogSegment</span>.open(dir,

baseOffset = newOffset,

config,

time = time,

fileAlreadyExists = <span class="hljs-literal">false</span>,

initFileSize = initFileSize,

preallocate = config.preallocate)

<span class="hljs-comment">//8.加入segment集合中。</span>

addSegment(segment)

<span class="hljs-comment">// 9.更新LEO。</span>

updateLogEndOffset(nextOffsetMetadata.messageOffset)

<span class="hljs-comment">//10.异步执行flush操作，从恢复点到最新的offset都需要flush。</span>

scheduler.schedule(<span class="hljs-string">"flush-log"</span>, () => flush(newOffset), delay = <span class="hljs-number">0</span>L)

info(<span class="hljs-string">s"Rolled new log segment at offset <span class="hljs-subst">$newOffset</span> in <span class="hljs-subst">${time.hiResClockMs() - start}</span> ms."</span>)

segment

}

}

}

</code></pre>
<p>这个方法的作用是<strong>滚动新建一个活跃的logSegment文件</strong>，logSegment文件以logEndOffset命名。</p>
<p>第一步：获取当前LEO值。</p>
<p>第二步：基于LEO值生成日志分段文件，新的分段文件都是以LEO这个偏移量来命名的。</p>
<p>第三步：判断这个文件是否存在。</p>
<p>第四步：判断是否有相同base offset的segment已经加载进内存了。如果内存存在就在segments集合和物理磁盘同时删除文件。</p>
<p>第五步：基于LEO值生成一个日志索引文件。除了日志文件之外，还要新建索引文件。</p>
<p>第六步：基于LEO值生成一个时间索引文件。</p>
<p>第七步：新建一个LogSegment对象。</p>
<p>第八步：LogSegment对象加入segment集合中。</p>
<p>第九步：更新LEO。</p>
<p>第十步：异步执行flush操作，从恢复点到最新的offset都需要flush。</p>
<p>下面用一个流程图来展示整个步骤：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3aef8dfc26a46f7b5d74facdc7de8d1~tplv-k3u1fbpfcp-watermark.image?" alt="新建logSegment流程图.png"></p>
<h2>总结</h2>
<p>这节课我们学习了Kafka Broker的文件路径，同时给你大体介绍了Log类的功能和字段。然后着重分析了logSegment的内存组织方式、跳表结构是如何提升查询效率的。最后还讲解了Log类是如何管理logSegment的，下节课我们继续学习Log类的其他方法。</p></div>
</body></html>