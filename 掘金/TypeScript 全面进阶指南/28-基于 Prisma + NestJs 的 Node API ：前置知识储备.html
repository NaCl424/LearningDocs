<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>基于 Prisma + NestJs 的 Node API ：前置知识储备</h1>
<p>在这一节，我们会使用 TypeScript 来开发一个 Node API，并将它部署在服务器上。技术选型方面，我们使用 <a href="https://docs.nestjs.com/" target="_blank" rel="nofollow noopener noreferrer">NestJs</a> 作为框架，<a href="https://www.prisma.io/" target="_blank" rel="nofollow noopener noreferrer">Prisma</a> 作为 ORM，<a href="https://dashboard.heroku.com/apps" target="_blank" rel="nofollow noopener noreferrer">Heroku</a> 作为部署平台与数据库提供商。</p>
<p>需要说明的是，我们要开发的 API 并不会十分完善。一方面，过多的 CRUD 代码并没有教学意义。另一方面，如果要完整开发一个生产可用的 API ，可能还需要再写一本小册才行。</p>
<p>那你可能会问，上面说的工具我都不了解怎么办呀？比较友好的一点是，你不需要对这几个工具非常了解，因为我们会分别介绍相应的前置知识。更加友好的是，你也不需要有自己的服务器与数据库，Heroku 已经帮我们准备好了。</p>
<p>但你仍然需要有基本的 NodeJs 使用经验，至少使用 Express / Koa 进行过基本的 API 开发，以及了解数据库、ORM 的基本知识。</p>
<blockquote>
<p>本节代码见：<a href="https://github.com/linbudu599/tiny-book-blog-api" target="_blank" rel="nofollow noopener noreferrer">Blog API</a></p>
</blockquote>
<h2>Heroku 环境配置</h2>
<p>在正式开始前，我们不妨提前配置好 Heroku 的环境，因为这一步耗时比较久，我们可以让它在一边安装，先开始下面的学习。</p>
<p>在终端运行以下命令：</p>
<pre><code class="hljs language-bash"><span class="hljs-comment"># 适用于 Mac，需要安装 HomeBrew</span>
brew tap heroku/brew &#x26;&#x26; brew install heroku
<span class="hljs-comment"># 或者使用这个命令</span>
curl https://cli-assets.heroku.com/install.sh | sh
</code></pre>
<blockquote>
<p>关于其他安装方式，参考 <a href="https://devcenter.heroku.com/articles/heroku-cli" target="_blank" rel="nofollow noopener noreferrer">Heroku CLI</a> 。</p>
</blockquote>
<h2>NestJS 基础</h2>
<p>接下来，我们来了解 NestJs 的基础概念。</p>
<p>NestJs 是一个 NodeJs 框架，它和 Express、Koa、Egg 的主要区别其实就两点，<strong>应用风格</strong>与<strong>框架能力</strong>。</p>
<p>我们先来说应用风格。NestJs 中大量地使用了装饰器以及依赖注入（IoC &#x26; DI）相关的理念，这一点官方团队自谦是受到了 Angular 的启发。而这也就意味着，在开发规模较大的项目时，Nest 也能够很好地保持项目间各个模块的引用关系清晰解耦，而 Express、Koa 其实随着项目规模的不断扩大，会需要开发者更有意识去进行依赖关系的维护。</p>
<p>而框架能力其实也是许多团队与企业在技术选型时的重要参考因素。在这一点上，就像 Angular 内置了路由、请求、表单、校验、SSR 等能力，是一个真正意义上的“全家桶”。Nest 也是如此，官方团队基本上已经把 95% 以上的能力都提供完毕，包括 ORM 的集成（<code>@nestjs/mongoose</code>, <code>@nestjs/typeorm</code>）、消息队列（<code>@nestjs/bull</code>）、Open API（<code>@nestjs/swagger</code>）、鉴权（<code>@nestjs/passport</code>）、GraphQL  （<code>@nestjs/graphql</code>, <code>@nestjs/apollo</code> ）等等。在大部分情况下，这些能力以及附带的详细文档就能很好地满足你的需求。</p>
<p>当然，没有事物是十全十美的。我个人认为 Nest 不友好的地方在于，新手可能需要一些时间才能理解其模块作用域与依赖各种关系，imports、provides、providers、exports 等概念确实不是很好理解。</p>
<p>既然说基础了，那我们还是要介绍一下基本使用代码，这段代码我们在装饰器一节中已经很熟悉了：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-meta">@Controller</span>(<span class="hljs-string">'cats'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CatsController</span> {
  <span class="hljs-meta">@Get</span>()
  <span class="hljs-title function_">findAll</span>(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action returns all cats'</span>;
  }
}
</code></pre>
<p>本质上 Nest 也就是一个 Node API 框架，因此完全没必要在初次接触时就做深入了解，等我们用到的时候再学，才不会被劝退。</p>
<p>我们先新建好项目：</p>
<pre><code class="hljs language-bash">npm i @nestjs/cli -g
nest new &#x3C;application>
</code></pre>
<p>初始的目录结构是这样的：</p>
<pre><code class="hljs language-text">project
├── src
├──── app.controller.ts
├──── app.module.ts
├──── app.service.ts
├──── main.ts
├── package.json
├── nest-cli.json
└── tsconfig.json
</code></pre>
<p>我们来简单介绍一下重要文件的功能，更好地了解 NestJs 的开发风格。</p>
<ul>
<li>
<p><code>app.controller.ts</code>，即 API 路由的定义文件，我们在这里去定义 <code>GET /user/list</code> <code>POST /user/add</code> 这样的请求处理逻辑。需要注意的是，在 Nest 应用中我们一般不会在 Controller 中去处理业务逻辑，Controller 通常只会处理请求入参的校验、请求响应的包装，具体的业务逻辑来自于 <code>app.service.ts</code>。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.service'</span>;

<span class="hljs-meta">@Controller</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppController</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> appService: AppService</span>) {}

  <span class="hljs-meta">@Get</span>()
  <span class="hljs-title function_">getHello</span>(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">appService</span>.<span class="hljs-title function_">getHello</span>();
  }
}
</code></pre>
</li>
<li>
<p><code>app.service.ts</code>，我们在 Service 层去处理数据库交互、BFF、日志等等的逻辑，然后供 Controller 层来调用。这并不意味着 Controller 中有一个 UpdateUser 处理方法，那么 Service 层中也要有专门的 UpdateUser 方法。更好的方式是将 Service 拆得更细一些，如 UpdateUser 需要依次调用 QueryUser （检查当前用户是否存在）、CheckUserMutationAvaliable （当前用户是否被允许进行信息更新）、UpdateUser （更新用户）、NoticeUserFollowerUpdate （提醒用户的粉丝发生了资料更新）等等数个细粒度的 Service 。这样一来，在未来新增 Controller 时，你只需要重新按照逻辑组装 Service 即可，而不需要再完全重写一个功能大半相似的。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppService</span> {
  <span class="hljs-title function_">getHello</span>(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello World!'</span>;
  }
}
</code></pre>
</li>
<li>
<p><code>app.module.ts</code>，这一文件是应用的核心文件，我们需要这一模块才能在 <code>main.ts</code> 中去启动应用。在实际开发中，可能会有多个 <code>.module.ts</code> 文件来实现对业务逻辑的模块拆分，如 <code>user.module.ts</code>、<code>upload.module.ts</code> 等。同时，在这个文件内我们会定义属于这一模块的 Controller 与 Service ，别的模块可以通过导入这个模块来使用内部的 Service ，而不是直接导入 Service 造成模块间的混乱引用。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppController</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.controller'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.service'</span>;

<span class="hljs-meta">@Module</span>({
  <span class="hljs-attr">imports</span>: [],
  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">AppController</span>],
  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">AppService</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> {}
</code></pre>
</li>
<li>
<p><code>main.ts</code>，最终启动的入口文件，在这里我们定义全局级别的应用配置。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NestFactory</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> chalk <span class="hljs-keyword">from</span> <span class="hljs-string">'chalk'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AppModule</span>);
  <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
}
<span class="hljs-title function_">bootstrap</span>();
</code></pre>
</li>
</ul>
<p>项目中文件的基本功能就介绍到这里，在扩展阅读部分，我们还会介绍 NestJs 应用中两种不同的目录结构组织方式，如果你感兴趣可以去读一下。接下来，我们来了解本节应用中的另一个重要部分：Prisma ORM。</p>
<h2>Prisma 基础</h2>
<p><a href="https://www.prisma.io/" target="_blank" rel="nofollow noopener noreferrer">Prisma</a> 是一个“比较特殊”的 ORM，为什么这么说呢？我们知道，ORM 库（Object-Relational Mapping），其实就是编程语言到 SQL 的映射，也就是说，我们无需学习 SQL 的使用，直接用最熟悉的代码调用方法，即可与数据库进行交互。</p>
<p>而 NodeJs 中的 ORM 目前基本都是通过 js / ts 文件进行定义的，比如 <a href="https://github.com/sequelize/sequelize" target="_blank" rel="nofollow noopener noreferrer">Sequelize</a>、<a href="https://github.com/typeorm/typeorm" target="_blank" rel="nofollow noopener noreferrer">TypeORM</a> 等，均是通过面向对象的方式进行数据库实体的定义：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Entity</span>, <span class="hljs-title class_">PrimaryGeneratedColumn</span>, <span class="hljs-title class_">Column</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"typeorm"</span>;

<span class="hljs-meta">@Entity</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-meta">@PrimaryGeneratedColumn</span>()
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;

  <span class="hljs-meta">@Column</span>()
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Column</span>()
  <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Column</span>()
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
}
</code></pre>
<p>这就是 Prisma 最特殊的一点，它使用自己的 SDL（Schema Define Language，也可以说是 DSL ，Domain-Specified Language）来声明一个实体：</p>
<pre><code class="hljs language-text">// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  // output   = "./client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Article {
  id          Int     @id @default(autoincrement())
  title       String?
  description String  @default("这篇文章还没有介绍...")
  content     String
}
</code></pre>
<p>如在上面的例子中，我们在 <code>schema.prisma</code> 中使用 Prisma 自己定义的语法来进行描述，可以在 VS Code 中安装扩展来获得语法高亮：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b56cff57141f44c49b0143a7dee88043~tplv-k3u1fbpfcp-zoom-1.image" alt="imaged37616c085b20456.png"></p>
<p>而不论是用编程语言还是 SDL 来描述数据库实体，都需要有转换到 SQL 的这一步。在传统 ORM 中这一步实时进行，在你调用 <code>user.find()</code> 时动态地进行转换。而在 Prisma 中，这一步则要特殊一些。</p>
<p>我们在实践中熟悉，首先在项目内初始化 prisma：</p>
<pre><code class="hljs language-bash">npx prisma init
</code></pre>
<p>它会为你创建 <code>prisma/schema.prisma</code>、<code>.env</code> 文件，我们还需要安装对应的依赖：</p>
<pre><code class="hljs language-bash">npm i prisma -g
npm i @prisma/client --save-dev
</code></pre>
<p>在这里，prisma 是 Prisma CLI，而 <code>@prisma/client</code> 则是其运行时所需的依赖。</p>
<p>在 <code>.env</code> 文件中定义了我们的数据库地址，Prisma 支持基本上所有的主流数据库。后面我们会使用免费的 Heroku 数据库，现在保持不动即可。</p>
<p>我们先将最终的 Schema 部分填入，然后来解释其中的语法：</p>
<pre><code class="hljs language-text">generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Tag {
  id          String    @id @default(cuid())
  name        String
  description String?
  Article     Article[]
}

model Category {
  id          String    @id @default(cuid())
  name        String
  description String?
  Article     Article[]
}

model Article {
  id          Int     @id @default(autoincrement())
  title       String?
  description String  @default("这篇文章还没有介绍...")
  content     String

  visible     Boolean @default(true)

  tag      Tag[]
  category Category[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
}


</code></pre>
<p>首先，<code>generator client</code> 这个部分定义了我们的项目类型与一些 Prisma 配置，既然 Prisma 专门搞了新的 SDL 作为实体声明，那它肯定不会只支持 JavaScript。这里我们将 <code>provider</code> 配置为 <code>prisma-client-js</code>，在后面转换一步时，它就会生成 JS 代码，你才能调用它。<code>datasource db</code> 则定义了数据库的类型与地址，这里我们使用 <code>env()</code> 函数从环境变量中注入定义。</p>
<p>下面的 model 部分就是数据库的实体定义了，我们定义了 Article、Tag、Category 三个实体，在 Prisma Schema 中内置了一些特殊语法与函数，如 <code>@id</code> 将这一列标记为主键，<code>@default(autoincrement())</code> 意为使用自增主键作为默认值，<code>@default(now())</code> 意为使用创建/修改时的日期作为默认值。</p>
<p>在 Prisma Schema 中我们可以用非常自然的方式声明关联：</p>
<pre><code class="hljs language-text">model Tag {
  Article     Article[]
}

model Category {
  Article     Article[]
}

model Article {
  tag      Tag[]
  category Category[]
}
</code></pre>
<p>实际上我们就是声明了 Article-Tag、Article-Category 这两对<strong>多对多</strong>的级联关系。接着，我们来体验下转换，执行以下命令：</p>
<pre><code class="hljs language-bash">prisma generate
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fde89e7ee8541abbc8695851de1d471~tplv-k3u1fbpfcp-zoom-1.image" alt="imagea1dd0f09cd0c6303.png"></p>
<p>这里的 Prisma Client 会被生成到 <code>node_modules/@prisma/client</code> 下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce733ab100514fb8ac4bce6f17c3601d~tplv-k3u1fbpfcp-zoom-1.image" alt="image013d3fbf7ddad47c.png"></p>
<p>而在实际使用时，我们就需要导入它并实例化：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">PrismaClient</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;

<span class="hljs-keyword">const</span> prisma = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrismaClient</span>();
</code></pre>
<p>接下来，你将体验到 Prisma 最大的特色之一：类型安全。我们尝试访问以下 prisma 的属性：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5158276dadf04997bc8553d2405702af~tplv-k3u1fbpfcp-zoom-1.image" alt="image749525dface6a1d2.png"></p>
<p>每一个实体上的每一种方法都有全面覆盖的类型提示，而这背后当然是 prisma generate 命令中由 Prisma Schema 所生成的 TS 类型定义。</p>
<p>你可能会问，TypeORM 的 TS 支持也很好，为什么我单单说 Prisma 是类型安全的？这是因为在这些基于编程的语言中，类型实际上是我们自己书写的，ORM 由这些定义映射到数据库的过程中并不能保证是安全的。如在 TypeORM 中，一个字段是否可能为空是通过额外的选项 <code>@Column({ nullable: true })</code> 的方式来声明的。</p>
<p>而在 Prisma 中，我们通过 Prisma Schema 来描述数据库实体，相比 JavaScript / TypeScript，它无疑更加自然也更贴近 SQL。同时数据库的表结构与 TS 类型定义的生成均基于 Prisma Schema ，这也就保证了表结构与我们实际类型定义的同步。而如果你担心 Prisma 生成的类型不够严谨，可以翻翻看生成的 Prisma Client 代码。如这个例子中我们只有三个实体，共计 16 个字段，Prisma 生成了将近 5000 行的类型定义。</p>
<p>如果你对 Prisma 产生了兴趣，我此前写过系列文章来详细地介绍 Prisma 的使用，参考 <a href="https://juejin.cn/post/6973277530996342798" target="_blank" rel="nofollow noopener noreferrer">Prisma：下一代 ORM，不仅仅是 ORM 上篇</a>、<a href="https://juejin.cn/post/6973950142445518884" target="_blank" rel="nofollow noopener noreferrer">下篇</a>。</p>
<p>关于 Prisma 的工作流程，你可以参考这张图片：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b92e9f7bc66c4dea82b8b911bba8a96e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>接下来，我们要来了解如何在 Nest 中去集成 Prisma，这一步我们不需要任何的集成包，只有非常自然地导入与调用。</p>
<h3>在 NestJs 中集成 Prisma</h3>
<p>在 NestJs 中集成 Prisma 其实也非常简单，秉持着模块化的理念，我们将 Prisma 相关的逻辑单独放到一个模块中。</p>
<p>新建 <code>prisma.service.ts</code>：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">Injectable</span>,
  <span class="hljs-title class_">OnApplicationShutdown</span>,
  <span class="hljs-title class_">OnApplicationBootstrap</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">PrismaClient</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrismaService</span>
  <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PrismaClient</span>
  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OnApplicationBootstrap</span>, <span class="hljs-title class_">OnApplicationShutdown</span>
{
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>();
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">onApplicationBootstrap</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.$connect();
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">onApplicationShutdown</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.$disconnect();
  }
}
</code></pre>
<p><code>onApplicationBootstrap</code> 和 <code>onApplicationShutdown</code> 是 NestJs 提供的应用级生命周期，我们继承 PrismaClient，通过 implements 来实现这两个方法，然后分别在启动与停止阶段与数据库连接、断开连接。</p>
<p>在前面我们已经提到，Prisma Client 需要被实例化后才能使用。我们这里的 PrismaService 也是，但是如果某一处代码需要使用它，IoC 容器在交给它这个类时就会进行实例化过程。</p>
<p>然后新建 <code>prisma.module.ts</code>：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Global</span>, <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">PrismaService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./prisma.service'</span>;

<span class="hljs-meta">@Global</span>()
<span class="hljs-meta">@Module</span>({
  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">PrismaService</span>],
  <span class="hljs-attr">exports</span>: [<span class="hljs-title class_">PrismaService</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrismaModule</span> {}
</code></pre>
<p>通过这种方式，Prisma 相关的所有能力都被归纳在这个模块中，后续你还可以继续添加如 <a href="https://www.prisma.io/docs/concepts/components/prisma-client/middleware" target="_blank" rel="nofollow noopener noreferrer">Prisma Middleware</a> 的功能。</p>
<p>接着别忘了将 Prisma Module 也添加到 AppModule 中：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PrismaModule</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./data/prisma.module'</span>;

<span class="hljs-meta">@Module</span>({
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">PrismaModule</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> {}
</code></pre>
<p>这样，其他地方的 Service 就可以使用 Prisma Service 了！</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">PrismaService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../data/prisma.service'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleService</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> prisma: PrismaService</span>) {}

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">query</span>(): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">Article</span>[]> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">prisma</span>.<span class="hljs-property">article</span>.<span class="hljs-title function_">findMany</span>();
    <span class="hljs-keyword">return</span> res;
  }
}
</code></pre>
<p>还记得我们在前面说到，Prisma 的核心优势之一就是它的类型安全，它会基于 Prisma Schema 生成对应的 TypeScript 类型定义，而我们实际上可以直接复用这些类型。</p>
<p>新建 <code>src/types/index.ts</code> ，这里会存放项目中的类型定义，在这个项目中我们只需要使用从 Prisma Client 中导出的：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">Prisma</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">ArticleCreateInput</span> = <span class="hljs-title class_">Prisma</span>.<span class="hljs-property">ArticleCreateInput</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">ArticleUpdateInput</span> = <span class="hljs-title class_">Prisma</span>.<span class="hljs-property">ArticleUpdateInput</span> &#x26;
  <span class="hljs-title class_">Prisma</span>.<span class="hljs-property">ArticleWhereUniqueInput</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">Article</span>, <span class="hljs-title class_">Tag</span>, <span class="hljs-title class_">Category</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;

<span class="hljs-comment">// ...类似的</span>
</code></pre>
<p>直接在代码中使用这些类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">PrismaService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../data/prisma.service'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Article</span>, <span class="hljs-title class_">ArticleCreateInput</span>, <span class="hljs-title class_">ArticleUpdateInput</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../types'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleService</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> prisma: PrismaService</span>) {}

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">create</span>(<span class="hljs-attr">createInput</span>: <span class="hljs-title class_">ArticleCreateInput</span>): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">Article</span>> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">prisma</span>.<span class="hljs-property">article</span>.<span class="hljs-title function_">create</span>({
      <span class="hljs-attr">data</span>: createInput,
    });

    <span class="hljs-keyword">return</span> res;
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">update</span>(<span class="hljs-attr">updateInput</span>: <span class="hljs-title class_">ArticleUpdateInput</span>): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">Article</span>> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">prisma</span>.<span class="hljs-property">article</span>.<span class="hljs-title function_">update</span>({
      <span class="hljs-attr">data</span>: updateInput,
      <span class="hljs-attr">where</span>: {
        <span class="hljs-attr">id</span>: updateInput.<span class="hljs-property">id</span>,
      },
    });

    <span class="hljs-keyword">return</span> res;
  }
}
</code></pre>
<h2>总结与预告</h2>
<p>这一节我们学习了 NestJs 框架与 Prisma ORM 的基础概念与使用方式，以及在 NestJs 中集成 Prisma 的方法。相比于其它同类型框架，它们都有着决定性的优势，如 NestJs 的全家桶套餐、Prisma 的类型安全与性能。</p>
<p>完成了这些前置地知识储备后，下一节我们就将进入正式的开发与部署阶段了。但我们并不会走完整个开发阶段，我更相信授人以渔的教学方式，因此实际开发时我们只会完成一部分开发，走通整个流程。如果这两个框架让你感到有点意思，你就会自驱地完成整个流程开发的，毕竟兴趣才是我们最好的老师。相比于开发部分，我们对部署部分的介绍要更加详细，因为我们将使用 Heroku 平台提供的部署与数据库服务，这对于大部分同学来说都是首次接触。</p>
<h2>扩展阅读</h2>
<h3>NestJs 应用目录结构的不同组织方式</h3>
<p>前面我们介绍了 Controller、Service 等文件的基本功能，除此以外，NestJs 应用中其实存在着两种不同的文件组织风格：按功能与按逻辑进行拆分。</p>
<p>按功能进行拆分，即我们本节的应用使用的方式，这一方式下的目录结构是这样的：</p>
<pre><code class="hljs language-text">project
├── src
├──── controllers
├──── services
├──── providers
├──── app.module.ts
├──── main.ts
├── package.json
├── nest-cli.json
└── tsconfig.json
</code></pre>
<p>也就是说，所有的 Controller 文件都在 <code>/controllers</code> 文件夹下，所有的 Service 文件都在 <code>/services</code> 文件夹下。这一方式适用于项目规模较小的情况，此时无需进行精细的模块化拆分，我们只会有一个 AppModule 。</p>
<p>而按逻辑进行拆分的目录结构可能是这样的：</p>
<pre><code class="hljs language-text">project
├── src
├──── user
├─────── user.controller.ts
├─────── user.service.ts
├─────── user.module.ts
├──── manager
├─────── manager.controller.ts
├─────── manager.service.ts
├─────── manager.module.ts
├──── app.module.ts
├──── main.ts
├── package.json
├── nest-cli.json
└── tsconfig.json
</code></pre>
<p>此时我们的 Controller、Service 都会被归类到对应业务逻辑的文件夹下，每个业务逻辑拥有自己的 Module ，然后再在 AppModule 中汇总。</p>
<p>这一方式适合存在一定规模的项目，以及内部业务模块分类较多的情况，此时使用基于逻辑的目录结构划分可以帮助你更好地进行模块拆分，同时获得更直观的模块依赖关系。</p>
<h3>Data Mapper 与 Active Record</h3>
<p>即使你此前已经有过 ORM 的实践经验，还有两个概念可能是你未了解过的，即 <strong>Data Mapper</strong> 与 <strong>Active Record</strong> 。TypeORM的简介中提到，<em><strong>TypeORM supports both Active Record and Data Mapper patterns</strong></em>，即它同时支持了这两种模式。那么这两种模式对代码有什么影响，它们的差别又是什么？</p>
<p>先来看 Active Record 模式下的 TypeORM 代码：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BaseEntity</span>, <span class="hljs-title class_">Entity</span>, <span class="hljs-title class_">PrimaryGeneratedColumn</span>, <span class="hljs-title class_">Column</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"typeorm"</span>;

<span class="hljs-meta">@Entity</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">BaseEntity</span> {
  <span class="hljs-meta">@PrimaryGeneratedColumn</span>()
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;

  <span class="hljs-meta">@Column</span>()
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Column</span>()
  <span class="hljs-attr">isActive</span>: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
user.<span class="hljs-property">name</span> = <span class="hljs-string">"不渡"</span>;
user.<span class="hljs-property">isActive</span> = <span class="hljs-literal">true</span>;

<span class="hljs-keyword">await</span> user.<span class="hljs-title function_">save</span>();

<span class="hljs-keyword">const</span> newUsers = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>({ <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span> });
</code></pre>
<p>TypeORM中，Active Record 模式下需要让实体类继承 <code>BaseEntity</code>类，然后实体类上就具有了各种操作方法，如 <code>save</code>  <code>remove</code>  <code>find </code>方法等。Active Record 模式最早由 Martin Fowle在 <em><strong>企业级应用架构模式</strong></em> 一书中命名，即直接在对象上支持相关的 CRUD 方法。</p>
<p>而 Data Mapper 下的代码则是这样的：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Entity</span>, <span class="hljs-title class_">PrimaryGeneratedColumn</span>, <span class="hljs-title class_">Column</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"typeorm"</span>;

<span class="hljs-meta">@Entity</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-meta">@PrimaryGeneratedColumn</span>()
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;

  <span class="hljs-meta">@Column</span>()
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Column</span>()
  <span class="hljs-attr">isActive</span>: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">const</span> userRepository = connection.<span class="hljs-title function_">getRepository</span>(<span class="hljs-title class_">User</span>);

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
user.<span class="hljs-property">name</span> = <span class="hljs-string">"不渡"</span>;
user.<span class="hljs-property">isActive</span> = <span class="hljs-literal">true</span>;

<span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">save</span>(user);

<span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">remove</span>(user);

<span class="hljs-keyword">const</span> newUsers = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">find</span>({ <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span> });
</code></pre>
<p>在 Data Mapper 模式下，实体类不能够自己进行数据库操作，而是需要先获取到一个对应到表的“仓库”，然后再调用这个“仓库”上的方法。</p>
<p>这一模式同样由 Martin Fowler 前辈最初命名，Data Mapper 就像是一层拦在操作者与实际数据之间的访问层，就如上面例子中，需要先获取具有访问权限（即相应方法）的对象，再进行数据的操作。</p>
<p>对这两个模式进行比较，很容易发现 Active Record 模式要更加简单，适用于较简单的应用。可以减少很多代码。而 Data Mapper 模式则更加严谨，适用于开发规模较大的应用，一个例子是在 Nest 的 TypeORM 集成包中，也是注入Repository实例然后再进行操作的，即也属于 Data Mapper 模式。</p>
<p>最后，实际上 Prisma 使用的也是 Data Mapper 模式，我们需要 Prisma Client 来作为访问层。</p>
<h3>ORM 与 QueryBuilder</h3>
<p>ORM 并不是唯一一种让我们可以不用写 SQL 就能操作数据库的方式，同时它也不是最贴近 SQL 的方式。</p>
<p>Query Builder 就是这另外一种使用方式，它和 ORM 一样，通过编程语言书写，但不同的是它并不包括实体类映射到数据库表的部分，而只是负责 Query 。</p>
<p>以 TypeORM 的 Query Builder 模式为例：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { getConnection } <span class="hljs-keyword">from</span> <span class="hljs-string">"typeorm"</span>;

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getConnection</span>()
  .<span class="hljs-title function_">createQueryBuilder</span>()
  .<span class="hljs-title function_">select</span>(<span class="hljs-string">"user"</span>)
  .<span class="hljs-title function_">from</span>(<span class="hljs-title class_">User</span>, <span class="hljs-string">"user"</span>)
  .<span class="hljs-title function_">where</span>(<span class="hljs-string">"user.id = :id"</span>, { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> })
  .<span class="hljs-title function_">getOne</span>();
</code></pre>
<p>这么一连串的链式调用，其实就等价于 <code>userRepo.find({ id: 1 })</code> 的作用，看起来更麻烦了，但你是否感觉到了灵活性的成倍增长？在 Query Builder 中，，每一次链式调用都会对最终生成的 SQL 产生一些调整，因此我们可以通过非常细粒度的调整来更加的贴近原生 SQL 。</p>
<p>除了 TypeORM 以外，Node 中使用较多的 Query Builder 还包括 <a href="https://github.com/knex/knex" target="_blank" rel="nofollow noopener noreferrer">knex</a>、<a href="https://github.com/koskimas/kysely" target="_blank" rel="nofollow noopener noreferrer">kysely</a> 等。</p>
<p>关于 Prisma、Query Builder 与 ORM 的比较，可以参考下面这张图片：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/456cfd8784284b5b91c0d19b90f1103b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="comparison"></p></div>
</body></html>