<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>装饰器与反射元数据：了解装饰器基本原理与应用</h1>
<p>上一节我们了解了 TypeScript 与 ECMAScript 的关系，以及可选链与空值合并这两个 TypeScript 中的 ECMAScript 提案。其实，还有一个 ECMAScript 提案也已经成为 TypeScript 中相当重要的一部分，它就是装饰器。</p>
<p>装饰器语法在 Python、Java 等语言中都能见到，但在 JavaScript 中并没有被大量使用。一方面是因为，装饰器其实还不能被称为 JavaScript 的一部分，另一方面则是它对应用场景有着一定要求，比如只能使用在 Class 上，而 Class 并不是 JavaScript 中大量使用的语法。</p>
<p>至于为什么说装饰器还不是 JavaScript 的一部分，我们会在扩展阅读中介绍更多。这一节我们只关注 TypeScript 中的装饰器，从基础语法到不同种类的装饰器，从反射到反射元数据，再到基于这些概念实现依赖注入、IoC 容器等等。</p>
<blockquote>
<p>本节代码见：<a href="https://github.com/linbudu599/TypeScript-Tiny-Book/tree/main/packages/21-decorators" target="_blank" rel="nofollow noopener noreferrer">Decorators</a></p>
</blockquote>
<p>首先我们需要明确的是，<strong>装饰器的本质其实就是一个函数</strong>，只不过它的入参是提前确定好的。同时，TypeScript 中的装饰器目前<strong>只能在类以及类成员上使用</strong>。</p>
<p>装饰器通过 <code>@</code> 语法来使用：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Deco</span>(<span class="hljs-params"></span>) { }

<span class="hljs-meta">@Deco</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {}
</code></pre>
<p>这样的装饰器只能起到固定的功能，我们实际上使用更多的是 Decorator Factory，即装饰器工厂的形式：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Deco</span>(<span class="hljs-params"></span>) { 
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> {}
}

<span class="hljs-meta">@Deco</span>()
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {}
</code></pre>
<p>在这种情况下，程序执行时会先执行 <code>Deco()</code> ，再用内部返回的函数作为装饰器的实际逻辑。这样，我们就可以通过入参来灵活地调整装饰器的作用。接下来，我们就来学习一下 TypeScript 中的装饰器是如何使用的，它们分别有什么作用？</p>
<h2>装饰器大起底</h2>
<p>TypeScript 中的装饰器可以分为<strong>类装饰器</strong>、<strong>方法装饰器</strong>、<strong>访问符装饰器</strong>、<strong>属性装饰器</strong>以及<strong>参数装饰器</strong>五种，最常见的主要还是类装饰器、方法装饰器以及属性装饰器。接下来，我们会依次介绍这几种装饰器的具体使用。</p>
<h3>类装饰器</h3>
<p>类装饰器是直接作用在类上的装饰器，它在执行时的入参只有一个，那就是这个类本身（而不是类的原型对象）。因此，我们可以通过类装饰器来覆盖类的属性与方法，如果你在类装饰器中返回一个新的类，它甚至可以篡改掉整个类的实现。</p>
<pre><code class="hljs language-typescript"><span class="hljs-meta">@AddProperty</span>(<span class="hljs-string">'linbudu'</span>)
<span class="hljs-meta">@AddMethod</span>()
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  a = <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">AddMethod</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">ClassDecorator</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target: <span class="hljs-built_in">any</span></span>) =></span> {
    target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">newInstanceMethod</span> = <span class="hljs-function">() =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Let's add a new instance method!"</span>);
    };
    target.<span class="hljs-property">newStaticMethod</span> = <span class="hljs-function">() =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Let's add a new static method!"</span>);
    };
  };
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">AddProperty</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">ClassDecorator</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target: <span class="hljs-built_in">any</span></span>) =></span> {
    target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">newInstanceProperty</span> = value;
    target.<span class="hljs-property">newStaticProperty</span> = <span class="hljs-string">`static <span class="hljs-subst">${value}</span>`</span>;
  };
}
</code></pre>
<p>这里，我们通过 TypeScript 内置的 ClassDecorator 类型定义来进行类型标注，由于类装饰器只有一个参数，我们也不想使用过多的类型代码，这里我就直接 any 了。我们的函数返回了一个 ClassDecorator ，因此这个装饰器就是一个 Decorator Factory，在实际执行时需要以 <code>@Deco()</code> 的形式调用。</p>
<p>在 AddMethod 与 AddProperty 方法中，我们分别在 target、<code>target.prototype</code> 上添加了方法与属性，还记得 ES6 中 Class 的本质仍然是基于原型的吗？在这里 target 上的属性实际上是<strong>静态成员</strong>，也就是其实例上不会获得的方法，而 <code>target.prototype</code> 上的属性才是会随着继承与实例化过程被传递的<strong>实例成员</strong>。</p>
<p>我们来调用一下看看：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">any</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();

foo.<span class="hljs-title function_">newInstanceMethod</span>();
(&#x3C;<span class="hljs-built_in">any</span>><span class="hljs-title class_">Foo</span>).<span class="hljs-title function_">newStaticMethod</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">newInstanceProperty</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((&#x3C;<span class="hljs-built_in">any</span>><span class="hljs-title class_">Foo</span>).<span class="hljs-property">newStaticProperty</span>);
</code></pre>
<pre><code class="hljs language-text">Let's add a new instance method!
Let's add a new static method!
linbudu
static linbudu
</code></pre>
<p>我们在这里调用的方法并没有直接在 Foo 中定义，而是通过装饰器来强行添加！我们也可以在装饰中返回一个子类：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">OverrideBar</span> = (<span class="hljs-params">target: <span class="hljs-built_in">any</span></span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> target {
    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {}
    <span class="hljs-title function_">overridedPrint</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'This is Overrided Bar!'</span>);
    }
  };
};

<span class="hljs-meta">@OverrideBar</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> {
  <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'This is Bar!'</span>);
  }
}

<span class="hljs-comment">// 被覆盖了，现在是一个空方法</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>().<span class="hljs-title function_">print</span>();

<span class="hljs-comment">// This is Overrided Bar!</span>
(&#x3C;<span class="hljs-built_in">any</span>><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>()).<span class="hljs-title function_">overridedPrint</span>();
</code></pre>
<p>在 React Class 组件时代，其实你会发现有许多功能也是通过装饰器实现的。如 Mobx 的 <code>@observer</code> 与 <code>@observable</code>，React-Redux 的 <code>@connect</code> 等。</p>
<h3>方法装饰器</h3>
<p>方法装饰器的入参包括<strong>类的原型</strong>、<strong>方法名</strong>以及<strong>方法的属性描述符</strong>（PropertyDescriptor），而通过属性描述符你可以控制这个方法的内部实现（即 value）、可变性（即 writable）等信息。</p>
<p>能拿到原本实现，也就意味着，我们可以在执行原本方法的同时，插入一段新的逻辑，比如计算这个方法的执行耗时：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-meta">@ComputeProfiler</span>()
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'RES'</span>);
      }, <span class="hljs-number">3000</span>);
    });
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ComputeProfiler</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">MethodDecorator</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">
    _target,
    methodIdentifier,
    descriptor: TypedPropertyDescriptor&#x3C;<span class="hljs-built_in">any</span>>
  </span>) =></span> {
    <span class="hljs-keyword">const</span> originalMethodImpl = descriptor.<span class="hljs-property">value</span>!;
    descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args: <span class="hljs-built_in">unknown</span>[]</span>) {
      <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> originalMethodImpl.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行原本的逻辑</span>
      <span class="hljs-keyword">const</span> end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
        <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">String</span>(methodIdentifier)}</span> Time: `</span>,
        end.<span class="hljs-title function_">getTime</span>() - start.<span class="hljs-title function_">getTime</span>()
      );
      <span class="hljs-keyword">return</span> res;
    };
  };
}

(<span class="hljs-keyword">async</span> () => {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">fetch</span>());
})();
</code></pre>
<pre><code class="hljs language-text">fetch Time:  3003
RES
</code></pre>
<p>需要注意的是，方法装饰器的 target 是<strong>类的原型而非类本身</strong>。</p>
<h3>访问符装饰器</h3>
<p>访问符装饰器并不常见，甚至访问符对于部分同学来说也是陌生的，但它其实就是 <code>get value(){}</code> 与 <code>set value(v)=>{}</code> 这样的方法，其中 getter 在你访问这个属性 <code>value</code> 时触发，而 setter 在你对 <code>value</code> 进行赋值时触发。访问符装饰器本质上仍然是方法装饰器，它们使用的类型定义也相同。</p>
<p>需要注意的是，访问符装饰器只能同时应用在一对 getter / setter 的其中一个，即要么装饰 getter 要么装饰 setter 。这是因为，不论你是装饰哪一个，装饰器入参中的属性描述符都会包括 getter 与setter 方法：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  _value!: <span class="hljs-built_in">string</span>;

  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>;
  }

  <span class="hljs-meta">@HijackSetter</span>(<span class="hljs-string">'LIN_BU_DU'</span>)
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = input;
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">HijackSetter</span>(<span class="hljs-params">val: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">MethodDecorator</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, methodIdentifier, descriptor: <span class="hljs-built_in">any</span></span>) =></span> {
    <span class="hljs-keyword">const</span> originalSetter = descriptor.<span class="hljs-property">set</span>;
    descriptor.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">newValue: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-keyword">const</span> composed = <span class="hljs-string">`Raw: <span class="hljs-subst">${newValue}</span>, Actual: <span class="hljs-subst">${val}</span>-<span class="hljs-subst">${newValue}</span>`</span>
      originalSetter.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, composed);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`HijackSetter: <span class="hljs-subst">${composed}</span>`</span>);
    };
    <span class="hljs-comment">// 篡改 getter，使得这个值无视 setter 的更新，返回一个固定的值</span>
    <span class="hljs-comment">// descriptor.get = function () {</span>
    <span class="hljs-comment">//   return val;</span>
    <span class="hljs-comment">// };</span>
  };
}

<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();
foo.<span class="hljs-property">value</span> = <span class="hljs-string">'LINBUDU'</span>; <span class="hljs-comment">// HijackSetter: Raw: LINBUDU, Actual: LIN_BU_DU-LINBUDU</span>
</code></pre>
<p>在这个例子中，我们通过装饰器劫持了 setter ，在执行原本的 setter 方法修改了其参数。同时，我们也可以在这里去劫持 getter（<code>descriptor.get</code>），这样一来在读取这个值时，会直接返回一个我们固定好的值，而非其实际的值（如被 setter 更新过的）。</p>
<h3>属性装饰器</h3>
<p>属性装饰器在独立使用时能力非常有限，它的入参只有<strong>类的原型</strong>与<strong>属性名称</strong>，返回值会被忽略，但你仍然可以通过<strong>直接在类的原型上赋值</strong>来修改属性：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-meta">@ModifyNickName</span>()
  nickName!: <span class="hljs-built_in">string</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ModifyNickName</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">PropertyDecorator</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyIdentifier</span>) =></span> {
    target[propertyIdentifier] = <span class="hljs-string">'林不渡!'</span>;
    target[<span class="hljs-string">'otherName'</span>] = <span class="hljs-string">'别名林不渡!'</span>;
  };
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-property">nickName</span>);
<span class="hljs-comment">// @ts-expect-error</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-property">otherName</span>);
</code></pre>
<pre><code class="hljs language-text">林不渡!
别名林不渡!
</code></pre>
<p>我们在原型对象上强行写入了属性，但这种方法实际上过于 hack，在后面我们会了解如何通过委托的方式来为一个属性注入值。</p>
<h3>参数装饰器</h3>
<p>参数装饰器包括了构造函数的参数装饰器与方法的参数装饰器，它的入参包括<strong>类的原型</strong>、<strong>参数所在的方法名</strong>与<strong>参数在函数参数中的索引值（即第几个参数）</strong>，如果只是单独使用，它的作用同样非常有限。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">handler</span>(<span class="hljs-params"><span class="hljs-meta">@CheckParam</span>() input: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input);
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">CheckParam</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">ParameterDecorator</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, methodIdentifier, index</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, methodIdentifier, index);
  };
}

<span class="hljs-comment">// {} handler 0</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">handler</span>(<span class="hljs-string">'linbudu'</span>);
</code></pre>
<p>后面我们会了解如何基于参数装饰器进行参数的默认值注入与校验，现在就先到这儿，思考另一个问题：一个类中可以同时拥有这几种装饰器，那么这些<strong>不同装饰器的执行时机与顺序是如何的</strong>？</p>
<h3>装饰器的执行机制</h3>
<p>装饰器的执行机制中主要包括<strong>执行时机</strong>、<strong>执行原理</strong>以及<strong>执行顺序</strong>这三个概念。</p>
<p>首先是执行时机，还记得我们在最开始说的吗？装饰器的本质就是一个函数，因此只要在类上定义了它，即使不去实例化这个类或者读取静态成员，它也会正常执行。很多时候，其实我们也并不会实例化具有装饰器的类，而是通过反射元数据的能力来消费，这一点我们后面会讲到。而装饰器的执行原理，我们可以通过编译后的代码来了解：</p>
<pre><code class="hljs language-typescript"><span class="hljs-meta">@Cls</span>()
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@Param</span>() init?: <span class="hljs-built_in">string</span></span>) { }

  <span class="hljs-meta">@Prop</span>()
  prop!: <span class="hljs-built_in">string</span>

  <span class="hljs-meta">@Method</span>()
  <span class="hljs-title function_">handler</span>(<span class="hljs-params"><span class="hljs-meta">@Param</span>() input: <span class="hljs-built_in">string</span></span>) {

  }
}
</code></pre>
<p>这一段代码编译的产物会是这样的（经过简化）：</p>
<pre><code class="hljs language-javascript"><span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">var</span> __decorate = (<span class="hljs-variable language_">this</span> &#x26;&#x26; <span class="hljs-variable language_">this</span>.<span class="hljs-property">__decorate</span>) || <span class="hljs-keyword">function</span> (<span class="hljs-params">decorators, target, key, desc</span>) {
   <span class="hljs-comment">// ...</span>
};
<span class="hljs-keyword">var</span> __param = (<span class="hljs-variable language_">this</span> &#x26;&#x26; <span class="hljs-variable language_">this</span>.<span class="hljs-property">__param</span>) || <span class="hljs-keyword">function</span> (<span class="hljs-params">paramIndex, decorator</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key</span>) { <span class="hljs-title function_">decorator</span>(target, key, paramIndex); }
};

<span class="hljs-keyword">let</span> <span class="hljs-title class_">Foo</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">init</span>) { }
    <span class="hljs-title function_">handler</span>(<span class="hljs-params">input</span>) {
    }
};
<span class="hljs-title function_">__decorate</span>([
    <span class="hljs-title class_">Prop</span>(),
], <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">"prop"</span>, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>);
<span class="hljs-title function_">__decorate</span>([
    <span class="hljs-title class_">Method</span>(),
    <span class="hljs-title function_">__param</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Param</span>()),
], <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">"handler"</span>, <span class="hljs-literal">null</span>);
<span class="hljs-title class_">Foo</span> = <span class="hljs-title function_">__decorate</span>([
    <span class="hljs-title class_">Cls</span>(),
    <span class="hljs-title function_">__param</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Param</span>()),
], <span class="hljs-title class_">Foo</span>);
</code></pre>
<blockquote>
<p>完整的代码见：<a href="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAYQDYGcAUBKAXC1AQ3XQBEBTCOAJ0KhsQG8AoRRa8qEapTKQ6gHNO2RAF4AfE0QBfZnOahIsBIgCynABZwAJjnwao2nRSq161Jq3aduvfkJHipjWfOaLw0eEgAK1OAAHfUR-IPJqKABPUxo6BhY2Di4eRD4BYShRSSs2OQUlb1VfAUIAWxCS2jLOCNjzBOtkuzSHTOyXNwUAATQsbGYIIhJEADE4OFzEKjB0KGoQaBpMbqrynEQYMBgoAH58OeotwVFXBTZVgOCBtkCrg-nj8UQAclQtgCMQHRAXjwuwtdrHM6DAIIgQbAIICHkcwIJni9IWDEO8wF8fn9rN1DMYcNZNIQwDpUBEVmsKqItoEQFBYcdTv83Njcbp8WxkeDOQAJIkksmrUqUzZgGl0iGPeGM6z5DyDBBzRDACbPMDkADuYwmOAA3EA" target="_blank" rel="nofollow noopener noreferrer">Playground</a></p>
</blockquote>
<p>这里的 <code>__decorate</code> 方法，其实就是通过实际入参来判断当前到底执行的是哪种装饰器，然后执行对应的装饰逻辑。而观察这个方法调用时的入参，我们会再次观察到这些装饰器的不同入参：<strong>方法与属性装饰器是类的原型对象</strong>，而<strong>类装饰器才能获得这个类本身作为入参</strong>。而属性装饰器应用时，这个属性还未被初始化（属性需要实例化才会有值），这也是为什么它无法像方法装饰器那样获取到值。</p>
<p>可以看到，上面的装饰器顺序依次是<strong>实例上的属性、方法、方法参数</strong>，然后是<strong>静态的属性、方法、方法参数</strong>，最后是<strong>类以及类构造函数参数</strong>。</p>
<p>而从这一编译结果中，我们还能观察到不同类型装饰器的<strong>执行顺序</strong>。首先是实例上的属性、方法、方法参数，然后是静态的属性、方法、方法参数，最后是类以及类构造函数参数。而装饰器的<strong>应用顺序</strong>则略有不同，<strong>方法参数装饰器会先于方法装饰器应用</strong>（<code>__param(0, Param())</code>）。</p>
<blockquote>
<p>关于执行顺序与应用顺序，执行是<strong>装饰器求值得到最终装饰器表达式</strong>的过程，而应用则是<strong>最终装饰器逻辑代码执行</strong>的过程：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 执行</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> {
    <span class="hljs-comment">// 应用</span>
  }
}
</code></pre>
</blockquote>
<p>实际上，对于实例与静态的属性、方法装饰器而言，它们的执行与应用顺序其实<strong>取决于它们定义的位置</strong>，你可以在上面的例子里把方法定义在属性之前，就会发现执行顺序变成了<strong>方法</strong>-<strong>方法参数</strong>-<strong>属性</strong>，即先定义先执行。</p>
<p>在 TypeScript 官方文档中对应用顺序给出了详细的定义：</p>
<ol>
<li><em>参数装饰器</em>，然后依次是<em>方法装饰器</em>，<em>访问符装饰器</em>，或<em>属性装饰器</em>应用到每个实例成员。</li>
<li><em>参数装饰器</em>，然后依次是<em>方法装饰器</em>，<em>访问符装饰器</em>，或<em>属性装饰器</em>应用到每个静态成员。</li>
<li><em>参数装饰器</em>应用到构造函数。</li>
<li><em>类装饰器</em>应用到类。</li>
</ol>
<p>最后，我们再看一个例子，来更深刻地了解执行顺序与应用顺序：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Deco</span>(<span class="hljs-params">identifier: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">any</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${identifier}</span> 执行`</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${identifier}</span> 应用`</span>);
  };
}

<span class="hljs-meta">@Deco</span>(<span class="hljs-string">'类装饰器'</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@Deco</span>(<span class="hljs-string">'构造函数参数装饰器'</span>) name: <span class="hljs-built_in">string</span></span>) {}

  <span class="hljs-meta">@Deco</span>(<span class="hljs-string">'实例属性装饰器'</span>)
  prop?: <span class="hljs-built_in">number</span>;

  <span class="hljs-meta">@Deco</span>(<span class="hljs-string">'实例方法装饰器'</span>)
  <span class="hljs-title function_">handler</span>(<span class="hljs-params"><span class="hljs-meta">@Deco</span>(<span class="hljs-string">'实例方法参数装饰器'</span>) args: <span class="hljs-built_in">any</span></span>) {}
}
</code></pre>
<p>以上的代码输出是这样的：</p>
<pre><code class="hljs language-text">实例属性装饰器 执行
实例属性装饰器 应用
实例方法装饰器 执行
实例方法参数装饰器 执行
实例方法参数装饰器 应用
实例方法装饰器 应用
类装饰器 执行
构造函数参数装饰器 执行
构造函数参数装饰器 应用
类装饰器 应用
</code></pre>
<p>执行顺序就不再赘述，这里我们主要关注应用顺序。顺序大致是<strong>实例属性-实例方法参数-构造函数参数-类</strong>，好像不对，不是说参数装饰器先应用吗？这是因为在这个例子中，我们是先定义属性和属性装饰器的，因此属性装饰器会先应用。如果方法在前，可不就是方法参数装饰器先应用？</p>
<p>你会发现，类装饰器是最后应用的。也就是说，如果我们在方法装饰器中标记某些信息，最终的类装饰器是可以消费到，并且基于此信息对类或类的实例进行某些操作的。如标记为 <code>@Deprecated</code> 的方法，我们在最终的类装饰器中可以将这些方法实现替换为一个报错！而标记这些信息的方法则有很多，最简单的如，在全局声明一个 Map，类作为 Key，这些信息作为 Value 也是可以的。当然，后面我们会说到如何使用更好的方式实现。</p>
<h4>多个同类装饰器的执行顺序</h4>
<p>另外，我们也可以使用多个同种装饰器，比如一个类上可以有好多个类装饰器：</p>
<pre><code class="hljs language-typescript"><span class="hljs-meta">@Deprecated</span>()
<span class="hljs-meta">@User</span>()
<span class="hljs-meta">@Internal</span>
<span class="hljs-meta">@Provide</span>()
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {}
</code></pre>
<p>这种情况下，这些装饰器的执行顺序又是怎样的？其顺序分为两步。首先，<strong>由上至下</strong>依次对装饰器的表达式求值，得到装饰器的实现，<code>@Internal</code> 中实现即为 Internal 方法，而 <code>@Provide()</code> 中实现则需要进行一次求值。</p>
<p>然后，这些装饰器的具体实现才会<strong>从下往上</strong>调用，如这里是 Provide、Internal、User、Deprecated 的顺序。从这个角度来看，甚至有点像洋葱模型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">MethodDecorator</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'foo in'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, propertyKey, descriptor</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'foo out'</span>);
  };
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Bar</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">MethodDecorator</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'bar in'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, propertyKey, descriptor</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'bar out'</span>);
  };
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Baz</span>: <span class="hljs-title class_">MethodDecorator</span> = <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'baz apply'</span>);
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-meta">@Foo</span>()
  <span class="hljs-meta">@Bar</span>()
  <span class="hljs-meta">@Baz</span>
  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) {}
}

<span class="hljs-comment">// foo in</span>
<span class="hljs-comment">// bar in</span>
<span class="hljs-comment">// baz apply</span>
<span class="hljs-comment">// bar out</span>
<span class="hljs-comment">// foo out</span>
</code></pre>
<p>类似的，如果一个方法中的多个参数均存在装饰器，那么同样是 <code>Parma1 in</code> - <code>Param2 in </code> - <code>Param2 out</code> - <code>Param1 out</code> 的顺序，也就是<strong>后面参数的装饰器逻辑</strong>反而先执行。</p>
<p><strong>但我们通常不会在同种装饰器中进行存在依赖关系的操作。</strong> 对于属性、参数装饰器来说，我们通常只进行信息注册，委托别人处理。对于方法装饰器来说，我们最多只进行方法执行前后的逻辑注入。而这些过程都应当是彼此独立的。</p>
<p>那么，这里的委托又如何实现呢？这时候我们就要介绍一位新朋友了：<strong>反射（Reflect）</strong>。你可能很早就认识，但没怎么接触过。</p>
<h2>反射 Reflect</h2>
<p>Reflect 在 ES6 中被首次引入，它主要是为了配合 Proxy 保留一份方法原始的实现逻辑，如以下来自阮一峰老师的 ES6  标准入门中 <a href="https://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="nofollow noopener noreferrer">Reflect</a> 一节的代码：</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Proxy</span>(target, {
  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, name, value, receiver</span>) {
    <span class="hljs-keyword">var</span> success = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, name, value, receiver);
    <span class="hljs-keyword">if</span> (success) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'property '</span> + name + <span class="hljs-string">' on '</span> + target + <span class="hljs-string">' set to '</span> + value);
    }
    <span class="hljs-keyword">return</span> success;
  }
});
</code></pre>
<p>Proxy 将修改这个对象的 set 方法，但我们可以通过 <code>Reflect.set</code> 方法获得原本的默认实现（不会被修改），先执行完默认实现逻辑再添加自己的额外逻辑。</p>
<p>Proxy 上的这些方法会一一对应到 Reflect 中（或者说 Reflect 中只有 Proxy 上方法的对应实现），如 defineProperty、deleteProperty、apply、get、set、has 等等。这些方法其实也可以在别的对象上找到，如 <code>Object.defineProperty</code>、<code>Function.prototype.apply</code> 等等，因此 Reflect 其实也起到了方法收拢的作用。</p>
<p>如果你有 Java、Go 等语言的基础，一定会反驳说反射才不是用来干这个的呢。别急，我们才刚要开始介绍。</p>
<p>上面的 Proxy 对象的 set 方法是运行时才实际执行的，也就是说我们通过反射，在<strong>运行时去修改了程序的行为</strong>。这就是反射的核心要素：<strong>在程序运行时去检查以及修改程序行为</strong>，比如在代码运行时通过 <code>Reflect.construct</code> 实例化一个类，通过 <code>Reflect.setPrototypeOf</code> 修改对象原型指向，这些其实都属于反射 API 。</p>
<blockquote>
<p>此前 JavaScript 中的反射 API 散落在各个顶级对象的命名空间下，因此我们需要 Reflect 来进行一次统一。</p>
</blockquote>
<p>比如通过反射来实例化一个类：</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 普通情况</span>
<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>()
foo.<span class="hljs-title function_">hello</span>()

<span class="hljs-comment">// 基于反射</span>
<span class="hljs-keyword">const</span> foo = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Foo</span>, [])
<span class="hljs-keyword">const</span> hello = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(foo, <span class="hljs-string">'hello'</span>)
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(hello, foo, [])
</code></pre>
<p>我们的主要内容和反射并没有太大的关系，下面要介绍的反射元数据才是本节的重量级角色。但你仍然需要铭记反射的核心理念：<strong>在程序运行时去检查以及修改程序行为</strong>。</p>
<h2>反射元数据 Reflect Metadata</h2>
<p>不同于反射，<strong>反射元数据（Reflect Metadata）</strong> 这一提案虽然同样很早就被提出，但至今都未真正的成为 ECMAScript 的一部分，原因在于元数据和装饰器提案的联系非常紧密，随着装饰器提案迟迟不能推进，元数据当然也无法独自向前。因此，想要使用反射元数据，你还需要安装 <a href="https://github.com/rbuckton/reflect-metadata" target="_blank" rel="nofollow noopener noreferrer">reflect-metadata</a> ，并在入口文件中的顶部 <code>import "reflect-metadata"</code> 。</p>
<p>反射元数据提案（即 <code>"reflect-metadata"</code> 包）为顶级对象 Reflect 新增了一批专用于元数据读写的 API，如 <code>Reflect.defineMetadata</code>、<code>Reflect.getMetadata</code> 等。那么元数据又是什么？你可以将元数据理解为<strong>用于描述数据的数据</strong>，如某个方法的参数信息、返回值信息就可称为该方法的元数据。</p>
<p>那么元数据又存储在哪里？提案中专门说明了这一点，为类或类属性添加了元数据后，构造函数（或是构造函数的原型，根据静态成员还是实例成员决定）会具有 <code>[[Metadata]]</code> 属性，该属性内部包含一个 Map 结构，键为属性键，值为元数据键值对。也就是说，<strong>静态成员的元数据信息存储于构造函数</strong>，而<strong>实例成员的元数据信息存储于构造函数的原型上</strong>。</p>
<p>我们来简单使用下元数据的注册与提取：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> <span class="hljs-string">'reflect-metadata'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">handler</span>(<span class="hljs-params"></span>) {}
}

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(<span class="hljs-string">'class:key'</span>, <span class="hljs-string">'class metadata'</span>, <span class="hljs-title class_">Foo</span>);
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(<span class="hljs-string">'method:key'</span>, <span class="hljs-string">'handler metadata'</span>, <span class="hljs-title class_">Foo</span>, <span class="hljs-string">'handler'</span>);
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(
  <span class="hljs-string">'proto:method:key'</span>,
  <span class="hljs-string">'proto handler metadata'</span>,
  <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,
  <span class="hljs-string">'handler'</span>
);
</code></pre>
<p>defineMetadata 的入参包括元数据 Key、元数据 Value、目标类 Target 以及一个可选的属性，在这里我们的三个调用分别是在 Foo、Foo.handler 以及 Foo.prototype 上注册元数据。而提取则可以通过 getMetadata 方法：</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// [ 'class:key' ]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadataKeys</span>(<span class="hljs-title class_">Foo</span>));
<span class="hljs-comment">// ['method:key']</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadataKeys</span>(<span class="hljs-title class_">Foo</span>, <span class="hljs-string">'handler'</span>));
<span class="hljs-comment">// ['proto:method:key'];</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadataKeys</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'handler'</span>));

<span class="hljs-comment">// class metadata</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'class:key'</span>, <span class="hljs-title class_">Foo</span>));
<span class="hljs-comment">// handler metadata</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'method:key'</span>, <span class="hljs-title class_">Foo</span>, <span class="hljs-string">'handler'</span>));
<span class="hljs-comment">// proto handler metadata</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'proto:method:key'</span>, <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'handler'</span>));
</code></pre>
<p>实际上，反射元数据正是我们实现属性装饰器中提到的“委托”能力的基础。我们在属性装饰器中去注册一个元数据，然后在真正实例化这个类时，就可以拿到类原型上的元数据，以此对实例化完毕的类再进行额外操作。比如说，我先通过元数据说明，这个属性需要获得变量 a 的值，在实例化时，我们发现有这个元数据，就会对应进行赋值操作。</p>
<p>正是考虑到这一点，反射元数据中直接就内置了基于装饰器的调用方式：</p>
<pre><code class="hljs language-typescript"><span class="hljs-meta">@Reflect</span>.<span class="hljs-title function_">metadata</span>(<span class="hljs-string">'class:key'</span>, <span class="hljs-string">'METADATA_IN_CLASS'</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-meta">@Reflect</span>.<span class="hljs-title function_">metadata</span>(<span class="hljs-string">'prop:key'</span>, <span class="hljs-string">'METADATA_IN_PROPERTY'</span>)
  <span class="hljs-keyword">public</span> <span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'linbudu'</span>;

  <span class="hljs-meta">@Reflect</span>.<span class="hljs-title function_">metadata</span>(<span class="hljs-string">'method:key'</span>, <span class="hljs-string">'METADATA_IN_METHOD'</span>)
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">handler</span>(): <span class="hljs-built_in">void</span> {}
}
</code></pre>
<p><code>@Reflect.metadata</code> 装饰器会基于应用的位置进行实际的逻辑调用，如在类上装饰时以类作为 target 进行注册，而在静态成员与实例成员中分别使用构造函数、构造函数原型。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();

<span class="hljs-comment">// METADATA_IN_CLASS</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'class:key'</span>, <span class="hljs-title class_">Foo</span>));
<span class="hljs-comment">// undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'class:key'</span>, <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>));

<span class="hljs-comment">// METADATA_IN_METHOD</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'method:key'</span>, <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'handler'</span>));
<span class="hljs-comment">// METADATA_IN_METHOD</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'method:key'</span>, foo, <span class="hljs-string">'handler'</span>));

<span class="hljs-comment">// METADATA_IN_PROPERTY</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'prop:key'</span>, <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'prop'</span>));
<span class="hljs-comment">// METADATA_IN_PROPERTY</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'prop:key'</span>, foo, <span class="hljs-string">'prop'</span>));
</code></pre>
<p>看起来我们现在拥有了实现委托的基本能力，但实际上这还不够。所有的元数据都需要我们提前定义好，如果我们希望直接用一些已有的信息作为元数据呢？比如下面这个例子：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
  <span class="hljs-meta">@InjectModel</span>()
  <span class="hljs-attr">userModel</span>: <span class="hljs-title class_">UserModel</span>;
}
</code></pre>
<p>我希望将 userModel 属性的类型 UserModel 作为一个元数据信息注入，同时我不会为 <code>@InjectModel()</code> 装饰器提供任何信息，那我们就束手无策了吗？</p>
<p>还记得我们在介绍反射概念时说的，<strong>反射允许程序去检视自身</strong>，而属性类型作为程序的一部分，也应当是能被反射收集的。为了实现这一目的，反射元数据提案中还内置了基于类型的元数据，你可以通过 <code>design:type</code>、<code>design:paramtypes</code> 以及 <code>design:returntype</code> 这三个内置的元数据 Key，获取到类与类成员的类型、参数类型、返回值类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> <span class="hljs-string">'reflect-metadata'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">DefineType</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-built_in">Object</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">metadata</span>(<span class="hljs-string">'design:type'</span>, <span class="hljs-keyword">type</span>);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">DefineParamTypes</span>(<span class="hljs-params">...types: <span class="hljs-built_in">Object</span>[]</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">metadata</span>(<span class="hljs-string">'design:paramtypes'</span>, types);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">DefineReturnType</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-built_in">Object</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">metadata</span>(<span class="hljs-string">'design:returntype'</span>, <span class="hljs-keyword">type</span>);
}

<span class="hljs-meta">@DefineParamTypes</span>(<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-meta">@DefineType</span>(<span class="hljs-title class_">String</span>)
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'linbudu'</span>;
  }

  <span class="hljs-meta">@DefineType</span>(<span class="hljs-title class_">Function</span>)
  <span class="hljs-meta">@DefineParamTypes</span>(<span class="hljs-title class_">Number</span>, <span class="hljs-title class_">Number</span>)
  <span class="hljs-meta">@DefineReturnType</span>(<span class="hljs-title class_">Number</span>)
  <span class="hljs-title function_">add</span>(<span class="hljs-attr">source</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">input</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> source + input;
  }
}

<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();
<span class="hljs-comment">// [ [Function: Number], [Function: Number] ]</span>
<span class="hljs-keyword">const</span> paramTypes = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'design:paramtypes'</span>, foo, <span class="hljs-string">'add'</span>);
<span class="hljs-comment">// [Function: Number]</span>
<span class="hljs-keyword">const</span> returnTypes = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'design:returntype'</span>, foo, <span class="hljs-string">'add'</span>);
<span class="hljs-comment">// [Function: String]</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">type</span> = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'design:type'</span>, foo, <span class="hljs-string">'name'</span>);
</code></pre>
<p>需要注意的是，这一提案实际上并不依赖 TypeScript ，这些类型信息来自于运行时，而非我们的类型标注。同时这些内置元数据取出的值是装箱类型对象，如 String、Number 等。</p>
<p>TypeScript 为其进行了额外的支持，然后我们才可以获取到类型标注所对应的元数据，如：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> {
  <span class="hljs-meta">@DefineType</span>(<span class="hljs-title class_">Foo</span>)
  prop!: <span class="hljs-title class_">Foo</span>;
}

<span class="hljs-keyword">const</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>();
<span class="hljs-comment">// [class Foo]</span>
<span class="hljs-keyword">const</span> type2 = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'design:type'</span>, bar, <span class="hljs-string">'prop'</span>);
</code></pre>
<p>这也是为什么我们需要启用 <code>emitDecoratorMetadata</code> 配置的原因之一。上面的装饰器执行机制代码中我们看到了编译后的装饰器代码，而启用 <code>emitDecoratorMetadata</code> 后，产物中会多出这些代码：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> __metadata = (<span class="hljs-variable language_">this</span> &#x26;&#x26; <span class="hljs-variable language_">this</span>.<span class="hljs-property">__metadata</span>) || <span class="hljs-keyword">function</span> (<span class="hljs-params">k, v</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Reflect</span> === <span class="hljs-string">"object"</span> &#x26;&#x26; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">metadata</span> === <span class="hljs-string">"function"</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">metadata</span>(k, v);
};

<span class="hljs-title function_">__decorate</span>([
    <span class="hljs-title class_">Prop</span>(),
    <span class="hljs-title function_">__metadata</span>(<span class="hljs-string">"design:type"</span>, <span class="hljs-title class_">String</span>) <span class="hljs-comment">// 新增</span>
], <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">"prop"</span>, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>);

<span class="hljs-title function_">__decorate</span>([
    <span class="hljs-title class_">Method</span>(),
    <span class="hljs-title function_">__param</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Param</span>()),
    <span class="hljs-title function_">__metadata</span>(<span class="hljs-string">"design:type"</span>, <span class="hljs-title class_">Function</span>), <span class="hljs-comment">// 新增</span>
    <span class="hljs-title function_">__metadata</span>(<span class="hljs-string">"design:paramtypes"</span>, [<span class="hljs-title class_">String</span>]), <span class="hljs-comment">// 新增</span>
    <span class="hljs-title function_">__metadata</span>(<span class="hljs-string">"design:returntype"</span>, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) <span class="hljs-comment">// 新增</span>
], <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">"handler"</span>, <span class="hljs-literal">null</span>);

<span class="hljs-title class_">Foo</span> = <span class="hljs-title function_">__decorate</span>([
    <span class="hljs-title class_">Cls</span>(),
    <span class="hljs-title function_">__param</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Param</span>()),
    <span class="hljs-title function_">__metadata</span>(<span class="hljs-string">"design:paramtypes"</span>, [<span class="hljs-title class_">String</span>]) <span class="hljs-comment">// 新增</span>
], <span class="hljs-title class_">Foo</span>);
</code></pre>
<p>有了装饰器、反射元数据以及内置的基于类型的元数据信息，我们就可以实现“委托”的能力了。以看似平平无奇的属性装饰器为例，我们使用元数据来实现基于装饰器的属性校验。</p>
<p>在这个例子里，我们会实现两种校验逻辑，对必填属性（Required）与属性类型的校验（String / Number / Boolean），其基本使用方式如下：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-meta">@Required</span>()
  name!: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@ValueType</span>(<span class="hljs-title class_">TypeValidation</span>.<span class="hljs-property">Number</span>)
  age!: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
<span class="hljs-comment">// @ts-expect-error</span>
user.<span class="hljs-property">age</span> = <span class="hljs-string">'18'</span>;
</code></pre>
<p>我们会将 user 实例传递给校验方法，在这里应当给出两处错误：没有提供必填属性 name，以及 age 属性的类型不符。</p>
<p>如果理解了元数据的作用，那我们的思路就很明确了，装饰器将元数据附加到属性或类上，然后校验方法中遍历属性读取这些元数据，再对比类型是否匹配即可。</p>
<p>首先是 Required ，我们肯定下意识是这么写：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Required</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">PropertyDecorator</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, prop</span>) =></span> {
    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(<span class="hljs-string">"required"</span>, <span class="hljs-literal">true</span>, target, prop);
  };
}
</code></pre>
<p>也就是在这个属性上定义了一个名为 required 的元数据。但你是否想过，如果实例中根本就没有这个属性呢？就像上面的 user 一样，那这里的元数据不就丢失了？</p>
<p>要解决这一问题，其实只需要将元数据定义在类上即可。我们用一个专门描述必填属性的元数据，存储这个类内部所有的必填属性即可：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> requiredMetadataKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'requiredKeys'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Required</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">PropertyDecorator</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, prop</span>) =></span> {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">existRequiredKeys</span>: <span class="hljs-built_in">string</span>[] =
      <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(requiredMetadataKey, target) ?? [];

    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(
      requiredMetadataKey,
      [...existRequiredKeys, prop],
      target
    );
  };
}
</code></pre>
<p>而对于属性的校验其实就简单了，由于对类型的校验逻辑可以归到一起，我们就使用<strong>装饰器工厂 + 入参</strong>的形式来注入对应的元数据信息，这次我们只需要在属性层面注入元数据即可：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">TypeValidation</span> {
  <span class="hljs-title class_">String</span> = <span class="hljs-string">'string'</span>,
  <span class="hljs-title class_">Number</span> = <span class="hljs-string">'number'</span>,
  <span class="hljs-title class_">Boolean</span> = <span class="hljs-string">'boolean'</span>,
}

<span class="hljs-keyword">const</span> validationMetadataKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'expectedType'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ValueType</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: TypeValidation</span>): <span class="hljs-title class_">PropertyDecorator</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, prop</span>) =></span> {
    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(validationMetadataKey, <span class="hljs-keyword">type</span>, target, prop);
  };
}
</code></pre>
<p>然后就是校验逻辑了，我们需要一个额外的 validator 方法：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validator</span>(<span class="hljs-params">entity: <span class="hljs-built_in">any</span></span>) {}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">validator</span>(user));
</code></pre>
<p>如果校验完全通过，那这一方法的返回值则是一个空数组，否则的话内部会存有报错信息。首先是对于必填属性的校验，我们需要取出注册在类上的，描述必填属性的元数据，再检查这些必填属性是否都存在了：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validator</span>(<span class="hljs-params">entity: <span class="hljs-built_in">any</span></span>) {
  <span class="hljs-keyword">const</span> clsName = entity.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-attr">messages</span>: <span class="hljs-built_in">string</span>[] = [];
  <span class="hljs-comment">// 先检查所有必填属性</span>
  <span class="hljs-keyword">const</span> <span class="hljs-attr">requiredKeys</span>: <span class="hljs-built_in">string</span>[] = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(
    requiredMetadataKey,
    entity
  );

  <span class="hljs-comment">// 基于反射拿到所有存在的属性</span>
  <span class="hljs-keyword">const</span> existKeys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(entity);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> requiredKeys) {
    <span class="hljs-keyword">if</span> (!existKeys.<span class="hljs-title function_">includes</span>(key)) {
      messages.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${clsName}</span>.<span class="hljs-subst">${key}</span> should be required.`</span>);
      <span class="hljs-comment">// throw new Error(`${key} is required!`);</span>
    }
  }

  <span class="hljs-keyword">return</span> messages;
}
</code></pre>
<p>然后是对属性类型的校验，我们的 TypeValidation 枚举中，枚举值就是 <code>typeof</code> 的返回值，因此这里直接使用即可：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validator</span>(<span class="hljs-params">entity: <span class="hljs-built_in">any</span></span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// 接着基于定义在属性上的元数据校验属性类型</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> existKeys) {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">expectedType</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(
      validationMetadataKey,
      entity,
      key
    );

    <span class="hljs-keyword">if</span> (!expectedType) <span class="hljs-keyword">continue</span>;

    <span class="hljs-comment">// 枚举也是对象，因此 Object.values 同样可以生效（只不过也会包括键名）</span>
    <span class="hljs-comment">// @ts-expect-error</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(<span class="hljs-title class_">TypeValidation</span>).<span class="hljs-title function_">includes</span>(expectedType)) {
      <span class="hljs-keyword">const</span> actualType = <span class="hljs-keyword">typeof</span> entity[key];
      <span class="hljs-keyword">if</span> (actualType !== expectedType) {
        messages.<span class="hljs-title function_">push</span>(
          <span class="hljs-string">`expect <span class="hljs-subst">${entity.constructor.name}</span>.<span class="hljs-subst">${<span class="hljs-built_in">String</span>(
            key
          )}</span> to be <span class="hljs-subst">${expectedType}</span>, but got <span class="hljs-subst">${actualType}</span>.`</span>
        );
        <span class="hljs-comment">// throw new Error(`${String(key)} is not ${expectedType}!`);</span>
      }
    }
  }
  <span class="hljs-keyword">return</span> messages;
}
</code></pre>
<p>最终的输出会是这样的：</p>
<pre><code class="hljs language-css"><span class="hljs-selector-attr">[  <span class="hljs-string">'User.name should be required.'</span>,  <span class="hljs-string">'expect User.age to be number, but got string.'</span>]</span>
</code></pre>
<p>除了这两种校验，你也可以通过元数据的帮助来实现更复杂的校验逻辑。如 MinLength、MaxLength、Min、Max 甚至 Email、IP 这样，对属性值内容的校验。思路仍然还是那么简单明了：<strong>注册元数据，消费元数据</strong>。</p>
<h2>总结与预告</h2>
<p>这一节，我们了解了装饰器的基本概念，包括 TypeScript 中的五种装饰器，以及这些装饰器的入参、使用场景、执行顺序等等。另外我们还掌握了反射元数据的使用，目前看起来它好像并没有什么特别之处？那么在下一节，我们就会在反射元数据的基础上，去了解一个新的概念：控制反转。</p>
<h2>扩展阅读</h2>
<h3>装饰器的坎坷进历程</h3>
<p>正如我们在开头提到的，装饰器从被作为一个提案提出开始，很是经历了一番风雨，下面我们就来具体介绍一下它到底都经历了些什么。</p>
<p>首先需要明确的是，目前 JavaScript（ECMAScript）中的装饰器，和我们这节学习的 TypeScript 装饰器基本是两件完全不同的事物。<a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="nofollow noopener noreferrer">装饰器提案</a> 距离最开始提出已经过去了数年，在这期间提案内容，也就是语法、作用与运行时机制等，已经迭代了四个版本。</p>
<p>第四个版本在 2022 年 3 月份的 TC39 会议中终于如愿进入 Stage 3，也就意味着这一版本的实现基本上就是未来最终落地的版本。此前的版本都在 Stage 2 就胎死腹中，而 TypeScript 与 Babel 中的装饰器则是基于第一版的提案实现的，虽然语法都还是 <code>@</code> ，但这两个版本的装饰器实际上差异非常之大。</p>
<blockquote>
<p>如果你有兴趣了解新版装饰器的具体语义，可以阅读我此前发表的 <a href="https://mp.weixin.qq.com/s/6PTcjJQTED3WpJH8ToXInw" target="_blank" rel="nofollow noopener noreferrer">2022 年 3 月 TC39 会议报告</a> 来了解更多。另外，在 ECMAScript 装饰器进入 Stage 4，或已经有可用的编译支持（Babel / TypeScript ）后，我也会更新关于新版装饰器的使用说明。</p>
</blockquote>
<p>通常来说， TypeScript 只会对已经到达 Stage 3 的提案进行提前的支持，如可选链、空值合并、逻辑赋值等。当 TypeScript 最初引入装饰器时大概是在 2015 年，此时装饰器提案位于 Stage 1 阶段。</p>
<p>促使 TS 提前引入的一个重要原因是，当时存在一门 TS 的超集语言（也就是 JS 的超集的超集？）  <a href="https://en.wikipedia.org/wiki/AtScript" target="_blank" rel="nofollow noopener noreferrer">AtScript</a>，它在 TS 的基础上去支持了装饰器语法，来供 Angular 框架使用。TS 团队与 Angular 团队在某种契机下达成一致，决定将装饰器以及相关的注解能力直接引入 TypeScript 中，而 Angular 团队不再维护 AtScript ，这实际上避免了未来可能出现的竞争与社区生态分裂问题。</p>
<p>虽然这两个版本的装饰器确实差异很大，但你其实无需担心出现未来需要面对断崖式的更新，目前新版装饰器的能力基本上能完全覆盖旧版所能提供的能力，因此升级成本对于用户或者框架开发者来说都不会太高。而如果还想继续使用旧版装饰器怎么办？我猜 TypeScript 会通过引入一个新的 Compiler Option 来控制实际表现与编译产物。</p>
<h3>Reflect.decorate</h3>
<p>如果你去观察了装饰器的编译代码，会发现 <code>__decorate</code> 方法中有一段代码是检查 <code>Reflect.decorate</code> 方法是否存在。这一方法其实也来自于 Reflect Metadata，见 <a href="https://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L115" target="_blank" rel="nofollow noopener noreferrer">L115</a>。这一方法的作用就是，通过反射的方式来进行装饰，如：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {}

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">decorate</span>([<span class="hljs-comment">/** ...一组装饰器 */</span>], <span class="hljs-title class_">Foo</span>)
</code></pre>
<p>这也就意味着，你甚至可以<strong>在方法内部去装饰某一个类或其成</strong>员，而不是仅仅只能依赖需要提前定义好的装饰器。</p></div>
</body></html>