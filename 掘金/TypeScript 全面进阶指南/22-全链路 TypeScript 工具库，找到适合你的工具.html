<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>全链路 TypeScript 工具库，找到适合你的工具</h1>
<p>在前面两节，我们了解了 TypeScript 在 React 与 ESLint 中的集成，而在实际项目开发时，我们还会接触许多与 TypeScript 相关的工具。如果按照作用场景来进行划分，这些工具大致可以划分为开发、校验、构建、类型四类。在这一节我们将介绍一批 TypeScript 工具库，讲解它们的基本使用，你可以在这里查找是否有符合你需求的工具。</p>
<p>本节的定位类似于 GitHub 上的 awesome-xxx 系列，我们更多是在简单介绍工具的作用与使用场景，不会有深入的讲解与分析。同时，本节的内容会持续更新，如果你还使用过其他好用的工具库，欢迎在评论区留言，我会随着更新不断收录更多的工具库。</p>
<h2>开发阶段</h2>
<p>这一部分的工具主要在项目开发阶段使用。</p>
<h3>项目开发</h3>
<ul>
<li>
<p><a href="https://github.com/TypeStrong/ts-node" target="_blank" rel="nofollow noopener noreferrer">ts-node</a> 与 <a href="https://github.com/wclr/ts-node-dev" target="_blank" rel="nofollow noopener noreferrer">ts-node-dev</a>：我们在环境搭建一节中已经介绍过，用于直接执行 .ts 文件。其中 ts-node-dev 基于 ts-node 和 node-dev（类似于 nodemon）封装，能够实现监听文件改动并重新执行文件的能力。</p>
</li>
<li>
<p><a href="https://github.com/gilamran/tsc-watch" target="_blank" rel="nofollow noopener noreferrer">tsc-watch</a>：它类似于 ts-node-dev，主要功能也是监听文件变化然后重新执行，但 tsc-watch 的编译过程更明显，也需要自己执行编译后的文件。你也可以通过 onSuccess 与 onFailure 参数，来在编译过程成功与失效时执行不同的逻辑。</p>
<pre><code class="hljs language-bash"><span class="hljs-comment">## 启动 tsc --watch，然后在成功时执行编译产物</span>
tsc-watch --onSuccess <span class="hljs-string">"node ./dist/server.js"</span>

<span class="hljs-comment">## 在失败时执行</span>
tsc-watch --onFailure <span class="hljs-string">"echo 'Beep! Compilation Failed'"</span>
</code></pre>
</li>
<li>
<p><a href="https://github.com/esbuild-kit/esno" target="_blank" rel="nofollow noopener noreferrer">esno</a>，antfu 的作品。核心能力同样是执行 .ts 文件，但底层是 ESBuild 而非 tsc，因此速度上会明显更快。</p>
</li>
<li>
<p><a href="https://www.npmjs.com/package/typed-install" target="_blank" rel="nofollow noopener noreferrer">typed-install</a>，我们知道有些 npm 包的类型定义是单独的 <code>@types/</code> 包，但我们并没办法分辨一个包需不需要额外的类型定义，有时安装了才发现没有还要再安装一次类型也挺烦躁的。typed-install 的功能就是在安装包时自动去判断这个包是否有额外的类型定义包，并为你自动地进行安装。其实我也写过一个类似的：<a href="https://www.npmjs.com/package/install-with-typing" target="_blank" rel="nofollow noopener noreferrer">install-with-typing</a>。</p>
</li>
<li>
<p><a href="https://github.com/kawamataryo/suppress-ts-errors" target="_blank" rel="nofollow noopener noreferrer">suppress-ts-error</a>，自动为项目中所有的类型报错添加 <code>@ts-expect-error</code> 或 <code>@ts-ignore</code> 注释，重构项目时很有帮助。</p>
</li>
<li>
<p><a href="https://github.com/mattpocock/ts-error-translator" target="_blank" rel="nofollow noopener noreferrer">ts-error-translator</a>，将 TS 报错翻译成更接地气的版本，并且会根据代码所在的上下文来详细说明报错原因，目前只有英文版本，中文版本感觉遥遥无期，因为 TS 的报错实在太多了……</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a32aab7b4974a2e90f4110aab24dbc0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
</li>
</ul>
<h3>代码生成</h3>
<ul>
<li><a href="https://github.com/JoshuaKGoldberg/TypeStat" target="_blank" rel="nofollow noopener noreferrer">TypeStat</a>，能够将 JavaScript 文件转化为 TypeScript 文件，并在这个过程中去尝试提取类型。同时它也能够修正 TypeScript 中的 <code>--noImplicitAny</code> 以及 <code>--noImplicitThis</code> 错误。</li>
<li><a href="https://github.com/usabilityhub/ts-auto-guard" target="_blank" rel="nofollow noopener noreferrer">ts-auto-guard</a>，还记得我们在类型工具中学习的，基于 is 的类型守卫吗？有时候手动编写能够匹配运行时值类型的类型守卫会比较累人，你可以使用这个工具来自动基于接口生成类型守卫：</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// my-project/Person.guard.ts</span>

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Person</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Person'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPerson</span>(<span class="hljs-params">obj: <span class="hljs-built_in">unknown</span></span>): obj is <span class="hljs-title class_">Person</span> {
  <span class="hljs-keyword">const</span> typedObj = obj <span class="hljs-keyword">as</span> <span class="hljs-title class_">Person</span>
  <span class="hljs-keyword">return</span> (
    <span class="hljs-keyword">typeof</span> typedObj === <span class="hljs-string">'object'</span> &#x26;&#x26;
    <span class="hljs-keyword">typeof</span> typedObj[<span class="hljs-string">'name'</span>] === <span class="hljs-string">'string'</span> &#x26;&#x26;
    (<span class="hljs-keyword">typeof</span> typedObj[<span class="hljs-string">'age'</span>] === <span class="hljs-string">'undefined'</span> ||
      <span class="hljs-keyword">typeof</span> typedObj[<span class="hljs-string">'age'</span>] === <span class="hljs-string">'number'</span>) &#x26;&#x26;
    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(typedObj[<span class="hljs-string">'children'</span>]) &#x26;&#x26;
    typedObj[<span class="hljs-string">'children'</span>].<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">e</span> =></span> <span class="hljs-title function_">isPerson</span>(e))
  )
}
</code></pre>
<ul>
<li>
<p><a href="https://github.com/YousefED/typescript-json-schema" target="_blank" rel="nofollow noopener noreferrer">typescript-json-schema</a>，从 TypeScript 代码生成 JSON Schema，如以下代码：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> {
    <span class="hljs-comment">/**
     * The size of the shape.
     *
     * <span class="hljs-doctag">@minimum</span> 0
     * <span class="hljs-doctag">@TJS</span>-type integer
     */</span>
    <span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>;
}
</code></pre>
<p>会生成以下的 JSON Schema：</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"$ref"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"#/definitions/Shape"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"$schema"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"http://json-schema.org/draft-07/schema#"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"definitions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"Shape"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"size"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"description"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"The size of the shape."</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"minimum"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"integer"</span>
        <span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"object"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
</li>
<li>
<p><a href="https://github.com/bcherny/json-schema-to-typescript" target="_blank" rel="nofollow noopener noreferrer">json-schema-to-typescript</a>，和上面那位反过来，从 JSON Schema 生成 TypeScript 代码：</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"title"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Example Schema"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"object"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"firstName"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"string"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lastName"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"string"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"age"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"description"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Age in years"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"integer"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"minimum"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"hairColor"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"enum"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"black"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"brown"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"blue"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"string"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"additionalProperties"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"required"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"firstName"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"lastName"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleSchema</span> {
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/**
   * Age in years
   */</span>
  age?: <span class="hljs-built_in">number</span>;
  hairColor?: <span class="hljs-string">"black"</span> | <span class="hljs-string">"brown"</span> | <span class="hljs-string">"blue"</span>;
}
</code></pre>
</li>
</ul>
<p>需要注意的是，JSON Schema 并不是我们常见到的。描述实际值的 JSON，它更像是 TS 类型那样的<strong>结构定义</strong>，存在着值类型、可选值、访问性等相关信息的描述，如 required、type、description 等字段，因此它才能够与 TypeScript 之间进行转换。</p>
<h2>类型相关</h2>
<p>以下工具库主要针对类型，包括提供通用工具类型与对工具类型进行测试。</p>
<ul>
<li><a href="https://github.com/sindresorhus/type-fest" target="_blank" rel="nofollow noopener noreferrer">type-fest</a>，不用多介绍了，目前 star 最多下载量最高的工具类型库，Sindre Sorhus 的作品，同时也是个人认为最接地气的一个工具类型库。</li>
<li><a href="https://github.com/piotrwitek/utility-types" target="_blank" rel="nofollow noopener noreferrer">utility-types</a>，包含的类型较少，但这个库是我类型编程的启蒙课，我们此前对 FunctionKeys、RequiredKeys 等工具类型的实现就来自于这个库。</li>
<li><a href="https://www.npmjs.com/package/ts-essentials" target="_blank" rel="nofollow noopener noreferrer">ts-essentials</a></li>
<li><a href="https://github.com/pelotom/type-zoo" target="_blank" rel="nofollow noopener noreferrer">type-zoo</a></li>
<li><a href="https://github.com/millsp/ts-toolbelt" target="_blank" rel="nofollow noopener noreferrer">ts-toolbelt</a>，目前包含工具类型数量最多的一位，基本上能满足你的所有需要。</li>
<li><a href="https://www.npmjs.com/package/tsd" target="_blank" rel="nofollow noopener noreferrer">tsd</a>，用于进行类型层面的单元测试，即验证工具类型计算结果是否是符合预期的类型，也是 Sindre Sorhus 的作品，同时 type-fest 中工具类型的单元测试就是基于它。</li>
<li><a href="https://github.com/dsherret/conditional-type-checks" target="_blank" rel="nofollow noopener noreferrer">conditional-type-checks</a>，类似于 tsd，也是用于对类型进行单元测试。</li>
</ul>
<h2>校验阶段</h2>
<p>以下这些工具通常用于在项目逻辑中进行具有实际逻辑的校验（而不同于 tsd 仅在类型层面）。</p>
<h3>逻辑校验</h3>
<ul>
<li>
<p><a href="https://github.com/colinhacks/zod" target="_blank" rel="nofollow noopener noreferrer">zod</a>，核心优势在于与 TypeScript 的集成，如能从 Schema 中直接提取出类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = z.<span class="hljs-title function_">object</span>({
  <span class="hljs-attr">username</span>: z.<span class="hljs-title function_">string</span>(),
});

<span class="hljs-title class_">User</span>.<span class="hljs-title function_">parse</span>({ <span class="hljs-attr">username</span>: <span class="hljs-string">"Ludwig"</span> });

<span class="hljs-comment">// extract the inferred type</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = z.<span class="hljs-property">infer</span>&#x3C;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">User</span>>;
<span class="hljs-comment">// { username: string }</span>
</code></pre>
<p>我个人比较看好的一个库，在 tRPC、Blitz 等前后端一体交互的框架中能同时提供类型保障和 Schema 校验，同时和 Prisma 这一类库也有着很好地集成。最重要的是社区生态非常丰富，有许多自动生成的工具（<a href="https://github.com/rsinohara/json-to-zod" target="_blank" rel="nofollow noopener noreferrer">json-to-zod</a>、<a href="https://github.com/kbkk/abitia/tree/master/packages/zod-dto" target="_blank" rel="nofollow noopener noreferrer">zod-nest-dto</a> 等）。</p>
</li>
<li>
<p><a href="https://github.com/typestack/class-validator" target="_blank" rel="nofollow noopener noreferrer">class-validator</a>，TypeStack 的作品，基于装饰器来进行校验，我们会在后面的装饰器一节了解如何基于装饰器进行校验。</p>
</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Post</span> {
  <span class="hljs-meta">@Length</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Contains</span>(<span class="hljs-string">'hello'</span>)
  <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@IsInt</span>()
  <span class="hljs-meta">@Min</span>(<span class="hljs-number">0</span>)
  <span class="hljs-meta">@Max</span>(<span class="hljs-number">10</span>)
  <span class="hljs-attr">rating</span>: <span class="hljs-built_in">number</span>;

  <span class="hljs-meta">@IsEmail</span>()
  <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">let</span> post = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Post</span>();
post.<span class="hljs-property">title</span> = <span class="hljs-string">'Hello'</span>; <span class="hljs-comment">// 错误</span>
post.<span class="hljs-property">text</span> = <span class="hljs-string">'this is a great post about hell world'</span>; <span class="hljs-comment">// 错误</span>
post.<span class="hljs-property">rating</span> = <span class="hljs-number">11</span>; <span class="hljs-comment">// 错误</span>
post.<span class="hljs-property">email</span> = <span class="hljs-string">'google.com'</span>; <span class="hljs-comment">// 错误</span>

<span class="hljs-title function_">validate</span>(post).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">errors</span> =></span> {
  <span class="hljs-comment">// 查看是否返回了错误</span>
  <span class="hljs-keyword">if</span> (errors.<span class="hljs-property">length</span> > <span class="hljs-number">0</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'校验失败，错误信息: '</span>, errors);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'校验通过！'</span>);
  }
});
</code></pre>
<ul>
<li>
<p><a href="https://github.com/ianstormtaylor/superstruct" target="_blank" rel="nofollow noopener noreferrer">superstruct</a>，功能与使用方式类似于 zod，更老牌一些。</p>
</li>
<li>
<p><a href="https://github.com/sindresorhus/ow" target="_blank" rel="nofollow noopener noreferrer">ow</a>，用于函数参数的校验，我通常在 CLI 工具里大量使用。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> ow <span class="hljs-keyword">from</span> <span class="hljs-string">'ow'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">unicorn</span> = input => {
	<span class="hljs-title function_">ow</span>(input, ow.<span class="hljs-property">string</span>.<span class="hljs-title function_">minLength</span>(<span class="hljs-number">5</span>));

	<span class="hljs-comment">// …</span>
};

<span class="hljs-title function_">unicorn</span>(<span class="hljs-number">3</span>);
<span class="hljs-comment">//=> ArgumentError: Expected `input` to be of type `string` but received type `number`</span>

<span class="hljs-title function_">unicorn</span>(<span class="hljs-string">'yo'</span>);
<span class="hljs-comment">//=> ArgumentError: Expected string `input` to have a minimum length of `5`, got `yo`</span>
</code></pre>
</li>
<li>
<p><a href="https://github.com/pelotom/runtypes" target="_blank" rel="nofollow noopener noreferrer">runtypes</a>，类似于 Zod，也是运行时的类型与 Schema 校验。</p>
</li>
</ul>
<h3>类型覆盖检查</h3>
<ul>
<li><a href="https://github.com/alexcanessa/typescript-coverage-report" target="_blank" rel="nofollow noopener noreferrer">typescript-coverage-report</a>，检查你的项目中类型的覆盖率，如果你希望项目的代码质量更高，可以使用这个工具来检查类型的覆盖程度，从我个人使用经验来看，大概 95% 左右就是一个比较平衡的程度了。类似于 Lint 工具，如果使用这一工具来约束项目代码质量，也可以放在 pre-commit 中进行。</li>
<li><a href="https://github.com/plantain-00/type-coverage" target="_blank" rel="nofollow noopener noreferrer">type-coverage</a>，前者的底层依赖，可以用来定制更复杂的场景。</li>
</ul>
<h2>构建阶段</h2>
<p>以下工具主要在构建阶段起作用。</p>
<ul>
<li><a href="https://esbuild.github.io/" target="_blank" rel="nofollow noopener noreferrer">ESBuild</a>，应该无需过多介绍。需要注意的是 ESBuild 和 TypeScript Compiler 还是存在一些构建层面的差异，比如 ESBuild 无法编译装饰器（但可以使用插件，对含有装饰器的文件回退到 tsc 编译）。</li>
<li><a href="https://swc.rs/" target="_blank" rel="nofollow noopener noreferrer">swc</a>，也无需过多介绍。SWC 的目的是替代 Babel，因此它是可以直接支持装饰器等特性的。</li>
<li><a href="https://www.npmjs.com/package/fork-ts-checker-webpack-plugin" target="_blank" rel="nofollow noopener noreferrer">fork-ts-checker-webpack-plugin</a>，Webpack 插件，使用额外的子进程来进行 TypeScript 的类型检查（需要禁用掉 ts-loader 自带的类型检查）。</li>
<li><a href="https://github.com/privatenumber/esbuild-loader" target="_blank" rel="nofollow noopener noreferrer">esbuild-loader</a>，基于 ESBuild 的 Webpack Loader，放在这里是因为它基本可以完全替代 ts-loader 来编译 ts 文件。</li>
<li><a href="https://www.npmjs.com/package/rollup-plugin-dts" target="_blank" rel="nofollow noopener noreferrer">rollup-plugin-dts</a>，能够将你项目内定义与编译生成的类型声明文件重新进行打包。</li>
<li><a href="https://parceljs.org/" target="_blank" rel="nofollow noopener noreferrer">Parcel</a>，一个 Bundler，与 Webpack、Rollup 的核心差异是零配置，不需要任何 loader 或者 plugin 配置就能对常见基本所有的样式方案、语言方案、框架方案进行打包。我在之前搭过一个基于 Parcel 的项目起手式：<a href="https://github.com/LinbuduLab/Parcel-Tsx-Template" target="_blank" rel="nofollow noopener noreferrer">Parcel-Tsx-Template</a>，可以来感受一下<strong>零配置</strong>是什么体验。</li>
</ul>
<h2>总结与预告</h2>
<p>这一节我们汇总了各个场景下的 TypeScript 工具库，就像开头所说，本节的内容会持续更新，如果你还使用过其它让你赞不绝口的工具库，欢迎在评论区或答疑群提交给我。</p>
<p>下一节，我们会来了解一个对你来说可能熟悉又陌生的名词：ECMAScript，包括它到底代表了什么，和 TypeScript 的关系如何，TypeScript 中的 ECMAScript 语法如何使用，以及未来的 ECMAScript 怎么样。</p></div>
</body></html>