<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>对话框 3：如何使用 JSON 数据控制路径对话框？</h1>
<p>在上一节课程中，我们通过获取操作系统的版本号这个需求讲解了主进程发送消息给渲染进程的知识，同时还介绍了如何把这个交互过程封装成一个 Promise API。但是这个需求比较简单，没有涉及到在 JavaScript 和 C++ 之间传递复杂数据的知识。</p>
<p>本节课程我们就通过实现打开路径对话框的需求来讲解这些知识。</p>
<h2>JavaScript 传递复杂数据</h2>
<p>在以前的章节中我们曾经介绍过 JavaScript 的对话框（alert confirm prompt 和阻止页面关闭对话框），路径对话框与这些 JavaScript 对话框类似，唯一不同的地方就是路径对话框有很多可配置项，比如窗口标题，过滤字符串，默认路径，是否允许多选等。</p>
<p>我们计划在 JavaScript 代码中把这些配置项封装到一个 Json 对象中，然后把这个 Json 对象传递给渲染进程，再由渲染进程把这个 Json 对象传递给主进程，再由主进程使用这个 Json 对象携带的数据来打开路径对话框，当用户做出路径选择后，再由主进程封装一个新的 Json 对象并发送给渲染进程，渲染进程收到这个对象之后再传递给 JavaScript 代码，这样 JavaScript 代码就得到了用户选择的路径了。</p>
<p>计划确定之后，我们先从 JavaScript 代码着手开展工作，首先封装一个新的对象 <code>dialog</code>，代码如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> dialog = {
  <span class="hljs-function"><span class="hljs-title">getMsgName</span>(<span class="hljs-params">args</span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`dialog_<span class="hljs-subst">${args.callee.name}</span>`</span>;
  },
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">openFile</span>(<span class="hljs-params">param</span>)</span> {
    <span class="hljs-keyword">let</span> msgName = <span class="hljs-built_in">this</span>.getMsgName(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">let</span> resultStr = <span class="hljs-keyword">await</span> native.call(msgName, <span class="hljs-built_in">JSON</span>.stringify(param));
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(resultStr);
  },
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">openFolder</span>(<span class="hljs-params">param</span>)</span> {
    <span class="hljs-keyword">let</span> msgName = <span class="hljs-built_in">this</span>.getMsgName(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">let</span> resultStr = <span class="hljs-keyword">await</span> native.call(msgName, <span class="hljs-built_in">JSON</span>.stringify(param));
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(resultStr);
  },
};
</code></pre>
<p>这段代码中创建的 dialog 对象与我们前面一节课程介绍的 system 对象很相似，不过 dialog 对象的两个方法 <code>openFile</code> 和 <code>openFolder</code> 都向渲染进程传递了一个 <code>Json</code> 字符串，而且这两个方法都返回了一个 Json 对象，返回的 Json 对象我们稍后再介绍。先看着两个 Json 字符串是从何而来的。</p>
<p>这两个 Json 字符串是从一个 Json 配置对象中序列化来的，这个配置对象用于控制路径对话框的外观和行为，它是在按钮点击事件中定义的，代码如下所示：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> fileOpenBtn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#fileOpenBtn"</span>);
fileOpenBtn.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-keyword">async</span> () => {
  <span class="hljs-keyword">let</span> param = {
    <span class="hljs-attr">title</span>: <span class="hljs-string">"这是打开文件对话框的标题"</span>,
    <span class="hljs-attr">defaultPath</span>: <span class="hljs-string">"C:\\Program Files"</span>,
    <span class="hljs-attr">filters</span>: [<span class="hljs-string">"image/*"</span>, <span class="hljs-string">"text/*"</span>],
    <span class="hljs-attr">filterIndex</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">multiSelections</span>: <span class="hljs-literal">true</span>,
  };
  <span class="hljs-keyword">let</span> files = <span class="hljs-keyword">await</span> dialog.openFile(param);
  <span class="hljs-built_in">console</span>.log(files);
});
<span class="hljs-keyword">let</span> dirOpneBtn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#dirOpneBtn"</span>);
dirOpneBtn.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-keyword">async</span> () => {
  <span class="hljs-keyword">let</span> param = {
    <span class="hljs-attr">title</span>: <span class="hljs-string">"这是打开文件夹对话框的标题"</span>,
    <span class="hljs-attr">defaultPath</span>: <span class="hljs-string">"C:\\Program Files"</span>,
  };
  <span class="hljs-keyword">let</span> files = <span class="hljs-keyword">await</span> dialog.openFolder(param);
  <span class="hljs-built_in">console</span>.log(files);
});
</code></pre>
<p>Json 对象中 <code>title</code> 是对话框的标题，<code>defaultPath</code> 是对话框的默认路径，<code>filters</code> 是对话框文件过滤器数组，<code>filterIndex</code> 为默认对话框文件过滤器的下标，<code>multiSelections</code> 为是否允许用户在对话框中选择多个文件。</p>
<p>当用户点击按钮的时候，这个配置对象将被序列化成字符串再发送到渲染进程，接下来我们就看一下渲染进程的实现逻辑。</p>
<h2>渲染进程中转复杂数据</h2>
<p>我们知道 JavaScript 传递数据给渲染进程时最终执行的是渲染进程的 <code>V8Handler</code> 类的 <code>Execute</code> 方法，这个方法的 <code>arguments</code> 参数携带了 JavaScript 传递过来的参数，接下来我们看一下这个方法的代码：</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">V8Handler::Execute</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CefString&#x26; name, CefRefPtr&#x3C;CefV8Value> object, <span class="hljs-keyword">const</span> CefV8ValueList&#x26; arguments, CefRefPtr&#x3C;CefV8Value>&#x26; retval, CefString&#x26; exception)</span>
</span>{
    <span class="hljs-keyword">auto</span> msgName = arguments[<span class="hljs-number">0</span>]-><span class="hljs-built_in">GetStringValue</span>();
    <span class="hljs-keyword">if</span> (msgName == <span class="hljs-string">"native_registe_callback"</span>) {
        callBack = arguments[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    CefRefPtr&#x3C;CefProcessMessage> msg = CefProcessMessage::<span class="hljs-built_in">Create</span>(msgName);
    CefRefPtr&#x3C;CefListValue> msgBody =  msg-><span class="hljs-built_in">GetArgumentList</span>();
    <span class="hljs-keyword">if</span> (arguments.<span class="hljs-built_in">size</span>() > <span class="hljs-number">1</span> &#x26;&#x26; arguments[<span class="hljs-number">1</span>]-><span class="hljs-built_in">IsString</span>()) {
        msgBody-><span class="hljs-built_in">SetString</span>(<span class="hljs-number">0</span>, arguments[<span class="hljs-number">1</span>]-><span class="hljs-built_in">GetStringValue</span>());
    }
    CefRefPtr&#x3C;CefV8Context> context = CefV8Context::<span class="hljs-built_in">GetCurrentContext</span>();
    context.<span class="hljs-built_in">get</span>()-><span class="hljs-built_in">GetFrame</span>()-><span class="hljs-built_in">SendProcessMessage</span>(PID_BROWSER, msg);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};
</code></pre>
<p>我们在这段代码中增加了一个判断逻辑，如果 JavaScript 传递过来了 2 个以上的参数，并且第二个参数是字符串类型的话，那么我们就把这个参数附加到发送给主进程的消息体内。注意<strong>这里并没有做类型转换，JavaScript 传递来的是字符串，我们就原封不动把这个字符串转发给了浏览器进程</strong>。</p>
<p>浏览器进程才是处理配置对象的核心场所，接下来我们就看一下浏览器进程的处理逻辑。</p>
<h2>主进程处理复杂数据</h2>
<p>我们知道浏览器进程是通过 <code>PageHandler</code> 类的 <code>OnProcessMessageReceived</code> 方法来处理渲染进程发来的消息的，前面我们已经完成了 window、system 的处理逻辑，接下来我们就看一下 <code>dialog</code> 的处理逻辑，代码如下所示：</p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">"dialog"</span>) {
    CefRefPtr&#x3C;CefListValue> msgBody = message-><span class="hljs-built_in">GetArgumentList</span>();
    nlohmann::json param = nlohmann::json::<span class="hljs-built_in">parse</span>(msgBody-><span class="hljs-built_in">GetString</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">ToString</span>());
    std::wstring title = <span class="hljs-built_in">convertStr</span>(param[<span class="hljs-string">"title"</span>].get&#x3C;std::string>());
    std::wstring defaultPath = <span class="hljs-built_in">convertStr</span>(param[<span class="hljs-string">"defaultPath"</span>].get&#x3C;std::string>());
    CefRefPtr&#x3C;CefRunFileDialogCallback> dcb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DialogHandler</span>(messageName, frame);
    CefBrowserHost::FileDialogMode mode;
    std::vector&#x3C;CefString> fileFilters;
    <span class="hljs-keyword">int</span> filterIndex = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) == <span class="hljs-string">"openFile"</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> std::string&#x26; var : param[<span class="hljs-string">"filters"</span>]) {
            fileFilters.<span class="hljs-built_in">push_back</span>(var);
        }
        filterIndex = param[<span class="hljs-string">"filterIndex"</span>].get&#x3C;<span class="hljs-keyword">int</span>>();
        mode = param[<span class="hljs-string">"multiSelections"</span>].get&#x3C;<span class="hljs-keyword">bool</span>>() ? FILE_DIALOG_OPEN_MULTIPLE : FILE_DIALOG_OPEN;
        browser-><span class="hljs-built_in">GetHost</span>()-><span class="hljs-built_in">RunFileDialog</span>(mode, title, defaultPath, fileFilters, filterIndex, dcb);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) == <span class="hljs-string">"openFolder"</span>) {
        mode = FILE_DIALOG_OPEN_FOLDER;
        browser-><span class="hljs-built_in">GetHost</span>()-><span class="hljs-built_in">RunFileDialog</span>(mode, title, defaultPath, fileFilters, filterIndex, dcb);
    }
}
</code></pre>
<p>在这段代码中，我们获取到渲染进程发来的消息的第一项数据，也就 JavaScript 传来的 Json 字符串，并把这个 Json 字符串转化为一个 Json 对象。</p>
<p>转化过程是我们通过一个第三方 C++ 库完成的，这个库的开源地址为：<a href="https://github.com/nlohmann/json" target="_blank" rel="nofollow noopener noreferrer">https://github.com/nlohmann/json</a> ，只要把它的 <code>single_include/nlohmann</code> 目录下的 <code>json.hpp</code> 文件拷贝到自己的工程中，就可以通过<code>#include "Helper/json.hpp"</code>使用它了。</p>
<p><code>nlohmann::json::parse</code> 方法可以把一个字符串转化为一个 <code>nlohmann::json</code> 类型的 C++ 对象，转化成 C++ 对象之后就可以使用 <code>param["title"].get&#x3C;std::string>()</code> 这样的方式获取对象中的数据了。</p>
<p>由于这个库使用 <code>utf-8</code> 的编码格式反序列化 Json 字符串，所以包含中文的数据要经过一次转码才能使用（不然会出现乱码），<code>convertStr</code> 方法就是负责转码的工具函数，代码如下：</p>
<pre><code class="hljs language-c++"><span class="hljs-function">std::wstring <span class="hljs-title">convertStr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string&#x26; str)</span>
</span>{
    <span class="hljs-keyword">static</span> std::wstring_convert&#x3C;std::codecvt_utf8&#x3C;<span class="hljs-keyword">wchar_t</span>>> utf8_conv;
    <span class="hljs-keyword">return</span> utf8_conv.<span class="hljs-built_in">from_bytes</span>(str);
}
</code></pre>
<p>这个方法负责把 <code>std::string</code> 类型的数据转化为 <code>std::wstring</code> 类型的数据。</p>
<p>得到可用的配置数据之后，我们创建了一个自定义类型 <code>DialogHandler</code> 的对象。需要注意的是我们实例化 DialogHandler 对象时，把 <code>frame</code> 和 <code>messageName</code> 传递给了这个对象，当用户在路径对话框内做出选择之后（无论是选择了路径还是直接点击了取消按钮），CEF 框架会调用 DialogHandler 对象的 <code>OnFileDialogDismissed</code> 方法，在这个方法中我们使用 frame 和 messageName 向渲染进程发送消息，这部分逻辑我们稍后还会有详细介绍。</p>
<p><code>FileDialogMode</code> 是 CEF 定义的对话框类型枚举，CEF 定义了很多对话框类型，但这里我们只用到了三种：<strong>打开单个文件对话框、打开多个文件对话框、打开路径对话框</strong>。这个枚举的值是通过消息名称和配置对象的 <code>multiSelections</code> 属性共同决定的。</p>
<p><code>fileFilters</code> 是存储文件过滤器的容器，我们通过 <code>param["filters"]</code> 获取到 JavaScript 传递过来的过滤器数组之后，就把这个数组内的值填充到这个 C++ 容器中了。</p>
<p>准备好所有的对话框配置项之后，我们就通过 <code>BrowserHost</code> 对象的 <code>RunFileDialog</code> 方法打开了对话框，这个方法所需的参数就是我们前面准备好的配置项。</p>
<p>代码运行至此，路径对话框就被打开了，这里需要注意的是<strong>打开路径对话框之后我们并没有发送任何消息给渲染进程，也就是说此时 JavaScript 的 Promise 对象尚未成功 resolve</strong>。只有在用户做出选择（或者取消选择）之后，Promise 对象才会成功 resolve，而且此时 JavaScript 代码会得到用户选择的具体路径信息。</p>
<p>这些工作都是在 DialogHandler 类中完成的，接下来我们就看一下 DialogHandler 类的实现逻辑。</p>
<h2>路径对话框处理类</h2>
<p><code>DialogHandler</code> 类继承自 <code>CefRunFileDialogCallback</code> 基类，这个类只有一个有价值的方法：<code>OnFileDialogDismissed</code>，当路径对话框被关闭时，CEF 框架会主动调用这个方法，DialogHandler 类的代码如下所示：</p>
<pre><code class="hljs language-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"include/wrapper/cef_message_router.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"include/cef_browser.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Helper/json.hpp"</span></span>
<span class="hljs-keyword">using</span> nlohmann::json;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DialogHandler</span> :</span> <span class="hljs-keyword">public</span> CefRunFileDialogCallback
{
<span class="hljs-keyword">public</span>:
	<span class="hljs-built_in">DialogHandler</span>(std::string&#x26; msgName, CefRefPtr&#x3C;CefFrame> frame) :<span class="hljs-built_in">msgName</span>(msgName), <span class="hljs-built_in">frame</span>(frame) {};
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnFileDialogDismissed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> selected_accept_filter, <span class="hljs-keyword">const</span> std::vector&#x3C;CefString>&#x26; file_paths)</span> <span class="hljs-keyword">override</span> </span>{
		json result;
		result[<span class="hljs-string">"success"</span>] = <span class="hljs-literal">true</span>;
		result[<span class="hljs-string">"data"</span>] = {};
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &#x3C; file_paths.<span class="hljs-built_in">size</span>(); i++)
		{
			result[<span class="hljs-string">"data"</span>].<span class="hljs-built_in">push_back</span>(file_paths[i].<span class="hljs-built_in">ToString</span>());
		}
		CefRefPtr&#x3C;CefProcessMessage> msgBack = CefProcessMessage::<span class="hljs-built_in">Create</span>(msgName);
		CefRefPtr&#x3C;CefListValue> msgArgs = msgBack-><span class="hljs-built_in">GetArgumentList</span>();
		std::string dataStr = result.<span class="hljs-built_in">dump</span>();
		msgArgs-><span class="hljs-built_in">SetString</span>(<span class="hljs-number">0</span>, dataStr);
		frame-><span class="hljs-built_in">SendProcessMessage</span>(PID_RENDERER, msgBack);
	}
	<span class="hljs-built_in">DialogHandler</span>(<span class="hljs-keyword">const</span> DialogHandler&#x26;) = <span class="hljs-keyword">delete</span>;
	DialogHandler&#x26; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> DialogHandler&#x26;) = <span class="hljs-keyword">delete</span>;
<span class="hljs-keyword">private</span>:
	std::string msgName;
	CefRefPtr&#x3C;CefFrame> frame;
	<span class="hljs-built_in">IMPLEMENT_REFCOUNTING</span>(DialogHandler);
};
</code></pre>
<p>当 <code>OnFileDialogDismissed</code> 方法被执行时，我们创建了一个 <code>nlohmann::json</code> 类型的对象，用户选择的文件路径或目录路径将以字符串的形式存放在这个对象的 <code>data</code> 属性内。data 属性是一个数组类型的值，可以存放多个数据。我们可以使用这个 Json 对象的 <code>dump</code> 方法把这个 Json 对象序列化成字符串。</p>
<p>得到用户选择的数据之后，我们就把这个数据存放到进程间消息 <code>msgBack</code> 中了。最后通过 frame 对象把消息发回给渲染进程。frame 对象和 msgName 字符串都是在实例化 DialogHandler 对象时，通过构造函数传进来的。</p>
<p>渲染进程接到浏览器进程的消息之后，就会把这个消息发送给 JavaScript，由于 msgName 是在 JavaScript 发起异步请求前定义的，所以 JavaScript 收到这个返回的消息后，Promise 对象就会被成功 resolve 了（这些内容我们以前的章节都介绍过，这里不再赘述了），而且 resolve 得到的结果就是由用户选择的文件路径组成的 Json 字符串，接着我们使用 JSON.parse 方法把这个字符串序列化成 Json 对象，这就是前文 dialog.openFile 和 dialog.openFolder 方法的返回值。</p>
<p>至此我们就完成了使用 JavaScript 控制路径对话框的需求，你可以运行一下程序，看看程序运行结果是否符合预期。</p>
<h2>总结</h2>
<p>我们通过讲解如何使用 JavaScript 控制路径对话框这个需求讲解了如何在 JavaScript 与 C++ 间传递 Json 数据的知识。</p>
<p>值得注意的是<strong>我们实现的路径的对话框是模态的，也就是说当这个对话框弹出后，浏览器进程的所有操作都会被阻塞（渲染进程与 JavaScript 执行线程不会被阻塞）</strong>，你可以试试在弹出这个对话框之后再调用我们上一节介绍的获取系统版本号的 API，看看能得到结果吗？你会发现只有对话框关闭后，系统版本号才能正确返回给 JavaScript 调用者，这符合你的预期吗？</p>
<p>实际上我们在浏览器进程完成的几项任务都是在浏览器进程的主线程中完成的，也就是说这几项任务都是阻塞的，只不过获取版本号或者控制窗口这类操作在极短的时间内就完成了，所以我们感觉不到阻塞的影响。</p>
<p>有的时候开发者可能就是希望路径对话框阻塞主进程的其他操作，但类似读取文件这类任务就不应该出现阻塞的现象，我们下一节课程就以读文件为例介绍如何在主进程的不同线程下完成任务。</p>
<h2>源码</h2>
<p>本节示例代码请通过如下地址自行下载：</p>
<p><a href="https://gitee.com/horsejs_admin/cef-in-action/tree/PathDialog/" target="_blank" rel="nofollow noopener noreferrer">https://gitee.com/horsejs_admin/cef-in-action/tree/PathDialog/</a></p></div>
</body></html>