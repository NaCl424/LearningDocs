<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>专题式讲解 —— XA事务与两阶段提交</h1>
<h1>XA事务与两阶段提交</h1>
<p>标签： MySQL是怎样运行的</p>
<hr>
<h2>什么是分布式事务</h2>
<p>我们平常使用事务的时候，基本流程是这样的：</p>
<ul>
<li>使用<code>BEGIN/START TRANSACTION</code>来开启一个事务。</li>
<li>然后可以继续向服务器发送一些增删改查语句，这些语句都属于这个事务的一部分。</li>
<li>之后可以向服务器发送<code>COMMIT</code>语句来表明这个事务的所有语句都已经发送完了，服务器可以提交这个事务了。</li>
</ul>
<blockquote>
<p>小贴士：<br><br>
如果auto_commit系统变量值为1，并且我们未显式使用BEGIN/START TRANSACTION开启事务，那MySQL也会将单条语句当作是一个事务来执行。</p>
</blockquote>
<p>我们知道MySQL分为server层和存储引擎层，而<strong>事务具体是在存储引擎层实现的</strong>。有的存储引擎支持事务，有的不支持。</p>
<p>对于支持事务的存储引擎来说，它们提供了相应的开启事务、提交事务的接口。server层只需要调用这些接口，来让存储引擎执行事务。</p>
<p>除了MySQL自带的支持事务的存储引擎InnoDB外，其他一些公司也为MySQL开发了一些支持事务的存储引擎，比方说阿里的XEngine，Facebook的Rocksdb等。</p>
<p>在书写包含在一个事务中的语句时，不同语句可能会涉及不同存储引擎的表，这时如果我们想保持整个事务要么全部执行，要么全部不执行的话，本质上就需要保证各个存储引擎的事务全部提交，或者全部回滚。不能存在某些存储引擎事务提交了，某些存储引擎事务回滚了的情况。</p>
<p>稍微总结一下就是：我们有一个大的事务，我们可以称其为<code>全局事务</code>，这个全局事务由若干的小的事务组成。要实现这个大的事务，就必须让它对应的若干个小的事务全部完成，或者全部回滚。我们也可以把这个大的全局事务称作<code>分布式事务</code>。</p>
<p>除了上述涉及多个存储引擎的全局事务之外，<code>分布式事务</code>还有更多的应用场景。比方说我们的数据分布在多个MySQL服务器中；甚至有的数据分布在MySQL服务器中，有的数据分布在Oracle服务器中；甚至有些服务器在中国，有些服务器在美国。我们想完成一个操作，这个操作会更新多个系统里的数据，此时如果我们想让这个操作具有原子性，就需要保证让各个系统中的小事务要么全部提交，要么全部回滚。这时的这个跨多个系统的操作也可以被称作<code>分布式事务</code>。</p>
<p>跨行转账是一个典型的分布式事务的实例。各个银行都有自己的服务，如果狗哥在招商银行存了10块钱，他想把这10块钱转给猫爷在建设银行的账户，那么招商银行先得给狗哥账户扣10块，然后建设银行给猫爷账户增10块。而招商银行和建设银行根本就不是一个系统，招商银行给狗哥扣钱的业务放到了自己的一个事务里，建设银行给猫爷加钱的业务放到了自己的一个事务里，这两个事务其实在各自的系统中并没有什么关系，完全有可能招商银行的事务提交了，而建设银行的事务由于系统宕机而失败了，这就导致狗哥扣了钱，却没有转给猫爷的惨剧发生。所以我们必须引入一些机制，来实现<code>分布式事务</code>。</p>
<h2>XA规范</h2>
<p>有一个名叫<code>X/Open</code>（这名儿听着就挺霸气）的组织提出了一个名为<code>XA</code>的规范。</p>
<blockquote>
<p>小贴士：<br><br>
为节省同志们去搜索这份规范的宝贵时间，大家在“我们都是小青蛙”公众号输入“XA”即可下载该规范。</p>
</blockquote>
<p>有人说<code>XA</code>的含义是<code>Extended Architecture</code>。令人迷惑的是，我竟然没在上述规范中找到<code>XA</code>到底是个啥意思（很尴尬😅），大家把它理解成一个名字就好了，其实叫成<code>王尼玛</code>也没啥问题。</p>
<p>这个XA规范提出了2个角色：</p>
<ul>
<li>一个全局事务由多个小的事务组成，所以我们得在某个地方找一个总揽全局的家伙，这个家伙用于和各个小事务进行沟通，指导它们是提交还是回滚。这个家伙被称作事务协调器（Transaction Coordinator）或者资源管理器（Resource Manager）。</li>
</ul>
<p>不论是<code>事务协调器</code>，还是<code>资源管理器</code>这样的名字念起来都比较拗口，有催眠功效，我们后续就把<code>事务协调器</code>或者<code>资源管理器</code>称作<code>大哥</code>了哈。</p>
<ul>
<li>管理一个小事务的家伙被称作事务管理器（Transaction Manager）。</li>
</ul>
<p><code>事务管理器</code>念起来也比较拗口，我们就把它称作<code>小弟</code>了哈。</p>
<p>要提交一个全局事务，那么属于该全局事务的若干个小事务就应该全部提交，只要有任何一个小事务无法提交，那么整个全局事务就应该全部回滚。所以此时<code>大哥</code>不能让各个<code>小弟</code>逐个提交，因为不能保证后面提交的<code>小弟</code>是否可能发生错误。此时XA规范中指出，要提交一个全局事务，必须分为2步：</p>
<ul>
<li>
<p>Prepare阶段：当<code>大哥</code>准备提交一个全局事务时，会依次通知各个<code>小弟</code>说：“现在事务中的语句都已经执行完了，我们准备提交了，你这里有没有什么问题？”。如果<code>小弟</code>觉得自己没有问题，就把在事务执行过程中所产生的redo日志都刷新到硬盘，然后对<code>大哥</code>说：“没有问题”。如果<code>小弟</code>遇到了啥突发情况不能提交（比方说磁盘满了，不能写redo了），就对大哥说：“不行，提交不了了”。</p>
</li>
<li>
<p>Commit阶段：如果在Prepare阶段各个<code>小弟</code>给<code>大哥</code>的答复都是:“OK，木有问题”，那<code>大哥</code>就要真正通知各个小弟去提交事务了。如果在Prepare阶段某个<code>小弟</code>给<code>大哥</code>的回复是：“NO，做不了”，那<code>大哥</code>就得通知所有<code>小弟</code>：“遇到突发情况，所有人立即回滚”。<code>小弟</code>收到通知便都回滚了。<strong>不过在<code>大哥</code>通知各个<code>小弟</code>是要提交之前，都需在某个地方记录一下这个全局事务已经提交，以及各个小弟都是什么的信息。</strong></p>
</li>
</ul>
<p>XA规范把上述全局事务提交时所经历的两个阶段称作<code>两阶段提交</code>。</p>
<blockquote>
<p>小贴士：<br><br>
如果一个全局事务仅包含一个<code>小弟</code>的话，那两阶段提交可以退化成1阶段提交。</p>
</blockquote>
<p>大家可以看到，XA规范引入了一个在事务提交时的<code>Prepare阶段</code>，这个阶段就是让各个事务做好提交前的准备，具体就是把语句执行过程中产生的redo日志都刷盘。如果语句执行过程中的redo日志都刷盘了，那么即使之后系统崩溃，那么在重启的时候还是可以恢复到该事务各个语句都执行完的样子。</p>
<p>这样的话，在Prepare阶段结束后，即使某个小弟因为某些原因而崩溃，在之后重启恢复时，也可以把自己再次恢复成<code>Prepare</code>状态。<strong>在崩溃恢复结束后，大哥可以继续让小弟提交或者回滚。</strong></p>
<p>以上就是XA规范的核心内容，下边可以来唠叨一下MySQL对上述XA规范的实现了。</p>
<h2>MySQL中的XA事务</h2>
<p>MySQL中的XA事务分为<code>外部XA</code>和<code>内部XA</code>，我们分别来看一下。</p>
<h3>外部XA</h3>
<p>在MySQL的<code>外部XA</code>实现中，MySQL服务器充当<code>小弟</code>，而连接服务器的客户端程序充当<code>大哥</code>。</p>
<p>与使用<code>BEGIN</code>语句开启，使用<code>COMMIT</code>提交的常规事务不同，如果我们想在MySQL中使用XA事务，需要一些特殊的语句：</p>
<ul>
<li><code>XA {START|BEGIN} xid</code>：该语句用于开启一个XA事务，此时该XA事务处于<code>ACTIVE</code>状态。</li>
</ul>
<p>在一台MySQL服务器上，每个XA事务都必须有一个唯一的id，被称作<code>xid</code>。这个xid是由发起XA事务的应用程序（客户端）自己指定的，只要我们自己保证它唯一就好了。</p>
<p>这个<code>xid</code>其实是由<code>gtrid</code>、<code>bqual</code>、<code>formatID</code>三个部分组成的：</p>
<pre><code>xid: gtrid [, bqual [, formatID ]]
</code></pre>
<p>其中<code>gtrid</code>（global transaction id）是指全局事务id，是一个<strong>字符串</strong>，<code>bqual</code>是指分支限定符，<code>formatID</code>是指gtrid和bqual所使用的格式。</p>
<p>不过我们这里并不打算详纠啥是个分支，还限定符，以及啥格式之类的，我们可以在指定<code>xid</code>的时候省略<code>bqual</code>和<code>formatID</code>的值，MySQL会使用默认的值（<code>bqual</code>默认是空字符串''，<code>formatID</code>默认是1）。也就是说我们文章后续内容指定<code>xid</code>时仅指定<code>gtrid</code>就好了，也就是指定一个<strong>字符串</strong>即可。</p>
<ul>
<li>
<p><code>XA END xid</code>：在使用<code>XA START xid</code>开启了一个XA事务后，客户端就可以接着发送属于这个XA事务的各条语句，等所有语句都发送完毕后，就可以接着发送<code>XA END xid</code>来告知服务器由<code>xid</code>标识的XA事务的所有语句都输入完了。此时该XA事务处于<code>IDLE</code>状态。</p>
</li>
<li>
<p><code>XA PREPARE xid</code>：对于处于<code>IDLE</code>状态的XA事务，应用程序就可以询问MySQL服务器是否准备好提交这个XA事务了，此时就可以给服务器发送<code>XA PREPARE xid</code>语句。当MySQL服务器收到此语句后，就需要做准备提交前的工作了，比如把该事务执行过程中所产生的redo日志刷新到磁盘等。此时XA事务处于<code>PREPARE</code>状态。</p>
</li>
<li>
<p><code>XA COMMIT xid [ONE PHASE]</code>：对于处于<code>PREPARE</code>状态的XA事务，应用程序可以发送<code>XA COMMIT xid</code>来让MySQL服务器提交XA事务。如果此XA事务尚处于<code>IDEL</code>状态，那应用程序可以不发送<code>XA PREPARE xid</code>，而直接发送<code>XA COMMIT xid ONE PHASE</code>来让MySQL服务器直接提交事务即可。此XA事务处于<code>COMMITE</code>状态。</p>
</li>
<li>
<p><code>XA ROLLBACK xid</code>：应用程序通过发送此语句来让MySQL服务器回滚xid所标识的事务。此时XA事务处于<code>ABORT</code>状态。</p>
</li>
<li>
<p><code>XA RECOVER</code>：应用程序想看一下当前MySQL服务器上已经处于Prepare状态的XA事务有哪些，就可以发送该语句。</p>
</li>
</ul>
<p>介绍了在MySQL中使用<code>外部XA</code>的一些语句，接下来可以画一个XA事务的状态转换图了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0710b0b3a10346a8b59836eebb212278~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>哔哔了很多，赶紧来做个实验：</p>
<pre><code>mysql> XA START 'a';    //XA事务进入ACTIVE状态
Query OK, 0 rows affected (0.00 sec)

mysql> DELETE FROM x WHERE id = 1;  //XA事务中包含的语句
Query OK, 1 row affected (0.00 sec)

mysql> XA END 'a';      //XA事务进入IDEL状态
Query OK, 0 rows affected (0.00 sec)

mysql> XA PREPARE 'a';  //XA事务进入PREPARE状态
Query OK, 0 rows affected (0.01 sec)

mysql> XA COMMIT 'a';   //XA事务进入COMMIT状态
Query OK, 0 rows affected (0.01 sec)
</code></pre>
<p>MySQL的外部XA除了被用于跨行转账这种经典的分布式事务应用场景，还被广泛应用于所谓的<code>数据库中间件</code>。</p>
<p>现在各个公司由于表中数据太多，这些数据会被分散在不通服务器中存储。由应用程序员分别和不同的MySQL服务器打交道实在费劲，所以有一种称作<code>数据库中间件</code>的东西开始问世。即应用程序只将SQL语句发送给数据库中间件，中间件分析一下该SQL访问的数据都在哪些不同的服务器中存储着，并且计算出不通服务器应该执行哪些SQL语句。然后就可以对不同的服务器分别开启XA事务，并且让把不同服务器需要执行的语句分别发送到不同的服务器中。等应用程序员告知中间件准备提交事务时，中间件先给各个服务器发送<code>XA PREPARE</code>语句，如果各个服务器都返回OK的话，接着就给各个服务器发送<code>XA COMMIT</code>语句来提交XA事务，等各个服务器把提交成功的消息返回给中间件，中间件就可以通知应用程序事务提交成功了。</p>
<h3>内部XA</h3>
<p>对于一台服务器来说，即使客户端使用<code>BEGIN/START TRANSACTION</code>语句开启的普通事务，该事务所包含的语句也有可能涉及多个存储引擎。此时MySQL内部采用XA规范来保证所有支持事务的存储引擎要么全部提交，要么全部回滚，这也被称作MySQL的<code>内部XA</code>。</p>
<p>另外有一点值得注意的是，<code>内部XA</code>除了解决这种设计多个存储引擎的事务之外，还解决保证binlog和存储引擎所做的修改是一致的问题。我们稍后重点展开一下这个问题。</p>
<p>在MySQL内部执行一个事务时，存储引擎会修改相应的数据，server层会记录语句对应的binlog。这是两个要么都完成，要么都步完成的事情。否则的话：</p>
<ul>
<li>
<p>如果存储引擎修改了相应数据并且提交了事务，而server层却未写入binlog。在有主从复制的场景中，意味着这个事务不会在从库中得已执行，从而造成主从之间的数据不一致。</p>
</li>
<li>
<p>如果server层写入了binlog，但存储引擎却回滚了事务。在有主从复制的场景中，意味着这个事务会在从库中得已执行，从而造成主从之间的数据不一致。</p>
</li>
</ul>
<p>那我们需要保证：<strong>如果存储引擎提交了事务，server层的binlog日志必须也被写入到硬盘上；如果存储引擎回滚了事务，server层的binlog日志必须不能被写入到硬盘上</strong>。</p>
<p>MySQL采用<code>内部XA</code>来实现上述内容，下边以Innodb存储引擎为例，具体讨论一下Innodb事务的提交和binlog日志写入的过程。</p>
<h2>有binlog参与的内部XA事务</h2>
<blockquote>
<p>小贴士：<br><br>
后续会用到很多undo日志结构的内容，这些内容都在《MySQL是怎样运行的：从根儿上理解MySQL》书籍中有详细叙述，如果不了解的话，看起来可能会有点儿困难，建议先将undo日志章节内容看熟。</p>
</blockquote>
<p>当客户端执行<code>COMMIT</code>语句或者在自动提交的情况下，MySQL内部开启一个XA事务，分两阶段来完成XA事务的提交：</p>
<ul>
<li>Prepare阶段：存储引擎将该事务执行过程中产生的redo日志刷盘，并且将本事务的状态设置为<code>PREPARE</code>。binlog啥也不干。下边看一下具体的代码。</li>
</ul>
<p><code>binlog_prepare</code>是在PREPARE阶段对binlog所做的一些操作：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7c5fcf038804a038a9ad4c653342831~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><code>binlog_prepare</code>函数基本啥也没干，我们就不展开说了。</p>
<p><code>innobase_xa_prepare</code>是InnoDB存储引擎实现的XA规范的prepare接口：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96973190bde74a56a0830e34cf81ec36~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个函数做了很多事情，我们得好好唠叨一下。</p>
<p>首先我们知道事务执行过程中需要写undo日志，这些undo日志被写到若干个页面中，这些页面也被称作<code>Undo页面</code>，这些页面会串成一个链表，称作<code>Undo页面</code>链表。在一个事务对应的Undo页面链表的首个页面中，记录了一些关于这个事务的一些属性，我们贴个图看一下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a32bb3d49e2448658f7498abafaf832c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我们先看一下其中的<code>Undo Log Segment Header</code>部分：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07f4ca85ffba492a9bc4c630013b7bc3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>其中的<code>TRX_UNDO_STATE</code>字段就表明该事务目前处于什么状态。当处于Prepare阶段时，调用<code>innobase_xa_prepare</code>函数会将<code>TRX_UNDO_STATE</code>字段的值设置为<code>TRX_UNDO_PREPARED</code>（整数5），表明当前事务处在Prepare阶段。</p>
<p>我们再看一下<code>Undo Log Header</code>部分：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4804c72202f48a687d8cf6965b54348~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个部分体现着这个<code>Undo页面链表</code>所属的事务的各种信息，包括事务id。其中两个属性和我们今天主题特别搭：</p>
<ul>
<li><code>TRX_UNDO_XID_EXISTS</code>：表示有没有xid信息。</li>
<li><code>XID信息</code>：表示具体的xid是什么。</li>
</ul>
<p>当处于Prepare阶段时，调用<code>innobase_xa_prepare</code>函数会将<code>TRX_UNDO_XID_EXISTS</code>设置为TRUE，并将本次内部XA事务的<code>xid</code>（这个xid是MySQL自己生成的）写入<code>XID信息</code>处。</p>
<blockquote>
<p>小贴士：<br><br>
再一次强调，修改Undo页面也是在修改页面，事务凡是修改页面就需要先记录相应的redo日志。</p>
</blockquote>
<p>记录了关于该事务的各种属性之后，接下来该将到现在为止所产生的所有redo日志进行刷盘，刷盘的函数如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/092d5f17321d49afbf20e86132e22ebe~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>在将redo日志刷盘之后，即使之后系统崩溃，在重启恢复的时候也可以将处于Prepare状态的事务完全恢复。</p>
<blockquote>
<p>小贴士：<br><br>
在MySQL 5.7中，有一个称之为<code>组提交</code>（group commit）的优化。即设计InnoDB的大叔觉得各个事务分别刷自己的redo日志和binlog效率太低，他们把并发执行的多个事务所产生的redo日志和binlog在后续的Commit阶段集中起来统一刷新，这样可能提升效率，所以在MySQL 5.7以及之后的版本中，上述在Prepare阶段刷新redo日志的操作会被推迟到Commit阶段才真正执行。关于<code>组提交</code>的优化措施我们并不想过多展开，大家忽略这个优化就好了，这里就认为在Prepare阶段事务就已经将执行过程中产生的redo日志刷盘就OK。</p>
</blockquote>
<ul>
<li>Commit阶段：先将事务执行过程中产生的binlog刷新到硬盘，再执行存储引擎的提交工作。</li>
</ul>
<p>将binlog刷盘的函数如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb59b4d9c0124c6494971e09eacb14d8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>InnoDB存储引擎提交事务使用<code>innobase_commit</code>函数完成存储引擎层面的事务提交：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff4a85ae423445ce980e66290ce3a976~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><code>innobase_commit</code>函数做了很多事情，我们挑一些重要的来说。</p>
<p>首先是更新<code>Undo页面链表</code>的状态，将我们上边说的<code>Undo Log Segment Header</code>部分的STATE字段更新一下。更新规则如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5b500e0d49f4e4db02353e59f06818f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>也就是说如果当前事务产生的undo日志比较少，那么就继续让别的事务复用该<code>Undo页面链表</code>，将STATE设置为<code>TRX_UNDO_CACHED</code>；如果<code>Undo页面链表</code>用于存储INSERT操作产生的undo日志，那么就将STATE设置为<code>TRX_UNDO_TO_FREE</code>，稍后会释放<code>Undo页面链表</code>占用的页面；如果<code>Undo页面链表</code>用于存储其他操作产生的undo日志，那么就将STATE设置为<code>TRX_UNDO_TO_PURGE</code>，等待purge线程后台回收该<code>Undo页面链表</code>。</p>
<blockquote>
<p>小贴士：<br><br>
UPDATE、DELETE操作产生的undo日志可能会用于其他事务的MVCC操作，所以不能立即删除。</p>
</blockquote>
<p>对于存储UPDATE、DELETE操作产生的undo日志的<code>Undo页面链表</code>，还要将其加入所谓的History链表，关于这个History链表是啥，我们这里就不展开了。</p>
<p>每个<code>Undo页面链表</code>的首个页面的页号会被存储在表空间的某个地方，以便崩溃恢复的时候可以根据该页来进行恢复。如果此时在事务提交时，<code>Undo页面链表</code>的状态被设置为<code>TRX_UNDO_CACHED</code>，那存储<code>Undo页面链表</code>的首个页面的页号的地方也就不需要做改动；如果此时在事务提交时，<code>Undo页面链表</code>的状态被设置为<code>TRX_UNDO_CACHED</code>，那存储<code>Undo页面链表</code>的首个页面的页号的地方就得被设置为空，这样这个地方就可以被其他事务使用了。</p>
<p>至此，这个事务就算是提交完了。</p>
<h2>崩溃恢复</h2>
<p>每当系统重启时，都会先进入恢复过程。</p>
<p>此时首先按照已经刷新到磁盘的redo日志修改页面，把系统恢复到崩溃前的状态。</p>
<p>然后在表空间中找一下各个<code>Undo页面链表</code>的首个页面的页号，然后就可以读取该页面的各种信息。我们再把这个页面的内容给大家看一下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63f7a21f94e04fa094a863880a65eb0f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>通过这个页面，我们可以知道该<code>Undo页面链表</code>对应的事务状态是什么：</p>
<ul>
<li>
<p>如果是<code>TRX_UNDO_ACTIVE</code>状态，也就是活跃状态，直接按照undo日志里记载的内容将其回滚就好了。</p>
</li>
<li>
<p>如果是<code>TRX_UNDO_PREPARE</code>状态，那么是提交还是回滚就取决于binlog的状态了，我们稍后再说。</p>
</li>
<li>
<p>如果是其他状态，就将该事务提交即可。</p>
</li>
</ul>
<p>对于处于PREPARE状态的事务，存储引擎既可以提交，也可以回滚，这取决于目前该事务对应的binlog是否已经写入硬盘。这时就会读取最后一个binlog日志文件，从日志文件中找一下有没有该PREPARE事务对应的xid记录，如果有的话，就将该事务提交，否则就回滚好了。</p>
<h2>最后</h2>
<p>这一篇文章有点儿长，不点赞/在看/分享，真的好么～</p></div>
</body></html>