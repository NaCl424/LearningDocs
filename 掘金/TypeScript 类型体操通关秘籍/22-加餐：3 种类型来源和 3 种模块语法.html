<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>加餐：3 种类型来源和 3 种模块语法</h1>
<p>TypeScript 给 JavaScript 添加了一套类型语法，我们声明变量的时候可以给变量加上类型信息，这样编译阶段就可以检查出变量使用的对不对，也就是类型检查。</p>
<p>给变量添加类型，很自然可以想到时在声明的时候指定：</p>
<p>比如对象：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Person {
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
    age?: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> guang: Person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'guang'</span>
}
</code></pre>
<p>比如函数：</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1: <span class="hljs-built_in">number</span>, num2: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{
    <span class="hljs-keyword">return</span> num1 + num2;
}
</code></pre>
<p>这样当使用它们的时候，比如变量赋值、函数调用，就可以通过类型信息检查出使用的对不对：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18c1067053754da1b23abbde5b8e8110~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d203439ac79c4c0d83c3ea1d9b3c675f~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>TypeScript 这样设计类型语法没啥问题，但是只是这样还不够。</p>
<p>我们自己写的代码可以这样声明类型，但不是我们写的呢？</p>
<p>比如 JS 引擎提供的 Number、String、Date、RegExp，浏览器环境的 HTMLElement、Event 等 api。</p>
<p>这些 api 是执行引擎内置的实现，但我们代码里会用到它们，也同样需要检查使用的对不对，也就是类型检查。怎么给这些 api 加上类型呢？</p>
<h2>TypeScript 类型声明的三种来源</h2>
<p>TypeScript 设计了 declare 的语法，可以单独声明变量的类型：</p>
<p>比如对象：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Person {
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
    age?: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> guang: Person;
</code></pre>
<p>比如函数：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1: <span class="hljs-built_in">number</span>, num2: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;
</code></pre>
<p>这样单独声明了类型，使用这些 api 的时候也就能做类型检查。</p>
<p>像 JS 引擎那些 api，还有浏览器提供的 api，这些基本是必用的，而且都有标准的。所以 TypeScript 给内置了它们的类型声明。</p>
<p>TypeScript 包下有个 lib 目录，里面有一堆 lib.xx.d.ts 的类型声明文件，这就是 TS 内置的一些类型声明。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c67a7818d32249269ac8ebdd96787a76~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/452c218beebe495f9e23e37efb89dd94~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>因为这些只是声明类型，而没有具体的 JS 实现，TS 就给单独设计了一种文件类型，也就是 d.ts， d 是 declare 的意思。</p>
<p>比如 lib.dom.d.ts 里的类型声明：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35ddc8f8c22b4074992857e99789c903~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>因为是 ts 内置的，所以配置一下就可以用了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2a586d8004049e194a110cd23982a6f~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>tsconfig.json 里配置下 compilerOptions.lib，就可以引入对应的 d.ts 的类型声明文件。</p>
<p>有的同学可能会说，可是内置的类型声明也不多呀，只有 dom 和 es 的。</p>
<p>确实，因为 JS 的 api 还有浏览器的 api 都是有标准的，那自然可以按照标准来定义类型。其余的环境的 api 可能没有标准，经常变，那自然就没法内置了，比如 node。所以 lib 里只有 dom 和 es 的类型声明。</p>
<p>那 node 环境，还有其他环境里的内置 api 怎么配置类型声明呢？</p>
<p>node 等环境的 api 因为没有标准而没有被 TS 内置，但 TS 同样也支持了这些环境的类型声明的配置。</p>
<p>方式是通过 @types/xxx 的包：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9778d228e72843b1b6567e49fb9accd6~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>TS 会先加载内置的 lib 的类型声明，然后再去查找 @types 包下的类型声明。</p>
<p>这样，其他环境的类型声明就可以通过这种方式来扩展。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74b45cde7be94785948429a71e1ebb77~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>@types 包是在 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/README.zh.md" target="_blank" rel="nofollow noopener noreferrer">DefinitelyTyped</a> 这个项目下统一管理的，想创建一个 @types 包的话要去看一下他们的文档。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aab5ef6002c54213bce055f463720b68~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>一般来说，很快就可以发到 npm 的：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cc4766a3ffc43d5a4ea465edec456db~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>我们知道，TS 内置的那些 lib 是可以配置的，扩展的这些 @types/xx 的包自然也可以配置：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89863c6e73fb4c9c9fa532239f0062de~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>可以指定加载 @types 目录下的哪些包，还可以修改查找 @types 包的目录（默认是 node_modules/@types)：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97cd492ca69249c8b886cbcc39c22390~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>除了给 node 等环境的 api 加上类型声明外，@types 包还有一种用途，就是给一些 JS 的包加上类型声明：</p>
<p>如果代码本身是用 ts 写的，那编译的时候就可以开启 compilerOptions.declaration，来生成 d.ts 文件：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8712a57078514d8cb97cd0cccc235fc2~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>然后在 package.json 里配置 types 来指定 dts 的位置：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c4f190636de46359b3440b3be7fc1f9~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>这样就不需要单独的 @types 包了。</p>
<p>但如果代码不是用 ts 写的，那可能既需要单独写一个 @types/xxx 的包来声明 ts 类型，然后在 tsconfig.json 里配置下，加载进来。</p>
<p>比如常用的 vue3 就不需要 @types/vue 包，因为本身是用 ts 写的，npm 包里也包含了 dts 文件。</p>
<p>但是 react 不是 ts 写的，是用的 facebook 自己的 flow，自然就需要 @types/react 的包来加上 ts 类型声明。</p>
<p>至此，ts 内置的 dom 和 es 的类型声明，其他环境还有一些包的类型声明我们都知道怎么加载了。</p>
<p>那自己写的 ts 代码呢？</p>
<p>这些其实我们经常配置，就是配置下编译的入口文件，通过 includes 指定一堆，然后通过 excludes 去掉一部分。还可以通过 files 再单独包含一些：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f280facf1dcc4ec08b4f739b4b9c0ba4~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>tsc 在编译的时候，会分别加载 lib 的，@types 下的，还有 include 和 files 的文件，进行类型检查。</p>
<p>这就是 ts 类型声明的三种来源。</p>
<p>现在还有一个问题，有的 api 是全局的，有的 api 是某个模块的，ts 是怎么声明全局 api 的类型，怎么声明模块内的 api 的类型呢？</p>
<h2>全局类型声明 vs 模块类型声明</h2>
<p>我们写的 JS 代码就是有的 api 是全局的，有的 api 是模块内的，所以 TS 需要支持这个也很正常。</p>
<p>但 JS 的模块规范不是一开始就有的，最开始是通过在全局挂一个对象，然后这个对象上再挂一些 api 的方式，也就是命名空间 namespace。</p>
<p>所以 TS 最早支持的模块化方案自然也就是 namespace：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">namespace</span> Guang {
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Person {
        <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
        age?: <span class="hljs-built_in">number</span>;
    }

    <span class="hljs-keyword">const</span> name = <span class="hljs-string">'guang'</span>;
    <span class="hljs-keyword">const</span> age = <span class="hljs-number">20</span>;

    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> guang: Person = {
        name,
        age
    }
    <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>):<span class="hljs-title">number</span> </span>{
        <span class="hljs-keyword">return</span> a + b;
    }
}
</code></pre>
<p>理解 namespace 的话可以看一下编译后的代码：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c094481781546508551a06dfd9bc80b~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>就是全局上放一个对象，然后对象上再挂几个暴露出去的属性。</p>
<p>看了编译后的代码，是不是 namespace 瞬间就学会了～</p>
<p>后来，出现了 CommonJS 的规范，那种不能叫 namespace 了，所以 TS 支持了 module，</p>
<p>很容易想到，@types/node 的 api 定义就是一堆的 module：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbb6767321e64d25985384af5568cd65~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>这个 module 和 namespace 有什么区别呢？</p>
<p>其实真没什么区别，只不过 module 后一般接一个路径，而 namespace 后一般是一个命名空间名字。其他的语法都一样的。</p>
<p>而且这个结论是有依据的：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dec4bdeacf6a4a17a1f7adfbe16a9ac9~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c77268d47ca41e2a042734bcab2b424~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>用 <a href="https://astexplorer.net" target="_blank" rel="nofollow noopener noreferrer">astexplorer.net</a> 看一下 parse 后的 AST，两者的 AST类型都是一样的。也就是说编译器后续的处理都一样，那不是一种东西是什么。</p>
<p>再后来的故事大家都知道了，JS 有了 es module 规范，所以现在推荐直接用 import export 的方式来声明模块和导入导出了。</p>
<p>额外多了的，只不过有一个 import type 的语法，可以单独引入类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {xxx} <span class="hljs-keyword">from</span> <span class="hljs-string">'yyy'</span>;
</code></pre>
<p>所以现在声明模块不咋推荐用 namespace 和 module，还是尽量用 es module 吧。</p>
<p>那全局的类型声明呢？</p>
<p>有了 es module 之后，TS 有了一个单独的设计：</p>
<p><strong>dts 中，如果没有 import、export 语法，那所有的类型声明都是全局的，否则是模块内的。</strong></p>
<p>我们试验一下：</p>
<p>include 配置 src 下的 ts 文件，然后再用 files 引入 global.d.ts 文件：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14f5c8b9fb9b41239a23e97b5d4dd295~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>在 global.d.ts 里声明一个 func 函数：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6adbf7d853043c99e9742135e50d2b3~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>在 src/index.ts 里是有提示的：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2442225f75b14fc3bcf46ff3e0863926~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>编译也不报错：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66aefdb9f62a46d6b1e10dc94723c970~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>加上一个 import 语句：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbc08a3c490f4f03846d7777b9e417bb~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>编译就报错了，说是找不到 func：
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16f35249ce194944bc4c1e6cb37845b2~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>这说明 func 就不再是全局的类型了。</p>
<p>这时候可以手动 declare global：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2d36f271f364478a430e83866f0fb32~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>再试一下，编译就通过了：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92dc60483aec429abc80f167ac2928fc~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>而且不止是 es module 的模块里可以用 global 声明全局类型，module 的方式声明的 CommonJS 模块也是可以的：</p>
<p>比如 @types/node 里就有不少这种全局类型声明：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21dd101b6d414b5180594083372d91b2~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>这就是 3 种 typescript 声明模块的语法，以及声明全局类型的方式。</p>
<p>那么如果就是需要引入模块，但是也需要全局声明类型，有什么更好的方式呢？</p>
<p>有，通过编译器指令 reference。这样既可以引入类型声明，又不会导致所有类型声明都变为模块内的：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/608e41bb549f4e7caf4f873761c6be9e~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>可以看到很多 dts 都这样引入别的 dts 的，就是为了保证引入的类型声明依然是全局的：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04e331aef1d8412a828776db010e49e5~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<h2>总结</h2>
<p>TypeScript 给 JavaScript 添加了类型信息，在编译时做类型检查。</p>
<p>除了在变量声明时定义类型外，TS 也支持通过 declare 单独声明类型。只存放类型声明的文件后缀是 d.ts。</p>
<p>TypeScript 有三种存放类型声明的地方：</p>
<ul>
<li>lib： 内置的类型声明，包含 dom 和 es 的，因为这俩都是有标准的。</li>
<li>@types/xx： 其他环境的 api 类型声明，比如 node，还有 npm 包的类型声明</li>
<li>开发者写的代码：通过 include + exclude 还有 files 指定</li>
</ul>
<p>其中，npm 包也可以同时存放 ts 类型，通过 packages.json 的 types 字段指定路径即可。</p>
<p>常见的是 vue 的类型是存放在 npm 包下的，而 react 的类型是在 @types/react 里的。因为源码一个是 ts 写的，一个不是。</p>
<p>巧合的是，TS 声明模块的方式也是三种：</p>
<ul>
<li>namespace：最早的实现模块的方式，编译为声明对象和设置对象的属性的 JS 代码，很容易理解</li>
<li>module：和 namespace 的 AST 没有任何区别，只不过一般用来声明 CommonJS 的模块，在 @types/node 下有很多</li>
<li>es module：es 标准的模块语法，ts 额外扩展了 import type</li>
</ul>
<p>dts 的类型声明默认是全局的，除非有 es module 的 import、export 的声明，这时候就要手动 declare global 了。为了避免这种情况，可以用 reference 的编译器指令。</p>
<p><strong>学习类型定义是怎么给 JS 加上类型，学习类型编程是怎么动态生成类型和对类型做修改，这些类型可能会通过模块或全局的方式来组织，所以还需要学习模块语法，而且可能会放在 lib、@types/xxx、用户目录等位置，还要学习不同来源的类型的查找机制。</strong></p>
<p>深入掌握 TypeScript 的话，除了学习类型定义以及类型编程，这三种类型声明的来源（lib、@types、用户目录），以及三种模块声明的方式（namespace、module、es module），还有全局类型的声明（global、reference），也都是要掌握的。</p></div>
</body></html>