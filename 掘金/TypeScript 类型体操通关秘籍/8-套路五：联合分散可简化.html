<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>套路五：联合分散可简化</h1>
<p>联合类型在类型编程中是比较特殊的，TypeScript 对它做了专门的处理，写法上可以简化，但也增加了一些认知成本。</p>
<p>这是类型体操的第五个套路：联合分散可简化。</p>
<h2>分布式条件类型</h2>
<p><strong>当类型参数为联合类型，并且在条件类型左边直接引用该类型参数的时候，TypeScript 会把每一个元素单独传入来做类型运算，最后再合并成联合类型，这种语法叫做分布式条件类型。</strong></p>
<p>比如这样一个联合类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Union = <span class="hljs-string">'a'</span> | <span class="hljs-string">'b'</span> | <span class="hljs-string">'c'</span>;
</code></pre>
<p>我们想把其中的 a 大写，就可以这样写：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> UppercaseA&#x3C;Item <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> = 
    Item <span class="hljs-keyword">extends</span> <span class="hljs-string">'a'</span> ?  Uppercase&#x3C;Item> : Item;
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/842143798583491aae9dbec0da327da8~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>可以看到，我们类型参数 Item 约束为 string，条件类型的判断中也是判断是否是 a，但传入的是联合类型。</p>
<p>这就是 TypeScript 对联合类型在条件类型中使用时的特殊处理：会把联合类型的每一个元素单独传入做类型计算，最后合并。</p>
<p>这和联合类型遇到字符串时的处理一样：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b29105cf568f4eeeac7240f7f4b5619f~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>这样确实是简化了类型编程逻辑的，不需要递归提取每个元素再处理。</p>
<p>TypeScript 之所以这样处理联合类型也很容易理解，因为联合类型的每个元素都是互不相关的，不像数组、索引、字符串那样元素之间是有关系的。所以设计成了每一个单独处理，最后合并。</p>
<p>知道了 TypeScript 怎么处理的联合类型，趁热打铁来练习一下：</p>
<h2>CamelcaseUnion</h2>
<p>Camelcase 我们实现过，就是提取字符串中的字符，首字母大写以后重新构造一个新的。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Camelcase&#x3C;Str <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> = 
    Str <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Left}</span>_<span class="hljs-subst">${infer Right}</span><span class="hljs-subst">${infer Rest}</span>`</span>
    ? <span class="hljs-string">`<span class="hljs-subst">${Left}</span><span class="hljs-subst">${Uppercase&#x3C;Right>}</span><span class="hljs-subst">${Camelcase&#x3C;Rest>}</span>`</span>
    : Str;
</code></pre>
<p>提取 _ 左右的字符，把右边字符大写之后构造成新的字符串，余下的字符串递归处理。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bc1e45afeb244e9a64be8ef9aeba12a~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>如果是对字符串数组做 Camelcase，那就要递归处理每一个元素：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> CamelcaseArr&#x3C;
  Arr <span class="hljs-keyword">extends</span> unknown[]
> = Arr <span class="hljs-keyword">extends</span> [infer Item, ...infer RestArr]
  ? [Camelcase&#x3C;Item &#x26; <span class="hljs-built_in">string</span>>, ...CamelcaseArr&#x3C;RestArr>]
  : [];
</code></pre>
<p>类型参数 Arr 为待处理数组。</p>
<p>递归提取每一个元素做 Camelcase，因为 Camelcase 要求传入 string，这里要 &#x26; string 来变成 string 类型。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30fa987f5f7741e3b23255035aa0e27f~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>那如果是联合类型呢？</p>
<p>联合类型不需要递归提取每个元素，TypeScript 内部会把每一个元素传入单独做计算，之后把每个元素的计算结果合并成联合类型。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> CamelcaseUnion&#x3C;Item <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> = 
  Item <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Left}</span>_<span class="hljs-subst">${infer Right}</span><span class="hljs-subst">${infer Rest}</span>`</span> 
    ? <span class="hljs-string">`<span class="hljs-subst">${Left}</span><span class="hljs-subst">${Uppercase&#x3C;Right>}</span><span class="hljs-subst">${CamelcaseUnion&#x3C;Rest>}</span>`</span> 
    : Item;
</code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31fe16b1436f41578fbd65dc7bcfb102~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/FAFwngDgpgBAwgQwLZQDYGMEGcoB4DKIATjFAB4hQB2AJljFsQJZUDmAfDALwzAz8xCJcpVr0ABgBIA3iwBmUEgBkockAF8A+jPmKYAJSasAFhp1UFJfVEbrxfAQH4YU6SrXqZAVQjQimHFxDExB2T2lEFAxsPGtGMPsBGAAuQWIAbmBQSFhItACoOIBXVBBueGR8mNwAcgQETXrGhBr2TOzoCqiCgEEiIlwHPuEKajoYIqoAayoAewB3KgBtAF1gTh5h0lGxGCXdEgBJSiQAGhgAOiuDgxsQYbX+ZyW86MDjqCQYADIGZjZ2OcrhdXr1+kE7sN2I8UnsVu1wJ1QTFhsVSuVkThhrglnUGk16jVzjUAEYkzRkikkokwGrodCaemM9A1FZtLKI3KVN5QLxUJizKi4D5fERjeiMIgsDjlBwi7aicauG7uDTaWQWPTBUzhG5xDTiXhJZyuVXhHx+ApBIymMIyTG8-mCiHxOxGgSpEUInJdKo4PkCqhoso8B0B5145rNGowAA+tMpiepcdpTLTLLaQA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>这不和单个字符串的处理没区别么？</p>
<p>没错，对联合类型的处理和对单个类型的处理没什么区别，TypeScript 会把每个单独的类型拆开传入。不需要像数组类型那样需要递归提取每个元素做处理。</p>
<p>确实简化了很多，好像都是优点？</p>
<p>也不全是，其实这样处理也增加了一些认知成本，不信我们再来看个例子：</p>
<h2>IsUnion</h2>
<p>判断联合类型我们会这样写：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> IsUnion&#x3C;A, B = A> =
    A <span class="hljs-keyword">extends</span> A
        ? [B] <span class="hljs-keyword">extends</span> [A]
            ? <span class="hljs-literal">false</span>
            : <span class="hljs-literal">true</span>
        : <span class="hljs-built_in">never</span>
</code></pre>
<p>当传入联合类型时，会返回 true：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/978314675e0f448f9d0c0e6cd643fbd8~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>当传入其他类型时，会返回 false：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f947f111a34c4bb4b338243a7030651f~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAkgzgVQHYEsD2SA8BBANFAISgF4psA+EgKClrKggA9gIkATOMmungfigDaBALoNmrDoOzDuPOVH4AzAIYAbOBFny6ALijAATgFdN2qHqQQAbhANUqoSLESoMAJQhwjq4CWfJ0LAByZSCAHyCAI3CggGMYtiDyAG57R2h4APdPb2AAJj9M1ywBKBCgqDCy6Mqy+OEUoA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>是不是在心里会问：什么鬼？这段逻辑是啥？</p>
<p>这就是分布式条件类型带来的认知成本。</p>
<p>我们先来看这样一个类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> TestUnion&#x3C;A, B = A> = A  <span class="hljs-keyword">extends</span> A ? { <span class="hljs-attr">a</span>: A, <span class="hljs-attr">b</span>: B} : <span class="hljs-built_in">never</span>;

<span class="hljs-keyword">type</span> TestUnionResult = TestUnion&#x3C;<span class="hljs-string">'a'</span> | <span class="hljs-string">'b'</span> | <span class="hljs-string">'c'</span>>;
</code></pre>
<p>传入联合类型 'a' | 'b' | 'c' 的时候，结果是这样的：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/551f7861406c4ba591f6c50ffe17b153~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>A 和 B 都是同一个联合类型，为啥值还不一样呢？</p>
<p>因为条件类型中如果左边的类型是联合类型，会把每个元素单独传入做计算，而右边不会。</p>
<p>所以 A 是 'a' 的时候，B 是 'a' | 'b' | 'c'， A 是 'b' 的时候，B 是 'a' | 'b' | 'c'。。。</p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAKhDOwCqA7AlgexQHgIIBooAhKAXilwD4yKooIAPYCFAE3loH4oBvKAQwBcFQgCNhRAL5RhKCADcIAJwDcAKDWhIsBMnRYASggCuAG2A04iVJhwByfnagAfKHdFPXdgMZ3KKoA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>那么利用这个特点就可以实现 Union 类型的判断：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> IsUnion&#x3C;A, B = A> =
    A <span class="hljs-keyword">extends</span> A
        ? [B] <span class="hljs-keyword">extends</span> [A]
            ? <span class="hljs-literal">false</span>
            : <span class="hljs-literal">true</span>
        : <span class="hljs-built_in">never</span>
</code></pre>
<p>类型参数 A、B 是待判断的联合类型，B 默认值为 A，也就是同一个类型。</p>
<p>A extends A 这段看似没啥意义，主要是为了触发分布式条件类型，让 A 的每个类型单独传入。</p>
<p>[B] extends [A]  这样不直接写 B 就可以避免触发分布式条件类型，那么 B 就是整个联合类型。</p>
<p>B 是联合类型整体，而 A 是单个类型，自然不成立，而其它类型没有这种特殊处理，A 和 B 都是同一个，怎么判断都成立。</p>
<p>利用这个特点就可以判断出是否是联合类型。</p>
<p>其中有两个点比较困惑，我们重点记一下：</p>
<p><strong>当 A 是联合类型时：</strong></p>
<ul>
<li>
<p><strong>A extends A 这种写法是为了触发分布式条件类型，让每个类型单独传入处理的，没别的意义。</strong></p>
</li>
<li>
<p><strong>A extends A 和 [A] extends [A] 是不同的处理，前者是单个类型和整个类型做判断，后者两边都是整个联合类型，因为只有 extends 左边直接是类型参数才会触发分布式条件类型。</strong></p>
</li>
</ul>
<p>理解了这两点，分布式条件类型就算掌握了。</p>
<p>掌握了难点之后，我们再做些练习：</p>
<h2>BEM</h2>
<p>bem 是 css 命名规范，用 block__element--modifier 的形式来描述某个区块下面的某个元素的某个状态的样式。</p>
<p>那么我们可以写这样一个高级类型，传入 block、element、modifier，返回构造出的 class 名：</p>
<p>这样使用：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> bemResult = BEM&#x3C;<span class="hljs-string">'guang'</span>, [<span class="hljs-string">'aaa'</span>, <span class="hljs-string">'bbb'</span>], [<span class="hljs-string">'warning'</span>, <span class="hljs-string">'success'</span>]>;
</code></pre>
<p>它的实现就是三部分的合并，但传入的是数组，要递归遍历取出每一个元素来和其他部分组合，这样太麻烦了。</p>
<p>而如果是联合类型就不用递归遍历了，因为联合类型遇到字符串也是会单独每个元素单独传入做处理。</p>
<p>数组转联合类型可以这样写：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf5ac5ee90d44f24a06fae128c43ecb3~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>那么 BEM 就可以这样实现：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> BEM&#x3C;
    Block <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,
    Element <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[],
    Modifiers <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[]
> = <span class="hljs-string">`<span class="hljs-subst">${Block}</span>__<span class="hljs-subst">${Element[<span class="hljs-built_in">number</span>]}</span>--<span class="hljs-subst">${Modifiers[<span class="hljs-built_in">number</span>]}</span>`</span>;
</code></pre>
<p>类型参数 Block、Element、Modifiers 分别是 bem 规范的三部分，其中 Element 和 Modifiers 都可能多个，约束为 string[]。</p>
<p>构造一个字符串类型，其中 Element 和 Modifiers 通过索引访问来变为联合类型。</p>
<p>字符串类型中遇到联合类型的时候，会每个元素单独传入计算，也就是这样的效果：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b7efa1dc1714cbe9b19138bac87e257~tplv-k3u1fbpfcp-watermark.image?" alt="">
<a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAQgogWQDwCgrtgGwPYGMDWUEAHsBAHYAmAzlNcAE4CW5A5gDRoZyYQC2FYEVIUadRi1YBtALqcMUBNkpMAZkwgNaJMlVr1mbWSgB8UALxQABgBIA3jBwEAvgH1X9nv0FTyAVz4AI00ZZwBaMPslFXVNal8A4IZQqwBuFAzQSChgvgAlCGo-TCFLeGQAclY-AEM2CvYoKQqa1oaoCsCuirkmioB3GoZySXaKotxcQuoek1SgA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>可以看到，用好了联合类型，确实能简化类型编程逻辑。</p>
<h2>AllCombinations</h2>
<p>我们再来实现一个全组合的高级类型，也是联合类型相关的：</p>
<p>希望传入 'A' | 'B' 的时候，能够返回所有的组合： 'A' | 'B' | 'BA' | 'AB'。</p>
<p>这种全组合问题的实现思路就是两两组合，组合出的字符串再和其他字符串两两组和：</p>
<p>比如 'A' | 'B' | 'c'，就是 A 和 B、C 组合，B 和 A、C 组合，C 和 A、B 组合。然后组合出来的字符串再和其他字符串组合。</p>
<p>任何两个类型的组合有四种：A、B、AB、BA</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Combination&#x3C;A <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, B <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> =
    | A
    | B
    | <span class="hljs-string">`<span class="hljs-subst">${A}</span><span class="hljs-subst">${B}</span>`</span>
    | <span class="hljs-string">`<span class="hljs-subst">${B}</span><span class="hljs-subst">${A}</span>`</span>;
</code></pre>
<p>然后构造出来的字符串再和其他字符串组合。</p>
<p>所以全组合的高级类型就是这样：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> AllCombinations&#x3C;A <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, B <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> = A> = 
    A <span class="hljs-keyword">extends</span> A
        ? Combination&#x3C;A, AllCombinations&#x3C;Exclude&#x3C;B, A>>>
        : <span class="hljs-built_in">never</span>;
</code></pre>
<p>类型参数 A、B 是待组合的两个联合类型，B 默认是 A 也就是同一个。</p>
<p>A extends A 的意义就是让联合类型每个类型单独传入做处理，上面我们刚学会。</p>
<p>A 的处理就是 A 和 B 中去掉 A 以后的所有类型组合，也就是 Combination&#x3C;A, B 去掉 A 以后的所有组合>。</p>
<p>而 B 去掉 A 以后的所有组合就是 AllCombinations&#x3C;Exclude&#x3C;B, A>>，所以全组合就是 Combination&#x3C;A, AllCombinations&#x3C;Exclude&#x3C;B, A>>>。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba9469c0c3ea4ac0a5e1ebe96ac8bb1f~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>这里利用到了分布式条件类型的特性，通过 A extends A 来取出联合类型中的单个类型。</p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAwg9gWwEYEsB2BDYK5oDwCCUEAHsBGgCYDOU1wATugOYA0UAQsWRTXYywB8UALwAoKJKgAfKAQlTZHBZNkADACQBvAgF9tHXWpUyomrYe161AbgljQkOQBtn8ZOiw401Qt3JUtPRMaGyc-rxBAqGicsIichGBciYA-LCIqJjYuITsBK7uWV64vgCiJADGzgCulBB4HPmCLSYAXFBoEABuEAx2DuDQBW6Znjk+AEoQ1DXOwLEjRePevgDkBGumaxxbsmswa4I2QA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h2>总结</h2>
<p><strong>联合类型中的每个类型都是相互独立的，TypeScript 对它做了特殊处理，也就是遇到字符串类型、条件类型的时候会把每个类型单独传入做计算，最后把每个类型的计算结果合并成联合类型。</strong></p>
<p>条件类型左边是联合类型的时候就会触法这种处理，叫做分布式条件类型。</p>
<p>有两点特别要注意：</p>
<ul>
<li>
<p>A extends A 不是没意义，意义是取出联合类型中的单个类型放入 A</p>
</li>
<li>
<p>A extends A 才是分布式条件类型， [A] extends [A] 就不是了，只有左边是单独的类型参数才可以。</p>
</li>
</ul>
<p>我们后面做了一些案例，发现联合类型的这种 distributive 的特性确实能简化类型编程，但是也增加了认知成本，不过这也是不可避免的事。</p>
<p><a href="https://www.typescriptlang.org/play?#code/PTAEGEEMFsFMBsDGkDOsBQAXAngB1hDAsmgDwDKmATqLAB6awB2AJiqCtQJZMDmAfKAC8odKHGhKNeo1bsABgBIA3jwBmsGgBlYazAF8A+ivWbQAJS68AFgZNMNNc7E775YiQH5QS5Tr36KgCquPhUJLCkljaY-IHKUHBIqJHOnHHuEqAAXJLUANzoWHgEicQpaQCu8JjChEkRpADkkJCGre2QTfyFxfj15WgAglRUpB4j0gzMbKCVTADWTAD2AO5MANoAuuiCIpO003KgG6Y0AJKM0AA0oAB0D2cWLpiTO+LeG2XJZJew0KAAGQcbh8fi3B53b4RSZRF6TfjvHInLa9HD9aEpSZVGp1THDUakDYtNodVpNW5NABGVMMNLpVIpoCaiEQhlZ7MQTS2PSK6NKRB+sCCTC4yyYpD+AJkM3YnCoPAEdQ8UsOslmvie-gMxlUDjM0Vs8SeaQM8lEWW8vm18RCYUahti8XxwtF4rh6TcFokuSlaJKAyFIrFTBxtRELuD7pJnU6TVAAB9mfSU4zE8yOZmubz0CBQOcUFGmHyAwWi6QhrcAEJ1IZ7DziIZq2WgIYNrKgT5VrbN44bIZIjsd7xqSDwNDtofiXLUSoYKfIpiwABumhL-TLbtDLmq4fzha3zS6CepTRPXJPLG6-o3B5DYYATHVNyGicyuunT5+uTzenmACovEWfQEIBnDlpWoA1vseytuIMrHE23jKKAkC5JBVK5FW+iLiumg3qBQFbmGdRgZg5YtPGSZftR2Z-mAVYAKIALIgVBLHjFkVbwMsiALL2szyoq1ztox8D-MwtQIYJoK8NsIlZMxywsFwahcJo7DSXKsnbLsdS+NxvELEYupiRJTCYBsTCVNAVKaFs+gALSOSoSkqWpGlWTZdlUA58i9GxdnQCRIhMcxzS8JUkB8EyxKtF0lI0oyWy3MSqyQFQooxZSKCVKyLgoNyOZ5kM8DwOAyy2TwkCYCGKBsRVVVMDVr5NlpIIKnw1YCdpnVKkI7ZJm2WRJlWg0+CoQzxNhmQSEmBnxFN-liGxpXlZVVLVbV4ooBWPUdcJUH7UJfC1rBbVHLMw1eBAG1ba1txrY1m3NdtTC7YxdCIPAlQsJEVaPfwQPtrkS6rlQBGtmVz33TtIVQ+tTUtTtzRDFRzJVujTTgNeQA" target="_blank" rel="nofollow noopener noreferrer">本文案例的合并</a></p></div>
</body></html>