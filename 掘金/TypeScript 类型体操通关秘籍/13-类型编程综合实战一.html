<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>类型编程综合实战一</h1>
<p>我们学会了 6 个类型体操的套路，各种高级类型都能写出来，也知道了类型体操的意义（类型之间有关联的时候必须要类型编程，用类型编程能做到更精准的类型提示和检查），但是做的练习还是不够多。</p>
<p>前面的案例更多是用于讲某个套路的，这节开始我们做一些比较综合的案例。</p>
<h2>KebabCaseToCamelCase</h2>
<p>常用的变量命名规范有两种，一种是 KebabCase，也就是 aaa-bbb-ccc 这种中划线分割的风格，另一种是 CamelCase， 也就是 aaaBbbCcc 这种除第一个单词外首字母大写的风格。</p>
<p>如果想实现 KebabCase 到 CamelCase 的转换，该怎么做呢？</p>
<p>比如从 guang-and-dong 转换成 guangAndDong。</p>
<p>这种明显是要做字符串字面量类型的提取和构造，并且因为单词数量不确定，要递归地处理。</p>
<p>所以是这样写：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">KebabCaseToCamelCase</span>&#x3C;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> = 
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Item}</span>-<span class="hljs-subst">${infer Rest}</span>`</span> 
        ? <span class="hljs-string">`<span class="hljs-subst">${Item}</span><span class="hljs-subst">${KebabCaseToCamelCase&#x3C;Capitalize&#x3C;Rest>>}</span>`</span>
        : <span class="hljs-title class_">Str</span>;
</code></pre>
<p>类型参数 Str 是待处理的字符串类型，约束为 string。</p>
<p>通过模式匹配提取 Str 中 - 分隔的两部分，前面的部分放到 infer 声明的局部变量 Item 里，后面的放到 infer 声明的局部变量 Rest 里。</p>
<p>提取的第一个单词不大写，后面的字符串首字母大写，然后递归的这样处理，然后也就是 `${Item}${KebabCaseToCamelCase&#x3C;Capitalize>`。</p>
<p>如果模式匹配不满足，就返回 Str。</p>
<p>这样就完成了 KebabCase 到 CamelCase 的转换：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa9b283ab5ad407a99627de2ae131a5d~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?ts=4.5.0-beta#code/C4TwDgpgBA0hBGBDeBhRBnCAVA9mgthADZqYA8AysAE5QQAewEAdgCbpTo0CWzA5gD4oAXigAoKJKhVaDJmw4ADACQBvXgDMItAJJN8AXwC0azdqgAlCFwOLxUh1AD8UFar0RDauElQZseIiEJP5kaGDcwIhE3ABeEGRWXAICthKOkgBc0jQA3GJioJCwCMikAQTE5UkiJb7luJUh5ADkfACuiPxGXaxGrDj8LQL5YkA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>那反过来怎么转换呢？我们再实现下 CamelCase 到 KebabCase 的转换：</p>
<h2>CamelCaseToKebabCase</h2>
<p>同样是对字符串字面量类型的提取和构造，也需要递归处理，但是 CamelCase 没有 - 这种分割符，那怎么分割呢？</p>
<p>可以判断字母的大小写，用大写字母分割。</p>
<p>也就是这样：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">CamelCaseToKebabCase</span>&#x3C;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> = 
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer First}</span><span class="hljs-subst">${infer Rest}</span>`</span>
        ? <span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Lowercase</span>&#x3C;<span class="hljs-title class_">First</span>> 
            ? <span class="hljs-string">`<span class="hljs-subst">${First}</span><span class="hljs-subst">${CamelCaseToKebabCase&#x3C;Rest>}</span>`</span>
            : <span class="hljs-string">`-<span class="hljs-subst">${Lowercase&#x3C;First>}</span><span class="hljs-subst">${CamelCaseToKebabCase&#x3C;Rest>}</span>`</span>
        : <span class="hljs-title class_">Str</span>;
</code></pre>
<p>类型参数 Str 为待处理的字符串类型。</p>
<p>通过模式匹配提取首个字符到 infer 声明的局部变量 First，剩下的放到 Rest。</p>
<p>判断下当前字符是否是小写，如果是的话就不需要转换，递归处理后续字符，也就是 `${First}${CamelCaseToKebabCase}`。</p>
<p>如果是大写，那就找到了要分割的地方，转为 - 分割的形式，然后把 First 小写，后面的字符串递归的处理，也就是 `-${Lowercase}${CamelCaseToKebabCase}`。</p>
<p>如果模式匹配不满足，就返回 Str。</p>
<p>这样就完成了 CamelCase 到 KebabCase 的转换：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40eb2b22902344f09b0b9b98bc3e1bbc~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?ts=4.5.0-beta#code/C4TwDgpgBAwghgWwgG3gZwgFQPYGkIBGcB6EAPAMrABOUEAHsBAHYAmaUaNAlswOYA+KAF4oAKCiSoVWgyZsOAAwAkAb14AzCLQBi3alwC+azdqgAlCEcUSpdgPxQ9B4HUYt2UADLYA7toBjOAwyZy4hWzsoqEcVVTDgY1V4JFRgrDxCYlIyS3DDG2jogC4oRQBaNR9-aiCQhIEklJRSHHwiEnTcq2BGwqLSmQBuMTFQSFhEFvS2rM6MPJFJ1NbMjpyAcj4AVzh+AEE2ABFsfg2BEaA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>做了两个字符串类型的练习，再来做个数组类型的：</p>
<h2>Chunk</h2>
<p>希望实现这样一个类型：</p>
<p>对数组做分组，比如 1、2、3、4、5 的数组，每两个为 1 组，那就可以分为 1、2 和 3、4 以及 5 这三个 Chunk。</p>
<p>这明显是对数组类型的提取和构造，元素数量不确定，需要递归的处理，并且还需要通过构造出的数组的 length 来作为 chunk 拆分的标志。</p>
<p>所以这个类型逻辑这么写：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Chunk</span>&#x3C;
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[], 
    <span class="hljs-title class_">ItemLen</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, 
    <span class="hljs-title class_">CurItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[] = [], 
    <span class="hljs-title class_">Res</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[] = []
> = <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span>] ? 
          <span class="hljs-title class_">CurItem</span>[<span class="hljs-string">'length'</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ItemLen</span> ? 
            <span class="hljs-title class_">Chunk</span>&#x3C;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">ItemLen</span>, [<span class="hljs-title class_">First</span>], [...<span class="hljs-title class_">Res</span>, <span class="hljs-title class_">CurItem</span>]> :
            <span class="hljs-title class_">Chunk</span>&#x3C;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">ItemLen</span>, [...<span class="hljs-title class_">CurItem</span>, <span class="hljs-title class_">First</span>], <span class="hljs-title class_">Res</span>> 
    : [...<span class="hljs-title class_">Res</span>, <span class="hljs-title class_">CurItem</span>]
</code></pre>
<p>类型参数 Arr 为待处理的数组类型，约束为 unknown。类型参数 ItemLen 是每个分组的长度。</p>
<p>后两个类型参数是用于保存中间结果的：类型参数 CurItem 是当前的分组，默认值 []，类型参数 Res 是结果数组，默认值 []。</p>
<p>通过模式匹配提取 Arr 中的首个元素到 infer 声明的局部变量 First 里，剩下的放到 Rest 里。</p>
<p>通过 CurItem 的 length 判断是否到了每个分组要求的长度 ItemLen：</p>
<p>如果到了，就把 CurItem 加到当前结果 Res 里，也就是 [...Res, CurItem]，然后开启一个新分组，也就是 [First]。</p>
<p>如果没到，那就继续构造当前分组，也就是 [...CurItem, First]，当前结果不变，也就是 Res。</p>
<p>这样递归的处理，直到不满足模式匹配，那就把当前 CurItem 也放到结果里返回，也就是 [...Res, CurItem]。</p>
<p>这样就完成了根据长度对数组分组的功能：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3948d21be8a4fb68bc3776deacee22f~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?ts=4.5.0-beta#code/C4TwDgpgBAwgFgVwHYGsA8AoK2oEEBO+UEAHsBEgCYDOUyKSA9gO5IDaAugDRRY4CS5ALYAZCsTIUaUJAiEAjCPh59sMBPkEQhE8lVr0mrTlAC8UTipxQAShFqk90wy3YczFjhgB8HgkUcpWjYASyQAMyUoADEQ-GpgHgA6FLDIojsE9wB+Xmt82A0tITYAcgAbCgBzYDhS90D9KGKxJChc1QKceHo0TMTm4VaeNlj44G4LFKTMnnVNYQ5fAC5OrthEVD77AZaKEen54p4xrJ5M307lqZTZwoXtLwxQSA36TI8erbYARi4AJi4AGYuAAWLgAVkm-28AG4MEA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>字符串类型、数组类型都做了一些练习，接下来再做个索引类型的：</p>
<h2>TupleToNestedObject</h2>
<p>我们希望实现这样一个功能：</p>
<p>根据数组类型，比如 [‘a’, ‘b’, ‘c’] 的元组类型，再加上值的类型 'xxx'，构造出这样的索引类型：</p>
<pre><code class="hljs language-javascript">{
    <span class="hljs-attr">a</span>: {
        <span class="hljs-attr">b</span>: {
            <span class="hljs-attr">c</span>: <span class="hljs-string">'xxx'</span>
        }
    }
}
</code></pre>
<p>这个依然是提取、构造、递归，只不过是对数组类型做提取，构造索引类型，然后递归的这样一层层处理。</p>
<p>也就是这样的：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">TupleToNestedObject</span>&#x3C;<span class="hljs-title class_">Tuple</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[], <span class="hljs-title class_">Value</span>> = 
    <span class="hljs-title class_">Tuple</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span>]
      ? {
          [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> <span class="hljs-title class_">First</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Key</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span> ? <span class="hljs-title class_">Key</span> : <span class="hljs-built_in">never</span>]: 
              <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]
                  ? <span class="hljs-title class_">TupleToNestedObject</span>&#x3C;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">Value</span>>
                  : <span class="hljs-title class_">Value</span>
      }
      : <span class="hljs-title class_">Value</span>;
</code></pre>
<p>类型参数 Tuple 为待处理的元组类型，元素类型任意，约束为 unknown[]。类型参数 Value 为值的类型。</p>
<p>通过模式匹配提取首个元素到 infer 声明的局部变量 First，剩下的放到 infer 声明的局部变量 Rest。</p>
<p>用提取出来的 First 作为 Key 构造新的索引类型，也就是 Key in First，值的类型为 Value，如果 Rest 还有元素的话就递归的构造下一层。</p>
<p>为什么后面还有个 as Key extends keyof any ? Key : never 的重映射呢？</p>
<p>因为比如 null、undefined 等类型是不能作为索引类型的 key 的，就需要做下过滤，如果是这些类型，就返回 never，否则返回当前 Key。</p>
<p>这里的 keyof any 在内置的高级类型那节也有讲到，就是取当前支持索引支持哪些类型的：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88532b7b2d834b4591306f32cda0b45a~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>如果提取不出元素，那就构造结束了，返回 Value。</p>
<p>这样就实现了根据元组构造索引类型的功能：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24c8dbf5011d4d27952c32ecfb9b337d~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>当传入 number 时：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ca07272383c4728a19b48f064381382~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>当传入 undefined 时：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20afc50bcef84df1853a60e9f5e10a34~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?ts=4.5.0-beta#code/FAFwngDgpgBAKgVwgGynA9gOSgZxFAEwHkAjAKygGMQAeRFWKAD3wDsCcYFWBrV9AO6sA2gF0ANDABqAQ2QIoAPhgBeGMBib4SVDGZsOMYQEtWAMygAnGADFjlvJIB0L0xesAlXCFEatmgH4YAG8-f39hAGkoMBhTW3s8GBlOaNj9KHZOHhj0M2TWWKC0mAAuGFYoADcrUXKw8MavJIysrl5+ITEGxt6YIPpUDGw8QlIKahpmkElZeSUevvDyuYVFgF9FlbkFAG5gA-BobQZh7zHyKhBm1ROhrHPiS8nhAHIAcwQZVnfXyVfvgQ-q8COgfq8JDAAIyKfagSCwQZoB6jJ4Ta64ABMtyRZ1R4yuNDen2+v3+gL+FQQAFsSFZxCCwb9ITC4UdETpkSN8Girs0AMw4zl4nkEl4fL7g8nsSncAhQMymQgM0Hglmww4I5LIZCCQhpOBatQ5MB5ApgfZAA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>我们再来练习下内置的高级类型，我们对这块的练习比较少：</p>
<h2>PartialObjectPropByKeys</h2>
<p>我们想实现这样一个功能：</p>
<p>把一个索引类型的某些 Key 转为 可选的，其余的 Key 不变，</p>
<p>比如</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dong</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
    <span class="hljs-attr">address</span>: <span class="hljs-built_in">string</span>
}
</code></pre>
<p>把 name 和 age 变为可选之后就是这样的：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dong2</span> {
    name?: <span class="hljs-built_in">string</span>
    age?: <span class="hljs-built_in">number</span>
    <span class="hljs-attr">address</span>: <span class="hljs-built_in">string</span> 
}
</code></pre>
<p>这样的类型逻辑很容易想到是用映射类型的语法构造一个新的类型。</p>
<p>但是我们这里要求只用内置的高级类型来实现。</p>
<p>那要怎么做呢？</p>
<p>内置的高级类型里有很多处理映射类型的，比如 Pick 可以根据某些 Key 构造一个新的索引类型，Omit 可以删除某些 Key 构造一个新的索引类型，Partial 可以把索引类型的所有 Key 转为可选。</p>
<p>综合运用这些内置的高级类型就能实现我们的需求：</p>
<p>我们先把 name 和 age 这俩 Key 摘出来构造一个新的索引类型：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bda4effa66cc46338c0bed9ced7c492e~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>然后把剩下的 Key 摘出来构造一个新的索引类型：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a5d569cce1a4d428dd9e751b19c37c2~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>把第一个索引类型转为 Partial，第二个索引类型不变，然后取交叉类型。</p>
<p>交叉类型会把同类型做合并，不同类型舍弃，所以结果就是我们需要的索引类型。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialObjectPropByKeys</span>&#x3C;
    <span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>>,
    <span class="hljs-title class_">Key</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>
> = <span class="hljs-title class_">Partial</span>&#x3C;<span class="hljs-title class_">Pick</span>&#x3C;<span class="hljs-title class_">Obj</span>,<span class="hljs-title class_">Extract</span>&#x3C;keyof <span class="hljs-title class_">Obj</span>, <span class="hljs-title class_">Key</span>>>> &#x26; <span class="hljs-title class_">Omit</span>&#x3C;<span class="hljs-title class_">Obj</span>,<span class="hljs-title class_">Key</span>>;
</code></pre>
<p>类型参数 Obj 为待处理的索引类型，约束为 Record&#x3C;string, any>。</p>
<p>类型参数 Key 为要转为可选的索引，那么类型自然是 string、number、symbol 中的类型，通过 keyof any 来约束更好一些。默认值是 Obj 的索引。</p>
<blockquote>
<p>keyof any 是动态返回索引支持的类型，如果开启了 keyOfStringsOnly 的编译选项，那么返回的就是 string，否则就是 string | number | symbol 的联合类型，这样动态取的方式比写死更好。</p>
</blockquote>
<p>Extract 是用于从 Obj 的所有索引 keyof Obj 里取出 Key 对应的索引的，这样能过滤掉一些 Obj 没有的索引。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3696f8a23c8e44b18b27e05aa0e23cc3~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>从 Obj 中 Pick 出 Key 对应的索引构造成新的索引类型并转为 Partial 的，也就是 Partial&#x3C;Pick&#x3C;Obj,Extract&#x3C;keyof Obj, Key>>>，其余的 Key 构造一个新的索引类型，也就是 Omit&#x3C;Obj,Key>。然后两者取交叉就是我们需要的索引类型：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dff679e1cfe47198f8e2d100fe9167d~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>为啥这里没计算出最终的类型呢？</p>
<p>因为 ts 的类型只有在用到的的时候才会去计算，这里并不会去做计算。我们可以再做一层映射，当构造新的索引类型的时候，就会做计算了：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Copy</span>&#x3C;<span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>>> = {
    [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span>]:<span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]
}

<span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialObjectPropByKeys</span>&#x3C;
    <span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>>,
    <span class="hljs-title class_">Key</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span> = keyof <span class="hljs-title class_">Obj</span>
> = <span class="hljs-title class_">Copy</span>&#x3C;<span class="hljs-title class_">Partial</span>&#x3C;<span class="hljs-title class_">Pick</span>&#x3C;<span class="hljs-title class_">Obj</span>,<span class="hljs-title class_">Extract</span>&#x3C;keyof <span class="hljs-title class_">Obj</span>, <span class="hljs-title class_">Key</span>>>> &#x26; <span class="hljs-title class_">Omit</span>&#x3C;<span class="hljs-title class_">Obj</span>,<span class="hljs-title class_">Key</span>>>;
</code></pre>
<p>这里的 Copy 就是通过映射类型的语法构造新的索引类型，key 和 value 都不变。</p>
<p>这样就会计算出最终的索引类型：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c0b497d248544d6b5b114d4847e0031~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?ts=4.5.0-beta#code/FASwdgLgpgTgZgQwMZQAQBED2YDmqDewqxqYCAtlAFyoDOEM4ORJCO1pAruQEawvEEAEyEwotWjXqNcwAL4tgEAJ4AHNAGFMq5QB4A8jwBWqKAA9oYIbVQAlKEkwwhu6UwA0qBGGUA+X6gAvAQCqADaANJQyqjgqADW0ZhwqIZGALpUaZHR6fLASmpoAAoIMBAgCAA2aQ4QxTDaAELKUcq0uqFpphZQVjb2js6uDB5ePr7uoW09ltYJSSneMcGJysmpxsABwVo6uqXllVUHIEjxBsbuAKIWMMgQumsbaZ5t-gEAZKnkII+v718AG4Cip1KhDhVqrUkPVGqoWm1aPYbMFIccYXDmq1oh0sLhPAByMiUQmoAA+qEJbCghOBoKKPz+KKCTMe+JwRJJtIpVJpdJBhXBxTO8RZaNFug5XIoPMp1PYAoKQrQtwYD3FqDV91hT0WGGwnKp3LJ8v5vOpCAQAqAA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>当然，这里的 Copy 也可以不加，并不影响功能。</p>
<h2>总结</h2>
<p>我们学完了类型编程的套路，也知道了类型编程的意义（类型有关联的时候必须用类型编程，类型编程可以实现更精准的类型提示和检查），但是做的综合一些的案例还是少，这节就各种类型的类型编程都做了一遍。</p>
<p>包括字符串类型、数组类型、索引类型的构造、提取，都涉及到了递归，也对内置的高级类型做了练习。</p>
<p>这一节的类型练下来，相信你会对类型编程会更加得心应手了。</p>
<p><a href="https://www.typescriptlang.org/play?ts=4.5.0-beta#code/PTAEGkFMCMENoMKwM6QCoHskFtIBslUAoAFwE8AHSCGeQ9LWXAlSAHgGUSAnUSADxKQAdgBNkoZDwCWwgOYA+UAF5QRUBtBdeAoWIkADACQBvWQDNIvAJJDsAXwC0pi1dAAlSFPsG1m-6AA-KDGJraQDqZQcIismDj49GxIFNIksHjSAF7snlIKCj7qARoAXFo8ANxEpJTU0XRxjMz0eSo0MfTxTImsbADkcgCusPKOo6KOohjy-QrVRCCgCSyomA2xxORUyz2rDBtJ2nyCIuKSMvJKqsUax7pnhi7ClrwAYtLc3s+vHl4kRRKGmCHy+JBOenOABkMAB3KwAYz6oPyfiB-mCoRRANMKy6GEOfTyJEKBlu6NA5QMzhMMPh3CRqDY2MKuL2+MJTOJpPJ-nK2gW22oeKanMgbVUIrWBNom3YgxG8gAgmIACIzORzBZLBAACyGwgA1rUdnqDYa2OSldwdKd9KBzcI4cIANoAXQANGiNOFsFCRBDHqBhENsNArF7yQghtxfYH7Y7ne72u7I-42g8E0anbDXW6U26iNdQNbbZCJC7XO9PlIvQA6BtVv5SfPBXkBaOxuwu-p4ERyEi6-r5zPnX3+4RBb0Us1GtjEr3jkRel3Yz2gF0Nut5L2d31upSldslWcWhegJfCFdbvd2L1rr15JTk8qbhs75Yx-c1IXLfVGiU-3NNgXQARg9AAmD0AGYPQAFg9ABWdcIPmGoQDQIYKD7TAADl-kgUQAHloAAK0gBESBNahMOwhh8KkQiSPIyi2Fovt43ORNc1TUAADUMiGSBi3JdjqFHCsm2xetGxeNxiULEpghMY9NBdKAyFAWRQGxUAUBoTSJNAQ1IDIDBzD04RNOCDTKWDSAADcrDdcpVJKYlOIkbi8zcilgjEvCCOIsiKJIed-i9AS8CEhRfPRcooqE9t7HbBLBMgBZqNAAKMAYoRgpYkhAJyvKmJC1ie2GUZNS9foJn6D1+mmWZ11AtCspKoLmNCvIIPaTrGIK0KQIVaqGtAOqxHGkMwwjJqNWHL02sFOpsqwnDcq68qiq8aD+vW+itsKkaqtmWr6q9A1REgcxZEIxrms1Vr2t-DI8DhQiNLQVbVBMsyLNGMhtTAAAFWBuBIaQMm6yiQe4DAKAAITIDTkDyIhZCEbhzFgBFqHVeRQBU-xhB6copG4WQ5HJWA5EgcoZvDbgadEURuC8ZBycuamUo0LKEARsg2GYzy-gRDBuFENgKapr1AYKdpibU2ztL+8zQGYlzmPU0zCxSrKwYhqG8Bhkg4YR5HUctfwRaMzxxcl6XublqyFA9clbKMtWAas9pvY1sii3aAWKCFw3IYyNgQekBELWYj0AFFBG4XGwv9+ODIKJQADINewNJhbIj0NIKFadnD43TfNpGUdMtGvHaCvoe26vLbrtgCbkWrSdwfpQAAHwm2nIC1H9VqI-OdokVQJ4Lzvu56PvB7qunR4NmPDUA6PY47jUF97geh9X9qsqTnhU8As+U9Y-354mnuR8PlfH+X2A361IA" target="_blank" rel="nofollow noopener noreferrer">本文案例的合并</a></p></div>
</body></html>