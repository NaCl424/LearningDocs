<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>套路三：递归复用做循环</h1>
<p>会做类型的提取和构造之后，我们已经能写出很多类型编程逻辑了，但是有时候提取或构造的数组元素个数不确定、字符串长度不确定、对象层数不确定。这时候怎么办呢？</p>
<p>其实前面的案例我们已经涉及到了一些，就是递归。</p>
<p>这就是第三个类型体操套路：递归复用做循环。</p>
<h2>递归复用</h2>
<p><strong>递归是把问题分解为一系列相似的小问题，通过函数不断调用自身来解决这一个个小问题，直到满足结束条件，就完成了问题的求解。</strong></p>
<p>TypeScript 的高级类型支持类型参数，可以做各种类型运算逻辑，返回新的类型，和函数调用是对应的，自然也支持递归。</p>
<p><strong>TypeScript 类型系统不支持循环，但支持递归。当处理数量（个数、长度、层数）不固定的类型的时候，可以只处理一个类型，然后递归的调用自身处理下一个类型，直到结束条件也就是所有的类型都处理完了，就完成了不确定数量的类型编程，达到循环的效果。</strong></p>
<p>既然提到了数组、字符串、对象等类型，那么我们就来看一下这些类型的递归案例吧。</p>
<h2>Promise 的递归复用</h2>
<h3>DeepPromiseValueType</h3>
<p>先用 Promise 热热身，实现一个提取不确定层数的 Promise 中的 value 类型的高级类型。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ttt = <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>>>>>;
</code></pre>
<p>这里是 3 层 Promise，value 类型是索引类型。</p>
<p>数量不确定，一涉及到这个就要想到用递归来做，每次只处理一层的提取，然后剩下的到下次递归做，直到结束条件。</p>
<p>所以高级类型是这样的：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepPromiseValueType</span>&#x3C;P <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-built_in">unknown</span>>> =
    P <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&#x3C;infer <span class="hljs-title class_">ValueType</span>> 
        ? <span class="hljs-title class_">ValueType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-built_in">unknown</span>>
            ? <span class="hljs-title class_">DeepPromiseValueType</span>&#x3C;<span class="hljs-title class_">ValueType</span>>
            : <span class="hljs-title class_">ValueType</span>
        : <span class="hljs-built_in">never</span>;
</code></pre>
<p>类型参数 P 是待处理的 Promise，通过 extends 约束为 Promise 类型，value 类型不确定，设为 unknown。</p>
<p>每次只处理一个类型的提取，也就是通过模式匹配提取出 value 的类型到 infer 声明的局部变量 ValueType 中。</p>
<p>然后判断如果 ValueType 依然是 Promise类型，就递归处理。</p>
<p>结束条件就是 ValueType 不为 Promise 类型，那就处理完了所有的层数，返回这时的 ValueType。</p>
<p>这样，我们就提取到了最里层的 Promise 的 value 类型，也就是索引类型：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/518c10e2128b444f88711904e725aab5~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAIhFgAoCcD2BbAlgZwgNQEMAbAVwgBVwIAeRKCAD2AgDsATbKFDHGklgNYtUAdxYA+cVAC8AKCgKu9Jqw5c0WXNUwsAZhGRRCpClSnzFlgPxHiZSpGXN2nbpr6DhY8Rct+oNnAIbrzG9lTUYaaQPv7+AFy2Jg4Qvn6JLBAAbgYA3LKyoI5BSBq8AEoQ2CREwDKw8KU8uFEptGVaIVqVAMaoyGzU2MDIOgDmADRQBCwgkpK5QA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>其实这个类型的实现可以进一步的简化：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepPromiseValueType2</span>&#x3C;T> = 
    T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&#x3C;infer <span class="hljs-title class_">ValueType</span>> 
        ? <span class="hljs-title class_">DeepPromiseValueType2</span>&#x3C;<span class="hljs-title class_">ValueType</span>>
        : T;
</code></pre>
<p>不再约束类型参数必须是 Promise，这样就可以少一层判断。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e24a07fc579647ff9d974943af1626fc~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAIhFgAoCcD2BbAlgZwgNQEMAbAVwgBVwIAeRKCAD2AgDsATbKFDHGklgNYtUAdxYA+cVAC8AKCgKu9Jqw5c0WXNUwsAZhGRRCpClSnzFlgPxHiZSpGXN2nbpr6DhY8Rct+oNnAIbrzG9lTUYaaQPv7+AFy2Jg4Qvn6JLBAAbgYA3LKyoI5BSBq8AEoQ2CREwDKw8KU8uFEptGVaIVqVAMaoyGzU2MDIOgDmADRQBCwgkpL5hVQNwR34dtEQAEzU5FLSUGnkTqqua9p6BknhMYdxAStN7q1UOy8xaZaJ5ItF0CVddbJV6VTgHAFrd7bdrNGiAmHuagsEjoABGBnm4nyQA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>接下来再看下数组类型的递归复用：</p>
<h2>数组类型的递归</h2>
<h3>ReverseArr</h3>
<p>有这样一个元组类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];
</code></pre>
<p>我们把它反过来，也就是变成：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];
</code></pre>
<p>这个学完了提取和构造很容易写出来：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReverseArr</span>&#x3C;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]> = 
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">One</span>, infer <span class="hljs-title class_">Two</span>, infer <span class="hljs-title class_">Three</span>, infer <span class="hljs-title class_">Four</span>, infer <span class="hljs-title class_">Five</span>]
        ? [<span class="hljs-title class_">Five</span>, <span class="hljs-title class_">Four</span>, <span class="hljs-title class_">Three</span>, <span class="hljs-title class_">Two</span>, <span class="hljs-title class_">One</span>]
        : <span class="hljs-built_in">never</span>;
</code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d67c9c3c77f04234919e17730a1c8d67~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>但如果数组长度不确定呢？</p>
<p>数量不确定，条件反射的就要想到递归。</p>
<p>我们每次只处理一个类型，剩下的递归做，直到满足结束条件。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReverseArr</span>&#x3C;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]> = 
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span>] 
        ? [...<span class="hljs-title class_">ReverseArr</span>&#x3C;<span class="hljs-title class_">Rest</span>>, <span class="hljs-title class_">First</span>] 
        : <span class="hljs-title class_">Arr</span>;
</code></pre>
<p>类型参数 Arr 为待处理的数组类型，元素类型不确定，也就是 unknown。</p>
<p>每次只处理一个元素的提取，放到 infer 声明的局部变量 First 里，剩下的放到 Rest 里。</p>
<p>用 First 作为最后一个元素构造新数组，其余元素递归的取。</p>
<p>结束条件就是取完所有的元素，也就是不再满足模式匹配的条件，这时候就返回 Arr。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1caebf3f4c9e41198dfaac48f35bcd56~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAShBuEBOBnCBBJSA8mlQgA9gIA7AExSgFdSBrUgewHdSBtAXQD4oBeKAFBRhUPAWJlKUNgEtSAM2RQAYjNTAANFAB0uuYvxwUwDoJHmoAfmm7tcRKgxZsR4Fy2r1poReEAuUSwAbgEBUEhYBGQ0PCNqABtgPkiHGOc2AEYNACYNAGYNABYNAFZuIKA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h3>Includes</h3>
<p>既然递归可以做循环用，那么像查找元素这种自然也就可以实现。</p>
<p>比如查找 [1, 2, 3, 4, 5] 中是否存在 4，是就返回 true，否则返回 false。</p>
<p>从长度不固定的数组中查找某个元素，数量不确定，这时候就应该想到递归。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Includes</span>&#x3C;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[], <span class="hljs-title class_">FindItem</span>> = 
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span>]
        ? <span class="hljs-title class_">IsEqual</span>&#x3C;<span class="hljs-title class_">First</span>, <span class="hljs-title class_">FindItem</span>> <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span>
            ? <span class="hljs-literal">true</span>
            : <span class="hljs-title class_">Includes</span>&#x3C;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">FindItem</span>>
        : <span class="hljs-literal">false</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">IsEqual</span>&#x3C;A, B> = (A <span class="hljs-keyword">extends</span> B ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>) &#x26; (B <span class="hljs-keyword">extends</span> A ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>);
</code></pre>
<p>类型参数 Arr 是待查找的数组类型，元素类型任意，也就是 unknown。FindItem 待查找的元素类型。</p>
<p>每次提取一个元素到 infer 声明的局部变量 First 中，剩余的放到局部变量 Rest。</p>
<p>判断 First 是否是要查找的元素，也就是和 FindItem 相等，是的话就返回 true，否则继续递归判断下一个元素。</p>
<p>直到结束条件也就是提取不出下一个元素，这时返回 false。</p>
<p>相等的判断就是 A 是 B 的子类型并且 B 也是 A 的子类型，。</p>
<p>这样就完成了不确定长度的数组中的元素查找，用递归实现了循环。</p>
<p>当包含时：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d3068162fb34b41840be24c55f94dbd~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>当不包含时：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd8609a747bd462db18c2b3aa35294e4~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/FAFwngDgpgBAkgOwMYBsCuATKBnAPAQQCdCYoAPEKBDbGNBAawQHsB3BAbQF0AaGAMQCW1OJQC2APhgBeGMBgKYREuUrVaHYQDMoJIYWwg+AOlPbdMAEo4QXeYocB+eNgCiARzQBDFLn2G+IRFxKVUqGhgQQjQoewd4mGcomLiExQAueGR0LDxrAIFhDFEoSVSHTK0fbCgAbmBQSFg4N08fAj4AISlZAAp8Ugpw2k7EyOjYSuqoAEoYADIYXtGw9SUx5MmYKpQamfrG6CzUTBx8tBQQGWOcnFwOAEY+ACY+AGY+ABY+AFZeGE+EgO4COiBOuXOl2e1zBtzwjxe7y+v3+ADYgUA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h3>RemoveItem</h3>
<p>可以查找自然就可以删除，只需要改下返回结果，构造一个新的数组返回。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">RemoveItem</span>&#x3C;
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[], 
    <span class="hljs-title class_">Item</span>, 
    <span class="hljs-title class_">Result</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[] = []
> = <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span>]
        ? <span class="hljs-title class_">IsEqual</span>&#x3C;<span class="hljs-title class_">First</span>, <span class="hljs-title class_">Item</span>> <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span>
            ? <span class="hljs-title class_">RemoveItem</span>&#x3C;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">Item</span>, <span class="hljs-title class_">Result</span>>
            : <span class="hljs-title class_">RemoveItem</span>&#x3C;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">Item</span>, [...<span class="hljs-title class_">Result</span>, <span class="hljs-title class_">First</span>]>
        : <span class="hljs-title class_">Result</span>;
        
<span class="hljs-keyword">type</span> <span class="hljs-title class_">IsEqual</span>&#x3C;A, B> = (A <span class="hljs-keyword">extends</span> B ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>) &#x26; (B <span class="hljs-keyword">extends</span> A ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>);
</code></pre>
<p>类型参数 Arr 是待处理的数组，元素类型任意，也就是 unknown[]。类型参数 Item 为待查找的元素类型。类型参数 Result 是构造出的新数组，默认值是 []。</p>
<p>通过模式匹配提取数组中的一个元素的类型，如果是 Item 类型的话就删除，也就是不放入构造的新数组，直接返回之前的 Result。</p>
<p>否则放入构造的新数组，也就是再构造一个新的数组 [...Result, First]。</p>
<p>直到模式匹配不再满足，也就是处理完了所有的元素，返回这时候的 Result。</p>
<p>这样我们就完成了不确定元素个数的数组的某个元素的删除：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eef06834cb424514b8783823b5b02642~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAShC2B7AbhAksBAeAggJzyggA9MA7AEwGcoBXMgazMQHcyBtAXQBooMFecKrQA2wIqQiUa9Jqw6coAXihcAfMqgAoKLqj5CJctVUBLMgDMIhAGKm8VYLwB0r81cJDgnHXr8B+PioAUQBHWgBDESw7Byc+THgNIykTYDxaCF8-HKhAuCRUfngsL15iwQhhMTVs3L0ALlgEFHRE0qr4itVXZyFReNjHTlr6qCb+sQBuLS1QSCCwyOicXgAhDRUAChwJYxo1vKh0zPGoCyiqCABKKAAyKC3DlOl9I5PoJouRK+uZufA0AKrWKk3EKmBRXa7AAjNwAEwI7gAZh4UHhaimQA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h3>BuildArray</h3>
<p>我们学过数组类型的构造，如果构造的数组类型元素个数不确定，也需要递归。</p>
<p>比如传入 5 和元素类型，构造一个长度为 5 的该元素类型构成的数组。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">BuildArray</span>&#x3C;
    <span class="hljs-title class_">Length</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, 
    <span class="hljs-title class_">Ele</span> = <span class="hljs-built_in">unknown</span>, 
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[] = []
> = <span class="hljs-title class_">Arr</span>[<span class="hljs-string">'length'</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Length</span> 
        ? <span class="hljs-title class_">Arr</span> 
        : <span class="hljs-title class_">BuildArray</span>&#x3C;<span class="hljs-title class_">Length</span>, <span class="hljs-title class_">Ele</span>, [...<span class="hljs-title class_">Arr</span>, <span class="hljs-title class_">Ele</span>]>;
</code></pre>
<p>类型参数 Length 为数组长度，约束为 number。类型参数 Ele 为元素类型，默认值为 unknown。类型参数 Arr 为构造出的数组，默认值是 []。</p>
<p>每次判断下 Arr 的长度是否到了 Length，是的话就返回 Arr，否则在 Arr 上加一个元素，然后递归构造。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00049e632bbf4707b879cbd062fe0762~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/FAFwngDgpgBAQgVwJYBsAmBBATlghmAHgBkoA7AcxAAsYoAPEMtAZxlIQFsAjKLAGhjAYwmAFEUsALwwEpANakA9gHdSAoSOxZaDJq1kKVpANoBdGNLMA+CxuFbjAcgkVqj8-UakWMEq5p2IsIA-DBagkFBAFzwyOha+MRklFQC4lACxgB0OVppEqZWANzAoJCwiKiYOABKUMwIKCAWsVUJhACsxUA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>学完了数组类型的递归，我们再来看下字符串类型。</p>
<h2>字符串类型的递归</h2>
<h3>ReplaceAll</h3>
<p>学模式匹配的时候，我们实现过一个 Replace 的高级类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReplaceStr</span>&#x3C;
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,
    <span class="hljs-title class_">From</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,
    <span class="hljs-title class_">To</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>
> = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Prefix}</span><span class="hljs-subst">${From}</span><span class="hljs-subst">${infer Suffix}</span>`</span> 
    ? <span class="hljs-string">`<span class="hljs-subst">${Prefix}</span><span class="hljs-subst">${To}</span><span class="hljs-subst">${Suffix}</span>`</span> : <span class="hljs-title class_">Str</span>;
</code></pre>
<p>它能把一个字符串中的某个字符替换成另一个：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5e1e3328db5470b9d759eb194b66b9c~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>但是如果有多个这样的字符就处理不了了。</p>
<p>如果不确定有多少个 From 字符，怎么处理呢？</p>
<p><strong>在类型体操里，遇到数量不确定的问题，就要条件反射的想到递归。</strong></p>
<p>每次递归只处理一个类型，这部分我们已经实现了，那么加上递归的调用就可以。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReplaceAll</span>&#x3C;
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, 
    <span class="hljs-title class_">From</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, 
    <span class="hljs-title class_">To</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>
> = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Left}</span><span class="hljs-subst">${From}</span><span class="hljs-subst">${infer Right}</span>`</span>
        ? <span class="hljs-string">`<span class="hljs-subst">${Left}</span><span class="hljs-subst">${To}</span><span class="hljs-subst">${ReplaceAll&#x3C;Right, From, To>}</span>`</span>
        : <span class="hljs-title class_">Str</span>;
</code></pre>
<p>类型参数 Str 是待处理的字符串类型，From 是待替换的字符，To 是替换到的字符。</p>
<p>通过模式匹配提取 From 左右的字符串到 infer 声明的局部变量 Left 和 Right 里。</p>
<p>用 Left 和 To 构造新的字符串，剩余的 Right 部分继续递归的替换。</p>
<p>结束条件是不再满足模式匹配，也就是没有要替换的元素，这时就直接返回字符串 Str。</p>
<p>这样就实现了任意数量的字符串替换：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f7e0390108248b7babfe8115c59ad47~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/FDAuE8AcFMAICVqQDYEMDG0CCzkB4BlUAJ1mgA9RoA7AEwGdZ6SBLagcwBpZhY-YAYsQD2AWzKUaDJqw7de-ACrCJVOo2bE27AHywAvD37HYRUhTXSABgBIA3mwBm0UgBloj0AF97QsT4dqZ1J4FnYAC28rBRMTAH5YWzt3TwDlAMQUDGxcPFCI0G4-UW5lHS9o2NiALlMSAG4QCBgEJDRMHGREegBXZFADVqyO3IBydh7UDlgJqfYZyY5R7nHF9mXYUdphJZ16oA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h3>StringToUnion</h3>
<p>我们想把字符串字面量类型的每个字符都提取出来组成联合类型，也就是把 'dong' 转为 'd' | 'o' | 'n' | 'g'。</p>
<p>怎么做呢？</p>
<p>很明显也是提取和构造：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringToUnion</span>&#x3C;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> = 
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer One}</span><span class="hljs-subst">${infer Two}</span><span class="hljs-subst">${infer Three}</span><span class="hljs-subst">${infer Four}</span>`</span>
        ? <span class="hljs-title class_">One</span> | <span class="hljs-title class_">Two</span> | <span class="hljs-title class_">Three</span> | <span class="hljs-title class_">Four</span>
        : <span class="hljs-built_in">never</span>;
</code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb1071c2ee7f45368ad816f7179a92a3~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>但如果字符串长度不确定呢？</p>
<p>数量不确定，在类型体操中就要条件反射的想到递归。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringToUnion</span>&#x3C;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> = 
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer First}</span><span class="hljs-subst">${infer Rest}</span>`</span>
        ? <span class="hljs-title class_">First</span> | <span class="hljs-title class_">StringToUnion</span>&#x3C;<span class="hljs-title class_">Rest</span>>
        : <span class="hljs-built_in">never</span>;
</code></pre>
<p>类型参数 Str 为待处理的字符串类型，通过 extends 约束为 string。</p>
<p>通过模式匹配提取第一个字符到 infer 声明的局部变量 First，其余的字符放到局部变量 Rest。</p>
<p>用 First 构造联合类型，剩余的元素递归的取。</p>
<p>这样就完成了不确定长度的字符串的提取和联合类型的构造：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e2e1688af304c16b5ed60af0b335e3a~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAysBOBLAdgcwCoHsCqzGeQB454oIAPYCZAEwGco6EVUA+KAXigCgo-YEZStXpQABgBIA3igBmEUgDFE8JgF9pchVABKEdWN79jAfijLVwKAB8BSNFlz4iepqyPG+ALijIIANwUAbm5Q0Eg7Fkc8AlcAVwAbKy4SKJwYogByAAsIBITMTNYQoA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h3>ReverseStr</h3>
<p>我们实现了数组的反转，自然也可以实现字符串类型的反转。</p>
<p>同样是递归提取和构造。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReverseStr</span>&#x3C;
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, 
    <span class="hljs-title class_">Result</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>
> = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer First}</span><span class="hljs-subst">${infer Rest}</span>`</span> 
    ? <span class="hljs-title class_">ReverseStr</span>&#x3C;<span class="hljs-title class_">Rest</span>, <span class="hljs-string">`<span class="hljs-subst">${First}</span><span class="hljs-subst">${Result}</span>`</span>> 
    : <span class="hljs-title class_">Result</span>;
</code></pre>
<p>类型参数 Str 为待处理的字符串。类型参数 Result 为构造出的字符，默认值是空串。</p>
<p>通过模式匹配提取第一个字符到 infer 声明的局部变量 First，其余字符放到 Rest。</p>
<p>用 First 和之前的 Result 构造成新的字符串，把 First 放到前面，因为递归是从左到右处理，那么不断往前插就是把右边的放到了左边，完成了反转的效果。</p>
<p>直到模式匹配不满足，就处理完了所有的字符。</p>
<p>这样就完成了字符串的反转：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c366b28c97c54473a8210ce4f8da0919~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/FAFwngDgpgBASlAblATgZygZRCgPNlGKADxCgDsATNGNHAS3IHMAaGYGT+KNAVwBsQRUhWq0GzGAF4YAclkA+aey4wCwslRoADACQBvRgDNUMAGL10IAL4HjphHWvaVqrgH5uydFhy5HIGx6+hZWtvqOAjbaShxunABc3HyCANzAoJCwCN4YBJGCyjmoeX6yABZQ-PwA9oqpQA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>学完了字符串的递归，我们再来看下对象的。</p>
<h2>对象类型的递归</h2>
<h3>DeepReadonly</h3>
<p>对象类型的递归，也可以叫做索引类型的递归。</p>
<p>我们之前实现了索引类型的映射，给索引加上了 readonly 的修饰：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ToReadonly</span>&#x3C;T> =  {
    <span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof T]: T[<span class="hljs-title class_">Key</span>];
}
</code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/040460cc07e0448cb1cefa224515d708~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>如果这个索引类型层数不确定呢？</p>
<p>比如这样：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> obj = {
    <span class="hljs-attr">a</span>: {
        <span class="hljs-attr">b</span>: {
            <span class="hljs-attr">c</span>: {
                <span class="hljs-attr">f</span>: <span class="hljs-function">() =></span> <span class="hljs-string">'dong'</span>,
                <span class="hljs-attr">d</span>: {
                    <span class="hljs-attr">e</span>: {
                        <span class="hljs-attr">guang</span>: <span class="hljs-built_in">string</span>
                    }
                }
            }
        }
    }
}
</code></pre>
<p>数量（层数）不确定，类型体操中应该自然的想到递归。</p>
<p>我们在之前的映射上加入递归的逻辑：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepReadonly</span>&#x3C;<span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>>> = {
    <span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span>]:
        <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>] <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>
            ? <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>
                ? <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>] 
                : <span class="hljs-title class_">DeepReadonly</span>&#x3C;<span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]>
            : <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]
}
</code></pre>
<p>类型参数 Obj 是待处理的索引类型，约束为 Record&#x3C;string, any>，也就是索引为 string，值为任意类型的索引类型。</p>
<p>索引映射自之前的索引，也就是 Key in keyof Obj，只不过加上了 readonly 的修饰。</p>
<p>值要做下判断，如果是 object 类型并且还是 Function，那么就直接取之前的值 Obj[Key]。</p>
<p>如果是 object 类型但不是 Function，那就是说也是一个索引类型，就递归处理 DeepReadonly&#x3C;Obj[Key]>。</p>
<p>否则，值不是 object 就直接返回之前的值 Obj[Key]。</p>
<p>这样就完成了任意层数的索引类型的添加 readonly 修饰：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03730514e65a409ba6ad49473cfbd0b0~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>我们取处理以后的索引 a 的值看一下，发现 b 已经加上了 readonly 修饰。</p>
<p>测试一下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e9b45c558b344b8bc28356e05b830c1~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAIhFgEoQIYBMD2A7ANiAPAPIBGAVlBAB7ARZoDOUyAxhgE5r73BsCWWAcwA0UFFhAA+CVAC8UAN4AoKCqhtUmXCCgBtANIRt-KAGtDGAGZQSpALoAuZauc39h2xWq0GUDGQjMwE7OIVAA-NZkbiAeVDR0jABiAK5YgbzYwaHZEa4GMVBZ2SH2sPBIGth4RFH5thJF2aV57ooAvoqKoJC+ZLIKWSilSsXEw42hzOPFxRalABQAlLLSAOSaAqtCEzNo0zMHEPsHJ1ACyWICpdx8gjunHafOjycvoW9QHR1d4NBwCMh0FUQMh6MkcMB+v8KkCtPg-KQJDpVihVrYANydbp-cqAzR4UHg4AAJihuMqcIRSJRaORxFpq2YaMxQA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>为啥这里没有计算呀？</p>
<p>因为 ts 的类型只有被用到的时候才会做计算。</p>
<p>所以可以在前面加上一段 Obj extends never ? never 或者 Obj extends any 等，从而触发计算：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepReadonly</span>&#x3C;<span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>>> =
    <span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>
        ? {
            <span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span>]:
                <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>] <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>
                    ? <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>
                        ? <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>] 
                        : <span class="hljs-title class_">DeepReadonly</span>&#x3C;<span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]>
                    : <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]
        }
        : <span class="hljs-built_in">never</span>;
</code></pre>
<p>这样就显示了计算后的类型：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03051aaaca3b4eed8cbf822ab7882a39~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>而且写 Obj extends any 还有额外的好处就是能处理联合类型，这个可以看套路五，会有解释。</p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAIhFgEoQIYBMD2A7ANiAPAPIBGAVlBAB7ARZoDOUyAxhgE5r73BsCWWAcwA0UFFhAA+CVAC8AKCiKoJclRp1GYkAqW6A-FADeO3aahtUmXCCgBtANIQb-KAGsnGAGbKyAXQBcJmbBKg5OvhTUtAxQGGQQzMBBwSlQBqGOIBFq0YwAYgCuWIm82MmpFelkYVlQ5RUp-rDwSJbYeETVmb4S9Q2KTRnhfQC+fU1YEABuEGwA3HJyoJCxZLJGQShNxinE2326zPv9up5NABQAlLLSAORWArdCB8FoxydmEO8fKQIFYgImtw+IIXhUxj8oBCGtCzLCoXIxktwNA4AhkOh2iBkPQCjhgOs0a1MdZ8HFSBI5kA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h2>总结</h2>
<p>递归是把问题分解成一个个子问题，通过解决一个个子问题来解决整个问题。形式是不断的调用函数自身，直到满足结束条件。</p>
<p>在 TypeScript 类型系统中的高级类型也同样支持递归，<strong>在类型体操中，遇到数量不确定的问题，要条件反射的想到递归。</strong> 比如数组长度不确定、字符串长度不确定、索引类型层数不确定等。</p>
<p>如果说学完了提取和构造可以做一些基础的类型体操，那再加上递归就可以实现各种复杂类型体操了。</p>
<p><a href="https://www.typescriptlang.org/play?#code/PTAEAUCcHsFsEsDOBTAXAKHSUARZyAHKOJZANQEMAbAV2QBUBPAtdAF2eV3yJgRUq0GnADzhQyAB5tkAOwAmiCH1IiasgNazoAd1kA+faAC86UOYgTpcxcpIoR8WQDNkkUILpMWRsxf8A-B7UXpxWMgpKxPzIapraevp+-imgQXiE0aSewiwiOd7ISampqMFChckpZbLIAG5uANyYHCzcmSooAErIiDRUbCbtvPbkIbmxWQ5TsT0AxtCQ8iKIbJBOAOYANKAUsoyGhs1YYBkjMQWcAEzsYWczlyxXIvRGxqBV9OE2UZ2xTq53I8ih8Smlhg9xoVnsDiiUyvRjq0uPc-sCrj0lO9UaN0WI-vjRoSYiJZDRYAAjNyHfTHbCAB1NACN+gCx-zDYHoNSAoACCkEgGGRoA5bh5fJEvPcUgitnUWl0sgA2gBdN6giwS76RUAKgFuUAAMXgXLYOwAdObde5MWwlWrUkEFebTcKucgJSJrfodobjbaqv4yhKkWEXaLIJj+oN3qG3WKFQBGLZXLYAZi2ABYtgBWFV0sAASVkc1o8l6tzaheLNFLiHFfM1Mvi8uV3qc8nzMlgqqqGqlP21loNRtWZotLj11qV-osQXziAAogBHGjUEQ+kdDhQd5BdhtKNZ0af20AH5BH6qgSsl3oe3omzftztw0qgZzUFDBisL5er7k7ABCqoABTcnuoD-uCp6gGUb5UCgACUoAAGSgEBEF9lqoFBFBMHvsg8GflwV7Vr0EYDEMxE1iICY7MmoBpqAmagDmOzprSLRhJRpG9JGVwUUW161jRoB0QxTEsaAABs7EnEKO7QA026wOWXA9LACnIEpdaStYWqygkipKjsSk7GRgwYY2cp6MqQzKt2-i9rptg6uO7jrveTqDpO56zt+K5UGuw73kpRgWfukCHmCgRyepimdreG4mXJfQDM+UVlGpGladaxmdjsjrmmZra+mlAbJZGhExVlnZmUMmVxTu1GJsmyYpkZIkydg-40PAVDyBKFCMCp4E9X1A2MCIAAycgbGwAAWYFkpSbg7FU85UFw7z6fKq0OfWYWgNt1m2u8dkmD2fIKgA5BtsizXNV22gd013fNdopEEGrnmU3W9f1fKDVNM3zTs63IPlToSqDG25hxbS-WNfK1e8CP-ZAgNZp1YCAOragBk3oATHKAN4+gDR6myYA9AQVAUHMbpUFQw0U1TNPcnTIgAMprGBqzrHdu0WPqfBc2smx8+Y9DQELPMbPZJQczp0pKAABgAJAA3oO03OGwAC+asC3Auvq65QrwBsc064r57RSrquazravi4bjPU7TAVdKb5venwOzi-o2uW1FFhlHLlXO8zdPI3JlMuyzAVXRsK53aACd7BsyeJxsV07PHGdZ6AV3yNAd1XVjoBy5s4sAKqyPARfDeXd1VzXRfs5zB3c5sMvmHLYE24O7mG15d7+z5Q7GqAAA+ZfC430DV7XsgJWwpVB6AtScsc9czxsTcL5HDc73PzeL1dc3IHT0Al3mcmcigcsM-UIrIHLrfy-2He8+9tXt9vQxXSXQwqg9wOn3Y2A81ZD1WP7d60UYwvxyqAG24DVZmX9r4MEGUeIDFDo-V0ctI5wLWCIU+58qCX1LoAIl9ACo+iTVkskzg9AoIXWQVAhrDQYcgJhRdWEiAAPIUgAFZgXmIsZYH9ti7H2IYc6-h+FCIOnsIaYIgiqythYSAnDmGsO1AAaWQIwUAThQAaH0dAZwoA5FKgwIHVIciFR6MYE9JyShoCCOQHMNgajA5BDsQ4pxCsDTqA8QvLxNjzA+MEfY-RfowlhLKBwrhLCJq+OiSvWJ0ELGRL8eebW30164Mqq4oR7xVH+AoGUUpJQKQVNCXMGp6TzDODKEBRCxgjAFyLpnLYoT-DyHqQ0-waBQCVIGakFOd0yjiJ6SUXJAzZk2PmakRZoBcm5PYTwRhWjGCRwSVskQRT2JAA" target="_blank" rel="nofollow noopener noreferrer">本文案例的合并</a></p>
<p>(其实这节的 IsEqual 判断是不完善的，套路六里面会讲原因)</p></div>
</body></html>