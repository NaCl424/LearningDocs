<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>套路一：模式匹配做提取</h1>
<p>TypeScript 类型编程的代码看起来比较复杂，但其实这些逻辑用 JS 大家都会写，之所以到了类型体操就不会了，那是因为还不熟悉一些套路。</p>
<p>所以，这节开始我们就来学习一些类型体操的套路，熟悉这些套路之后，各种类型体操逻辑就能够很顺畅的写出来。</p>
<p>首先，我们来学习类型体操的第一个套路：模式匹配做提取。</p>
<h2>模式匹配</h2>
<p>我们知道，字符串可以和正则做模式匹配，找到匹配的部分，提取子组，之后可以用 <img class="equation" src="https://juejin.cn/equation?tex=1%2C" alt="1,">2 等引用匹配的子组。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b6e9f15d14c452f8b5f4a59a3d3add8~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>Typescript 的类型也同样可以做模式匹配。</p>
<p>比如这样一个 Promise 类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> p = <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-string">'guang'</span>>;
</code></pre>
<p>我们想提取 value 的类型，可以这样做：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetValueType</span>&#x3C;P> = P <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&#x3C;infer <span class="hljs-title class_">Value</span>> ? <span class="hljs-title class_">Value</span> : <span class="hljs-built_in">never</span>;
</code></pre>
<p>通过 extends 对传入的类型参数 P 做模式匹配，其中值的类型是需要提取的，通过 infer 声明一个局部变量 Value 来保存，如果匹配，就返回匹配到的 Value，否则就返回 never 代表没匹配到。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fea3a531fab498e8ca7a1daace8038b~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBA4hwDUCGAbArhAKuCAeACgHxQC8U+UEAHsBAHYAmAzuQE4D2AtgJZN7d0AZhFZRk6CMQD8Y1BigAuKHQgA3EQG4AUDtCRY8cRgBKEJmhTBSBxHKw4CHHn1wByAOZokdd68KENIA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<p>这就是 Typescript 类型的模式匹配：</p>
<p><strong>Typescript 类型的模式匹配是通过 extends 对类型参数做匹配，结果保存到通过 infer 声明的局部类型变量里，如果匹配就能从该局部变量里拿到提取出的类型。</strong></p>
<p>这个模式匹配的套路有多有用呢？我们来看下在数组、字符串、函数、构造器等类型里的应用。</p>
<h2>数组类型</h2>
<h3>First</h3>
<p>数组类型想提取第一个元素的类型怎么做呢？</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
</code></pre>
<p>用它来匹配一个模式类型，提取第一个元素的类型到通过 infer 声明的局部变量里返回。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetFirst</span>&#x3C;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]> = 
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...<span class="hljs-built_in">unknown</span>[]] ? <span class="hljs-title class_">First</span> : <span class="hljs-built_in">never</span>;
</code></pre>
<p>类型参数 Arr 通过 extends 约束为只能是数组类型，数组元素是 unkown 也就是可以是任何值。</p>
<blockquote>
<p><strong>any 和 unknown 的区别</strong>：
any 和 unknown 都代表任意类型，但是 unknown 只能接收任意类型的值，而 any 除了可以接收任意类型的值，也可以赋值给任意类型（除了 never）。类型体操中经常用 unknown 接受和匹配任何类型，而很少把任何类型赋值给某个类型变量。</p>
</blockquote>
<p>对 Arr 做模式匹配，把我们要提取的第一个元素的类型放到通过 infer 声明的 First 局部变量里，后面的元素可以是任何类型，用 unknown 接收，然后把局部变量 First 返回。</p>
<p>当类型参数 Arr 为 [1,2,3] 时：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/189a8a20ed5c4f60905bc88ca9ba61bb~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>当类型参数 Arr 为 [] 时：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff00e79903474f01b522fc95b4189096~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBA4hwDECWAnAzsAPAQRSqEAHsBAHYAmaUArqQNakD2A7qQNoC6AfFALxS58REhSpskpAGYR8ydMAA0UAHSraDFuw4coAfihyMUAFxRSEAG4yA3ACh7oSLHiHgAJQhpqAG2B9niKgYmGwAjAoATAoAzNx2to7QcIHyHl6+Ef7JriFxtkA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h3>Last</h3>
<p>可以提取第一个元素，当然也可以提取最后一个元素，修改下模式类型就行：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetLast</span>&#x3C;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]> = 
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [...<span class="hljs-built_in">unknown</span>[], infer <span class="hljs-title class_">Last</span>] ? <span class="hljs-title class_">Last</span> : <span class="hljs-built_in">never</span>;
</code></pre>
<p>当类型参数 Arr 为 [1,2,3]时：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/959e27b8dbfd420182d8bcac575c6d5b~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBA4hwBkCGBnYAeAggJ21CAHsBAHYAmKUAriQNYkD2A7iQNoC6AfFALxQ55CxcpVYA6CTXrM27ADRQAliQBmEPMjTsoAfiibgUAFxQSEAG7qA3ACg7oSLHgGAShBRUANob5xEqDFYARjkAJjkAZi5bGwdoP1d3L2BQ3id-NHQOTisgA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h3>PopArr</h3>
<p>我们分别取了首尾元素，当然也可以取剩余的数组，比如取去掉了最后一个元素的数组：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PopArr</span>&#x3C;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]> = 
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [] ? [] 
        : <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [...infer <span class="hljs-title class_">Rest</span>, <span class="hljs-built_in">unknown</span>] ? <span class="hljs-title class_">Rest</span> : <span class="hljs-built_in">never</span>;
</code></pre>
<p>如果是空数组，就直接返回，否则匹配剩余的元素，放到 infer 声明的局部变量 Rest 里，返回 Rest。</p>
<p>当类型参数 Arr 为 [1,2,3] 时：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd533ba9b9a2431287b1c8d12f02e6df~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>当类型参数 Arr 为 [] 时：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22a64419e01a47f49ca4dc0d60bc8510~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBACg9mAggJ2QHhcqEAewIB2AJgM5QCuBA1gXAO4EDaAugHxQC8Um2ehpUFlAD8g5lABc3VL3zEyjAHTKAlgQBmELACUIJYABoK1Wg3Gjd+yVAIQAbloDcAKFehIsBJfIAbYJ08kVDRGAEYDACYDAGY2FzdwaHgwbz8IgOTMELigA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h3>ShiftArr</h3>
<p>同理可得 ShiftArr 的实现：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ShiftArr</span>&#x3C;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]> = 
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [] ? [] 
        : <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [<span class="hljs-built_in">unknown</span>, ...infer <span class="hljs-title class_">Rest</span>] ? <span class="hljs-title class_">Rest</span> : <span class="hljs-built_in">never</span>;
</code></pre>
<p>当类型参数 Arr 为 [1,2,3]时：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c5bb5c645a472ba143b4c4787e972a~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/FAFwngDgpgBAygCwJYDMQEEBOmA8XMxQAeIUAdgCYDOMArmQNZkD2A7mQNoC6AfDALwx8hEuWoxuMAPwSuMAFxDsI0pRod6TNmQA0MAHSGkZFFAIAlKFRByZl6wphkoANzMBuYF-DR4yNPa0ADYgAn6oGNg4HACMOgBMOgDMvJ6gkLCIEYEh8WFZaPjRqUA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h2>字符串类型</h2>
<p>字符串类型也同样可以做模式匹配，匹配一个模式字符串，把需要提取的部分放到 infer 声明的局部变量里。</p>
<h3>StartsWith</h3>
<p>判断字符串是否以某个前缀开头，也是通过模式匹配：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">StartsWith</span>&#x3C;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, <span class="hljs-title class_">Prefix</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> = 
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${Prefix}</span><span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>`</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
</code></pre>
<p>需要声明字符串 Str、匹配的前缀 Prefix 两个类型参数，它们都是 string。</p>
<p>用 Str 去匹配一个模式类型，模式类型的前缀是 Prefix，后面是任意的 string，如果匹配返回 true，否则返回 false。</p>
<p>当匹配时：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/891a3c57dc8b4a9581883b05d58ced38~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>不匹配时：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73e3eaa47b924f9ca4e837042a12650c~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAysCGAnYBnA6gS2ACwDx0SggA9gIA7AExShWEQ3IHMAaKABUQgDMNijSFarXqMmAPigBeWPQFkqNAAYASAN6cefAL7q6DZtqVQA-FHoBXaAC4o3eABsUEANwAoD6EiykqTDgAlCBQLB2BpH2R0LDwAciYLeGYoJMooSgB7Zli2eMTs8XcPNy9oOF9owODQ4AAmCPKo-ziEpKYUqnSsphyoWMyClyA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h3>Replace</h3>
<p>字符串可以匹配一个模式类型，提取想要的部分，自然也可以用这些再构成一个新的类型。</p>
<p>比如实现字符串替换：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReplaceStr</span>&#x3C;
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,
    <span class="hljs-title class_">From</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,
    <span class="hljs-title class_">To</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>
> = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Prefix}</span><span class="hljs-subst">${From}</span><span class="hljs-subst">${infer Suffix}</span>`</span> 
        ? <span class="hljs-string">`<span class="hljs-subst">${Prefix}</span><span class="hljs-subst">${To}</span><span class="hljs-subst">${Suffix}</span>`</span> : <span class="hljs-title class_">Str</span>;
</code></pre>
<p>声明要替换的字符串 Str、待替换的字符串 From、替换成的字符串 3 个类型参数，通过 extends 约束为都是 string 类型。</p>
<p>用 Str 去匹配模式串，模式串由 From 和之前之后的字符串构成，把之前之后的字符串放到通过 infer 声明的局部变量 Prefix、Suffix 里。</p>
<p>用 Prefix、Suffix 加上替换到的字符串 To 构造成新的字符串类型返回。</p>
<p>当匹配时：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cd97d2e01ec4749bd80ab520d1733ff~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>不匹配时：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41c48e63dc6240dfa481dd256c89a9e0~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAShYBsCGBjCBlYAnAPJrUEAHsBAHYAmAzlFdgJZkDmANFAGJYD2AtoSeWq0GzNgBUu-UpRp0sjJgD4oAXihR8UwTQAGAEgDejAGYQCABSwRj9IgF9DnXg6NlTBdAFdjN+zqgA-FD6BpbWti4SLl4+Ef4AXBrYANwAUOmgkLDwyGhwVJ4IwKrZiKgY2DgARADinkjMTPXMAOQ0AEYQdFDG8oJQ9DQBVWxVw6MAIlzMFNNMVYppGeDQcGV5XYXAAEwla7kVuFVI7SgjUGPnVVMzcwvJQA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h3>Trim</h3>
<p>能够匹配和替换字符串，那也就能实现去掉空白字符的 Trim：</p>
<p>不过因为我们不知道有多少个空白字符，所以只能一个个匹配和去掉，需要递归。</p>
<p>先实现 TrimRight:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">TrimStrRight</span>&#x3C;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> = 
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Rest}</span><span class="hljs-subst">${<span class="hljs-string">' '</span> | <span class="hljs-string">'\n'</span> | <span class="hljs-string">'\t'</span>}</span>`</span> 
        ? <span class="hljs-title class_">TrimStrRight</span>&#x3C;<span class="hljs-title class_">Rest</span>> : <span class="hljs-title class_">Str</span>;
</code></pre>
<p>类型参数 Str 是要 Trim 的字符串。</p>
<p>如果 Str 匹配字符串 + 空白字符 (空格、换行、制表符)，那就把字符串放到 infer 声明的局部变量 Rest 里。</p>
<p>把 Rest 作为类型参数递归 TrimRight，直到不匹配，这时的类型参数 Str 就是处理结果。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df89e8af4ccb4d868cae790b82d10fbc~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>同理可得 TrimLeft：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">TrimStrLeft</span>&#x3C;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> = 
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-string">' '</span> | <span class="hljs-string">'\n'</span> | <span class="hljs-string">'\t'</span>}</span><span class="hljs-subst">${infer Rest}</span>`</span> 
        ? <span class="hljs-title class_">TrimStrLeft</span>&#x3C;<span class="hljs-title class_">Rest</span>> : <span class="hljs-title class_">Str</span>;
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c44ef0a46e514a3588b220e23752da8d~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>TrimRight 和 TrimLeft 结合就是 Trim：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">TrimStr</span>&#x3C;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>> =<span class="hljs-title class_">TrimStrRight</span>&#x3C;<span class="hljs-title class_">TrimStrLeft</span>&#x3C;<span class="hljs-title class_">Str</span>>>;
</code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/332a738fff064ba58b073d1e03539275~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAKgTgSwLYGVhwEoIOYAtgA8acUEAHsBAHYAmAzlHegldgHxQC8UxpF19KAAMAJAG8WAMwgkMEJgF9xAciiqAPmoA6VDduDKFQqAH5YiVOix5CcphwBcPdAG4AUG9CRzya-jsArgA2wFw+lpg4+ATK2AEAhqxQySnJymzunuDQ8MjEADIQkoS85JS0DEyIrBzcpfwVwipqUJrKOnrtBkoSVNKy8sBGpuEFRbaDjs5wmV45FoXFgSFhuRGLhKqpUDQA9qzps9mj6ETofOWCVSzsXGvEfoT36BtncGwZHlnea8uh3M84DFtjt9tgUoc3EA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h2>函数</h2>
<p>函数同样也可以做类型匹配，比如提取参数、返回值的类型。</p>
<h3>GetParameters</h3>
<p>函数类型可以通过模式匹配来提取参数的类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetParameters</span>&#x3C;<span class="hljs-title class_">Func</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>> = 
    <span class="hljs-title class_">Func</span> <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: infer <span class="hljs-title class_">Args</span>) => <span class="hljs-built_in">unknown</span> ? <span class="hljs-title class_">Args</span> : <span class="hljs-built_in">never</span>;
</code></pre>
<p>类型参数 Func 是要匹配的函数类型，通过 extends 约束为 Function。</p>
<p>Func 和模式类型做匹配，参数类型放到用 infer 声明的局部变量 Args 里，返回值可以是任何类型，用 unknown。</p>
<p>返回提取到的参数类型 Args。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1dd929580e34c77afc6265886ee43f4~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBA4hwAUCGAnJBbeEUGcA8AYgK4B2AxlBAB7AQkAmOUx5wAlgPYkB8UAvM1IVqtBkwAUAOmmoA5jgBcUNiQBm2KAEEU8gJT9epANYkOAdxJQA-Fp1MlJCADdsAbgBQn0JCjI0mWlwAJQgcIgAbYH5YeD8MLFw8cRJ4pRxgFBVZABooJFkIByJ0ACNsfT5edMySWW4Pd29oOIDsHBCwyIAmaLhEVHjA-HEKqoys+qA" target="_blank" rel="nofollow noopener noreferrer">试一试</a></p>
<h2>GetReturnType</h2>
<p>能提取参数类型，同样也可以提取返回值类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetReturnType</span>&#x3C;<span class="hljs-title class_">Func</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>> = 
    <span class="hljs-title class_">Func</span> <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) => infer <span class="hljs-title class_">ReturnType</span> 
        ? <span class="hljs-title class_">ReturnType</span> : <span class="hljs-built_in">never</span>;
</code></pre>
<p>Func 和模式类型做匹配，提取返回值到通过 infer 声明的局部变量 ReturnType 里返回。</p>
<p>参数类型可以是任意类型，也就是 any[]（注意，这里不能用 unknown，这里的解释涉及到参数的逆变性质，具体原因逆变那一节会解释）。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4539c7a0a01c43a7837908c6397bcbfc~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBA4hwCV4FcBOA7AKuCAeAYsugMZQQAewE6AJgM5SEnACWA9ugHxQC8jRpClVoMAFADpJAQ1QBzOgC4oU9CADaAXQCUvbi3QAzCKihJgaLDigB+UygzZIUJeggA3YwG4AUN9BOzC0cIJDpkABtw4F5YeECHHFxRdCkAWwglOmBUfVkdHm4AchoOWULOTyA" target="_blank" rel="nofollow noopener noreferrer">试一试</a></p>
<h3>GetThisParameterType</h3>
<p>方法里可以调用 this，比如这样：</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dong</span> {
    <span class="hljs-attr">name</span>: string;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">"dong"</span>;
    }

    <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'hello, I\'m '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
    }
}

<span class="hljs-keyword">const</span> dong = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dong</span>();
dong.<span class="hljs-title function_">hello</span>();
</code></pre>
<p>用<code>对象.方法名</code>的方式调用的时候，this 就指向那个对象。</p>
<p>但是方法也可以用 call 或者 apply 调用：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75229ba1521c42d1940c441e6e0ee0d5~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>call 调用的时候，this 就变了，但这里却没有被检查出来 this 指向的错误。</p>
<p>如何让编译器能够检查出 this 指向的错误呢？</p>
<p>可以在方法声明时指定 this 的类型：</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dong</span> {
    <span class="hljs-attr">name</span>: string;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">"dong"</span>;
    }

    <span class="hljs-title function_">hello</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: Dong</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'hello, I\'m '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
    }
}
</code></pre>
<p>这样，当 call/apply 调用的时候，就能检查出 this 指向的对象是否是对的：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0fef176aec24e27ad2513b9a04afaa7~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>如果没有报错，说明没开启 strictBindCallApply 的编译选项，这个是控制是否按照原函数的类型来检查 bind、call、apply</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73676681ef8f450f9ba281584d44d131~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>这里的 this 类型同样也可以通过模式匹配提取出来：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetThisParameterType</span>&#x3C;T> 
    = T <span class="hljs-keyword">extends</span> (<span class="hljs-attr">this</span>: infer <span class="hljs-title class_">ThisType</span>, ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) => <span class="hljs-built_in">any</span> 
        ? <span class="hljs-title class_">ThisType</span> 
        : <span class="hljs-built_in">unknown</span>;
</code></pre>
<p>类型参数 T 是待处理的类型。</p>
<p>用 T 匹配一个模式类型，提取 this 的类型到 infer 声明的局部变量 ThisType 中，其余的参数是任意类型，也就是 any，返回值也是任意类型。</p>
<p>返回提取到的 ThisType。</p>
<p>这样就能提取出 this 的类型：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c8247dad58d4a0cbf2d1b2701908a45~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/MYGwhgzhAEAiD2A7A5tA3gKGt6iwFsBTALmggBcAnASxQG4MsdgkLKBXYc+SgCgEp0THDnIALahAB0eItAC80AEQATJMiUMRAX0YixhECHi9xk0ghSDMIkZULl2lRNADkBo-AA00AJIAdV3w3aABqaDNpWUItHF1dDBZECmg1FAVcQgB3OHUBBjTkKQ9jfMZC4sNjKWAwI140AA9m4gBGbX4GDHIATwAHQmgAcQcAFQkIAAUwSgIHQkpR-sIAHlGAPgzR6EJG8kJEFRhTCdJaADMF6HHJJYGfKUeZ5AhSMEQegG0AXUF5TfePWgAH5rhM7oNSOxEABrRDwLKILq9AbDMYTaazIj7RbLABKhBgihG5BuUxmcxxEJWKMI8HOqXUlU86y6GCAA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h2>构造器</h2>
<p>构造器和函数的区别是，构造器是用于创建对象的，所以可以被 new。</p>
<p>同样，我们也可以通过模式匹配提取构造器的参数和返回值的类型：</p>
<h3>GetInstanceType</h3>
<p>构造器类型可以用 interface 声明，使用 new(): xx 的语法。</p>
<p>比如：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonConstructor</span> {
    <span class="hljs-title function_">new</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Person</span>;
}
</code></pre>
<p>这里的 PersonConstructor 返回的是 Person 类型的实例对象，这个也可以通过模式匹配取出来。</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetInstanceType</span>&#x3C;
    <span class="hljs-title class_">ConstructorType</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) => <span class="hljs-built_in">any</span>
> = <span class="hljs-title class_">ConstructorType</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) => infer <span class="hljs-title class_">InstanceType</span> 
        ? <span class="hljs-title class_">InstanceType</span> 
        : <span class="hljs-built_in">any</span>;
</code></pre>
<p>类型参数 ConstructorType 是待处理的类型，通过 extends 约束为构造器类型。</p>
<p>用 ConstructorType 匹配一个模式类型，提取返回的实例类型到 infer 声明的局部变量 InstanceType 里，返回 InstanceType。</p>
<p>这样就能取出构造器对应的实例类型：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3bde943e699415fab2be6e6aeeeb454~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBA4hwEkB2BnYBDJBjCAVcEAPAMID2qwATgK5bCmX6RQQAewESAJilEhAHcoACgB049JQDmKAFxRMIAJRQAvAD4FSEJoBQUA2qhkKNOgybQ2Hbr35CxE6XK3K1mgJZIAZhEpRkNEwcSyh9QwiAfgCKYLwCMIiI+UUAbl1dLw5Kb3QcKAAFPxRyKABvcIMkdABbCHk0Si8pdIBfDKy-XPyiyhKkE0baen8KiPtharqGqmaleV7+tozQZjhEWOx4yAAlCF5VWHhAjC3LQkXyQaphhnV0oA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h3>GetConstructorParameters</h3>
<p>GetInstanceType 是提取构造器返回值类型，那同样也可以提取构造器的参数类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetConstructorParameters</span>&#x3C;
    <span class="hljs-title class_">ConstructorType</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) => <span class="hljs-built_in">any</span>
> = <span class="hljs-title class_">ConstructorType</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: infer <span class="hljs-title class_">ParametersType</span>) => <span class="hljs-built_in">any</span>
    ? <span class="hljs-title class_">ParametersType</span>
    : <span class="hljs-built_in">never</span>;
</code></pre>
<p>类型参数 ConstructorType 为待处理的类型，通过 extends 约束为构造器类型。</p>
<p>用 ConstructorType 匹配一个模式类型，提取参数的部分到 infer 声明的局部变量 ParametersType 里，返回 ParametersType。</p>
<p>这样就能提取出构造器对应的参数类型：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0db834880b4c4ca6a6e22c894eaa4209~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBA4hwGED2A7AzsATgVwMbCUwAUBDTEgW3gkzQB4AoKZqZdLPAzAFXGggAewCCgAmaKCggB3KAAoAdErIBzNAC4oJFCACUUALwA+LToYmDrVBhz5CvSFEHCxEqbMXLMazQEsUAGY0UKTkVMK0DhD6xqYgTCwA-CFklNSRfAnMmlIAbjQA3AwM-hEBJLjQRDRoqFAA3lmSaZo2-ipFAL7FpTTllSE1qGw2nIQNTe5yKC1QbSgquprVtKhdxaCOcIjWHHbEqeE1AEoQEpbbI3tcoWkR9Cu1KFe2XEZFQA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h2>索引类型</h2>
<p>索引类型也同样可以用模式匹配提取某个索引的值的类型，这个用的也挺多的，比如 React 的 index.d.ts 里的 PropsWithRef 的高级类型，就是通过模式匹配提取了 ref 的值的类型：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33c5fa6ffe7a4fda85230e5b363e0d5c~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>我们简化一下那个高级类型，提取 Props 里 ref 的类型：</p>
<h3>GetRefProps</h3>
<p>我们同样通过模式匹配的方式提取 ref 的值的类型：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetRefProps</span>&#x3C;<span class="hljs-title class_">Props</span>> = 
    <span class="hljs-string">'ref'</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-title class_">Props</span>
        ? <span class="hljs-title class_">Props</span> <span class="hljs-keyword">extends</span> { ref?: infer <span class="hljs-title class_">Value</span> | <span class="hljs-literal">undefined</span>}
            ? <span class="hljs-title class_">Value</span>
            : <span class="hljs-built_in">never</span>
        : <span class="hljs-built_in">never</span>;
</code></pre>
<p>类型参数 Props 为待处理的类型。</p>
<p>通过 keyof Props 取出 Props 的所有索引构成的联合类型，判断下 ref 是否在其中，也就是 'ref' extends keyof Props。</p>
<p>为什么要做这个判断，上面注释里写了：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/580bf3bf266f42c69b268d96a3fb09be~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>在 ts3.0 里面如果没有对应的索引，Obj[Key] 返回的是 {} 而不是 never，所以这样做下兼容处理。</p>
<p>如果有 ref 这个索引的话，就通过 infer 提取 Value 的类型返回，否则返回 never。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71790e667fba43759068d72d2f44f234~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>当 ref 为 undefined 时：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08aa267ecaaf461a959bcb83230352fe~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><a href="https://www.typescriptlang.org/play?ts=4.5.0-beta#code/C4TwDgpgBA4hwCUIDMAKAnA9mAzgHg2xwD4oBeKAKChqgHJ0U6oIAPYCAOwBMcoBrCCEzIohXNVpSA-GKy4W7LrygBvKI2TSAXFACWnZBHRQAagEMANgFdoAHyjWeKAxG4BfSVO9RZFmxBePrS6nBAAbsZBUqERxgDclJSgkLDwSGjyOEh8FHCIKOL46po6UACMADRQnOYAthC6dNyYnADmdO7Eicng0PkZRTkATORpBZlEeCUoZU7cLmHc1bUNTS3tnd2UQA" target="_blank" rel="nofollow noopener noreferrer">试一下</a></p>
<h2>总结</h2>
<p>就像字符串可以匹配一个模式串提取子组一样，TypeScript 类型也可以匹配一个模式类型提取某个部分的类型。</p>
<p><strong>TypeScript 类型的模式匹配是通过类型 extends 一个模式类型，把需要提取的部分放到通过 infer 声明的局部变量里，后面可以从这个局部变量拿到类型做各种后续处理。</strong></p>
<p>模式匹配的套路在数组、字符串、函数、构造器、索引类型、Promise 等类型中都有大量的应用，掌握好这个套路能提升很大一截类型体操水平。</p>
<p><a href="https://www.typescriptlang.org/play?#code/PTAEm8fRo9UZXlFmTR1TUPexgAOUFj-pCEVoeH1CcyoWUTAtBUAXjQNeUAoMkUABQCcB7AWwEsBnAUwC4yAXATwAO7UAHF2PAGoBDADYBXdgBVB7ADzUAfKAC8NUOwAePdgDsAJqxoMWHVcxMAzdrVDT57LQH5XshaE6gJuwAbs4A3BT8QqLibgoASuyscjI8OjGSvkoq6tZsagDkAOZyUiZFBRoaERRUgA6mgCN+qLVgYjwAYsy0rDy8Khmd3TyqAIK0LobG5pZyJgDWJvQA7iYA2gC6WrpjE0amFqCr9k4ugz0ANKAAdDezC8tr6+ug3mdpAUGhtDVRwm1viWSqXS-y6PVUqwAjOcAEznADMmwivwGYJ4gJSPBhIPEbwhSJaGQAMlIen1om0SeCdvo9tNQHdFisNltQDTJvtLKsbldGQ8Npdjs5QFSeM9vKL-IEQuFIv1KaT0UlMTieKKIdC4YjquS-uJRRjUtjdArwSyalRqPQBDtdTRrTtRuNaVMDnzmZt0uy6QcNi9Ds8At7XVyeUKXICeJd3SZxaBI1LPrK7VaBIa0rpU46obCEQSUan08b7TbxvidYSAMoAC2YDh4tpRNbrDbLwc5DPmTMerPb9L93j9QedHP7McuYccwsjcYTHxl3zl0Wb9fT6RXrdoGtz2uR-Q3RfXtfr2YJlDAgHVtQBk3oAmOWa59AlZ4UloPFYAHVmDxq9wm8-Xx+X7VqoT67CGoA9LQ9hFJcdDsA4zAGC6HaQdBrKgch9IAAYACQAN5wQhBgAL74ah5TEVh-o8LQfgBA4sgcD8+7-m+n7fmuuhPi+bFAaoxSlOUoBlGYoBmPQ5QFJcAllBUOp-jxgEccqRrrqxSnATJQkiWJEkVNJ4mSRWD6JAIMhSAAxlwdqmeZVmgSBNGYQc5EwaA7TWM5liuZcij0F5EE0Wh6SPk5o4HLheHhlY8GIaReEeUw8XRZWcgOERlH+pFhFxfhfnxal6VxVRASgcx0S2ZZ7CcfG7BmVVDkAEQiIJRQlLJBSWAARkkaQOFB+ygGwLyNZcjWeKNoCNQAInphlFI18n9JVVmHroK3sE1UhdRZk3jXts3lPNi01A+ihQYwv79OdzCMKB8TMEU1bDBh4XeUF5ToWFPqWJF0WRvFBSgEDAA+wMADomKDEM8AUmXeDdd00Q9T3DJGWilTR5XCIjKPPTViP3Y9z38e1QmgBTlPAxWKKEzRRLwS933ga5X1gR2kVA9DBSQ9z4Ow8lU4Rr18OgHTtAM-Wqjo1KZVLjjF2S0qQIZmLF2gUr-FUxT82VNjau3Q5r0-YFUGfTo4t48M4ua6BVT67jKmq+LWva-NlN6xQD6AL+KdT3lQbTUC+UiMOIzisHagfB6HxjdKo7SzBZAUJyYFk8MwEmsinSdvaAAAUPIvkUrABNFYzFwAlDoWgxv65eWPOXz60HtAh2H3Q1VHrcx+Hqh5yYbcBD5wlFFwgRyIwPW0FX2haKze7RC3bex6wa0ZEvPdx3nM9zx9RQVgH4iJDwci0CYyhCJHR-iKf585NnyeJ+nmfpA-ucFzcRcl8JJh8BsO9DSFrVE+Z8L7CG8MfW+YDEwLn1pA0BKhDTAhNNfEBd8hB9wHqHIee8AEFF1gfVo4hFC1lYBvduYCyAWXMqwSwh0iigDwmQKmWCx6uRqFTCyElIJyDTvQWg29GHMO1hTb8bArisPSI1Y6EQqbEQoFTas7AZAyHoHnMR396FVyYSIimtAb5n2BkolR9BLgAElwYFEYMDUAABqUAGiJFt1kZTeR8iqHcLSO7XQQQligHodvCI80rjGNUYEigwTQn0CuBZWQMg854QMEkzgkJiIV31m0EhbByGxzAaoRQrJFABXUaQ0uQCsmsDAROT+tBi4BDKH-dYACGn+gqdAgIMYMnENITk5wYDASqgqb02geTfj0AcLpcoITlGqMIaAQAIeaAAIEwAFmr+yITwMxJgehlCspQlEbRNnbNTtkDBABhTxtE+EjP6LnXx+dC61O-g05pv8tDCIproc5WyaK8J4Pw6Btz2B+I-lcL+9Tf4AOioc58xzoHvO1t4aFOyTnCHhVTcFfAaj2FjgxKyNBw4SSESwweptoIRHcdi5wuLhDUAJSYL5PCrlEspr4-uJLXIVwCLS7oElyXywyEi2FiCkiqkFbsnI3LWASQZT8q5cy2gysuX82gwyI77PEIq35-DVWqHhZqq5AKTZ3JBWCn+fAXl8DIKyfVyrDXgWNQ8upgCTg0Gju3SpKgLXwu8Kqyh6LpRN35Qqi5WqVVupXgMlBPAbXavDb3SV0qQ1yotGAQARL6AFR9KAzRD5KgcHQa0Jcr65vzQIVguQC2snhQUfRDgga5zmOwPg4yrAFrRZTH1DBS0BTwqAGtngykuriMIMGswzCxSCGYeRuiEU+HcG2kRjdnDzpgYGotiQ82dtXiKqN66S1lp7X2gI0JAgkvwXpOGNN5TXw3QWwExY2i7s3aoA98F+2djHQhCdlxWEBDPZJYiFYgA" target="_blank" rel="nofollow noopener noreferrer">本文案例的合并</a></p></div>
</body></html>