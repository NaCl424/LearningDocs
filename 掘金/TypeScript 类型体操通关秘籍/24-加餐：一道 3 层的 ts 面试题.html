<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>加餐：一道 3 层的 ts 面试题</h1>
<p>最近遇见一道不错的 TS 面试题，分享一下。</p>
<p>这道题有 3 个层次，我们一层层来看。</p>
<p>第一层的要求是这样的：</p>
<p><strong>实现一个 zip 函数，对两个数组的元素按顺序两两合并，比如输入 [1,2,3], [4,5,6] 时，返回 [[1,4], [2,5],[3,6]]</strong></p>
<p>这层就是每次各从两个数组取一个元素，合并之后放到数组里，然后继续处理下一个，递归进行这个流程，直到数组为空即可。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">zip</span>(<span class="hljs-params">target, source</span>) {
  <span class="hljs-keyword">if</span> (!target.<span class="hljs-property">length</span> || !source.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> [one, ...rest1] = target;
  <span class="hljs-keyword">const</span> [other, ...rest2] = source;

  <span class="hljs-keyword">return</span> [[one, other], ...<span class="hljs-title function_">zip</span>(rest1, rest2)];
}
</code></pre>
<p>结果是对的：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fe22402c8b74f4c92526bf6096746c3~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>第一层还是比较简单的，然后我们来看第二层要求：</p>
<p><strong>给这个 zip 函数定义 ts 类型（两种写法）</strong></p>
<p>函数的定义有两种形式：</p>
<p>直接通过 function 声明函数：</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) {}
</code></pre>
<p>和声明匿名函数然后赋值给变量：</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"></span>) => {}
</code></pre>
<p>而参数和返回值的类型都是数组，只是具体类型不知道，可以写 unknown[]。</p>
<p>所以两种函数类型的定义就是这样的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8af513936c74470adf20945b2608bff~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7c7ac25f0ec4f0c969c70db558f2eed~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>也是直接 function 声明函数类型和 interface 声明函数类型然后加到变量类型上两种。</p>
<p>因为具体元素类型不知道，所以用 unknown。</p>
<p>这里可能会问 any 和 unknown 的区别：</p>
<p>any 和 unknown 都可以接收任何类型：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42ee8313565841f4a1f1a44f3e87724d~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>但是 any 也可以赋值给任何类型，但 unknown 不行。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33ec41d7068a42559ce4f3746f1f1420~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88d86a61c4de4c10b633dfff9d4b9d8e~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>这里只是用来接收其他类型， 所以 unknown 比any 更合适一些，更安全。</p>
<p>这一层也是比较基础的 ts 语法，第三层就上了难度了：</p>
<p><strong>用类型编程实现精确的类型提示，比如参数传入 [1,2,3], [4,5,6]，那返回值的类型要提示出 [[1,4], [2,5],[3,6]]</strong></p>
<p>这里要求返回值类型是精确的，我们就要根据参数的类型来动态生成返回值类型。</p>
<p>也就是这样：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca16308fffd24d2ab93d201807594a6a~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>声明两个类型参数 Target、Source，约束为 unknown[]，也就是元素类型任意的数组类型。</p>
<p>这俩类型参数分别是传入的两个参数的类型。</p>
<p>返回值通过 Zip 计算得出。</p>
<p>然后要实现 Zip 的高级类型：</p>
<p>传入的类型参数分别是两个数组类型，我们同样要从中提取出每个元素合并到一起。</p>
<p>提取元素可以用模式匹配的方式：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e924383bcb5f4d1bb5d8aadb40ca6925~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bc144970bb24465afa100bb62897b42~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>所以这个类型就可以这样定义：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Zip</span>&#x3C;<span class="hljs-title class_">One</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[], <span class="hljs-title class_">Other</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]> =
    <span class="hljs-title class_">One</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">OneFirst</span>,...infer <span class="hljs-title class_">Rest1</span>]
      ? <span class="hljs-title class_">Other</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">OtherFirst</span>, ...infer <span class="hljs-title class_">Rest2</span>]
        ? [[<span class="hljs-title class_">OneFirst</span>, <span class="hljs-title class_">OtherFirst</span>], ...<span class="hljs-title class_">Zip</span>&#x3C;<span class="hljs-title class_">Rest1</span>, <span class="hljs-title class_">Rest2</span>>]
        : []
      : [];
</code></pre>
<p>分别提取两个数组的第一个元素，构造成新数组。然后对剩下的数组递归进行这样的处理，直到数组为空。</p>
<p>这样就实现了我们想要的高级类型：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02042c7cf3c94d0cbdf7a00616687231~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>但你把它作为返回值加到函数上会报错：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf4d7ba9f6c143db95f5a3fa324022e8~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>因为声明函数的时候都不知道参数是啥，自然计算不出 Zip&#x3C;Target, Source> 的值，所以这里会类型不匹配：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa43eefc8e264a818ad995678ddf0495~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>那怎么办呢？</p>
<p>可以用函数重载解决：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d58160fc26d498d9e209a312dd55e52~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>ts 支持函数重载，可以写多个同名函数的类型的类型定义，最后写函数的实现，这样用到这个函数的时候会根据参数的类型来匹配函数类型。</p>
<p>我们用了类型编程的那个函数通过这种方式写就不会报错了。</p>
<p>我们使用下看看：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e59c589b6d51472aad9212df40bf06fd~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>咋返回值的类型不对呢？</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4266a93fd9af4be5b6330fa7f95296a7~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>其实这时候匹配的函数类型是对的，只不过推导出的不是字面量类型。</p>
<p>这时候可以加个 as const。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f8588cdcde64c1b97b4304210cfbd9b~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>但是加上 as const 会推导出 readonly [1,2,3]</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd50614058c448f380cd8f3758ae5740~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>这样类型就不匹配了，所以要在类型参数的声明上也加上 readonly:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14d63087a00a43c5bf62937718c657c6~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>但这样 Zip 函数的类型又不匹配了。</p>
<p>难道要把所有用到这个类型的地方都加上 readonly 么？</p>
<p>不用，我们 readonly 的修饰去掉不就行了？</p>
<p>Typescript 有内置的高级类型 readonly：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5817c2792b54fbca35f3e30ddc1dcb9~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>可以把索引类型的每个索引都加上 readonly 修饰：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e15ea9a8e3f47559df54d123ea05d8a~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>但没有提供去掉 readonly 修饰的高级类型，我们可以自己实现一下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f2c283be97f404eac13fa7874fc41fb~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>用映射类型的语法构造个新索引类型，加上个 -readonly 就是去掉 readonly 修饰的意思。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c31e9a53ec944b38a0d47bb44c779eb~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>有的同学可能问了，数组类型也是索引类型么？</p>
<p>是，索引类型是聚合多个元素的类型，所以对象、数组、class 都是。</p>
<p>所以我们把它用在数组上自然也是可以的：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfe98ddda7a648919df64cd4b5f52a3e~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>（准确来说叫元组，元组是元素个数固定的数组）</p>
<p>那我们只要在传入 Zip 之前，用 Mutable 去掉 readonly 就可以了：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7d8e720ba61432d9235532593d79a11~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>再来试一下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ed1ca13d54f4b019c287d96a0666ef1~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>大功告成！现在返回值的类型就对了。</p>
<p>但还有个问题，如果不是直接传入字面量，是推导不出字面量类型的，这时候貌似就不对了：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f55554d25c45bbb6f93f2f3bf933f6~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>可我们不都声明重载类型了么？</p>
<p>如果推导不出字面量类型，应该匹配这个呀：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fcef5c14ecf4ae2bb9b2357d99f687c~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>但实际上它匹配的还是第一个：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/418948649bfe49e9ad6f939d8bf8b77a~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>这时候其实只要调换下两个函数类型的顺序就可以了：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c87b45ed6fc2477d96536a28ca33256c~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa8a0940591c4141aa348454e5986339~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>这时字面量参数的情况依然也是对的：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e88600ec9514d229775e5b5b9ce90f8~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>为什么呢？</p>
<p>因为<strong>重载函数的类型是从上到下依次匹配，只要匹配到一个就应用。</strong></p>
<p>非字面量的情况，类型是 number[]，能匹配 unknown[] 的那个类型，所以那个函数类型生效了。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c0ae501565b46f3a44568f56bc2e105~tplv-k3u1fbpfcp-watermark.image?" alt=""></p>
<p>而字面量的情况，推导出的是 readonly [1,2,3]，带有 readonly 所以不匹配 unknown[]，继续往下匹配，就匹配到了带有类型参数的那个函数类型。</p>
<p>这样两种情况就都应用了合适的函数类型。</p>
<p>全部代码是这样的：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Zip</span>&#x3C;<span class="hljs-title class_">One</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[], <span class="hljs-title class_">Other</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]> = <span class="hljs-title class_">One</span> <span class="hljs-keyword">extends</span> [
  infer <span class="hljs-title class_">OneFirst</span>,
  ...infer <span class="hljs-title class_">Rest1</span>
]
  ? <span class="hljs-title class_">Other</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">OtherFirst</span>, ...infer <span class="hljs-title class_">Rest2</span>]
    ? [[<span class="hljs-title class_">OneFirst</span>, <span class="hljs-title class_">OtherFirst</span>], ...<span class="hljs-title class_">Zip</span>&#x3C;<span class="hljs-title class_">Rest1</span>, <span class="hljs-title class_">Rest2</span>>]
    : []
  : [];

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Mutable</span>&#x3C;<span class="hljs-title class_">Obj</span>> = {
  -<span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span>]: <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>];
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">zip</span>(<span class="hljs-params">target: <span class="hljs-built_in">unknown</span>[], source: <span class="hljs-built_in">unknown</span>[]</span>): <span class="hljs-built_in">unknown</span>[];

<span class="hljs-keyword">function</span> zip&#x3C;<span class="hljs-title class_">Target</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">unknown</span>[], <span class="hljs-title class_">Source</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">unknown</span>[]>(
  <span class="hljs-attr">target</span>: <span class="hljs-title class_">Target</span>,
  <span class="hljs-attr">source</span>: <span class="hljs-title class_">Source</span>
): <span class="hljs-title class_">Zip</span>&#x3C;<span class="hljs-title class_">Mutable</span>&#x3C;<span class="hljs-title class_">Target</span>>, <span class="hljs-title class_">Mutable</span>&#x3C;<span class="hljs-title class_">Source</span>>>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">zip</span>(<span class="hljs-params">target: <span class="hljs-built_in">unknown</span>[], source: <span class="hljs-built_in">unknown</span>[]</span>) {
  <span class="hljs-keyword">if</span> (!target.<span class="hljs-property">length</span> || !source.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> [one, ...rest1] = target;
  <span class="hljs-keyword">const</span> [other, ...rest2] = source;

  <span class="hljs-keyword">return</span> [[one, other], ...<span class="hljs-title function_">zip</span>(rest1, rest2)];
}

<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">zip</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>);

<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-string">'5'</span>, <span class="hljs-number">6</span>];

<span class="hljs-keyword">const</span> result2 = <span class="hljs-title function_">zip</span>(arr1, arr2);

</code></pre>
<p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAWglmAPAeQHbQgD2BVATAZygFdUBrVAewHdUBtAXQBoplgALCAJyix3yKkKNegwB8UALxQAUFFbpe2XISh04qAGbcFEAGJwuBYCwB05jdp4AlCMYCMDOfKgB+Vhx18VRdVp1snFwGRiZQ5qaWOrbGAExOLi7udHRo+obGLIHcIcbM4ebwSDHA9iwlsWIJiVAAXGrV8vWMANwyMqCQUACyxMAAhgBGADYQKIMAVhLSAN7OALRcEP14lKjDIGoA0hCbGlBku5SarJMM9ciTdDsgDG0Avm0ymqQAxsBwa1AAXggAFAMuABzCDAepCKi0RgsAiUYhcV4QcHkSGiACUyOEULu7ReqHen1QPwQiAAKv1gaClPxVEsVmsNiQUSJoVAAMpwhEYZQCKB01brTYQlniP7OQEgsFQcmUkzOWHwxH1DmKiAyDGwEm9AYjMYyyViFjaoajRAqrliMRPPEEr6-MAAimSzGo1kKrkukVoqBzeRwE5-ACEEtBplGqCBHCgAB9o1BA+7EWHcJH2N6lsB4UTWu15K81sY1GsIGZzEsHAwpFAQ8A2nmC8Ai54uKXTOXgPEq4mIE95Bms2o6MWWJRm-kIva-u2yny7B20Tj7u186hC+XiMNG9JJ3QZ7EWABmSv9IgrzJqAAsLAArCwAGzH08NtFPM+NilcexV3csfdQI9tG+UAfrE35XlAADk14QfeOIyEB66bqB27-B+M4gS+QA" target="_blank" rel="nofollow noopener noreferrer">ts playground 地址</a></p>
<h2>总结</h2>
<p>今天我们做了一道综合的 ts 面试题，一共有三层：</p>
<p>第一层实现 js 的逻辑，用递归或者循环都能实现。</p>
<p>第二层给函数加上类型，用 function 声明类型和 interface 声明函数类型两种方式，参数和返回值都是 unknown[]。</p>
<p>第三层是用类型编程实现精准的类型提示，这一层需要拿到参数的类型，通过提取元素的类型并构造出新的数组类型返回。还要通过函数重载的方式来声明类型，并且要注意重载类型的声明顺序。</p>
<p>as const 能够让字面量推导出字面量类型，但会带有 readonly 修饰，可以自己写映射类型来去掉这个修饰。</p>
<p>其实这也是我们学习 ts 的顺序，我们先要能把 js 逻辑写出来，然后知道怎么给函数、class 等加 ts 类型，之后学习类型编程，知道怎么动态生成类型。</p>
<p>其中类型编程是 ts 最难的部分，也是最强大的部分。攻克了这一层，ts 就可以说学的差不多了。</p></div>
</body></html>