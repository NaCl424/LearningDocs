<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>实战：几何图形 - Geometry</h1>
<p>上一章我们介绍了坐标系，了解了如何把经过比例尺映射后的位置属性，转换成可以绘制到画布上的点。那么接下来我们就来看看如何把转换之后的数据真正地画到画布上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68663fd7ae66473ebc172cc73aca7c57~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>和前面一样，我们首先会从几何图形的相关理论讲起，然后在 Sparrow 中实现相关的部分。那么接下来废话不多说，就让我们开始吧。</p>
<h2>几何图形理论</h2>
<p>几何图形理论主要会介绍两个部分：几何图形（Geometry）和通道（Channel）。了解它们会对我们在选择视觉编码的时候会有帮助，就算再复杂的视觉编码也能被拆分成这两个部分去分析。</p>
<p>在可视化中，几何图形是根据数据集中的实体（Item）或者链接（Link）去绘制的图形元素，它还有一个同义词是标志（Mark）。通道又或者说视觉通道是用来控制几何图形的外观的。</p>
<p>下面是《Visualization Analysis &#x26; Design》中的一个例子。(a)条形图中用条这个几何图形来编码两个属性，其中分类属性用条的水平位置通道编码，数值属性用条的竖直位置通道来编码。(b)散点图中用点这个几何图形来编码两个数值属性，它们分别用点的水平和竖直位置通道来编码。(c)用颜色通道来编码一个额外的分类属性。（d）用大小通道来编码一个额外的数值属性。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2039ec498d63406baaa5340ef22994f2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>不同的几何图形拥有不同的通道和外观，接下来我们会实现以下的几何图形。每个几何图形的特征和可以绘制的图表我们会在实现过程中介绍。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02db69695cd4922b98ffee4105fa405~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>下图中展示了一些常见的视觉通道，它们主要分为两类。数值通道（Magnitude Channel）会我们提供和有多少相关的信息，主要用来编码数值属性，比如下图中的位置（Position)、大小（Size）和倾斜角度（Tilt）都是数值属性；特征通道（Identity Channel)给我们提供是什么、在哪里相关的信息，主要用来编码分类属性，比如下图中的形状（Shape）和颜色（Color）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1897de99008d43eab12b40a012c58f37~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>在设计可视化的时候的一个难点就是：面对手中的数据，选择什么几何图形的什么通道去编码数据的属性，可以让可视化结果能更加高效地传递信息？这部分的内容我们会在后面的分析篇中涉及，接下来的主要内容是实现几何图形。</p>
<p>在代码中的几何图形和比例尺、坐标一样，都是一个函数，它会将处理好的数据转化成屏幕上的像素点，因为我们的渲染器是基于 SVG 的，所以其实是转换成对应的 SVG 元素。</p>
<p>需要注意的是：几何图形渲染的数据不是一个数组，而是一个对象。这个对象的每一个 key 都是该几何图形的一个通道，对应的 value 是一个数组，数组的每一个元素是数据和该通道绑定的属性的值。具体可以参考以下的例子。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> data = [
  { <span class="hljs-attr">x</span>: <span class="hljs-number">0.2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0.3</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> },
  { <span class="hljs-attr">x</span>: <span class="hljs-number">0.4</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0.8</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'yellow'</span> },
  { <span class="hljs-attr">x</span>: <span class="hljs-number">0.1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0.6</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'blue'</span> },
]

<span class="hljs-keyword">const</span> values = {
  <span class="hljs-attr">x</span>: [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.1</span>],
  <span class="hljs-attr">y</span>: [<span class="hljs-number">0.3</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.6</span>],
  <span class="hljs-attr">color</span>: [<span class="hljs-string">'red'</span>, <span class="hljs-string">'yellow'</span>, <span class="hljs-string">'blue'</span>]
}
</code></pre>
<p>所有的几何图形都有如下的函数签名，同时也支持返回该几何图形拥有的通道。这些通道一方面可以对我们渲染的数据进行校验，另一方面可以在后面的开发中使用。</p>
<pre><code class="hljs language-js">
<span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">{Renderer}</span> </span>renderer 渲染引擎
 * <span class="hljs-doctag">@param <span class="hljs-type">{number []}</span> </span>I 索引数组
 * <span class="hljs-doctag">@param <span class="hljs-type">{[key:string] Scale}</span> </span>scales 每个通道用到的 scale
 * <span class="hljs-doctag">@param <span class="hljs-type">{[key:string]: number[]}</span> </span>values 每个通道需要渲染的值
 * <span class="hljs-doctag">@param <span class="hljs-type">{[key: string]: string}</span> </span>directStyles 图形的和通道无关的样式
 * <span class="hljs-doctag">@param <span class="hljs-type">{Coordinate}</span> </span>coordinate 使用的坐标系
 * <span class="hljs-doctag">@returns </span>渲染的 SVG 元素
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">geometry</span>(<span class="hljs-params">renderer, I, scales, values, directStyles, coordinate</span>) </span>{}

geometry.channels = <span class="hljs-function">() =></span> ({
  <span class="hljs-attr">x</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'x'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> },
  <span class="hljs-attr">y</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'y'</span> }
})
</code></pre>
<p>接下来还是用散点图的例子来看看几何图形的用法。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { createLinear } <span class="hljs-keyword">from</span> <span class="hljs-string">"./scale"</span>;
<span class="hljs-keyword">import</span> { createCoordinate, transpose, cartesian } <span class="hljs-keyword">from</span> <span class="hljs-string">'./coordinate'</span>;
<span class="hljs-keyword">import</span> { point } <span class="hljs-keyword">from</span> <span class="hljs-string">'./geometry'</span>;

<span class="hljs-comment">// 希望绘制一个散点图来看下面数据的分布</span>
<span class="hljs-keyword">const</span> data = [
  { <span class="hljs-attr">height</span>: <span class="hljs-number">180</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">150</span> },
  { <span class="hljs-attr">height</span>: <span class="hljs-number">163</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">94</span> },
  { <span class="hljs-attr">height</span>: <span class="hljs-number">173</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">130</span> }
];

<span class="hljs-comment">// 将对应的值提取出来</span>
<span class="hljs-keyword">const</span> H = data.map(<span class="hljs-function"><span class="hljs-params">d</span> =></span> d.height);
<span class="hljs-keyword">const</span> W = data.map(<span class="hljs-function"><span class="hljs-params">d</span> =></span> d.weight);
<span class="hljs-keyword">const</span> I = data.map(<span class="hljs-function">(<span class="hljs-params">_, index</span>) =></span> index);
<span class="hljs-keyword">const</span> extent = <span class="hljs-function"><span class="hljs-params">d</span> =></span> [<span class="hljs-built_in">Math</span>.min(...d), <span class="hljs-built_in">Math</span>.max(...d)];

<span class="hljs-comment">// 将数据的 height 映射为点的 x 属性（这里注意 range 是 [0, 1]）</span>
<span class="hljs-keyword">const</span> scaleX = createLinear({
  <span class="hljs-attr">domain</span>: extent(H),
  <span class="hljs-attr">range</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
});

<span class="hljs-comment">// 将数据的 width 映射为点的 y 属性（这里注意 range 是 [0, 1]）</span>
<span class="hljs-keyword">const</span> scaleY = createLinear({
  <span class="hljs-attr">domain</span>: extent(W),
  <span class="hljs-attr">range</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
})

<span class="hljs-comment">// 创建一个坐标系</span>
<span class="hljs-keyword">const</span> coordinate = createCoordinate({
  <span class="hljs-comment">// 指定画布的起点和宽高</span>
  <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">width</span>: <span class="hljs-number">600</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">400</span>,
  <span class="hljs-comment">// 一系列坐标系变换</span>
  <span class="hljs-attr">transforms</span>: [
    transpose(),
    cartesian(),
  ]
});

<span class="hljs-comment">// 使用比例尺映射数据</span>
<span class="hljs-keyword">const</span> values = {
  <span class="hljs-attr">x</span>: H.map(scaleX),
  <span class="hljs-attr">y</span>: W.map(scaleY)
};

<span class="hljs-keyword">const</span> scales = {
  <span class="hljs-attr">x</span>: scaleX,
  <span class="hljs-attr">y</span>: scaleY
};

<span class="hljs-comment">// 设置样式</span>
<span class="hljs-keyword">const</span> styles = {
  <span class="hljs-attr">fill</span>: <span class="hljs-string">'none'</span>,
  <span class="hljs-attr">stroke</span>: <span class="hljs-string">'steelblue'</span>
};

<span class="hljs-comment">// 绘制点</span>
point(renderer, scales, values, styles, coordinate);
</code></pre>
<p>在正式进入写代码环节之前，对 SVG 的 path 元素不了解的可以先去<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths" target="_blank" rel="nofollow noopener noreferrer">这里</a>学习一下，因为接下来的部分很多地方都需要用到它。</p>
<h2>创建通道</h2>
<p>首先我们先来实现通道的创建，每一个通道都是一个对象，它拥有的属性如下。</p>





























<table><thead><tr><th>属性名</th><th>描述</th><th>可选</th><th>默认值</th></tr></thead><tbody><tr><td>name</td><td>属性的名字</td><td>否</td><td>-</td></tr><tr><td>optional</td><td>values 里面是否需要该属性对应的值</td><td>否</td><td><code>true</code></td></tr><tr><td>scale</td><td>需要使用的比例尺</td><td>是</td><td></td></tr></tbody></table>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/channel.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createChannel</span>(<span class="hljs-params">{
  name, 
  optional = <span class="hljs-literal">true</span>,
  ...rest
}</span>) </span>{
  <span class="hljs-keyword">return</span> { name, optional, ...rest };
}
</code></pre>
<p>对于一个标准的几何元素来说，都具有以下的通道。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/channel.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createChannels</span>(<span class="hljs-params">options = {}</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">x</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'x'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }), <span class="hljs-comment">// x 坐标</span>
    <span class="hljs-attr">y</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'y'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }), <span class="hljs-comment">// y 坐标</span>
    <span class="hljs-attr">stroke</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'stroke'</span> }), <span class="hljs-comment">// 边框颜色</span>
    <span class="hljs-attr">fill</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'fill'</span> }), <span class="hljs-comment">// 填充颜色</span>
    ...options,
  };
}
</code></pre>
<h2>创建几何图形</h2>
<p>创建完通道，我们就来看看几何图形的创建。对于每一个几何图形，我们需要定义它的通道和渲染函数，并且在渲染之前检查一下是否提供了需要的数据和正确的比例尺。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/geometry.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGeometry</span>(<span class="hljs-params">channels, render</span>) </span>{
  <span class="hljs-keyword">const</span> geometry = <span class="hljs-function">(<span class="hljs-params">renderer, I, scales, values, styles, coordinate</span>) =></span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, { optional, scale }] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(channels)) {
      <span class="hljs-comment">// 只有必选的通道才会被检查</span>
      <span class="hljs-keyword">if</span> (!optional) {
        <span class="hljs-comment">// 如果没有提供对应的值就抛出异常</span>
        <span class="hljs-keyword">if</span> (!values[key]) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Missing Channel: <span class="hljs-subst">${key}</span>`</span>);
        <span class="hljs-comment">// 目前只用判断一下 band 比例尺</span>
        <span class="hljs-keyword">if</span> (scale === <span class="hljs-string">'band'</span> &#x26;&#x26; (!scales[key] || !scales[key].bandWidth)) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span> channel needs band scale.`</span>);
        }
      }
    }
    <span class="hljs-keyword">return</span> render(renderer, I, scales, values, styles, coordinate);
  };

  <span class="hljs-comment">// 将需要的通道返回</span>
  geometry.channels = <span class="hljs-function">() =></span> channels;

  <span class="hljs-keyword">return</span> geometry;
}
</code></pre>
<p>知道了如何创建一个几何图形，那么接下来我们就来一起实现一些基本的几何图形。</p>
<h2>点（Point）</h2>
<p>首先我们从点（Point）开始，点这个几何图形最基本的使用就是散点图，同时也可以用于气泡图、图可视化等中。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce68efe8e9414caf9bf48c22ad258d6e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>除了基本的通道以外，点还有一个半径（r）通道，去控制点的大小。结合上面的使用方法，下面的代码应该就不难理解了。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/point.js</span>

<span class="hljs-keyword">import</span> { createChannel, createChannels } <span class="hljs-keyword">from</span> <span class="hljs-string">'./channel'</span>;
<span class="hljs-keyword">import</span> { circle } <span class="hljs-keyword">from</span> <span class="hljs-string">'./shape'</span>;
<span class="hljs-keyword">import</span> { channelStyles } <span class="hljs-keyword">from</span> <span class="hljs-string">'./style'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">point</span>(<span class="hljs-params">renderer, I, scales, channels, directStyles, coordinate</span>) </span>{
  <span class="hljs-comment">//  默认的一些属性</span>
  <span class="hljs-keyword">const</span> defaults = {
    <span class="hljs-attr">r</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">fill</span>: <span class="hljs-string">'none'</span>,
  };
  <span class="hljs-comment">// 获取每一个通道经过比例尺映射的值</span>
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">x</span>: X, <span class="hljs-attr">y</span>: Y, <span class="hljs-attr">r</span>: R = [] } = channels;
  
  <span class="hljs-comment">// 通过索引去获得每一条数据各个通道的值</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(I, <span class="hljs-function">(<span class="hljs-params">i</span>) =></span> {
    <span class="hljs-keyword">const</span> { <span class="hljs-attr">r</span>: dr, ...restDefaults } = defaults;
    <span class="hljs-keyword">const</span> r = R[i] || dr;
    <span class="hljs-keyword">return</span> circle(renderer, coordinate, {
      ...restDefaults,
      <span class="hljs-comment">// 元素的样式由直接指定的样式和通过通道指定的样式决定</span>
      <span class="hljs-comment">// 经过通道指定的样式就是和数据相关的样式</span>
      <span class="hljs-comment">// 后的优先级更高</span>
      ...directStyles,
      ...channelStyles(i, channels),
      <span class="hljs-comment">// 圆心的位置</span>
      <span class="hljs-attr">cx</span>: X[i],
      <span class="hljs-attr">cy</span>: Y[i],
      r,
    });
  });
}

point.channels = <span class="hljs-function">() =></span> createChannels({
  <span class="hljs-attr">r</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'r'</span> }),
});
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/style.js</span>

<span class="hljs-comment">// 获得由通道指定的样式</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">channelStyles</span>(<span class="hljs-params">index, channels</span>) </span>{
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">stroke</span>: S, <span class="hljs-attr">fill</span>: F } = channels;
  <span class="hljs-comment">// 只有当 stroke 和 fill 这两个通道被指定的时候才会有用</span>
  <span class="hljs-keyword">return</span> {
    ...(S &#x26;&#x26; { <span class="hljs-attr">stroke</span>: S[index] }),
    ...(F &#x26;&#x26; { <span class="hljs-attr">fill</span>: F[index] }),
  };
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/shape.js</span>

<span class="hljs-comment">// 绘制不同坐标系下面的圆</span>
<span class="hljs-comment">// 绘制圆的函数和渲染器里面绘制圆的区别在于</span>
<span class="hljs-comment">// 这里需要考虑坐标系</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">circle</span>(<span class="hljs-params">renderer, coordinate, { cx, cy, r, ...styles }</span>) </span>{
  <span class="hljs-comment">// 对圆心进行坐标系变换</span>
  <span class="hljs-keyword">const</span> [px, py] = coordinate([cx, cy]);
  <span class="hljs-keyword">return</span> renderer.circle({ <span class="hljs-attr">cx</span>: px, <span class="hljs-attr">cy</span>: py, r, ...styles });
}
</code></pre>
<p>最后运行<a href="https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/point.spec.js" target="_blank" rel="nofollow noopener noreferrer">测试代码</a>会有以下的结果。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f10e77f7ed34208b7d203db1d9d9597~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>文字（Text）</h2>
<p>文字（Text）和点很像，只不过额外拥有旋转角度（rotate）、字体大小（fontSize）和内容（text）这些通道。文本一个典型用法就是词云图。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/622e4d98592a408c84150838c3d1ab39~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>它的实现和点类似。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/text.js</span>

<span class="hljs-keyword">import</span> { createChannel, createChannels } <span class="hljs-keyword">from</span> <span class="hljs-string">'./channel'</span>;
<span class="hljs-keyword">import</span> { createGeometry } <span class="hljs-keyword">from</span> <span class="hljs-string">'./geometry'</span>;
<span class="hljs-keyword">import</span> { text <span class="hljs-keyword">as</span> shapeText } <span class="hljs-keyword">from</span> <span class="hljs-string">'./shape'</span>;
<span class="hljs-keyword">import</span> { channelStyles } <span class="hljs-keyword">from</span> <span class="hljs-string">'./style'</span>;

<span class="hljs-keyword">const</span> channels = createChannels({
  <span class="hljs-attr">rotate</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'rotate'</span> }),
  <span class="hljs-attr">fontSize</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'fontSize'</span> }),
  <span class="hljs-attr">text</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'text'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }),
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">renderer, I, scales, values, directStyles, coordinate</span>) </span>{
  <span class="hljs-keyword">const</span> defaults = {
    <span class="hljs-attr">rotate</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">fontSize</span>: <span class="hljs-number">14</span>,
  };
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">x</span>: X, <span class="hljs-attr">y</span>: Y, <span class="hljs-attr">text</span>: T, <span class="hljs-attr">rotate</span>: R = [], <span class="hljs-attr">fontSize</span>: FS = [] } = values;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(I, <span class="hljs-function">(<span class="hljs-params">i</span>) =></span> shapeText(renderer, coordinate, {
    ...directStyles,
    ...channelStyles(i, values),
    <span class="hljs-attr">x</span>: X[i],
    <span class="hljs-attr">y</span>: Y[i],
    <span class="hljs-attr">rotate</span>: R[i] || defaults.rotate,
    <span class="hljs-attr">fontSize</span>: FS[i] || defaults.fontSize,
    <span class="hljs-attr">text</span>: T[i],
  }));
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> text = createGeometry(channels, render);
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/shape.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">text</span>(<span class="hljs-params">renderer, coordinate, { x, y, rotate, text, ...styles }</span>) </span>{
  <span class="hljs-keyword">const</span> [px, py] = coordinate([x, y]);
  renderer.save();
  <span class="hljs-comment">// 将词旋转</span>
  renderer.translate(px, py);
  renderer.rotate(rotate);
  <span class="hljs-keyword">const</span> textElement = renderer.text({ text, <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>, ...styles });
  renderer.restore();
  <span class="hljs-keyword">return</span> textElement;
}
</code></pre>
<p>最后运行<a href="https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/text.spec.js" target="_blank" rel="nofollow noopener noreferrer">测试代码</a>会有以下的结果。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26d8347b3ebf405599607b015aba2286~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>链接（Link）</h2>
<p>实现完了文字，我们接下来看看链接（Link）。链接可以用来绘制下面图中的边。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6006663372384df0889c5c5e4c9c64ab~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>因为链接本质上就是一条直线，所以它需要通过两个点来确定。我们已经通过通道 x 和 y 去确定一个点了，所以它还需要通过额外的 x1 和 x2 这两个通道去确定另外一个点。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44a6ad31cd014bc2b2a9c7d22542f4de~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>具体的实现如下。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/link.js</span>

<span class="hljs-keyword">import</span> { createChannels, createChannel } <span class="hljs-keyword">from</span> <span class="hljs-string">'./channel'</span>;
<span class="hljs-keyword">import</span> { createGeometry } <span class="hljs-keyword">from</span> <span class="hljs-string">'./geometry'</span>;
<span class="hljs-keyword">import</span> { link <span class="hljs-keyword">as</span> shapeLink } <span class="hljs-keyword">from</span> <span class="hljs-string">'./shape'</span>;
<span class="hljs-keyword">import</span> { channelStyles } <span class="hljs-keyword">from</span> <span class="hljs-string">'./style'</span>;

<span class="hljs-keyword">const</span> channels = createChannels({
  <span class="hljs-attr">x1</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'x1'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }),
  <span class="hljs-attr">y1</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'y1'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }),
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">renderer, I, scales, values, directStyles, coordinate</span>) </span>{
  <span class="hljs-keyword">const</span> defaults = {};
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">x</span>: X, <span class="hljs-attr">y</span>: Y, <span class="hljs-attr">x1</span>: X1, <span class="hljs-attr">y1</span>: Y1 } = values;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(I, <span class="hljs-function">(<span class="hljs-params">i</span>) =></span> shapeLink(renderer, coordinate, {
    ...defaults,
    ...directStyles,
    ...channelStyles(i, values),
    <span class="hljs-attr">x1</span>: X[i],
    <span class="hljs-attr">y1</span>: Y[i],
    <span class="hljs-attr">x2</span>: X1[i],
    <span class="hljs-attr">y2</span>: Y1[i],
  }));
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> link = createGeometry(channels, render);
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/shape.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">link</span>(<span class="hljs-params">renderer, coordinate, { x1, y1, x2, y2, ...styles }</span>) </span>{
  <span class="hljs-keyword">const</span> [p0, p1] = [[x1, y1], [x2, y2]].map(coordinate);
  <span class="hljs-keyword">return</span> renderer.line({ <span class="hljs-attr">x1</span>: p0[<span class="hljs-number">0</span>], <span class="hljs-attr">y1</span>: p0[<span class="hljs-number">1</span>], <span class="hljs-attr">x2</span>: p1[<span class="hljs-number">0</span>], <span class="hljs-attr">y2</span>: p1[<span class="hljs-number">1</span>], ...styles });
}
</code></pre>
<p>最后运行<a href="https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/link.spec.js" target="_blank" rel="nofollow noopener noreferrer">测试代码</a>会有以下的结果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f2fa0c224a24b21a40f933884b2f568~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>线（Line）</h2>
<p>接下来我们来看看线（Line）这个几何图形的实现，线主要用来实现折线图或者雷达图等。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdd01dc047b641efbe7984b4e78984d8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>线是由多个点连接而成，连接它们的可以是直线，也可以是曲线，我们这里只实现通过直线来连接这些点。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a75d1a99343e4951be9db2e53bdec156~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>线除了基本的通道之外，还有一个额外的 z 通道，用来对数据进行分组，从而绘制多条线，参考下面的例子。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// z 通道表示种类</span>
<span class="hljs-keyword">const</span> values = {
  <span class="hljs-attr">x</span>: [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.8</span>],
  <span class="hljs-attr">y</span>: [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.9</span>],
  <span class="hljs-attr">z</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>],
}

<span class="hljs-comment">// 上面的 values 会被拆分成两部分数据</span>
<span class="hljs-comment">// 每部分数据对应一条线</span>
<span class="hljs-comment">// z 为 'a' 的值</span>
<span class="hljs-keyword">const</span> line1 = {
  <span class="hljs-attr">x</span>: [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.9</span>],
  <span class="hljs-attr">y</span>: [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.2</span>],
}

<span class="hljs-comment">// z 为 'b' 的值</span>
<span class="hljs-keyword">const</span> line2 = {
  <span class="hljs-attr">x</span>: [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.8</span>],
  <span class="hljs-attr">y</span>: [<span class="hljs-number">0.9</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.9</span>]
}
</code></pre>
<p>理解了 z 通道，那么接下来的实现就不难理解了。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/line.js</span>

<span class="hljs-keyword">import</span> { createChannel, createChannels } <span class="hljs-keyword">from</span> <span class="hljs-string">'./channel'</span>;
<span class="hljs-keyword">import</span> { groupChannelStyles } <span class="hljs-keyword">from</span> <span class="hljs-string">'./style'</span>;
<span class="hljs-keyword">import</span> { line <span class="hljs-keyword">as</span> shapeLine } <span class="hljs-keyword">from</span> <span class="hljs-string">'./shape'</span>;
<span class="hljs-keyword">import</span> { group } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils'</span>;
<span class="hljs-keyword">import</span> { createGeometry } <span class="hljs-keyword">from</span> <span class="hljs-string">'./geometry'</span>;

<span class="hljs-keyword">const</span> channels = createChannels({
  <span class="hljs-attr">z</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'z'</span> }),
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">renderer, I, scales, values, directStyles, coordinate</span>) </span>{
  <span class="hljs-keyword">const</span> defaults = {};
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">x</span>: X, <span class="hljs-attr">y</span>: Y, <span class="hljs-attr">z</span>: Z } = values;
  <span class="hljs-comment">// 将索引 index 按照 z 通道的值分组</span>
  <span class="hljs-comment">// 每一个组对应一条直线</span>
  <span class="hljs-comment">// 如果 z 通道没有被指定，就默认一个分组，只绘制一条直线</span>
  <span class="hljs-keyword">const</span> series = Z ? group(I, <span class="hljs-function">(<span class="hljs-params">i</span>) =></span> Z[i]).values() : [I];
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(series, <span class="hljs-function">(<span class="hljs-params">I</span>) =></span> shapeLine(renderer, coordinate, {
    ...defaults,
    ...directStyles,
    <span class="hljs-comment">// 获该组的样式</span>
    ...groupChannelStyles(I, values),
    X,
    Y,
    I,
    <span class="hljs-attr">fill</span>: <span class="hljs-string">'none'</span>, <span class="hljs-comment">// 直线是没有填充颜色的</span>
  }));
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> line = createGeometry(channels, render);
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/style.js</span>

<span class="hljs-comment">// 获取这个组的第一个点的样式作为该条线的样式</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">groupChannelStyles</span>(<span class="hljs-params">[index], channels</span>) </span>{
  <span class="hljs-keyword">return</span> channelStyles(index, channels);
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/utils/array.js</span>

<span class="hljs-comment">/**
 * 数据根据 key 分组
 * <span class="hljs-doctag">@param <span class="hljs-type">{T[]}</span> </span>array 需要分组的数据
 * <span class="hljs-doctag">@param <span class="hljs-type">{T => string}</span> </span>key 获得数据 key 的函数
 * <span class="hljs-doctag">@returns <span class="hljs-type">{Map&#x3C;string, T>}</span></span>
 * <span class="hljs-doctag">@example</span>
 * const array = [
 *   {name:'a', value: 1},
 *   {name:'a', value: 2},
 *   {name:'b', value: 3}
 * ]
 * const groups = group(array, d => d.name);
 * groups // Map(2) {'a' => [{name: 'a', value:1}, {name: 'a', value: 2}], 'b' => [{name: 'b', value: 3}]}
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">group</span>(<span class="hljs-params">array, key = (d) => d</span>) </span>{
  <span class="hljs-keyword">const</span> keyGroups = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) {
    <span class="hljs-keyword">const</span> k = key(item);
    <span class="hljs-keyword">const</span> g = keyGroups.get(k);
    <span class="hljs-keyword">if</span> (g) {
      g.push(item);
    } <span class="hljs-keyword">else</span> {
      keyGroups.set(k, [item]);
    }
  }
  <span class="hljs-keyword">return</span> keyGroups;
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/utils/index.js</span>

<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./array'</span>;
</code></pre>
<p>这里稍微提一下绘制一条线的函数：每一条线是一条 path，这条 path 的点由直线的点构成。在极坐标系下这条线需要闭合，所以需要将第一个点加入到最后。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/shape.js</span>

<span class="hljs-keyword">import</span> { line <span class="hljs-keyword">as</span> pathLine } <span class="hljs-keyword">from</span> <span class="hljs-string">'./d'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">line</span>(<span class="hljs-params">renderer, coordinate, { X, Y, I: I0, ...styles }</span>) </span>{
  <span class="hljs-keyword">const</span> I = coordinate.isPolar() ? [...I0, I0[<span class="hljs-number">0</span>]] : I0;
  <span class="hljs-keyword">const</span> points = I.map(<span class="hljs-function">(<span class="hljs-params">i</span>) =></span> coordinate([X[i], Y[i]]));
  <span class="hljs-keyword">const</span> d = pathLine(points);
  <span class="hljs-keyword">return</span> renderer.path({ d, ...styles });
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/d.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">line</span>(<span class="hljs-params">[p0, ...points]</span>) </span>{
  <span class="hljs-keyword">return</span> [
    [<span class="hljs-string">'M'</span>, ...p0],
    ...points.map(<span class="hljs-function">(<span class="hljs-params">p</span>) =></span> [<span class="hljs-string">'L'</span>, ...p]),
  ];
}
</code></pre>
<p>最后运行<a href="https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/line.spec.js" target="_blank" rel="nofollow noopener noreferrer">测试代码</a>会有以下的结果。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfd097d9451f481c9c89633e1cf12e7c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>区域（Area）</h2>
<p>理解了线，那么理解区域（Area）就比较容易了。两条直线如下首位连接起来就成了一个区域。所以对于区域来讲，我们需要 x1 和 y1 两个额外的通道。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6513ce3c94f465aab37bbdc064cba88~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>区域的常见用途就是面积图，河流图和带填充颜色的雷达图。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfcaa8a14c4b46e39c090283e8d3e18f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/area.js</span>

<span class="hljs-keyword">import</span> { createChannel, createChannels } <span class="hljs-keyword">from</span> <span class="hljs-string">'./channel'</span>;
<span class="hljs-keyword">import</span> { groupChannelStyles } <span class="hljs-keyword">from</span> <span class="hljs-string">'./style'</span>;
<span class="hljs-keyword">import</span> { area <span class="hljs-keyword">as</span> shapeArea } <span class="hljs-keyword">from</span> <span class="hljs-string">'./shape'</span>;
<span class="hljs-keyword">import</span> { group } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils'</span>;
<span class="hljs-keyword">import</span> { createGeometry } <span class="hljs-keyword">from</span> <span class="hljs-string">'./geometry'</span>;

<span class="hljs-keyword">const</span> channels = createChannels({
  <span class="hljs-attr">x1</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'x1'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }),
  <span class="hljs-attr">y1</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'y1'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }),
  <span class="hljs-attr">z</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'z'</span> }),
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">renderer, I, scales, values, directStyles, coordinate</span>) </span>{
  <span class="hljs-keyword">const</span> defaults = {};
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">x</span>: X, <span class="hljs-attr">y</span>: Y, <span class="hljs-attr">z</span>: Z, <span class="hljs-attr">x1</span>: X1, <span class="hljs-attr">y1</span>: Y1 } = values;
  <span class="hljs-keyword">const</span> series = Z ? group(I, <span class="hljs-function">(<span class="hljs-params">i</span>) =></span> Z[i]).values() : [I];
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(series, <span class="hljs-function">(<span class="hljs-params">I</span>) =></span> shapeArea(renderer, coordinate, {
    ...defaults,
    ...directStyles,
    ...groupChannelStyles(I, values),
    <span class="hljs-attr">X1</span>: X,
    <span class="hljs-attr">Y1</span>: Y,
    <span class="hljs-attr">X2</span>: X1,
    <span class="hljs-attr">Y2</span>: Y1,
    I,
  }));
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> area = createGeometry(channels, render);
</code></pre>
<p>绘制每一个区域的时候我们也需要针对不同的坐标系使用不同的绘制方式。和线一样，在极坐标系下我们也需要把区域的首尾连接起来。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { contour } <span class="hljs-keyword">from</span> <span class="hljs-string">'./primitive'</span>;
<span class="hljs-keyword">import</span> { area <span class="hljs-keyword">as</span> pathArea } <span class="hljs-keyword">from</span> <span class="hljs-string">'./d'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">area</span>(<span class="hljs-params">renderer, coordinate, { X1, Y1, X2, Y2, I: I0, ...styles }</span>) </span>{
  <span class="hljs-comment">// 连接首尾</span>
  <span class="hljs-keyword">const</span> I = coordinate.isPolar() ? [...I0, I0[<span class="hljs-number">0</span>]] : I0;
  
  <span class="hljs-comment">// 将点按照顺时针方向排列</span>
  <span class="hljs-keyword">const</span> points = [
    ...I.map(<span class="hljs-function">(<span class="hljs-params">i</span>) =></span> [X1[i], Y1[i]]),
    ...I.map(<span class="hljs-function">(<span class="hljs-params">i</span>) =></span> [X2[i], Y2[i]]).reverse(),
  ].map(coordinate);

  <span class="hljs-comment">// 如果是在极坐标系下，绘制等高线</span>
  <span class="hljs-keyword">if</span> (coordinate.isPolar()) {
    <span class="hljs-keyword">return</span> contour(renderer, { points, ...styles });
  }
  
  <span class="hljs-comment">// 否者直接绘制区域</span>
  <span class="hljs-keyword">return</span> renderer.path({ <span class="hljs-attr">d</span>: pathArea(points), ...styles });
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/d.js</span>

<span class="hljs-comment">// 和 line 的区别就是进行了闭合操作</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">area</span>(<span class="hljs-params">points</span>) </span>{
  <span class="hljs-keyword">return</span> [
    ...line(points),
    [<span class="hljs-string">'Z'</span>],
  ];
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/primitive.js</span>

<span class="hljs-keyword">import</span> { area <span class="hljs-keyword">as</span> pathArea, line <span class="hljs-keyword">as</span> pathLine } <span class="hljs-keyword">from</span> <span class="hljs-string">'./d'</span>;

<span class="hljs-comment">// 绘制等高线</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contour</span>(<span class="hljs-params">renderer, { points, ...styles }</span>) </span>{
  <span class="hljs-keyword">const</span> end = points.length;
  <span class="hljs-keyword">const</span> mid = end / <span class="hljs-number">2</span>;
  <span class="hljs-comment">// 用一条 path 绘制等高线本身</span>
  <span class="hljs-keyword">const</span> contour = renderer.path({ <span class="hljs-attr">d</span>: pathArea(points), ...styles, <span class="hljs-attr">stroke</span>: <span class="hljs-string">'none'</span> });
  <span class="hljs-comment">// 用一条 path 绘制外边框</span>
  <span class="hljs-keyword">const</span> outerStroke = renderer.path({ <span class="hljs-attr">d</span>: pathLine(points.slice(<span class="hljs-number">0</span>, mid)), ...styles, <span class="hljs-attr">fill</span>: <span class="hljs-string">'none'</span> });
  <span class="hljs-comment">// 用一条 path 绘制内边框</span>
  <span class="hljs-keyword">const</span> innerStroke = renderer.path({ <span class="hljs-attr">d</span>: pathLine(points.slice(mid, end)), ...styles, <span class="hljs-attr">fill</span>: <span class="hljs-string">'none'</span> });
  <span class="hljs-keyword">return</span> [innerStroke, contour, outerStroke];
}
</code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64fd3b40f2b04e04aa10cf5a90c1b800~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>最后运行<a href="https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/area.spec.js" target="_blank" rel="nofollow noopener noreferrer">测试代码</a>会有以下的结果。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b08ff93df704468faf20c76a21c68459~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>矩形（Rect）</h2>
<p>接下来我们来看矩形（Rect），矩型最常见的用法就是矩阵树图。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/920942cd6e694632856c1589c37d5194~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>矩形除了拥有基本的通道之外，还应该如下图拥有 x1 和  这个两个额外的通道。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3421620cafc4e5d8a1e6bbeb59e905d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/rect.js</span>

<span class="hljs-keyword">import</span> { createChannel, createChannels } <span class="hljs-keyword">from</span> <span class="hljs-string">'./channel'</span>;
<span class="hljs-keyword">import</span> { createGeometry } <span class="hljs-keyword">from</span> <span class="hljs-string">'./geometry'</span>;
<span class="hljs-keyword">import</span> { rect <span class="hljs-keyword">as</span> shapeRect } <span class="hljs-keyword">from</span> <span class="hljs-string">'./shape'</span>;
<span class="hljs-keyword">import</span> { channelStyles } <span class="hljs-keyword">from</span> <span class="hljs-string">'./style'</span>;

<span class="hljs-keyword">const</span> channels = createChannels({
  <span class="hljs-attr">x1</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'x1'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }),
  <span class="hljs-attr">y1</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'y1'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }),
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">renderer, I, scales, values, directStyles, coordinate</span>) </span>{
  <span class="hljs-keyword">const</span> defaults = {};
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">x</span>: X, <span class="hljs-attr">y</span>: Y, <span class="hljs-attr">x1</span>: X1, <span class="hljs-attr">y1</span>: Y1 } = values;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(I, <span class="hljs-function">(<span class="hljs-params">i</span>) =></span> shapeRect(renderer, coordinate, {
    ...defaults,
    ...directStyles,
    ...channelStyles(i, values),
    <span class="hljs-attr">x1</span>: X[i],
    <span class="hljs-attr">y1</span>: Y[i],
    <span class="hljs-attr">x2</span>: X1[i],
    <span class="hljs-attr">y2</span>: Y1[i],
  }));
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> rect = createGeometry(channels, render);
</code></pre>
<p>每一个矩形的绘制可以说是本章最复杂的部分，因为在不同的坐标系下矩形的形状是不同的。假如我们用矩形的四个顶点(p0, p1, p2, p3)去描述它，那在不同坐标系下它的展示方式如下。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa28840636ed49d3bb62d64e70329e67~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>同时如果坐标系发生了转置，我们需要改变顶点的顺序。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfdb63dd161d4cc7a5ab5eae763d0a84~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/shape.js</span>

<span class="hljs-keyword">import</span> { dist, sub, equal } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils'</span>;
<span class="hljs-keyword">import</span> { ring } <span class="hljs-keyword">from</span> <span class="hljs-string">'./primitive'</span>;
<span class="hljs-keyword">import</span> { sector <span class="hljs-keyword">as</span> pathSector } <span class="hljs-keyword">from</span> <span class="hljs-string">'./d'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rect</span>(<span class="hljs-params">renderer, coordinate, { x1, y1, x2, y2, ...styles }</span>) </span>{
  <span class="hljs-keyword">const</span> v0 = [x1, y1];
  <span class="hljs-keyword">const</span> v1 = [x2, y1];
  <span class="hljs-keyword">const</span> v2 = [x2, y2];
  <span class="hljs-keyword">const</span> v3 = [x1, y2];
  
  <span class="hljs-comment">// 如果坐标系转置了，改变顶点的顺序</span>
  <span class="hljs-keyword">const</span> vs = coordinate.isTranspose() ? [v3, v0, v1, v2] : [v0, v1, v2, v3];
  <span class="hljs-keyword">const</span> ps = vs.map(coordinate);
  <span class="hljs-keyword">const</span> [p0, p1, p2, p3] = ps;

  <span class="hljs-comment">// 笛卡尔坐标系绘制矩形</span>
  <span class="hljs-keyword">if</span> (!coordinate.isPolar()) {
    <span class="hljs-keyword">const</span> [width, height] = sub(p2, p0);
    <span class="hljs-keyword">const</span> [x, y] = p0;
    <span class="hljs-keyword">return</span> renderer.rect({ x, y, width, height, ...styles });
  }

  <span class="hljs-comment">// 获得圆心的位置</span>
  <span class="hljs-keyword">const</span> center = coordinate.center();
  <span class="hljs-keyword">const</span> [cx, cy] = center;

  <span class="hljs-comment">// 如果角度小于360度</span>
  <span class="hljs-comment">// 判断的方法是顶点是否重合</span>
  <span class="hljs-comment">// 绘制扇形</span>
  <span class="hljs-keyword">if</span> (!(equal(p0, p1) &#x26;&#x26; equal(p2, p3))) {
    <span class="hljs-keyword">return</span> renderer.path({ <span class="hljs-attr">d</span>: pathSector([center, ...ps]), ...styles });
  }

  <span class="hljs-comment">// 如果角度等于360度，绘制圆环</span>
  <span class="hljs-keyword">const</span> r1 = dist(center, p2); <span class="hljs-comment">// 内半径</span>
  <span class="hljs-keyword">const</span> r2 = dist(center, p0); <span class="hljs-comment">// 外半径</span>
  <span class="hljs-keyword">return</span> ring(renderer, { cx, cy, r1, r2, ...styles });
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/d.js</span>

<span class="hljs-keyword">import</span> { dist, angleBetween, sub } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils'</span>;

<span class="hljs-comment">// 生成绘制扇形的路径</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sector</span>(<span class="hljs-params">[c, p0, p1, p2, p3]</span>) </span>{
  <span class="hljs-keyword">const</span> r = dist(c, p0);
  <span class="hljs-keyword">const</span> r1 = dist(c, p2);
  <span class="hljs-keyword">const</span> a = angleBetween(sub(p0, c), sub(p1, c));
  <span class="hljs-keyword">const</span> l = a > <span class="hljs-built_in">Math</span>.PI ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> l1 = a > <span class="hljs-built_in">Math</span>.PI ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> [
    [<span class="hljs-string">'M'</span>, p0[<span class="hljs-number">0</span>], p0[<span class="hljs-number">1</span>]],
    [<span class="hljs-string">'A'</span>, r, r, <span class="hljs-number">0</span>, l, <span class="hljs-number">1</span>, p1[<span class="hljs-number">0</span>], p1[<span class="hljs-number">1</span>]],
    [<span class="hljs-string">'L'</span>, p2[<span class="hljs-number">0</span>], p2[<span class="hljs-number">1</span>]],
    [<span class="hljs-string">'A'</span>, r1, r1, <span class="hljs-number">0</span>, l1, <span class="hljs-number">0</span>, p3[<span class="hljs-number">0</span>], p3[<span class="hljs-number">1</span>]],
    [<span class="hljs-string">'Z'</span>],
  ];
}
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1d2af96904b4ee78693110d02f5fd4c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/primitive.js</span>

<span class="hljs-keyword">import</span> { ring <span class="hljs-keyword">as</span> pathRing } <span class="hljs-keyword">from</span> <span class="hljs-string">'./d'</span>;

<span class="hljs-comment">// 绘制圆环</span>
<span class="hljs-comment">// 绘制圆环的能力从渲染引擎里面移出了</span>
<span class="hljs-comment">// 为了更好的扩展性，直接在这里绘制即可</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ring</span>(<span class="hljs-params">renderer, { cx, cy, r1, r2, ...styles }</span>) </span>{
  <span class="hljs-comment">// 用一个路径去绘制圆环本身</span>
  <span class="hljs-keyword">const</span> ring = renderer.path({ ...styles, <span class="hljs-attr">d</span>: pathRing([[cx, cy], [r1, r2]]), <span class="hljs-attr">stroke</span>: <span class="hljs-string">'none'</span> });
  <span class="hljs-comment">// 分别用两个圆去绘制圆环的边框</span>
  <span class="hljs-keyword">const</span> innerStroke = renderer.circle({ ...styles, <span class="hljs-attr">fill</span>: <span class="hljs-string">'none'</span>, <span class="hljs-attr">r</span>: r1, cx, cy });
  <span class="hljs-keyword">const</span> outerStroke = renderer.circle({ ...styles, <span class="hljs-attr">fill</span>: <span class="hljs-string">'none'</span>, <span class="hljs-attr">r</span>: r2, cx, cy });
  <span class="hljs-keyword">return</span> [innerStroke, ring, outerStroke];
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/d.js</span>

<span class="hljs-comment">// 生成绘制圆环的路径</span>
<span class="hljs-comment">// 用两个扇形来模拟</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ring</span>(<span class="hljs-params">[c, [r1, r2]]</span>) </span>{
  <span class="hljs-keyword">const</span> [cx, cy] = c;
  <span class="hljs-keyword">const</span> p0 = [cx, cy - r2];
  <span class="hljs-keyword">const</span> p1 = [cx, cy + r2];
  <span class="hljs-keyword">const</span> p2 = [cx, cy + r1];
  <span class="hljs-keyword">const</span> p3 = [cx, cy - r1];
  <span class="hljs-keyword">return</span> [
    ...sector([c, p0, p1, p2, p3]),
    ...sector([c, p1, p0, p3, p2]),
  ];
}
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92ca71d712c7459e8bf6db1d972fe3db~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/utils/vector.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">equal</span>(<span class="hljs-params">[x0, y0], [x1, y1]</span>) </span>{
  <span class="hljs-keyword">return</span> closeTo(x0, x1) &#x26;&#x26; closeTo(y0, y1);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closeTo</span>(<span class="hljs-params">x, y, tol = <span class="hljs-number">1e-5</span></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(x - y) &#x3C; tol;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dist</span>(<span class="hljs-params">[x0, y0], [x1 = <span class="hljs-number">0</span>, y1 = <span class="hljs-number">0</span>] = []</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt((x0 - x1) ** <span class="hljs-number">2</span> + (y0 - y1) ** <span class="hljs-number">2</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub</span>(<span class="hljs-params">[x1, y1], [x0, y0]</span>) </span>{
  <span class="hljs-keyword">return</span> [x1 - x0, y1 - y0];
}

<span class="hljs-comment">// 计算两个向量之间的夹角</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">angleBetween</span>(<span class="hljs-params">v0, v1</span>) </span>{
  <span class="hljs-keyword">const</span> a0 = angle(v0);
  <span class="hljs-keyword">const</span> a1 = angle(v1);
  <span class="hljs-keyword">if</span> (a0 &#x3C; a1) <span class="hljs-keyword">return</span> a1 - a0;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2</span> - (a0 - a1);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">angle</span>(<span class="hljs-params">[x, y]</span>) </span>{
  <span class="hljs-keyword">const</span> theta = <span class="hljs-built_in">Math</span>.atan2(y, x);
  <span class="hljs-keyword">return</span> theta;
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/utils/index.js</span>

<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./vector'</span>;
</code></pre>
<p>最后运行<a href="https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/rect.spec.js" target="_blank" rel="nofollow noopener noreferrer">测试代码</a>会有以下的结果。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4abdc8b703874602a21c0c74dab5921f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>格子（Cell）</h2>
<p>格子（Cell）和矩形的形状都是一样的，不同的是格子没有 x1 和 x2 两个通道，它的 x1 和 x2 这个属性不是通过通道得到的，而是通过比例尺计算出来的。</p>
<p>下面我们用格子常被用于的热力图来举例子。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/476ea2b31b104257876c32b6e6e9a49a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>上面的中每一个格子的 x 和 y 两个通道是由数据本身决定的，但是宽度和高度是分别是由水平方向和竖直方向格子的数量来决定的，而这个过程是通过 band 比例尺计算而得的。我们用竖直方向举例子。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { createBand } <span class="hljs-keyword">from</span> <span class="hljs-string">'./scale'</span>;

<span class="hljs-keyword">const</span> y = createBand({
 <span class="hljs-attr">domain</span>: [<span class="hljs-string">'Friday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Monday'</span>],
 <span class="hljs-attr">range</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
});

<span class="hljs-keyword">const</span> y = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-keyword">const</span> width = y.bandWidth();
<span class="hljs-keyword">const</span> y1 = y + width;
</code></pre>
<p>所以对于格子来说，它 x 和 y 通道的比例尺必须是 band 比例尺，它的实现如下。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/geometry/cell.js</span>

<span class="hljs-keyword">import</span> { createChannels, createChannel } <span class="hljs-keyword">from</span> <span class="hljs-string">'./channel'</span>;
<span class="hljs-keyword">import</span> { createGeometry } <span class="hljs-keyword">from</span> <span class="hljs-string">'./geometry'</span>;
<span class="hljs-keyword">import</span> { rect } <span class="hljs-keyword">from</span> <span class="hljs-string">'./shape'</span>;
<span class="hljs-keyword">import</span> { channelStyles } <span class="hljs-keyword">from</span> <span class="hljs-string">'./style'</span>;

<span class="hljs-keyword">const</span> channels = createChannels({
  <span class="hljs-attr">x</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'x'</span>, <span class="hljs-attr">scale</span>: <span class="hljs-string">'band'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }),
  <span class="hljs-attr">y</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'y'</span>, <span class="hljs-attr">scale</span>: <span class="hljs-string">'band'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }),
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">renderer, I, scales, values, directStyles, coordinate</span>) </span>{
  <span class="hljs-keyword">const</span> defaults = {};
  <span class="hljs-keyword">const</span> { x, y } = scales;
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">x</span>: X, <span class="hljs-attr">y</span>: Y } = values;
  <span class="hljs-keyword">const</span> width = x.bandWidth();
  <span class="hljs-keyword">const</span> height = y.bandWidth();
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(I, <span class="hljs-function">(<span class="hljs-params">i</span>) =></span> rect(renderer, coordinate, {
    ...defaults,
    ...directStyles,
    ...channelStyles(i, values),
    <span class="hljs-attr">x1</span>: X[i],
    <span class="hljs-attr">y1</span>: Y[i],
    <span class="hljs-attr">x2</span>: X[i] + width,
    <span class="hljs-attr">y2</span>: Y[i] + height,
  }));
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> cell = createGeometry(channels, render);
</code></pre>
<p>最后运行<a href="https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/cell.spec.js" target="_blank" rel="nofollow noopener noreferrer">测试代码</a>会有以下的结果。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86df8f3edb394fc286877fa3e3aa855e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>间隔（Interval）</h2>
<p>最后来看看间隔（Interval），间隔一种很强大的几何图形，用它可以绘制出很多图表：条形图，柱状图，玫瑰图，甜甜圈，饼图，瀑布图等等。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8844fa18b7647c3a2c884741c3a5d4d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>间隔和格子有会有点不同，间隔还需要额外的 y1 通道，用来确定矩形的高度。它的宽度同样还是根据 x 通道绑定的 band 比例尺来实现。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0e4660726d444a2b2b96c28124fa933~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>这里需要注意的是间隔还有额外的 z 通道，这点和线、区域是一样的，都是用来分组的。不同的是，这里的 z 通道会绑定一个 band 比例尺，计算间隔在组内的偏移。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2263ed64965348d894a88f1ca44d61ca~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { createChannel, createChannels } <span class="hljs-keyword">from</span> <span class="hljs-string">'./channel'</span>;
<span class="hljs-keyword">import</span> { channelStyles } <span class="hljs-keyword">from</span> <span class="hljs-string">'./style'</span>;
<span class="hljs-keyword">import</span> { rect } <span class="hljs-keyword">from</span> <span class="hljs-string">'./shape'</span>;
<span class="hljs-keyword">import</span> { createGeometry } <span class="hljs-keyword">from</span> <span class="hljs-string">'./geometry'</span>;

<span class="hljs-keyword">const</span> channels = createChannels({
  <span class="hljs-attr">x</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'x'</span>, <span class="hljs-attr">scale</span>: <span class="hljs-string">'band'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }),
  <span class="hljs-attr">z</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'z'</span>, <span class="hljs-attr">scale</span>: <span class="hljs-string">'band'</span> }),
  <span class="hljs-attr">y1</span>: createChannel({ <span class="hljs-attr">name</span>: <span class="hljs-string">'y1'</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> }),
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">renderer, I, scales, values, directStyles, coordinate</span>) </span>{
  <span class="hljs-keyword">const</span> defaults = {
    <span class="hljs-attr">z</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
  };
  <span class="hljs-keyword">const</span> { x, z } = scales;
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">x</span>: X, <span class="hljs-attr">y</span>: Y, <span class="hljs-attr">y1</span>: Y1, <span class="hljs-attr">z</span>: Z = [] } = values;
  <span class="hljs-keyword">const</span> groupWidth = x.bandWidth();
  <span class="hljs-keyword">const</span> intervalWidth = z ? z.bandWidth() : <span class="hljs-number">1</span>;
  <span class="hljs-keyword">const</span> width = groupWidth * intervalWidth;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(I, <span class="hljs-function">(<span class="hljs-params">i</span>) =></span> {
    <span class="hljs-keyword">const</span> { <span class="hljs-attr">z</span>: dz, <span class="hljs-attr">x</span>: dx, ...restDefaults } = defaults;
    <span class="hljs-keyword">const</span> offset = (Z[i] || dz) * groupWidth; <span class="hljs-comment">// 计算偏移</span>
    <span class="hljs-keyword">const</span> x1 = (X[i] || dx) + offset;
    <span class="hljs-keyword">return</span> rect(renderer, coordinate, {
      ...restDefaults,
      ...directStyles,
      ...channelStyles(i, values),
      x1,
      <span class="hljs-attr">y1</span>: Y[i],
      <span class="hljs-attr">x2</span>: x1 + width,
      <span class="hljs-attr">y2</span>: Y1[i],
    });
  });
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> interval = createGeometry(channels, render);
</code></pre>
<p>最后运行<a href="https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/interval.spec.js" target="_blank" rel="nofollow noopener noreferrer">测试代码</a>会有以下的结果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a955edf23a1c4a1cb578a1a95364ca41~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>作业</h2>
<p>又到了给大家布置小作业的时间了，这里大家可以尝试实现一下路径（Path）这个几何图形。它主要有三个通道如下表。</p>





























<table><thead><tr><th>通道名</th><th>描述</th><th>可选</th><th>默认值</th></tr></thead><tbody><tr><td>d</td><td>路径字符串或者数组</td><td>否</td><td>-</td></tr><tr><td>fill</td><td>填充颜色</td><td>否</td><td>-</td></tr><tr><td>stroke</td><td>边框颜色</td><td>是</td><td>-</td></tr></tbody></table>
<p>它主要用来绘制自定义的图形，比如地图等。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> index = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];

<span class="hljs-keyword">const</span> values =  {
    <span class="hljs-attr">fill</span>: [<span class="hljs-string">'#5B8FF9'</span>, <span class="hljs-string">'#5AD8A6'</span>],
    <span class="hljs-attr">d</span>: [ 
      <span class="hljs-string">'M 10 10 L 10 200 L 200 200 Z'</span>,
      [
        [<span class="hljs-string">'M'</span>, <span class="hljs-number">250</span>, <span class="hljs-number">250</span>],
        [<span class="hljs-string">'L'</span>, <span class="hljs-number">250</span>, <span class="hljs-number">300</span>],
        [<span class="hljs-string">'L'</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>],
        [<span class="hljs-string">'Z'</span>],
      ],
    ],
};

path(renderer, index, scales, values, coordinate);
</code></pre>
<p><a href="https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/path.spec.js" target="_blank" rel="nofollow noopener noreferrer">上面的代码</a>可以绘制出以下的效果。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f11f4cfb7e94c8daf526941e1359a2e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>具体的实现可以参考<a href="https://github.com/sparrow-vis/sparrow/tree/main/src/geometry/path.js" target="_blank" rel="nofollow noopener noreferrer">这里</a>。</p>
<h2>小结</h2>
<p>这一章就到这里结束了。我们从认识几何图形和通道开始，知道了几何图形通过通道来控制它的外观，然后了解一些基本的通道和分类的方法。这之后认识并且实现了几种常用的几何图形，并且知道了它们的用途。</p>
<p>也许大家现在还对很多东西比较模糊，不用着急，我们在后面的章节会有很多和几何图形以及通道接触的机会，越到后面大家对它们的理解会更加深刻。</p>
<p>最后这里为下一章做一下预告，下一章我们将进入辅助组件（Guide），看看它们是如何加快我们理解几何图形的速度的。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82543b7a6f47417b85b7ce9de2b93118~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p></div>
</body></html>