<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>实战：渲染流程 - Plot</h1>
<p>经过前面的学习，我们已经把渲染引擎和低级可视化模块开发完了，也了解了对应的可视化概念。那么这一章我们就把已经开发好的这些模块串起来，完成“从0到1开发一个图表库”的这一任务。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/723fb646abdc4a96acc3e50010abf1e8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这一章我们将从 Sparrow 的 API 介绍开始，然后梳理渲染流程，这之后再开始介绍关键代码。这一章可以说是整个实战环节的画龙点睛之笔，那么接下来就让我们开始吧！</p>
<h2>API 设计</h2>
<p>首先我们来看看 API 设计，也就是了解一下该如何使用我们最后完成 Sparrow。</p>
<p>Sparrow 最终只暴露出一个函数：<code>plot</code>。该函数根据指定的 options 渲染图表并且返回一个渲染好的 SVG 元素。函数签名可以用 TypeScript 简单地如下定义：</p>
<pre><code class="hljs language-js">plot(options: SPSpec): SVGSVGElement
</code></pre>
<p>至于这个 options 的结构用 TypeScript 可以简单地如下定义：</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">type</span> SPSpec = SPNode;

<span class="hljs-keyword">type</span> SPNode = {
  <span class="hljs-keyword">type</span>?: <span class="hljs-built_in">string</span>;
  data?: <span class="hljs-built_in">any</span>[],
  scales?: Recode&#x3C;ChannelTypes, Scale>,
  transforms?: Transform[],
  statistics?: Statistic[],
  encodings?: Recode&#x3C;ChannelTypes, Encode>,
  guides?: Recode&#x3C;ChannelTypes, Guide>,
  styles?: Record&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>>
  children?: SPNode[];
  paddingLeft?: <span class="hljs-built_in">number</span>,
  paddingRight?: <span class="hljs-built_in">number</span>,
  paddingTop?: <span class="hljs-built_in">number</span>,
  paddingBottom?: <span class="hljs-built_in">number</span>,
}
</code></pre>
<p>可以发现：它是一个嵌套的结构，描述的是上一章提到的视图树。</p>
<p>每一个节点的 type 除了上一章提到的 layer、col、row 这些<strong>容器节点</strong>之外，还可以是所有几何元素的类型：interval、area、text 等等，这些被称为<strong>视图节点</strong>，当然上一章提到的 facet 节点也算是一个视图节点。容器节点可以有 children 属性，但是视图节点不能有 children 属性。</p>
<p>下面对上面的节点的一些属性进行解释：</p>
<ul>
<li>data：任意类型的数据。</li>
<li>scales：比例尺的配置，比如：<code>{type: 'ordinal', range: ['red', 'yellow']}</code></li>
<li>transforms：数据预处理配置，比如：<code>data => data.sort()</code></li>
<li>statistics：统计函数配置，比如：<code>{type: 'stackY'}</code></li>
<li>encodings：指定几何元素的每个通道用什么编码，比如：<code>{x: 'genre', y: 'sold'}</code></li>
<li>guides：指定辅助组件的配置，比如：<code>{type: 'axisY', display: false}</code></li>
<li>styles：指定几何元素的样式，比如：<code>{strokeWidth: 10}</code></li>
<li>paddingLeft：几何图形区域到整个图表区域的左边距。</li>
<li>paddingRight：几何图形区域到整个图表区域的右边距。</li>
<li>paddingTop：几何图形区域到整个图表区域的上边距。</li>
<li>paddingBottom：几何图形区域到整个图表区域的下边距。</li>
</ul>
<p>对于容器节点来说，上面的属性对其没有效果，但是会被后代中视图节点继承。比如下面两种写法其实是等价的。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 可以理解为是下面的语法糖</span>
<span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'layer'</span>,
  <span class="hljs-attr">encodings</span>: {<span class="hljs-attr">x</span>: <span class="hljs-string">'name'</span>, <span class="hljs-attr">y</span>: <span class="hljs-string">'value'</span>}
  <span class="hljs-attr">children</span>: [
    {<span class="hljs-attr">type</span>: <span class="hljs-string">'point'</span>},
    {<span class="hljs-attr">type</span>: <span class="hljs-string">'line'</span>}
  ],
}

<span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'layer'</span>,
  <span class="hljs-attr">children</span>: [
    <span class="hljs-comment">// encodings 这个配置继承于父亲</span>
    {<span class="hljs-attr">type</span>: <span class="hljs-string">'point'</span>, <span class="hljs-attr">encodings</span>: {<span class="hljs-attr">x</span>: <span class="hljs-string">'name'</span>, <span class="hljs-attr">y</span>: <span class="hljs-string">'value'</span>}},
    {<span class="hljs-attr">type</span>: <span class="hljs-string">'line'</span>, <span class="hljs-attr">encodings</span>: {<span class="hljs-attr">x</span>: <span class="hljs-string">'name'</span>, <span class="hljs-attr">y</span>: <span class="hljs-string">'value'</span>}}
  ],
}
</code></pre>
<p>有了上面的介绍，接下来来看一个简单的例子。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> sports = [
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Sports'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">275</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Strategy'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">115</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Action'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">120</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Shooter'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">350</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Other'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">150</span> },
];
</code></pre>
<p>如果我们要用 Interval 去可视化上面的数据，那么我们将如下使用 Sparrow：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { plot } <span class="hljs-keyword">from</span> <span class="hljs-string">'@sparrow-vis/plot'</span>;

plot({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'interval'</span>, <span class="hljs-comment">// 指定节点的种类是 interval</span>
  <span class="hljs-attr">data</span>: sports, <span class="hljs-comment">// 指定数据</span>
  <span class="hljs-attr">encodings</span>: {
    <span class="hljs-attr">x</span>: <span class="hljs-string">'genre'</span>, <span class="hljs-comment">// 指定 x 通道由数据的 genre 属性决定</span>
    <span class="hljs-attr">y</span>: <span class="hljs-string">'sold'</span>, <span class="hljs-comment">// 指定 y 通道由数据的 sold 属性决定</span>
  },
});
</code></pre>
<p>最后的效果如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7da9b55aa0584523b7a5bdbd5570c765~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>接下来我们来看一个稍微复杂一点的例子，同样是上面的例子，这次我们来绘制一个饼图。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { plot } <span class="hljs-keyword">from</span> <span class="hljs-string">'@sparrow-vis/plot'</span>;

plot({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'interval'</span>,
  <span class="hljs-attr">data</span>: sports,
  <span class="hljs-comment">// 将数据的 sold 字段转换成百分比形式</span>
  <span class="hljs-attr">transforms</span>: [<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
    <span class="hljs-keyword">const</span> sum = data.reduce(<span class="hljs-function">(<span class="hljs-params">total, d</span>) =></span> total + d.sold, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> data.map(<span class="hljs-function">(<span class="hljs-params">{ genre, sold }</span>) =></span> ({ genre, <span class="hljs-attr">sold</span>: sold / sum }));
  }],
  <span class="hljs-comment">// 使用两个坐标系变换：transpose 和 polar</span>
  <span class="hljs-attr">coordinates</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-string">'transpose'</span> }, { <span class="hljs-attr">type</span>: <span class="hljs-string">'polar'</span> }],
  <span class="hljs-comment">// 使用一个统计变换 stackY</span>
  <span class="hljs-attr">statistics</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-string">'stackY'</span> }],
  <span class="hljs-comment">// 设置 x 通道使用的比例尺的 padding 属性</span>
  <span class="hljs-comment">// interval 的 x 通道必须使用 band 比例尺，所以有 padding 属性</span>
  <span class="hljs-attr">scales</span>: {
    <span class="hljs-attr">x</span>: { <span class="hljs-attr">padding</span>: <span class="hljs-number">0</span> },
  },
  <span class="hljs-attr">guides</span>: {
    <span class="hljs-attr">x</span>: { <span class="hljs-attr">display</span>: <span class="hljs-literal">false</span> }, <span class="hljs-comment">// 不显示 x 方向的坐标轴</span>
    <span class="hljs-attr">y</span>: { <span class="hljs-attr">display</span>: <span class="hljs-literal">false</span> }, <span class="hljs-comment">// 不显示 y 方向的坐标轴</span>
  },
  <span class="hljs-attr">encodings</span>: {
    <span class="hljs-attr">y</span>: <span class="hljs-string">'sold'</span>, <span class="hljs-comment">// y 通道和 sold 属性绑定</span>
    <span class="hljs-attr">fill</span>: <span class="hljs-string">'genre'</span>, <span class="hljs-comment">// fill 通道和 genre 属性绑定</span>
  },
  <span class="hljs-comment">// 设置饼图的样式</span>
  <span class="hljs-attr">styles</span>: {
    <span class="hljs-attr">stroke</span>: <span class="hljs-string">'#000'</span>, 
    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-number">2</span>,
  },
})
</code></pre>
<p>最后的效果如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a83a2a45f0d24cd0819c06c21aa1baee~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>了解完了 API 设计，接下来就来看看渲染流程，看看 plot 函数是如何将配置转换成 SVG 元素的，或者是如何把数据转换成像素点的。(更多的使用方式可以参看这里的<a href="https://github.com/sparrow-vis/sparrow/blob/main/__tests__/plot/plot.spec.js" target="_blank" rel="nofollow noopener noreferrer">测试代码</a>）。</p>
<p><strong>在开始看代码之前，大家可以先去 Sparrow 的<a href="https://sparrow-vis.github.io/#/introduction" target="_blank" rel="nofollow noopener noreferrer">官网</a>看看案例，了解一下 Sparrow 的具体使用方式，然后可以先想想自己会如何去实现。</strong> 这之后再读代码的话可以做到事半功倍的效果。</p>
<h2>渲染流程</h2>
<p>Sparrow 整个的渲染流程主要分为下面几个阶段：</p>
<ul>
<li>预处理：视图节点继承祖先容器节点的属性，同时合并同一区域的属性。</li>
<li>获取通道值：
<ul>
<li>通过 transforms 函数转换数据，获得需要可视化的表格数据。</li>
<li>根据编码 encodings 配置从数据中去提取几何图形每个通道对应的值。</li>
<li>通过 statsitcs 函数处理获得的通道值，获得最后真正被可视化出来的通道值。</li>
</ul>
</li>
<li>创建比例尺：根据当前的通道值以及 scales 配置去推断对应比例尺                                                       种类，定义域和值域的值。</li>
<li>创建辅助组件：根据推断出来的比例尺以及 guides 配置去创建对应的辅助元素。</li>
<li>创建坐标系：根据 coordinates 配置去创建对应的坐标系。</li>
<li>绘制：
<ul>
<li>绘制辅助组件。</li>
<li>绘制几何元素。</li>
</ul>
</li>
</ul>
<p>我们通过上面饼图的例子来展示一下这个流程。最开始的数据如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> data = [
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Sports'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">275</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Strategy'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">115</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Action'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">120</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Shooter'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">350</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Other'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">150</span> },
];
</code></pre>
<p>首先数据会经过如下 transforms 函数的转换，这里面的转换会被合成一个函数。</p>
<pre><code class="hljs language-js">plot({
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">transforms</span>: [<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
    <span class="hljs-keyword">const</span> sum = data.reduce(<span class="hljs-function">(<span class="hljs-params">total, d</span>) =></span> total + d.sold, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> data.map(<span class="hljs-function">(<span class="hljs-params">{ genre, sold }</span>) =></span> ({ genre, <span class="hljs-attr">sold</span>: sold / sum }));
  }]
  <span class="hljs-comment">// ...</span>
})
</code></pre>
<p>这一步之后的数据如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> transformedData = [
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Sports'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">0.2722772277227723</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Strategy'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">0.11386138613861387</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Action'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">0.1188118811881188</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Shooter'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">0.3465346534653465</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Other'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">0.1485148514851485</span> },
];
</code></pre>
<p>数据转换之后将会根据 encodings 去提取数据。</p>
<pre><code class="hljs language-js">plot({
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">encodings</span>: {
    <span class="hljs-attr">y</span>: <span class="hljs-string">'sold'</span>, <span class="hljs-comment">// y 通道和 sold 属性绑定</span>
    <span class="hljs-attr">fill</span>: <span class="hljs-string">'genre'</span>, <span class="hljs-comment">// fill 通道和 genre 属性绑定</span>
  },
  <span class="hljs-comment">// ...</span>
})
</code></pre>
<p>根据如上的配置会得到如下的结果：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> values = {
  <span class="hljs-comment">// fill 和 'genre' 字段绑定，所以提取出来是 'genre' 字段的值</span>
  <span class="hljs-attr">fill</span>: [<span class="hljs-string">'Sports'</span>, <span class="hljs-string">'Strategy'</span>, <span class="hljs-string">'Action'</span>, <span class="hljs-string">'Shooter'</span>, <span class="hljs-string">'Other'</span>],
  <span class="hljs-comment">// 没有指定 x 通道的值，默认为 0</span>
  <span class="hljs-attr">x</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  <span class="hljs-comment">// 没有指定 x 通道的值，默认为 0</span>
  <span class="hljs-attr">y1</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  <span class="hljs-comment">// y 和 'sold' 字段绑定，所以提取出来是 'sold' 字段的值</span>
  <span class="hljs-attr">y</span>: [<span class="hljs-number">0.2722772277227723</span>, <span class="hljs-number">0.11386138613861387</span>, <span class="hljs-number">0.1188118811881188</span>, <span class="hljs-number">0.3465346534653465</span>, <span class="hljs-number">0.1485148514851485</span>]
};
</code></pre>
<p>这之后就会就会经过 statistics 去处理数据。</p>
<pre><code class="hljs language-js">plot({
  <span class="hljs-comment">// ... </span>
  <span class="hljs-attr">statistics</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-string">'stackY'</span> }],
  <span class="hljs-comment">// ...</span>
})
</code></pre>
<p>处理后的数据如下，可以发现 y 方向的通道已经被堆叠过了。这个阶段获得的 <code>transformedValues</code> 就是获得的通道值。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> transformedValues = {
  <span class="hljs-comment">// fill 和 'genre' 字段绑定，所以提取出来是 'genre' 字段的值</span>
  <span class="hljs-attr">fill</span>: [<span class="hljs-string">'Sports'</span>, <span class="hljs-string">'Strategy'</span>, <span class="hljs-string">'Action'</span>, <span class="hljs-string">'Shooter'</span>, <span class="hljs-string">'Other'</span>],
  <span class="hljs-comment">// 没有指定 x 通道的值，默认为 0</span>
  <span class="hljs-attr">x</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  <span class="hljs-comment">// 没有指定 x 通道的值，默认为 0</span>
  <span class="hljs-attr">y1</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0.2722772277227723</span>, <span class="hljs-number">0.38613861386138615</span>, <span class="hljs-number">0.504950495049505</span>, <span class="hljs-number">0.8514851485148515</span>],
  <span class="hljs-comment">// y 和 'sold' 字段绑定，所以提取出来是 'sold' 字段的值</span>
  <span class="hljs-attr">y</span>: [<span class="hljs-number">0.2722772277227723</span>, <span class="hljs-number">0.38613861386138615</span>, <span class="hljs-number">0.504950495049505</span>, <span class="hljs-number">0.8514851485148515</span>, <span class="hljs-number">1</span>]
};
</code></pre>
<p>接下来就是根据获得的通道值创建比例尺了。</p>
<pre><code class="hljs language-js">plot({
  <span class="hljs-comment">// ... </span>
  <span class="hljs-attr">scales</span>: {
    <span class="hljs-attr">x</span>: { <span class="hljs-attr">padding</span>: <span class="hljs-number">0</span>}
  },
  <span class="hljs-comment">// ...</span>
})
</code></pre>
<p>下面只展示了根据通道值和 scales 配置推断出来的比例尺比较重要的属性。这里的推断规则会后面介绍。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> scaleDescriptors = {
  <span class="hljs-comment">// stroke 和 fill 通道都是用 color 比例尺</span>
  <span class="hljs-attr">color</span>: {
    <span class="hljs-attr">domain</span>: [<span class="hljs-string">'Sports'</span>, <span class="hljs-string">'Strategy'</span>, <span class="hljs-string">'Action'</span>, <span class="hljs-string">'Shooter'</span>, <span class="hljs-string">'Other'</span>],
    <span class="hljs-attr">range</span>: [<span class="hljs-string">'#5B8FF9'</span>, <span class="hljs-string">'#5AD8A6'</span>, <span class="hljs-comment">/* ... */</span>]
    <span class="hljs-attr">type</span>: <span class="hljs-string">'ordinal'</span>,
  },
  <span class="hljs-comment">// x 方向的通道（x1、x）都使用 x 比例尺</span>
  <span class="hljs-attr">x</span>: {
    <span class="hljs-attr">domain</span>: [<span class="hljs-number">0</span>],
    <span class="hljs-attr">range</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
    <span class="hljs-attr">type</span>: <span class="hljs-string">'band'</span>
  },
  <span class="hljs-comment">// y 方向的通道（y1、y）都使用 y 比例尺</span>
  <span class="hljs-attr">y</span>: {
    <span class="hljs-attr">domain</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
    <span class="hljs-attr">range</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
    <span class="hljs-attr">type</span>: <span class="hljs-string">'linear'</span>
  }
}
</code></pre>
<p>这之后会根据 scaleDescriptors 和 guides 的配置去推断 guidesDescriptors。</p>
<pre><code class="hljs language-js">plot({
  <span class="hljs-comment">// ... </span>
  <span class="hljs-attr">guides</span>: {
    <span class="hljs-attr">x</span>: { <span class="hljs-attr">display</span>: <span class="hljs-literal">false</span> }, <span class="hljs-comment">// 不显示 x 方向的坐标轴</span>
    <span class="hljs-attr">y</span>: { <span class="hljs-attr">display</span>: <span class="hljs-literal">false</span> }, <span class="hljs-comment">// 不显示 y 方向的坐标轴</span>
  },
  <span class="hljs-comment">// ...</span>
})
</code></pre>
<p>最后得到的 guidesDescriptors 如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> guidesDescriptors = {
  <span class="hljs-comment">// color 通道的辅助组件是 legendSwatches</span>
  <span class="hljs-comment">// x 和 y 因为都设置为 display: false 了，所以不现实</span>
  <span class="hljs-attr">color</span>: {
    <span class="hljs-attr">domain</span>: [<span class="hljs-string">'Sports'</span>, <span class="hljs-string">'Strategy'</span>, <span class="hljs-string">'Action'</span>, <span class="hljs-string">'Shooter'</span>, <span class="hljs-string">'Other'</span>]
    <span class="hljs-attr">label</span>: <span class="hljs-string">'genre'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'legendSwatches'</span>,
    <span class="hljs-attr">x</span>: <span class="hljs-number">45</span>, 
    <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>
  }
}
</code></pre>
<p>这之后创建坐标系，绘制辅助组件和几何图形就没有太多需要说的地方了。接下来就进入我们的写代码环节：因为 Plot 这个模块一共有 500 多行代码，所以就不全部在文章中讲解了，这里只会讲解一些比较重要的部分。</p>
<h2>plot</h2>
<p>我们首先从 plot 函数开始，该函数会预处理我们的配置，然后解析描述的视图树，将嵌套的视图树拍平成一个视图树组，最后通过 plotView 函数绘制每一个视图。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/plot/plot.js</span>

<span class="hljs-keyword">import</span> { createViews } <span class="hljs-keyword">from</span> <span class="hljs-string">'../view'</span>;
<span class="hljs-keyword">import</span> { createRenderer } <span class="hljs-keyword">from</span> <span class="hljs-string">'../renderer'</span>;
<span class="hljs-keyword">import</span> { createCoordinate } <span class="hljs-keyword">from</span> <span class="hljs-string">'../coordinate'</span>;
<span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">'./create'</span>;
<span class="hljs-keyword">import</span> { inferScales, applyScales } <span class="hljs-keyword">from</span> <span class="hljs-string">'./scale'</span>;
<span class="hljs-keyword">import</span> { initialize } <span class="hljs-keyword">from</span> <span class="hljs-string">'./geometry'</span>;
<span class="hljs-keyword">import</span> { inferGuides } <span class="hljs-keyword">from</span> <span class="hljs-string">'./guide'</span>;
<span class="hljs-keyword">import</span> { bfs, identity, map, assignDefined } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plot</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-comment">// 创建渲染引擎</span>
  <span class="hljs-keyword">const</span> { width = <span class="hljs-number">640</span>, height = <span class="hljs-number">480</span>, <span class="hljs-attr">renderer</span>: plugin } = root;
  <span class="hljs-keyword">const</span> renderer = createRenderer(width, height, plugin);
  
  <span class="hljs-comment">// 将配置从容器节点流向视图节点</span>
  flow(root);
  
  <span class="hljs-comment">// 将视图树转换成视图树组</span>
  <span class="hljs-keyword">const</span> views = createViews(root);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [view, nodes] <span class="hljs-keyword">of</span> views) {
    <span class="hljs-keyword">const</span> { transform = identity, ...dimensions } = view;
    <span class="hljs-keyword">const</span> geometries = [];
    <span class="hljs-keyword">const</span> scales = {};
    <span class="hljs-keyword">const</span> guides = {};
    <span class="hljs-keyword">let</span> coordinates = [];
    <span class="hljs-keyword">const</span> chartNodes = nodes.filter(<span class="hljs-function">(<span class="hljs-params">{ type }</span>) =></span> isChartNode(type));
    <span class="hljs-comment">// 合并同一区域的所拥有视图的配置</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> options <span class="hljs-keyword">of</span> chartNodes) {
      <span class="hljs-keyword">const</span> {
        <span class="hljs-attr">scales</span>: s = {},
        <span class="hljs-attr">guides</span>: g = {},
        <span class="hljs-attr">coordinates</span>: c = [],
        transforms = [],
        paddingLeft, paddingRight, paddingBottom, paddingTop,
        ...geometry
      } = options;
      assignDefined(scales, s); <span class="hljs-comment">// 合并 scales 配置</span>
      assignDefined(guides, g); <span class="hljs-comment">// 合并 guides 配置</span>
      <span class="hljs-comment">// 合并 padding 等配置</span>
      assignDefined(dimensions, { paddingLeft, paddingRight, paddingBottom, paddingTop });
      <span class="hljs-keyword">if</span> (c) coordinates = c; <span class="hljs-comment">// 使用最后一个视图的坐标系</span>
      <span class="hljs-comment">// 收集该区域的所有几何图形</span>
      geometries.push({ ...geometry, <span class="hljs-attr">transforms</span>: [transform, ...transforms] }); 
    }
    <span class="hljs-comment">// 绘制每一个区域</span>
    plotView({ renderer, scales, guides, geometries, coordinates, ...dimensions });
  }
  <span class="hljs-comment">// 返回 SVG 元素</span>
  <span class="hljs-keyword">return</span> renderer.node();
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/plot/plot.js</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flow</span>(<span class="hljs-params">root</span>) </span>{
  bfs(root, <span class="hljs-function">(<span class="hljs-params">{ type, children, ...options }</span>) =></span> {
    <span class="hljs-keyword">if</span> (isChartNode(type)) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (!children || children.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">const</span> keyDescriptors = [
      <span class="hljs-string">'o:encodings'</span>, <span class="hljs-string">'o:scales'</span>, <span class="hljs-string">'o:guides'</span>, <span class="hljs-string">'o:styles'</span>,
      <span class="hljs-string">'a:coordinates'</span>, <span class="hljs-string">'a:statistics'</span>, <span class="hljs-string">'a:transforms'</span>, <span class="hljs-string">'a:data'</span>,
    ];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> children) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> descriptor <span class="hljs-keyword">of</span> keyDescriptors) {
        <span class="hljs-keyword">const</span> [type, key] = descriptor.split(<span class="hljs-string">':'</span>);
        <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'o'</span>) {
          child[key] = { ...options[key], ...child[key] };
        } <span class="hljs-keyword">else</span> {
          child[key] = child[key] || options[key];
        }
      }
    }
  });
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/plot/plot.js</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isChartNode</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">switch</span> (type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'layer'</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">'col'</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">'row'</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}
</code></pre>
<h2>plotView</h2>
<p>接下来我们来看看 plotView 函数，该函数是真正把图表渲染出来的地方。</p>
<p>在这个流程中有两个函数比较关键：第一个就是 <code>initialize</code> 函数，这是获取每个几何图形通道值的地方；第二就是 <code>inferScales</code> 这个函数，这是给每个通道选择比例尺的地方，只要比例尺选择对了，那么绘制的几何图形就基本上没有问题了。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/plot/plot.js</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plotView</span>(<span class="hljs-params">{
  renderer,
  scales: scalesOptions,
  guides: guidesOptions,
  coordinates: coordinateOptions,
  geometries: geometriesOptions,
  width, height, x, y,
  paddingLeft = <span class="hljs-number">45</span>, paddingRight = <span class="hljs-number">45</span>, paddingBottom = <span class="hljs-number">45</span>, paddingTop = <span class="hljs-number">60</span>,
}</span>) </span>{
  <span class="hljs-comment">// 获得每个通道的值</span>
  <span class="hljs-keyword">const</span> geometries = geometriesOptions.map(initialize);
  <span class="hljs-keyword">const</span> channels = geometries.map(<span class="hljs-function">(<span class="hljs-params">d</span>) =></span> d.channels);
  
  <span class="hljs-comment">// 推断 scales 和 guides</span>
  <span class="hljs-keyword">const</span> scaleDescriptors = inferScales(channels, scalesOptions);
  <span class="hljs-keyword">const</span> guidesDescriptors = inferGuides(scaleDescriptors, { x, y, paddingLeft }, guidesOptions);

  <span class="hljs-comment">// 生成 scales 和 guides</span>
  <span class="hljs-keyword">const</span> scales = map(scaleDescriptors, create);
  <span class="hljs-keyword">const</span> guides = map(guidesDescriptors, create);

  <span class="hljs-comment">// 生成坐标系</span>
  <span class="hljs-keyword">const</span> transforms = inferCoordinates(coordinateOptions).map(create);
  <span class="hljs-keyword">const</span> coordinate = createCoordinate({
    <span class="hljs-attr">x</span>: x + paddingLeft,
    <span class="hljs-attr">y</span>: y + paddingTop,
    <span class="hljs-attr">width</span>: width - paddingLeft - paddingRight,
    <span class="hljs-attr">height</span>: height - paddingTop - paddingBottom,
    transforms,
  });

  <span class="hljs-comment">// 绘制辅助组件</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, guide] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(guides)) {
    <span class="hljs-keyword">const</span> scale = scales[key];
    guide(renderer, scale, coordinate);
  }

  <span class="hljs-comment">// 绘制几何元素</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> { index, geometry, channels, styles } <span class="hljs-keyword">of</span> geometries) {
    <span class="hljs-keyword">const</span> values = applyScales(channels, scales);
    geometry(renderer, index, scales, values, styles, coordinate);
  }
}
</code></pre>
<p>那么接下来我们就一起来看看 <code>initialize</code> 和 <code>inferScales</code> 这两个函数。</p>
<h2>initialize</h2>
<p><code>initialize</code> 主要流程代码如下，具体的实现可以参考注释。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/plot/geometry.js</span>

<span class="hljs-keyword">import</span> { compose, indexOf } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils'</span>;
<span class="hljs-keyword">import</span> { inferEncodings, valueOf } <span class="hljs-keyword">from</span> <span class="hljs-string">'./encoding'</span>;
<span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">'./create'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span>(<span class="hljs-params">{
  data,
  type,
  encodings: E = {},
  statistics: statisticsOptions = [],
  transforms: transformsOptions = [],
  styles,
}</span>) </span>{
  <span class="hljs-comment">// 执行 transform</span>
  <span class="hljs-comment">// 把所有的 transform 都合成一个函数</span>
  <span class="hljs-keyword">const</span> transform = compose(...transformsOptions.map(create));
  <span class="hljs-keyword">const</span> transformedData = transform(data);
  <span class="hljs-keyword">const</span> index = indexOf(transformedData);

  <span class="hljs-comment">// 执行 valueOf</span>
  <span class="hljs-comment">// 从表格数据里面提取各个通道的值</span>
  <span class="hljs-keyword">const</span> encodings = inferEncodings(type, transformedData, E);
  <span class="hljs-keyword">const</span> constants = {};
  <span class="hljs-keyword">const</span> values = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, e] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(encodings)) {
    <span class="hljs-keyword">if</span> (e) {
      <span class="hljs-keyword">const</span> { type, value } = e;
      <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'constant'</span>) constants[key] = value;
      <span class="hljs-keyword">else</span> values[key] = valueOf(transformedData, e);
    }
  }

  <span class="hljs-comment">// 执行 statistics</span>
  <span class="hljs-comment">// 把所有的 statistics 都合成一个函数</span>
  <span class="hljs-keyword">const</span> statistic = compose(...statisticsOptions.map(create));
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">values</span>: transformedValues, <span class="hljs-attr">index</span>: I } = statistic({ index, values });

  <span class="hljs-comment">// 创建通道</span>
  <span class="hljs-keyword">const</span> geometry = create({ type });
  <span class="hljs-keyword">const</span> channels = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, channel] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(geometry.channels())) {
    <span class="hljs-keyword">const</span> values = transformedValues[key];
    <span class="hljs-keyword">const</span> { optional } = channel;
    <span class="hljs-keyword">if</span> (values) {
      channels[key] = createChannel(channel, values, encodings[key]);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!optional) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Missing values for channel:<span class="hljs-subst">${key}</span>`</span>);
    }
  }

  <span class="hljs-comment">// 返回处理好数据</span>
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">index</span>: I, geometry, channels, <span class="hljs-attr">styles</span>: { ...styles, ...constants } };
}
</code></pre>
<p>其中比较关键的函数之一是 <code>inferEncodings</code>这个函数，这个函数一方面会推断出我们编码的种类，一方面会补全我们的编码信息。下面我们将通过两个例子来说明。</p>
<p>首先我们来看看对编码种类的推断。编码本质上也是一个函数，从数据里面提取一列数据。在 Sparrow 里面的编码有三种类型：</p>
<ul>
<li>field：从数据中提取对应字段的值。</li>
<li>transform：对数据的每一条数据进行转换获得一列值。</li>
<li>value：返回一个常量数组。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/plot/encoding</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">valueOf</span>(<span class="hljs-params">data, { type, value }</span>) </span>{
  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'transform'</span>) <span class="hljs-keyword">return</span> data.map(value); <span class="hljs-comment">// transform encoding</span>
  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'value'</span>) <span class="hljs-keyword">return</span> data.map(<span class="hljs-function">() =></span> value); <span class="hljs-comment">// value encoding</span>
  <span class="hljs-keyword">return</span> data.map(<span class="hljs-function">(<span class="hljs-params">d</span>) =></span> d[value]); <span class="hljs-comment">// field encoding</span>
}
</code></pre>
<p>具体参考下面这个例子，最后的效果如下图。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> sports = [
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Sports'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">275</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Strategy'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">115</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Action'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">120</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Shooter'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">350</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">'Other'</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">150</span> },
];

<span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'interval'</span>,
  <span class="hljs-attr">data</span>: sports,
  <span class="hljs-attr">encodings</span>: {
    <span class="hljs-attr">x</span>: <span class="hljs-string">'genre'</span>, <span class="hljs-comment">// field encoding</span>
    <span class="hljs-attr">y</span>: <span class="hljs-function"><span class="hljs-params">d</span> =></span> d.sold * <span class="hljs-number">2</span>, <span class="hljs-comment">// transform encoding</span>
    <span class="hljs-attr">fill</span>: <span class="hljs-string">'steelblue'</span> <span class="hljs-comment">// value encoding</span>
  },
}
</code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8804cd5b459a45468015ee2465e755bd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>具体的推断方法可以查看<a href="https://github.com/sparrow-vis/sparrow/blob/main/src/plot/encoding.js" target="_blank" rel="nofollow noopener noreferrer">这里</a>的 <code>inferType</code> 函数。</p>
<p>接下来我们来看看补全编码信息。在上面绘制条形图的时候，我们对图表的描述如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'interval'</span>,
  <span class="hljs-attr">data</span>: sports,
  <span class="hljs-attr">encodings</span>: {
    <span class="hljs-attr">x</span>: <span class="hljs-string">'genre'</span>,
    <span class="hljs-attr">y</span>: <span class="hljs-string">'sold'</span>,
  },
}
</code></pre>
<p>可以发现在描述中我们是希望通过一个 interval 去可视化数据，并且指定了 interval 的 x 和 y 通道，但是 interval 的 y1 通道却没有指定！这个时候我们就需将这个 y1 通道的编码信息推断出来，最后的结果等于下面的图表描述：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'interval'</span>,
  <span class="hljs-attr">data</span>: sports,
  <span class="hljs-attr">encodings</span>: {
    <span class="hljs-attr">x</span>: <span class="hljs-string">'genre'</span>,
    <span class="hljs-attr">y</span>: <span class="hljs-string">'sold'</span>,
    <span class="hljs-attr">y1</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 推断出来 y1 为 0</span>
  },
}
</code></pre>
<p>不同的几何图形有不同的推断规则，具体可以查看<a href="https://github.com/sparrow-vis/sparrow/blob/main/src/plot/encoding.js" target="_blank" rel="nofollow noopener noreferrer">这里</a>的 <code>inferEncodings</code> 函数。</p>
<h2>inferScales</h2>
<p>了解了 <code>initialize</code> 函数，我们接下来看看 <code>inferScales</code>，<strong>这个函数可以说是整个渲染流程的灵魂</strong>。因为通过前面的学习我们了解到：可视化就是一个数据到图形的过程，而从数据属性到视觉属性需要比例尺去映射。</p>
<p>创建比例尺是一个比较难以理解和麻烦的过程，是使用 D3 等底层可视化组件的过程中需要考虑的问题。但是对于上层可视化框架来说，这部分是要自动完成的的。</p>
<p>而比例尺的创建无非就三个步骤：</p>
<ul>
<li>确定比例尺类型</li>
<li>确定值域</li>
<li>确定定义域</li>
</ul>
<p>具体的实现如下：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/plot/scale.js</span>

<span class="hljs-keyword">import</span> { firstOf, group, lastOf, map, defined } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils'</span>;
<span class="hljs-keyword">import</span> { interpolateColor, interpolateNumber } <span class="hljs-keyword">from</span> <span class="hljs-string">'../scale'</span>;
<span class="hljs-keyword">import</span> { categoricalColors, ordinalColors } <span class="hljs-keyword">from</span> <span class="hljs-string">'./theme'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inferScales</span>(<span class="hljs-params">channels, options</span>) </span>{
  <span class="hljs-keyword">const</span> scaleChannels = group(channels.flatMap(<span class="hljs-built_in">Object</span>.entries), <span class="hljs-function">(<span class="hljs-params">[name]</span>) =></span> scaleName(name));
  <span class="hljs-keyword">const</span> scales = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [name, channels] <span class="hljs-keyword">of</span> scaleChannels) {
    <span class="hljs-keyword">const</span> channel = mergeChannels(name, channels);
    <span class="hljs-keyword">const</span> o = options[name] || {};
    <span class="hljs-keyword">const</span> type = inferScaleType(channel, o); <span class="hljs-comment">// 推断种类</span>
    scales[name] = {
      ...o,
      ...inferScaleOptions(type, channel, o),
      <span class="hljs-attr">domain</span>: inferScaleDomain(type, channel, o), <span class="hljs-comment">// 推断定义域</span>
      <span class="hljs-attr">range</span>: inferScaleRange(type, channel, o), <span class="hljs-comment">// 推断值域</span>
      <span class="hljs-attr">label</span>: inferScaleLabel(type, channel, o), 
      type,
    };
  }
  <span class="hljs-keyword">return</span> scales;
}
</code></pre>
<p>推断比例尺最核心的就是推断比例尺的类型，这里参考 [Observable Plot](<a href="https://github.com/observablehq/plot/blob/main/src/scales.j" target="_blank" rel="nofollow noopener noreferrer">https://github.com/observablehq/plot/blob/main/src/scales.j</a> s) 里面的推断方法，具体的实现如下。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/plot/scale.js</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inferScaleType</span>(<span class="hljs-params">channel, options</span>) </span>{
  <span class="hljs-keyword">const</span> { name, scale, values } = channel; <span class="hljs-comment">// 当前通道信息</span>
  <span class="hljs-keyword">const</span> { type, domain, range } = options; <span class="hljs-comment">// options.scales 里面的配置</span>
  
  <span class="hljs-comment">// 如果通道本身有默认的 scale 种类就是返回当前的种类</span>
  <span class="hljs-comment">// 比如 interval 的 x 的 scale 就是 band</span>
  <span class="hljs-keyword">if</span> (scale) <span class="hljs-keyword">return</span> scale;
  
  <span class="hljs-comment">// 如果用户在配置中声明了 type 就返回当前 type</span>
  <span class="hljs-comment">// 比如 scales: { type: log }</span>
  <span class="hljs-keyword">if</span> (type) <span class="hljs-keyword">return</span> type;
  
  <span class="hljs-comment">// 如果配置中的 range 或者 domain 的长度大于了 2 就说明是离散比例尺</span>
  <span class="hljs-comment">// 比如 scales: {fill: {range: ['red', 'yellow', 'green']}}</span>
  <span class="hljs-keyword">if</span> ((domain || range || []).length > <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> asOrdinalType(name);
  
  <span class="hljs-comment">// 根据配置中 domain 的数据类型决定 scale 的种类</span>
  <span class="hljs-keyword">if</span> (domain !== <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">if</span> (isOrdinal(domain)) <span class="hljs-keyword">return</span> asOrdinalType(name);
    <span class="hljs-keyword">if</span> (isTemporal(domain)) <span class="hljs-keyword">return</span> <span class="hljs-string">'time'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'linear'</span>;
  }
  
  <span class="hljs-comment">// 根据 channel 对应的 values 决定 scale 的种类</span>
  <span class="hljs-keyword">if</span> (isOrdinal(values)) <span class="hljs-keyword">return</span> asOrdinalType(name);
  <span class="hljs-keyword">if</span> (isTemporal(values)) <span class="hljs-keyword">return</span> <span class="hljs-string">'time'</span>;
  <span class="hljs-keyword">if</span> (isUnique(values)) <span class="hljs-keyword">return</span> <span class="hljs-string">'identity'</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">'linear'</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asOrdinalType</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">if</span> (isPosition(name)) <span class="hljs-keyword">return</span> <span class="hljs-string">'dot'</span>; <span class="hljs-comment">// 就是 point 比例尺</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'ordinal'</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPosition</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> name === <span class="hljs-string">'x'</span> || name === <span class="hljs-string">'y'</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isOrdinal</span>(<span class="hljs-params">values</span>) </span>{
  <span class="hljs-keyword">return</span> values.some(<span class="hljs-function">(<span class="hljs-params">v</span>) =></span> {
    <span class="hljs-keyword">const</span> type = <span class="hljs-keyword">typeof</span> v;
    <span class="hljs-keyword">return</span> type === <span class="hljs-string">'string'</span> || type === <span class="hljs-string">'value'</span>;
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTemporal</span>(<span class="hljs-params">values</span>) </span>{
  <span class="hljs-keyword">return</span> values.some(<span class="hljs-function">(<span class="hljs-params">v</span>) =></span> v <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnique</span>(<span class="hljs-params">values</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(values)).length === <span class="hljs-number">1</span>;
}
</code></pre>
<p>本章的渲染流程比较重要的代码就在这里介绍完了，完整的代码可以在<a href="https://github.com/sparrow-vis/sparrow/tree/main/src/plot" target="_blank" rel="nofollow noopener noreferrer">这里</a>浏览，同样也可以通过<a href="https://github.com/sparrow-vis/sparrow/tree/main/__tests__/plot" target="_blank" rel="nofollow noopener noreferrer">这里</a>的测试代码来验证代码的正确性。</p>
<h2>小结</h2>
<p>到目前为止，我们的 Sparrow 就全部开发完成了，没有借助任何依赖，不到 2000 行代码，可以绘制出平时使用的 80% 的图表（具体的图表可以参考<a href="https://github.com/sparrow-vis/sparrow/blob/main/__tests__/plot/plot.spec.js" target="_blank" rel="nofollow noopener noreferrer">这里</a>的测试代码），是不是很有成就感？（发布我们的图表库到 NPM 可以参考这篇<a href="https://juejin.cn/post/7052307032971411463" target="_blank" rel="nofollow noopener noreferrer">文章</a>）</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/879e056ccea346e1bca703561b752506~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>在实战部分，我们从渲染引擎开始，到一个个低级可视化绘制模块，最后再到本章的 Plot 模块的开发。这个过程我们不仅了解了更多可视化概念，这了解了一些编程方面的知识（比如函数式编程等）。</p>
<p>实战完了接下来就进入我们的分析环节，看看用我们的 Sparrow 能否回答之前提出的问题！</p></div>
</body></html>