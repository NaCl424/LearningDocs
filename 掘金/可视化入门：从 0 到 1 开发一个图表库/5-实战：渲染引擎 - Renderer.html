<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>实战：渲染引擎 - Renderer</h1>
<blockquote>
<p>感谢<a href="https://github.com/Aarebecca" target="_blank" rel="nofollow noopener noreferrer">厨神</a>参与这篇文章：什么是渲染引擎、为什么需要渲染引擎以及 @antv/g 相关部分的写作！</p>
</blockquote>
<p>之前在使用 SVG 开发一个条形图的过程中，我们发现有一些地方不方便。比如我们每次绘制一个元素，都需要三步：创建元素，设置元素属性，最后再挂载元素。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 创建元素 </span>
<span class="hljs-keyword">const</span> rect = <span class="hljs-title function_">createSVGElement</span>(<span class="hljs-string">'rect'</span>); 

<span class="hljs-comment">// 设置属性 </span>
rect.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'x'</span>, <span class="hljs-number">10</span>); 
rect.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'y'</span>, <span class="hljs-number">10</span>); 
rect.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'fill'</span>, <span class="hljs-string">'red'</span>); 
rect.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'width'</span>, <span class="hljs-number">50</span>); 
rect.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'height'</span>, <span class="hljs-number">50</span>); 

<span class="hljs-comment">// 挂载元素 </span>
g.<span class="hljs-title function_">appendChild</span>(<span class="hljs-string">'rect'</span>);
</code></pre>
<p>当画布中元素较少时，这种方式还可以忍受。但随着元素数量的增长，这会变得非常冗余和繁琐。所以我们需要开发一个非常简单和轻量级的<strong>渲染引擎（Renderer)</strong>  ，用它简化我们绘图的流程。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c6c10529aa1492eaffaa83d9dc2688a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>通过上图可以发现：Sparrow 将选择 SVG 而不是 Canvas2D 来作为绘图技术，这是因为 Sparrow 对性能没有要求，同时 SVG 相对于 Canvas2D 更好测试一点（SVG 有 DOM 结构，可以直接检查 DOM 来进行调试）。</p>
<p>接下来我们先从什么是渲染引擎讲起以及可视化需要它的原因，然后实现一个简单的渲染引擎，最后会简单拓展一下开源社区一些优秀的渲染引擎。</p>
<h2>什么是渲染引擎</h2>
<p>渲染引擎这一概念在不同领域有着不同的含义。对于前端开发者来数，渲染引擎是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebkit.org%2F" title="https://webkit.org/" target="_blank" rel="nofollow noopener noreferrer">WebKit</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.chromium.org%2Fblink" title="https://www.chromium.org/blink" target="_blank" rel="nofollow noopener noreferrer">Blink</a> 这样的浏览器排版引擎（或者说是内核），它负责解析 HTML 和 CSS 文档，并决定了文档里的元素将以怎样的形式放置在页面中的什么位置（即排版）。</p>
<p>对于艺术和计算机动画工作者来说，渲染引擎是基础图形绘制库，一般具有以下特点：</p>
<ul>
<li>能够绘制基本图形，如：点、直线、多边形、曲线等</li>
<li>支持图形内部填充、阴影效果等</li>
<li>支持纹理与贴图</li>
<li>抗锯齿以及亚像素优化</li>
<li>跨平台运行</li>
</ul>
<p>更高阶的渲染引擎甚至支持粒子系统、光线追踪等效果。</p>
<p>在数据可视化与可视分析领域，尤其是前端可视化方向，我们所使用的渲染引擎更偏向后者，但又有所区别。受平台及场景制约，前端可视化渲染引擎在具备上述特点的同时，还需要具备高性能、轻量化的特性，以满足在低网络传输带宽、低绘制性能等极端场景下的图形渲染需求。此外，在面向分析的可视化领域，3D 视图可能会导致意料之外的错误感知与洞察，因此 2D 渲染引擎得到了更大规模的应用。</p>
<h2>为什么需要渲染引擎</h2>
<p>用户大可直接在浏览器提供的 Canvas2D, SVG 和 WebGL 中使用原生语法直接绘制想要的图形，那么为什么还需要渲染引擎呢？包括上面提到的，这里给出几点原因：</p>
<ul>
<li>管理图元：使用渲染引擎能够更轻松的绘制并管理图形元素。</li>
<li>提供完善的动画与事件机制：原生语法绘制动画相对比较麻烦。</li>
<li>性能优化：渲染引擎基于底层渲染器的特性进行了大量优化工作，如脏矩阵渲染、分层渲染等，能够取得更好的渲染性能。使得开发者能够专注于视图的构建。</li>
<li>多个渲染器之间任意切换：如果有同时在这两种渲染器中进行绘制的需求，需要针对不同的渲染器进行单独开发，提高工作量的同时也难以保证其一致性。使用渲染引擎绘制时只需要指定所需的渲染器即可完成切换。</li>
</ul>
<p>现在我们从概念上简单聊了一下渲染引擎，就像我们一直强调的：具体的实战能帮助我们更好的理解概念，所以接下来我们就来开发 Sparrow 需要的渲染引擎。</p>
<h2>功能设计</h2>
<p>每一次开发都伴随着功能设计，它是我们接下来开发时候依据的蓝图。</p>
<p>因为 Sparrow 的功能相对简单，所以我们渲染器的功能用不复杂，主要侧重于更加轻松地绘制并且管理图形元素，简化我们绘制图形的流程。它主要有两个功能：</p>
<ul>
<li>绘制基本图形：支持 <code>rect</code>、<code>circle</code>、<code>line</code>、<code>path</code>、<code>text</code>、<code>ring</code> 这几种基本图形的绘制。</li>
<li>进行坐标系变换：支持 <code>translate</code>，<code>scale</code>，<code>rotate</code> 这三种变换，同时可以使用类似 <code>Canvas2D</code> 的 <code>save</code> 和 <code>restore</code> 去管理坐标系变换的状态。</li>
</ul>
<p>具体期望的使用方法如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { createRenderer } <span class="hljs-keyword">from</span> <span class="hljs-string">'renderer'</span>; 

<span class="hljs-comment">// 创建渲染器</span>
<span class="hljs-keyword">const</span> renderer = <span class="hljs-title function_">createRenderer</span>(<span class="hljs-number">600</span>, <span class="hljs-number">400</span>);

<span class="hljs-comment">// 绘制基本图形 </span>
renderer.<span class="hljs-title function_">rect</span>({
  <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, 
  <span class="hljs-attr">y</span>: <span class="hljs-number">10</span>, 
  <span class="hljs-attr">width</span>: <span class="hljs-number">50</span>, 
  <span class="hljs-attr">height</span>: <span class="hljs-number">50</span>, 
  <span class="hljs-attr">fill</span>: <span class="hljs-string">'red'</span>, 
});

<span class="hljs-comment">// 坐标变换 </span>
renderer.<span class="hljs-title function_">save</span>(); 
renderer.<span class="hljs-title function_">scale</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); 
renderer.<span class="hljs-title function_">rect</span>({ 
  <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, 
  <span class="hljs-attr">y</span>: <span class="hljs-number">10</span>, 
  <span class="hljs-attr">width</span>: <span class="hljs-number">50</span>, 
  <span class="hljs-attr">height</span>: <span class="hljs-number">50</span> 
}); 
renderer.<span class="hljs-title function_">restore</span>();
</code></pre>
<p>在开始将我们的功能设计落地之前，我们再来看看额外的一个和测试相关的约定。</p>
<h2>测试约定</h2>
<p><strong>本项目是测试驱动的，所以会有测试代码，但是不会在文章里面介绍它们。</strong>  这主要是因为是因为篇幅有限，同时不是小册子的核心内容。当然每当我们新增一个功能的时候，会给出测试代码的仓库地址，大家完成相应的功能可以用提供的测试代码来验证功能是否正确。</p>
<p>比如大家开发完成了 <code>foo</code> 这个函数，就可以增加以下的测试代码，然后运行：<code>npx jest __tests__/hello.spec.js</code> 看是否有问题。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// __tests__/hello.spec.js </span>

<span class="hljs-keyword">import</span> { foo } <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/foo'</span>; 

<span class="hljs-title function_">describe</span>(<span class="hljs-string">'test foo'</span>, <span class="hljs-function">() =></span> { 
  <span class="hljs-title function_">it</span>(<span class="hljs-string">'should returns foo'</span>, <span class="hljs-function">() =></span> { 
    <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">hello</span>()).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">'foo'</span>); 
  }); 
});
</code></pre>
<p>同时我们在写代码的过程中不会完全遵循 <code>airbnb-base</code> 的规范，所以需要修改 .eslintrc.js 如下，关闭一些规则的校验。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// .eslintrc.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">env</span>: {
    <span class="hljs-attr">browser</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">es2021</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">node</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">jest</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-attr">extends</span>: [<span class="hljs-string">'airbnb-base'</span>],
  <span class="hljs-attr">parserOptions</span>: {
    <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-number">13</span>,
    <span class="hljs-attr">sourceType</span>: <span class="hljs-string">'module'</span>,
  },
  <span class="hljs-attr">rules</span>: {
    <span class="hljs-comment">// 关闭 eslint 的如下功能</span>
    <span class="hljs-string">'import/prefer-default-export'</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">'no-use-before-define'</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">'no-shadow'</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">'no-restricted-syntax'</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">'no-return-assign'</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">'no-param-reassign'</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">'no-sequences'</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">'no-loop-func'</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">'no-nested-ternary'</span>: <span class="hljs-number">0</span>,
  },
};
</code></pre>
<p>不小心又说了这么多废话，接下来我们直接进入开发！</p>
<h2>创建渲染引擎（createRenderer）</h2>
<p>我们首先来实现 <code>createRenderer</code> 这个函数来返回我们的渲染器对象。它的所有功能都是通过这个对象对外暴露的。根据上面的功能设计，我们不难得到以下的代码。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/renderer.js</span>

<span class="hljs-keyword">import</span> { createContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'./context'</span>;
<span class="hljs-keyword">import</span> {
  line, circle, text, rect, path, ring,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./shape'</span>;
<span class="hljs-keyword">import</span> {
  restore, save, scale, translate, rotate,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./transform'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRenderer</span>(<span class="hljs-params">width, height</span>) {
  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">createContext</span>(width, height); <span class="hljs-comment">// 创建上下文信息</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">line</span>: <span class="hljs-function">(<span class="hljs-params">options</span>) =></span> <span class="hljs-title function_">line</span>(context, options), 
    <span class="hljs-attr">circle</span>: <span class="hljs-function">(<span class="hljs-params">options</span>) =></span> <span class="hljs-title function_">circle</span>(context, options),
    <span class="hljs-attr">text</span>: <span class="hljs-function">(<span class="hljs-params">options</span>) =></span> <span class="hljs-title function_">text</span>(context, options),
    <span class="hljs-attr">rect</span>: <span class="hljs-function">(<span class="hljs-params">options</span>) =></span> <span class="hljs-title function_">rect</span>(context, options),
    <span class="hljs-attr">path</span>: <span class="hljs-function">(<span class="hljs-params">options</span>) =></span> <span class="hljs-title function_">path</span>(context, options),
    <span class="hljs-attr">ring</span>: <span class="hljs-function">(<span class="hljs-params">options</span>) =></span> <span class="hljs-title function_">ring</span>(context, options), <span class="hljs-comment">// 绘制圆环</span>
    <span class="hljs-attr">restore</span>: <span class="hljs-function">() =></span> <span class="hljs-title function_">restore</span>(context),
    <span class="hljs-attr">save</span>: <span class="hljs-function">() =></span> <span class="hljs-title function_">save</span>(context),
    <span class="hljs-attr">scale</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =></span> <span class="hljs-title function_">scale</span>(context, ...args),
    <span class="hljs-attr">rotate</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =></span> <span class="hljs-title function_">rotate</span>(context, ...args),
    <span class="hljs-attr">translate</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =></span> <span class="hljs-title function_">translate</span>(context, ...args),
    <span class="hljs-attr">node</span>: <span class="hljs-function">() =></span> context.<span class="hljs-property">node</span>, <span class="hljs-comment">// 下面会讲解</span>
    <span class="hljs-attr">group</span>: <span class="hljs-function">() =></span> context.<span class="hljs-property">group</span>, <span class="hljs-comment">// 下面会讲解</span>
  };
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/index.js</span>

<span class="hljs-keyword">export</span> { createRenderer } <span class="hljs-keyword">from</span> <span class="hljs-string">'./renderer'</span>;
</code></pre>
<p>通过上面的代码我们可以发现：在初始化一个渲染器的时候，首先会去创建一个上下文 ，然后再把它给其他函数使用。接下来我们先看看上下文的创建，之后再实现其他函数。</p>
<h2>创建上下文（createContext）</h2>
<p>对于渲染引擎来说，上下文（Context）主要用于保存一些绘制或者其他功能需要的全局的信息，比如挂载画布的容器，当前的填充颜色，边框粗细等。</p>
<p>对于 Sparrow 需要的渲染器来说，它需要的 Context 比较简单：</p>
<ul>
<li>画布节点：这是一个 svg 节点，方便使用者将其挂载到 DOM 需要的位置。</li>
<li>挂载节点：这是一个 g 节点，是当前可以挂载新元素的节点。后面可以看到，我们可以通过更新它来到达管理坐标系变换的功能。</li>
</ul>
<p>Context 的创建是由如下的 <code>createContext(width, height)</code> 这个函数实现的。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/context.js</span>

<span class="hljs-keyword">import</span> { createSVGElement, mount } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createContext</span>(<span class="hljs-params">width, height</span>) {
  <span class="hljs-comment">// 创建画布 svg 节点，并且设置宽高</span>
  <span class="hljs-keyword">const</span> svg = <span class="hljs-title function_">createSVGElement</span>(<span class="hljs-string">'svg'</span>);
  svg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'width'</span>, width);
  svg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'height'</span>, height);
  svg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'viewBox'</span>, <span class="hljs-string">`0 0 <span class="hljs-subst">${width}</span> <span class="hljs-subst">${height}</span>`</span>);

  <span class="hljs-comment">// 创建挂载 g 节点，并且把该 g 节点挂载到 svg 节点上</span>
  <span class="hljs-keyword">const</span> g = <span class="hljs-title function_">createSVGElement</span>(<span class="hljs-string">'g'</span>);
  <span class="hljs-title function_">mount</span>(svg, g);

  <span class="hljs-comment">//返回画布节点和挂载节点</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">node</span>: svg,
    <span class="hljs-attr">group</span>: g,
  };
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/utils.js</span>

<span class="hljs-comment">// 创建 SVG 元素</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createSVGElement</span>(<span class="hljs-params">type</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(<span class="hljs-string">'http://www.w3.org/2000/svg'</span>, type);
}

<span class="hljs-comment">// 将 child 节点挂载到 parent 节点上面</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mount</span>(<span class="hljs-params">parent, child</span>) {
  <span class="hljs-keyword">if</span> (parent) {
    parent.<span class="hljs-title function_">appendChild</span>(child);
  }
}
</code></pre>
<p>在<a href="https://github.com/sparrow-vis/sparrow/blob/main/__tests__/renderer/renderer.spec.js" target="_blank" rel="nofollow noopener noreferrer">这里</a>复制测试代码到本地，通过 <code>DEBUG_MODE=1 npx jest __tests__/renderer/renderer.spec.js</code> 运行它们，如果能得到下面的效果，那么就没有什么问题了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9be0781bc77f4f97bf96c05dbd7bfb67~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p>创建 Context 大概就是这样，接下来我们就看看如何基于这个 Context 去绘制基础图形。</p>
<h2>绘制基本图形</h2>
<p>像文章开头说的那样，在 SVG 环境下我们绘制一个基本图形需要三步：创建元素、设置属性和挂载元素。</p>
<p>因为绘制不同的图形只是在创建元素阶段指定不同的元素类型，所以我们把上面三步封装成一个通用的 <code>shape</code> 函数：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/shape.js</span>

<span class="hljs-keyword">import</span> { applyAttributes, createSVGElement, mount } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">shape</span>(<span class="hljs-params">type, context, attributes</span>) {
  <span class="hljs-keyword">const</span> { group } = context; <span class="hljs-comment">// 挂载元素</span>
  <span class="hljs-keyword">const</span> el = <span class="hljs-title function_">createSVGElement</span>(type); <span class="hljs-comment">// 创建对应的元素</span>
  <span class="hljs-title function_">applyAttributes</span>(el, attributes); <span class="hljs-comment">// 设置属性</span>

  <span class="hljs-title function_">mount</span>(group, el); <span class="hljs-comment">// 挂载</span>
  <span class="hljs-keyword">return</span> el; <span class="hljs-comment">// 返回该元素</span>

}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/utils.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">applyAttributes</span>(<span class="hljs-params">element, attributes</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(attributes)) {
    <span class="hljs-comment">// 这里需要把类似 strokeWidth 的属性转换成 stroke-width 的形式</span>
    <span class="hljs-comment">// 思路就是将大写字母替成 - + 对应的小写字母的形式</span>
    <span class="hljs-comment">// 下面涉及到正则匹配，不太了解的同学可以去下面的链接学习：</span>
    <span class="hljs-comment">// https://juejin.cn/post/6844903487155732494</span>
    <span class="hljs-keyword">const</span> kebabCaseKey = key.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[A-Z]/g</span>, <span class="hljs-function">(<span class="hljs-params">d</span>) =></span> <span class="hljs-string">`-<span class="hljs-subst">${d.toLocaleLowerCase()}</span>`</span>);
    element.<span class="hljs-title function_">setAttribute</span>(kebabCaseKey, value);
  }
}
</code></pre>
<p>当我们完成了 shape 函数之后，那么绘制 <code>line</code>、<code>rect</code>，<code>circle</code> 等这些基本元素就非常容易了，只要给 <code>shape</code> 传入不同的元素的种类并且根据需要进行简单增强即可。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/shape.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">line</span>(<span class="hljs-params">context, attributes</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">shape</span>(<span class="hljs-string">'line'</span>, context, attributes);
}

<span class="hljs-comment">// rect 不支持 width 和 height 是负数，下面这种情况将绘制不出来</span>
<span class="hljs-comment">// &#x3C;rect width="-60" height="-60" x="100" y="100" /> ❌</span>
<span class="hljs-comment">// 为了使其支持负数的 width 和 height，我们转换成如下的形式</span>
<span class="hljs-comment">// &#x3C;rect width="60" height="60" x="40" y="40" /> ✅</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">rect</span>(<span class="hljs-params">context, attributes</span>) {
  <span class="hljs-keyword">const</span> {
    width, height, x, y,
  } = attributes;

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">shape</span>(<span class="hljs-string">'rect'</span>, context, {
    ...attributes,
    <span class="hljs-attr">width</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(width),
    <span class="hljs-attr">height</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(height),
    <span class="hljs-attr">x</span>: width > <span class="hljs-number">0</span> ? x : x + width,
    <span class="hljs-attr">y</span>: height > <span class="hljs-number">0</span> ? y : y + height,
  });
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">circle</span>(<span class="hljs-params">context, attributes</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">shape</span>(<span class="hljs-string">'circle'</span>, context, attributes);
}

<span class="hljs-comment">// text 元素是将展示内容放在标签内部，而不是作为标签的属性</span>
<span class="hljs-comment">// &#x3C;text text='content' /> ❌</span>
<span class="hljs-comment">// &#x3C;text>content&#x3C;/text> ✅</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">text</span>(<span class="hljs-params">context, attributes</span>) {
  <span class="hljs-keyword">const</span> { text, ...rest } = attributes;
  <span class="hljs-keyword">const</span> textElement = <span class="hljs-title function_">shape</span>(<span class="hljs-string">'text'</span>, context, rest);
  textElement.<span class="hljs-property">textContent</span> = text; <span class="hljs-comment">// 通过 textContent 设置标签内的内容</span>
  <span class="hljs-keyword">return</span> textElement;
}

<span class="hljs-comment">// 对 path 不熟悉的同学可以去这里学习</span>
<span class="hljs-comment">// https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths</span>
<span class="hljs-comment">// path 的属性 d （路径）是一个字符串，拼接起来比较麻烦，这里我们通过数组去生成</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//  ['M', 10, 10],</span>
<span class="hljs-comment">//  ['L', 100, 100],</span>
<span class="hljs-comment">//  ['L', 100, 10],</span>
<span class="hljs-comment">//  ['Z'],</span>
<span class="hljs-comment">// ];</span>
<span class="hljs-comment">// 上面的二维数组会被转换成如下的字符串</span>
<span class="hljs-comment">// 'M 10 10 L 100 100 L 100 10 Z'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">path</span>(<span class="hljs-params">context, attributes</span>) {
  <span class="hljs-keyword">const</span> { d } = attributes;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">shape</span>(<span class="hljs-string">'path'</span>, context, { ...attributes, <span class="hljs-attr">d</span>: d.<span class="hljs-title function_">flat</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">' '</span>) });
}
</code></pre>
<p>除了支持 SVG 本来就有的图形之外，我们还需要额外支持一个图形（后面 Dount 图表会使用）：圆环（Ring）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e57f063bc06745929e76004257799e90~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我们将用三个圆去模拟一个圆环，它们的填充色都是透明的，其中两个圆的边框去模拟圆环的边框(上面的红色部分），用一个圆的边框去模拟圆环本身（上面蓝色部分）。实现细节如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ring</span>(<span class="hljs-params">context, attributes</span>) {
  <span class="hljs-comment">// r1 是内圆的半径，r2 是外圆的半径</span>
  <span class="hljs-keyword">const</span> {
    cx, cy, r1, r2, ...styles
  } = attributes;
  <span class="hljs-keyword">const</span> { stroke, strokeWidth, fill } = styles;
  <span class="hljs-keyword">const</span> defaultStrokeWidth = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">const</span> innerStroke = <span class="hljs-title function_">circle</span>(context, {
    <span class="hljs-attr">fill</span>: <span class="hljs-string">'transparent'</span>,
    <span class="hljs-attr">stroke</span>: stroke || fill,
    strokeWidth,
    cx,
    cy,
    <span class="hljs-attr">r</span>: r1,
  });
  <span class="hljs-keyword">const</span> ring = <span class="hljs-title function_">circle</span>(context, {
    ...styles,
    <span class="hljs-attr">strokeWidth</span>: r2 - r1 - (strokeWidth || defaultStrokeWidth),
    <span class="hljs-attr">stroke</span>: fill,
    <span class="hljs-attr">fill</span>: <span class="hljs-string">'transparent'</span>,
    cx,
    cy,
    <span class="hljs-attr">r</span>: (r1 + r2) / <span class="hljs-number">2</span>,
  });
  <span class="hljs-keyword">const</span> outerStroke = <span class="hljs-title function_">circle</span>(context, {
    <span class="hljs-attr">fill</span>: <span class="hljs-string">'transparent'</span>,
    <span class="hljs-attr">stroke</span>: stroke || fill,
    strokeWidth,
    cx,
    cy,
    <span class="hljs-attr">r</span>: r2,
  });
  <span class="hljs-keyword">return</span> [innerStroke, ring, outerStroke];
}
</code></pre>
<p>同样复制<a href="https://github.com/sparrow-vis/sparrow/blob/main/__tests__/renderer/shape.spec.js" target="_blank" rel="nofollow noopener noreferrer">这里</a>的测试代码并且运行，如果运行测试代码能得到如下的效果，那么就也没有什么大问题了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2cb1d69390c4588a72ca36606976aac~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p>实现了绘制图形就这个功能，那么接下来我们就来完成坐标系变换这个功能。</p>
<h2>坐标系变换</h2>
<p>通过前面的学习，我们了解到：在 SVG 中使用坐标变换的能力其实就是给 g 元素添加对应的 transform 属性，然后被 g 元素包裹的所有子元素都会应用这个 transform 属性所指定的变换。</p>
<p>我们的目标让我们的渲染引擎支持：平移（translate）、放缩（Scale) 旋转（Rotate）这三种变换。这三种变换虽然名字和参数不同，但添加流程都是一样的，所以我们可以创建一个名叫 <code>transform</code> 的函数来统一这个流程。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/transform.js</span>

<span class="hljs-keyword">import</span> { applyTransform, createSVGElement, mount } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">type, context, ...params</span>) {
  <span class="hljs-comment">// type 是希望的变换种类：scale，translate，rotate 等</span>
  <span class="hljs-keyword">const</span> { group } = context;
  <span class="hljs-title function_">applyTransform</span>(group, <span class="hljs-string">`<span class="hljs-subst">${type}</span>(<span class="hljs-subst">${params.join(<span class="hljs-string">', '</span>)}</span>)`</span>);
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/utils.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">applyTransform</span>(<span class="hljs-params">element, transform</span>) {
  <span class="hljs-keyword">const</span> oldTransform = element.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'transform'</span>) || <span class="hljs-string">''</span>;
  <span class="hljs-comment">// 将新的变换指定到后面的变换后，这里需要字符串拼接</span>
  <span class="hljs-keyword">const</span> prefix = oldTransform ? <span class="hljs-string">`<span class="hljs-subst">${oldTransform}</span> `</span> : <span class="hljs-string">''</span>;
  element.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'transform'</span>, <span class="hljs-string">`<span class="hljs-subst">${prefix}</span><span class="hljs-subst">${transform}</span>`</span>);
}
</code></pre>
<p>这之后就不难实现如下的坐标系变换了。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/transform.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">translate</span>(<span class="hljs-params">context, tx, ty</span>) {
  <span class="hljs-title function_">transform</span>(<span class="hljs-string">'translate'</span>, context, tx, ty);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">context, theta</span>) {
  <span class="hljs-title function_">transform</span>(<span class="hljs-string">'rotate'</span>, context, theta);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">scale</span>(<span class="hljs-params">context, sx, sy</span>) {
  <span class="hljs-title function_">transform</span>(<span class="hljs-string">'scale'</span>, context, sx, sy);
}
</code></pre>
<p>在使用坐标系变换的时候，除了应用对应变换之外，还应该实现对变换状态的管理。这个地方的核心就是控制当前变换影响的元素范围。基于 SVG 通过 g 元素来指定变换的特点，我们只用更新当前挂载节点，使得当前变换只会影响当前挂载节点下面的元素即可。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/transform.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">context</span>) {
  <span class="hljs-keyword">const</span> { group } = context;
  <span class="hljs-keyword">const</span> newGroup = <span class="hljs-title function_">createSVGElement</span>(<span class="hljs-string">'g'</span>);
  <span class="hljs-title function_">mount</span>(group, newGroup);
  context.<span class="hljs-property">group</span> = newGroup;
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/renderer/transform.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">restore</span>(<span class="hljs-params">context</span>) {
  <span class="hljs-keyword">const</span> { group } = context;
  <span class="hljs-keyword">const</span> { parentNode } = group;
  context.<span class="hljs-property">group</span> = parentNode;
}
</code></pre>
<p>一切正常的话，运行<a href="https://github.com/sparrow-vis/sparrow/blob/main/__tests__/renderer/transform.spec.js" target="_blank" rel="nofollow noopener noreferrer">这里</a>的测试代码会有以下效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f77b14702d64565879b080bebe455de~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p>Sparrow 需要的渲染引擎我们已经完成啦，完整的代码可以在<a href="https://github.com/sparrow-vis/sparrow/tree/main/src/renderer" target="_blank" rel="nofollow noopener noreferrer">这里</a>查看。</p>
<h2>拓展</h2>
<p>虽然上面渲染引擎的开发很简单，但是一个真正优秀的渲染引擎远不如此。接下来我们就来了解几个社区上优秀且强大的渲染引擎。</p>
<p>首先我们来看看 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fg" title="https://github.com/antvis/g" target="_blank" rel="nofollow noopener noreferrer">@antv/g</a> ，它是 AntV 技术栈 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fg2" title="https://github.com/antvis/g2" target="_blank" rel="nofollow noopener noreferrer">G2</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fg6" title="https://github.com/antvis/g6" target="_blank" rel="nofollow noopener noreferrer">G6</a> 等成员的底层渲染引擎（最近 @antv/g 也发布了5.0，大家可以去了解一下！），它具有以下特点：</p>
<ul>
<li>强大、可扩展的渲染能力，并内置常用的基础图形。</li>
<li>极致的渲染性能，支持大数据量的可视化场景。</li>
<li>完整模拟浏览器 DOM 的事件，与原生事件的表现无差异。</li>
<li>流畅的动画实现，以及丰富的配置接口。</li>
<li>同时提供 Canvas 和 SVG 版本的实现，且两者的 API 基本保持一致。</li>
</ul>
<p>用 @antv/g 绘制一个简单的红色的圆形的代码如下：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 引入并选择渲染器</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Renderer</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">CanvasRenderer</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@antv/g-svg'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Canvas</span>, <span class="hljs-title class_">Circle</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@antv/g'</span>;


<span class="hljs-comment">// 实例化渲染器</span>
<span class="hljs-keyword">const</span> canvasRenderer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderer</span>();

<span class="hljs-comment">// 创建一个新的 G 画布</span>
<span class="hljs-keyword">const</span> canvas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Canvas</span>({
  <span class="hljs-attr">container</span>: <span class="hljs-string">'container'</span>, <span class="hljs-comment">// 画布的 DOM ID</span>
  <span class="hljs-attr">width</span>: <span class="hljs-number">500</span>, <span class="hljs-comment">// 画布宽度</span>
  <span class="hljs-attr">height</span>: <span class="hljs-number">500</span>, <span class="hljs-comment">// 画布高度</span>
  <span class="hljs-attr">renderer</span>: canvasRenderer, <span class="hljs-comment">// 渲染器实例化对象</span>
});

<span class="hljs-comment">// 创建一个圆形</span>
<span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>({
  <span class="hljs-attr">style</span>: {
    <span class="hljs-attr">x</span>: <span class="hljs-number">250</span>,
    <span class="hljs-attr">y</span>: <span class="hljs-number">250</span>,
    <span class="hljs-attr">r</span>: <span class="hljs-number">100</span>,
    <span class="hljs-attr">fill</span>: <span class="hljs-string">'red'</span>,
  },
});

<span class="hljs-comment">// 绘制圆形</span>
canvas.<span class="hljs-title function_">appendChild</span>(circle);
</code></pre>
<p>如果说 @antv/g 更注重性能上的提升，那么<a href="https://link.juejin.cn/?target=https%3A%2F%2Fp5js.org%2Fzh-Hans%2F" title="https://p5js.org/zh-Hans/" target="_blank" rel="nofollow noopener noreferrer">p5.js</a> 就更注重易用性。</p>
<p>p5.js 表面上说是一个面向艺术家、设计师、教育家、初学者以及任何其他人的创意编程库，但是它本身其实是一个渲染引擎。它不仅提供了一套完整，简洁的绘制接口，还对 HTML5 元素（如文字、输入框、视屏、摄像头及音频）的使用有支持。</p>
<p>下面我们同样来看看 p5.js 是如何绘制一个圆形的。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">background</span>(<span class="hljs-number">220</span>);
  <span class="hljs-title function_">fill</span>(<span class="hljs-string">'red'</span>);
  <span class="hljs-title function_">circle</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
}
</code></pre>
<p>@antv/g 和 p5js 都是绘制常规风格元素的渲染引擎，<a href="https://link.juejin.cn/?target=https%3A%2F%2Froughjs.com%2F" title="https://roughjs.com/" target="_blank" rel="nofollow noopener noreferrer">rough.js</a> 就不一样了：它绘制出来元素的效果都是手绘风格！</p>
<pre><code class="hljs language-js">rc.<span class="hljs-title function_">circle</span>(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">80</span>, { <span class="hljs-attr">fill</span>: <span class="hljs-string">'red'</span> }); <span class="hljs-comment">// fill with red hachure</span>
rc.<span class="hljs-title function_">rectangle</span>(<span class="hljs-number">120</span>, <span class="hljs-number">15</span>, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>, { <span class="hljs-attr">fill</span>: <span class="hljs-string">'red'</span> });
rc.<span class="hljs-title function_">circle</span>(<span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">80</span>, {
  <span class="hljs-attr">fill</span>: <span class="hljs-string">"rgb(10,150,10)"</span>,
  <span class="hljs-attr">fillWeight</span>: <span class="hljs-number">3</span> <span class="hljs-comment">// thicker lines for hachure</span>
});
rc.<span class="hljs-title function_">rectangle</span>(<span class="hljs-number">220</span>, <span class="hljs-number">15</span>, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>, {
  <span class="hljs-attr">fill</span>: <span class="hljs-string">'red'</span>,
  <span class="hljs-attr">hachureAngle</span>: <span class="hljs-number">60</span>, <span class="hljs-comment">// angle of hachure,</span>
  <span class="hljs-attr">hachureGap</span>: <span class="hljs-number">8</span>
});
rc.<span class="hljs-title function_">rectangle</span>(<span class="hljs-number">120</span>, <span class="hljs-number">105</span>, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>, {
  <span class="hljs-attr">fill</span>: <span class="hljs-string">'rgba(255,0,200,0.2)'</span>,
  <span class="hljs-attr">fillStyle</span>: <span class="hljs-string">'solid'</span> <span class="hljs-comment">// solid fill</span>
});
</code></pre>
<p>上面的代码绘制出来的效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7ca89ab5f4c485683a26feace1e8ced~tplv-k3u1fbpfcp-zoom-1.image" alt="68747470733a2f2f726f7567686a732e636f6d2f696d616765732f6d332e706e67.png"></p>
<h2>作业</h2>
<p>其实基于 roughjs 我们可以做出很多有意思的效果，比如我们可以基于 roughjs 封装和我们上面渲染器相同的 API 的手绘风格渲染器。这样当后面我们把 Sparrow 开发完成之后，我们只用修改渲染器就可以转换图表的绘制风格了。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { plot } <span class="hljs-keyword">from</span> <span class="hljs-string">"@sparrow-vis/sparrow"</span>;
<span class="hljs-keyword">import</span> { createPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">"@sparrow-vis/rough-renderer"</span>

<span class="hljs-keyword">const</span> data = [
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">"Sports"</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">275</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">"Strategy"</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">115</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">"Action"</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">120</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">"Shooter"</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">350</span> },
  { <span class="hljs-attr">genre</span>: <span class="hljs-string">"Other"</span>, <span class="hljs-attr">sold</span>: <span class="hljs-number">150</span> },
];

<span class="hljs-keyword">const</span> chart = <span class="hljs-title function_">plot</span>({
  data,
  <span class="hljs-attr">type</span>: <span class="hljs-string">"interval"</span>,
  <span class="hljs-attr">renderer</span>: <span class="hljs-title function_">createPlugin</span>(), <span class="hljs-comment">// 使用自定义的渲染器</span>
  <span class="hljs-attr">encodings</span>: {
    <span class="hljs-attr">x</span>: <span class="hljs-string">"genre"</span>,
    <span class="hljs-attr">y</span>: <span class="hljs-string">"sold"</span>,
    <span class="hljs-attr">fill</span>: <span class="hljs-string">"genre"</span>
  },
});

<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"container"</span>).<span class="hljs-title function_">appendChild</span>(chart);
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2c2f7e0f2dc445bab8eebed6dce660a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个作为作业大家可以自己尝试实现一下，也可以参考官方的<a href="https://github.com/sparrow-vis/rough-renderer/tree/main" target="_blank" rel="nofollow noopener noreferrer">实现</a>。</p>
<h2>小结</h2>
<p>这一章我们了解了什么是渲染引擎，并且也知道了它想要解决的问题，了解到一个比较完整的渲染引擎应该具有以下特点：</p>
<ul>
<li>轻松绘制和管理图形元素</li>
<li>优秀的渲染性能</li>
<li>对动画有比较好的支持</li>
<li>兼容不同渲染技术</li>
<li>完善的事件机制</li>
</ul>
<p>这之后我们通过开发一个简单的渲染引擎，完成了绘制元素和坐标变换这两个功能。不仅加深了对渲染引擎的理解，也为后面 Sparrow 的更加轻松地绘制图形打下基础。</p>
<p>那么下一篇我们将进入第一个可视化模块的开发：比例尺（Scale），看看它是如何把数据属性映射为视觉属性的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e93df0e7d1af400aa64f4ff03076c1b9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>最后的最后，这章我们算是正式进入 Sparrow 的开发了!</p></div>
</body></html>