<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>IOC：刷新后的处理&SpringBoot在刷新容器时的扩展</h1>
<h1 class="heading">16. IOC：刷新后的处理&amp;SpringBoot在刷新容器时的扩展</h1>
<p>【接前章】</p>
<p>本篇我们解析第9、12、13步骤：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>{
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// ...</span>
            <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span>
            <span class="hljs-comment">// 9. 子类的多态onRefresh</span>
            onRefresh();
            <span class="hljs-comment">// ...</span>
            <span class="hljs-comment">// Last step: publish corresponding event.</span>
            <span class="hljs-comment">// 12. 完成容器的创建工作</span>
            finishRefresh();
        }
        <span class="hljs-keyword">catch</span> (BeansException ex) {
            <span class="hljs-comment">// ...</span>
        }

        <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// Reset common introspection caches in Spring's core, since we</span>
            <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span>
            <span class="hljs-comment">// 13. 清除缓存</span>
            resetCommonCaches();
        }
    }
}
</code></pre><h2 class="heading">12. finishRefresh：完成容器的创建工作</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishRefresh</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span>
    <span class="hljs-comment">// 清除资源缓存(如扫描的ASM元数据)</span>
    clearResourceCaches();

    <span class="hljs-comment">// Initialize lifecycle processor for this context.</span>
    <span class="hljs-comment">// 初始化生命周期处理器</span>
    initLifecycleProcessor();

    <span class="hljs-comment">// Propagate refresh to lifecycle processor first.</span>
    <span class="hljs-comment">// 将刷新传播到生命周期处理器</span>
    getLifecycleProcessor().onRefresh();

    <span class="hljs-comment">// Publish the final event.</span>
    <span class="hljs-comment">// 发布容器刷新完成的事件，让监听器去回调各自的方法</span>
    publishEvent(<span class="hljs-keyword">new</span> ContextRefreshedEvent(<span class="hljs-keyword">this</span>));

    <span class="hljs-comment">// Participate in LiveBeansView MBean, if active.</span>
    LiveBeansView.registerApplicationContext(<span class="hljs-keyword">this</span>);
}
</code></pre><p>这些方法可以看得出来都属于最终的步骤了，简单扫一眼：</p>
<h3 class="heading">12.1 clearResourceCaches：清除资源缓存</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearResourceCaches</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>.resourceCaches.clear();
}
</code></pre><p>非常简单，不再深入。</p>
<h3 class="heading">12.2 initLifecycleProcessor：初始化生命周期处理器</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LIFECYCLE_PROCESSOR_BEAN_NAME = <span class="hljs-string">"lifecycleProcessor"</span>;

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initLifecycleProcessor</span><span class="hljs-params">()</span> </span>{
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    <span class="hljs-keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) {
        <span class="hljs-keyword">this</span>.lifecycleProcessor =
                beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);
        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
            logger.trace(<span class="hljs-string">"Using LifecycleProcessor ["</span> + <span class="hljs-keyword">this</span>.lifecycleProcessor + <span class="hljs-string">"]"</span>);
        }
    }
    <span class="hljs-keyword">else</span> {
        DefaultLifecycleProcessor defaultProcessor = <span class="hljs-keyword">new</span> DefaultLifecycleProcessor();
        defaultProcessor.setBeanFactory(beanFactory);
        <span class="hljs-keyword">this</span>.lifecycleProcessor = defaultProcessor;
        beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="hljs-keyword">this</span>.lifecycleProcessor);
        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
            logger.trace(<span class="hljs-string">"No '"</span> + LIFECYCLE_PROCESSOR_BEAN_NAME + <span class="hljs-string">"' bean, using "</span> +
                    <span class="hljs-string">"["</span> + <span class="hljs-keyword">this</span>.lifecycleProcessor.getClass().getSimpleName() + <span class="hljs-string">"]"</span>);
        }
    }
}
</code></pre><p>可以发现源码中默认使用 <code>DefaultLifecycleProcessor</code> 作为生命周期处理器。它的文档注释原文翻译：</p>
<blockquote>
<p>Default implementation of the LifecycleProcessor strategy.</p>
<p>LifecycleProcessor: Strategy interface for processing Lifecycle beans within the ApplicationContext.</p>
<p>用于在 <code>ApplicationContext</code> 中处理 <code>Lifecycle</code> 类型的Bean的策略接口。</p>
</blockquote>
<p>从文档注释中又看到了一个新的概念：<code>Lifecycle</code> 。</p>
<h4 class="heading">12.2.1 LifeCycle</h4>
<p><code>Lifecycle</code> 是一个接口，它的文档注释原文翻译：</p>
<blockquote>
<p>A common interface defining methods for start/stop lifecycle control. The typical use case for this is to control asynchronous processing. NOTE: This interface does not imply specific auto-startup semantics. Consider implementing SmartLifecycle for that purpose.
Can be implemented by both components (typically a Spring bean defined in a Spring context) and containers (typically a Spring ApplicationContext itself). Containers will propagate start/stop signals to all components that apply within each container, e.g. for a stop/restart scenario at runtime.
Can be used for direct invocations or for management operations via JMX. In the latter case, the org.springframework.jmx.export.MBeanExporter will typically be defined with an org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler, restricting the visibility of activity-controlled components to the Lifecycle interface.
Note that the present Lifecycle interface is only supported on top-level singleton beans. On any other component, the Lifecycle interface will remain undetected and hence ignored. Also, note that the extended SmartLifecycle interface provides sophisticated integration with the application context's startup and shutdown phases.</p>
<p>定义启动/停止生命周期控制方法的通用接口。典型的用例是控制异步处理。注意：此接口并不意味着特定的自动启动语义。考虑为此目的实施 SmartLifecycle。</p>
<p>可以通过组件（通常是在Spring上下文中定义的 <code>Spring</code> bean）和容器（通常是Spring <code>ApplicationContext</code> 本身）实现。容器会将开始/停止信号传播到每个容器中应用的所有组件，例如在运行时停止/重新启动的情况。</p>
<p>可以用于直接调用或通过JMX进行管理操作。在后一种情况下，通常将使用 <code>InterfaceBasedMBeanInfoAssembler</code> 定义 <code>MBeanExporter</code>，从而将活动控制的组件的可见性限制为 <code>Lifecycle</code> 接口。</p>
<p>请注意，当前的 <code>Lifecycle</code> 接口仅在顶级 <code>Singleton Bean</code> 上受支持。在任何其他组件上，<code>Lifecycle</code> 接口将保持未被检测到并因此被忽略。另外，请注意，扩展的 <code>SmartLifecycle</code> 接口提供了与应用程序上下文的启动和关闭阶段的复杂集成。</p>
</blockquote>
<p>到这里我们大概看懂了，实现了 <code>Lifecycle</code> 接口的Bean可以<strong>规范化它的生命周期</strong>，可以在IOC容器的启动、停止时，自动触发接口中定义的 <code>start</code> 方法和 <code>stop</code> 方法。</p>
<h4 class="heading">12.2.2 【扩展】SmartLifeCycle</h4>
<p><code>Lifecycle</code> 还有一个扩展的接口：<code>SmartLifecycle</code> ，它的文档注释关键部分：</p>
<blockquote>
<p>An extension of the Lifecycle interface for those objects that require to be started upon ApplicationContext refresh and/or shutdown in a particular order. The isAutoStartup() return value indicates whether this object should be started at the time of a context refresh. The callback-accepting stop(Runnable) method is useful for objects that have an asynchronous shutdown process. Any implementation of this interface must invoke the callback's run() method upon shutdown completion to avoid unnecessary delays in the overall ApplicationContext shutdown.</p>
<p><code>Lifecycle</code> 接口的扩展，用于那些需要按特定顺序刷新和/或关闭IOC容器时启动的对象。 <code>isAutoStartup()</code> 返回值指示是否应在刷新上下文时启动此对象。接受回调的 <code>stop(Runnable)</code> 方法对于具有异步关闭过程的对象很有用。此接口的任何实现都必须在关闭完成时调用回调的 <code>run()</code> 方法，以避免在整个IOC容器关闭中不必要的延迟。</p>
</blockquote>
<p>从文档注释中可以看到一个很关键的信息：<code>stop(Runnable)</code> ，这就意味着可以在 <code>stop</code> 动作中再注入一些自定义逻辑。从它的方法定义中，可以看到它还扩展了几个方法：</p>
<ul>
<li><code>getPhase</code> - Bean的排序（类似于 <code>@Order</code> 或 <code>Ordered</code> 接口）</li>
<li><code>isAutoStartup</code> - 如果该方法返回 false ，则不执行 start 方法。</li>
</ul>
<p>这两个接口比较简单，不再深入研究，有兴趣的小伙伴可以写几个测试Demo体会一下。</p>
<h3 class="heading">12.3 getLifecycleProcessor().onRefresh()</h3>
<p>紧接着调用这些 <code>LifecycleProcessor</code> 的 <code>onRefresh</code> 方法。具体到 <code>DefaultLifecycleProcessor</code> 中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> </span>{
    startBeans(<span class="hljs-keyword">true</span>);
    <span class="hljs-keyword">this</span>.running = <span class="hljs-keyword">true</span>;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startBeans</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoStartupOnly)</span> </span>{
    Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();
    Map&lt;Integer, LifecycleGroup&gt; phases = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    lifecycleBeans.forEach((beanName, bean) -&gt; {
        <span class="hljs-keyword">if</span> (!autoStartupOnly || (bean <span class="hljs-keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) {
            <span class="hljs-keyword">int</span> phase = getPhase(bean);
            LifecycleGroup group = phases.get(phase);
            <span class="hljs-keyword">if</span> (group == <span class="hljs-keyword">null</span>) {
                group = <span class="hljs-keyword">new</span> LifecycleGroup(phase, <span class="hljs-keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);
                phases.put(phase, group);
            }
            group.add(beanName, bean);
        }
    });
    <span class="hljs-keyword">if</span> (!phases.isEmpty()) {
        List&lt;Integer&gt; keys = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(phases.keySet());
        Collections.sort(keys);
        <span class="hljs-keyword">for</span> (Integer key : keys) {
            phases.get(key).start();
        }
    }
}
</code></pre><p>源码也是比较好理解的，它会从IOC容器中找出所有的 <code>Lifecycle</code> 类型的Bean，遍历回调 <code>start</code> 方法。</p>
<h3 class="heading">12.4 publishEvent(new ContextRefreshedEvent(this))</h3>
<p>很明显它发布了 <code>ContextRefreshedEvent</code> 事件，代表IOC容器已经刷新完成。有关事件与监听器的部分，我们在13篇中已经解释过了，不再赘述。</p>
<h2 class="heading">13. resetCommonCaches：清除缓存</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetCommonCaches</span><span class="hljs-params">()</span> </span>{
    ReflectionUtils.clearCache();
    AnnotationUtils.clearCache();
    ResolvableType.clearCache();
    CachedIntrospectionResults.clearClassLoader(getClassLoader());
}
</code></pre><p>清除缓存也是够简单了，不再深追。</p>
<hr>
<p>以上就是全部 <code>AbstractApplicationContext</code> 的 <strong>refresh</strong> 方法了。之前留了一个章节，说 <code>SpringBoot</code> 对 <code>onRefresh</code> 方法有一个扩展，下面咱来看看都扩展了个什么东西：</p>
<h2 class="heading">9. ServletWebServerApplicationContext.onRefresh</h2>
<p>在第13篇中，我们说在 <code>AbstractApplicationContext</code> 中没有真正实现这个方法，而是留给了子类。SpringBoot 扩展的IOC容器中对这个方法进行了真正地实现：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.onRefresh();
    <span class="hljs-keyword">try</span> {
        createWebServer();
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">"Unable to start web server"</span>, ex);
    }
}
</code></pre><p>它要创建一个WebServer：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createWebServer</span><span class="hljs-params">()</span> </span>{
    WebServer webServer = <span class="hljs-keyword">this</span>.webServer;
    ServletContext servletContext = getServletContext();
    <span class="hljs-keyword">if</span> (webServer == <span class="hljs-keyword">null</span> &amp;&amp; servletContext == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 9.1 这一步创建了嵌入式Servlet容器的工厂</span>
        ServletWebServerFactory factory = getWebServerFactory();
        <span class="hljs-comment">// 9.2 创建嵌入式Servlet容器</span>
        <span class="hljs-keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (servletContext != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">try</span> {
            getSelfInitializer().onStartup(servletContext);
        }
        <span class="hljs-keyword">catch</span> (ServletException ex) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">"Cannot initialize servlet context"</span>, ex);
        }
    }
    initPropertySources();
}
</code></pre><h3 class="heading">9.1 getWebServerFactory：获取嵌入式Servlet容器工厂Bean</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ServletWebServerFactory <span class="hljs-title">getWebServerFactory</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Use bean names so that we don't consider the hierarchy</span>
    <span class="hljs-comment">//获取IOC容器中类型为ServletWebServerFactory的Bean</span>
    String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);
    <span class="hljs-keyword">if</span> (beanNames.length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">"Unable to start ServletWebServerApplicationContext due to missing "</span>
                + <span class="hljs-string">"ServletWebServerFactory bean."</span>);
    }
    <span class="hljs-keyword">if</span> (beanNames.length &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">"Unable to start ServletWebServerApplicationContext due to multiple "</span>
                + <span class="hljs-string">"ServletWebServerFactory beans : "</span> + StringUtils.arrayToCommaDelimitedString(beanNames));
    }
    <span class="hljs-keyword">return</span> getBeanFactory().getBean(beanNames[<span class="hljs-number">0</span>], ServletWebServerFactory.class);
}
</code></pre><p>因为一次创建只能运行在一个 Servlet容器中，说明一次只能取出一个Bean来。</p>
<p>默认的 <code>Tomcat</code> 创建工厂应该从这里取出：<code>TomcatServletWebServerFactory</code>，他实现了 <code>ServletWebServerFactory</code> 接口。</p>
<p>这个 <code>TomcatServletWebServerFactory</code>，应该是在自动配置时注册好的。</p>
<h4 class="heading">9.1.1 自动配置下的 TomcatServletWebServerFactory 注册时机</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)
<span class="hljs-meta">@ConditionalOnClass</span>(ServletRequest.class)
<span class="hljs-meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)
<span class="hljs-meta">@EnableConfigurationProperties</span>(ServerProperties.class)
<span class="hljs-meta">@Import</span>({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,
        ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,
        ServletWebServerFactoryConfiguration.EmbeddedJetty.class,
        ServletWebServerFactoryConfiguration.EmbeddedUndertow.class })
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletWebServerFactoryAutoConfiguration</span>
</span></code></pre><p>这个类我们之前看过，它使用 <code>@Import</code> 导入了 <code>ServletWebServerFactoryConfiguration</code> 以及三个内部类：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletWebServerFactoryConfiguration</span> </span>{

    <span class="hljs-meta">@Configuration</span>
    <span class="hljs-comment">// 如果classpath下有Servlet的类，有Tomcat的类，有UpgradeProtocol的类，这个配置就生效</span>
    <span class="hljs-meta">@ConditionalOnClass</span>({ Servlet.class, Tomcat.class, UpgradeProtocol.class })
    <span class="hljs-meta">@ConditionalOnMissingBean</span>(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedTomcat</span> </span>{
        <span class="hljs-meta">@Bean</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> TomcatServletWebServerFactory <span class="hljs-title">tomcatServletWebServerFactory</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TomcatServletWebServerFactory();
        }
    }

    <span class="hljs-meta">@Configuration</span>
    <span class="hljs-meta">@ConditionalOnClass</span>({ Servlet.class, Server.class, Loader.class, WebAppContext.class })
    <span class="hljs-meta">@ConditionalOnMissingBean</span>(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedJetty</span> </span>{
        <span class="hljs-meta">@Bean</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> JettyServletWebServerFactory <span class="hljs-title">JettyServletWebServerFactory</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JettyServletWebServerFactory();
        }
    }

    <span class="hljs-meta">@Configuration</span>
    <span class="hljs-meta">@ConditionalOnClass</span>({ Servlet.class, Undertow.class, SslClientAuthMode.class })
    <span class="hljs-meta">@ConditionalOnMissingBean</span>(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedUndertow</span> </span>{
        <span class="hljs-meta">@Bean</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> UndertowServletWebServerFactory <span class="hljs-title">undertowServletWebServerFactory</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UndertowServletWebServerFactory();
        }
    }
}
</code></pre><p>不难发现，<code>TomcatServletWebServerFactory</code> 在这里被创建。</p>
<h3 class="heading">9.2 getWebServer：创建嵌入式Servlet容器</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// TomcatServletWebServerFactory</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> WebServer <span class="hljs-title">getWebServer</span><span class="hljs-params">(ServletContextInitializer... initializers)</span> </span>{
    Tomcat tomcat = <span class="hljs-keyword">new</span> Tomcat();
    File baseDir = (<span class="hljs-keyword">this</span>.baseDirectory != <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">this</span>.baseDirectory : createTempDir(<span class="hljs-string">"tomcat"</span>);
    tomcat.setBaseDir(baseDir.getAbsolutePath());
    Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-keyword">this</span>.protocol);
    tomcat.getService().addConnector(connector);
    customizeConnector(connector);
    tomcat.setConnector(connector);
    tomcat.getHost().setAutoDeploy(<span class="hljs-keyword">false</span>);
    configureEngine(tomcat.getEngine());
    <span class="hljs-keyword">for</span> (Connector additionalConnector : <span class="hljs-keyword">this</span>.additionalTomcatConnectors) {
        tomcat.getService().addConnector(additionalConnector);
    }
    prepareContext(tomcat.getHost(), initializers);
    <span class="hljs-keyword">return</span> getTomcatWebServer(tomcat);
}
</code></pre><p>方法体中第一行：</p>
<p><code>Tomcat tomcat = new Tomcat();</code></p>
<p>发现 Tomcat 在此被创建了。</p>
<h2 class="heading">12. ServletWebServerApplicationContext.finishRefresh</h2>
<p><code>ServletWebServerApplicationContext</code> 还重写了 <code>finishRefresh</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishRefresh</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.finishRefresh();
    WebServer webServer = startWebServer();
    <span class="hljs-keyword">if</span> (webServer != <span class="hljs-keyword">null</span>) {
        publishEvent(<span class="hljs-keyword">new</span> ServletWebServerInitializedEvent(webServer, <span class="hljs-keyword">this</span>));
    }
}
</code></pre><p>可以发现在此处启动嵌入式Web容器。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> WebServer <span class="hljs-title">startWebServer</span><span class="hljs-params">()</span> </span>{
    WebServer webServer = <span class="hljs-keyword">this</span>.webServer;
    <span class="hljs-keyword">if</span> (webServer != <span class="hljs-keyword">null</span>) {
        webServer.start();
    }
    <span class="hljs-keyword">return</span> webServer;
}
</code></pre><p>这里调用了 <code>WebServer</code> 的start方法真正启动嵌入式Web容器。</p>
<p>嵌入式Tomcat容器的更多原理解读和源码分析，在后面会有专门的篇章来读，此处不作过多解释，只希望小伙伴们知道在这个时机创建的嵌入式Tomcat即可。</p>
<hr>
<h2 class="heading">回到原来SpringApplication.run的标号</h2>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// 4.11 刷新后的处理</span>
    afterRefresh(context, applicationArguments);
    stopWatch.stop();
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) {
        <span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
    }
    <span class="hljs-comment">// 4.12 发布started事件</span>
    listeners.started(context);
    <span class="hljs-comment">// 4.13 运行器回调</span>
    callRunners(context, applicationArguments);
</code></pre><h3 class="heading">4.11 afterRefresh：刷新后的处理</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterRefresh</span><span class="hljs-params">(ConfigurableApplicationContext context, ApplicationArguments args)</span> </span>{
}
</code></pre><p>空方法，且借助IDEA发现没有子类再实现，故不再深究。</p>
<h3 class="heading">4.12 listeners.started：发布started事件</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">started</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>{
    <span class="hljs-keyword">for</span> (SpringApplicationRunListener listener : <span class="hljs-keyword">this</span>.listeners) {
        listener.started(context);
    }
}
</code></pre><p>源码很简单，根据前面的部分可得知直接来到 <code>EventPublishingRunListener</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">started</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>{
    context.publishEvent(<span class="hljs-keyword">new</span> ApplicationStartedEvent(<span class="hljs-keyword">this</span>.application, <span class="hljs-keyword">this</span>.args, context));
}
</code></pre><p>这部分会回到 <code>AbstractApplicationContext</code> 中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishEvent</span><span class="hljs-params">(ApplicationEvent event)</span> </span>{
    publishEvent(event, <span class="hljs-keyword">null</span>);
}
</code></pre><p>之后继续往下调：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishEvent</span><span class="hljs-params">(Object event, @Nullable ResolvableType eventType)</span> </span>{
    <span class="hljs-comment">// ......</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.earlyApplicationEvents != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">this</span>.earlyApplicationEvents.add(applicationEvent);
    }
    <span class="hljs-keyword">else</span> {
        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
    }

    <span class="hljs-comment">// Publish event via parent context as well...</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent <span class="hljs-keyword">instanceof</span> AbstractApplicationContext) {
            ((AbstractApplicationContext) <span class="hljs-keyword">this</span>.parent).publishEvent(event, eventType);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.parent.publishEvent(event);
        }
    }
}
</code></pre><p>上面的预处理部分咱们不关心，关键的看这两段if-else：</p>
<ul>
<li>第一段if-else是在当前IOC容器发布 <code>ApplicationStartedEvent</code> 事件</li>
<li>下面的if结构会向父容器发布 <code>ApplicationStartedEvent</code> 事件</li>
</ul>
<p>由此可见<strong>事件的发布还会影响到父容器</strong>。</p>
<h3 class="heading">4.13 callRunners：运行器回调</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">//从容器中获取了ApplicationRunner和CommandLineRunner</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callRunners</span><span class="hljs-params">(ApplicationContext context, ApplicationArguments args)</span> </span>{
    List&lt;Object&gt; runners = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
    runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());
    AnnotationAwareOrderComparator.sort(runners);
    <span class="hljs-comment">//ApplicationRunner先回调，CommandLineRunner后回调</span>
    <span class="hljs-keyword">for</span> (Object runner : <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(runners)) {
        <span class="hljs-keyword">if</span> (runner <span class="hljs-keyword">instanceof</span> ApplicationRunner) {
            callRunner((ApplicationRunner) runner, args);
        }
        <span class="hljs-keyword">if</span> (runner <span class="hljs-keyword">instanceof</span> CommandLineRunner) {
            callRunner((CommandLineRunner) runner, args);
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callRunner</span><span class="hljs-params">(ApplicationRunner runner, ApplicationArguments args)</span> </span>{
    <span class="hljs-keyword">try</span> {
        (runner).run(args);
    }
    <span class="hljs-keyword">catch</span> (Exception ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Failed to execute ApplicationRunner"</span>, ex);
    }
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callRunner</span><span class="hljs-params">(CommandLineRunner runner, ApplicationArguments args)</span> </span>{
    <span class="hljs-keyword">try</span> {
        (runner).run(args.getSourceArgs());
    }
    <span class="hljs-keyword">catch</span> (Exception ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Failed to execute CommandLineRunner"</span>, ex);
    }
}
</code></pre><p>这部分涉及到两个概念： <code>CommandLineRunner</code> 和 <code>ApplicationRunner</code> 。</p>
<h4 class="heading">4.13.1 CommandLineRunner</h4>
<p>文档注释原文翻译：</p>
<blockquote>
<p>Interface used to indicate that a bean should run when it is contained within a SpringApplication. Multiple CommandLineRunner beans can be defined within the same application context and can be ordered using the Ordered interface or @Order annotation.
If you need access to ApplicationArguments instead of the raw String array consider using ApplicationRunner.</p>
<p>用于指示bean被包含在 <code>SpringApplication</code> 中时应该运行的接口。可以在同一应用程序上下文中定义多个 <code>CommandLineRunner</code> Bean，并且可以使用 <code>Ordered</code> 接口或 <code>@Order</code> 注解对其进行排序。</p>
<p>如果需要访问 <code>ApplicationArguments</code> 而不是原始String数组，请考虑使用 <code>ApplicationRunner</code> 。</p>
</blockquote>
<h4 class="heading">4.13.2 ApplicationRunner</h4>
<p>文档注释原文翻译：</p>
<blockquote>
<p>Interface used to indicate that a bean should run when it is contained within a SpringApplication. Multiple ApplicationRunner beans can be defined within the same application context and can be ordered using the Ordered interface or @Order annotation.</p>
<p>用于指示bean被包含在 <code>SpringApplication</code> 中时应该运行的接口。可以在同一应用程序上下文中定义多个 <code>ApplicationRunner</code> Bean，并可以使用 <code>Ordered</code> 接口或 <code>@Order</code> 注解对其进行排序。</p>
</blockquote>
<p>文档注释都没有明确的对这两个组件有很好的解释。翻看 <code>SpringBoot</code> 的官方文档：</p>
<p><a target="_blank" href="https://docs.spring.io/spring-boot/docs/2.1.9.RELEASE/reference/htmlsingle/#boot-features-command-line-runner">https://docs.spring.io/spring-boot/docs/2.1.9.RELEASE/reference/htmlsingle/#boot-features-command-line-runner</a></p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/16/16dd4c31ad162d38~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>官方文档甚至没有说明这两个接口到底能干什么，只告诉我们怎么用。那这两个组件到底是干什么的呢？</p>
<h4 class="heading">4.13.3 【扩展】SpringBoot1.x中对这两个组件的应用</h4>
<p>其实这两个接口组件，如果翻看它的文档注释中的since，会发现一个没有标注，一个是 <code>SpringBoot1.3.0</code>，说明它们都来自于 <code>SpringBoot1.x</code> 。它们本来是用于监听特定的时机来执行一些操作，奈何 <code>SpringBoot2.x</code> 后扩展了事件，可以通过监听 <code>ApplicationStartedEvent</code> 来实现跟这两个组件一样的效果。换句话说，这两个组件已经被隐式的“淘汰”了，不必过多深究。</p>
<p>至此，SpringBoot应用启动成功。</p>
<h2 class="heading">小结</h2>
<ol>
<li>IOC容器初始化完成后会清理缓存。</li>
<li>SpringBoot 对IOC容器的扩展是创建嵌入式Web容器。</li>
<li>SpringBoot 存在一些版本过时但还没有清理或废弃的组件（如 <code>CommandLineRunner</code> 和 <code>ApplicationRunner</code>）。</li>
</ol>
<p>【到此为止，<code>SpringApplication</code> 的整个启动流程，以及IOC容器的启动和刷新流程就分析完毕了。下一篇咱把里面几个关键的点总结一下，并希望通过阅读IOC容器的源码，小伙伴能从中总结出一些规律和经验，真正有所收获】</p>
</div>
</body></html>