<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>声明式事务：生效原理</h1>
<h1 class="heading">21. 声明式事务：生效原理</h1>
<p>前面我们已经完整的解析了AOP的核心创建和作用机制，以及代理对象的执行原理。接下来的几篇咱来看 SpringFramework 中最经典的AOP实例：事务控制。</p>
<h2 class="heading">1. 编写测试Demo来测试事务</h2>
<p>编写一个普通的 Service 来简单构造一个事务场景。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoService</span> </span>{
    
    <span class="hljs-meta">@Transactional</span>(rollbackFor = Exception.class)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"test1 run..."</span>);
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;
        System.out.println(<span class="hljs-string">"test1 finish..."</span>);
    }
    
}
</code></pre><p>在启动类上标注 <code>@EnableTransactionManagement</code> 注解来启动注解事务。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@EnableTransactionManagement</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplication</span> </span>{
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ConfigurableApplicationContext ctx = SpringApplication.run(DemoApplication.class, args);
        DemoService demoService = ctx.getBean(DemoService.class);
        demoService.test1();
    }
    
}
</code></pre><p>运行主启动类，发现控制台没有打印 <code>test1 finish...</code> ，并输出异常信息。</p>
<pre><code class="hljs bash" lang="bash"><span class="hljs-built_in">test</span>1 run...
Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.ArithmeticException: / by zero
	at com.example.demo.service.DemoService.test1(DemoService.java:12)
	at com.example.demo.service.DemoService$<span class="hljs-variable">$FastClassBySpringCGLIB</span>$<span class="hljs-variable">$203c87bf</span>.invoke(&lt;generated&gt;)
</code></pre><p>并且从控制台的异常信息栈中发现了<strong>cglib</strong>的身影，因为编写的 Service 没有接口，使用<strong>cglib</strong>创建的代理对象。</p>
<p>接下来咱来开始分析注解声明式事务的生效原理。</p>
<h2 class="heading">2. @EnableTransactionManagement</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Import</span>(TransactionManagementConfigurationSelector.class)
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableTransactionManagement {
	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">proxyTargetClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;

	<span class="hljs-function">AdviceMode <span class="hljs-title">mode</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> AdviceMode.PROXY</span>;

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">order</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;
}
</code></pre><p>注解内部的定义咱暂且不关心，只记住默认使用 <strong>PROXY</strong> - 代理方式来增强代码即可。</p>
<p><code>@EnableTransactionManagement</code> 注解上面声明了 <code>@Import</code> ，它导了一个Selector：<code>TransactionManagementConfigurationSelector</code> 。</p>
<h2 class="heading">3. TransactionManagementConfigurationSelector</h2>
<p>咱已经很清楚， <code>ImportSelector</code> 的作用是筛选组件，返回组件的全限定类名，让IOC容器来创建这些组件。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionManagementConfigurationSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AdviceModeImportSelector</span>&lt;<span class="hljs-title">EnableTransactionManagement</span>&gt; </span>{

	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">protected</span> String[] selectImports(AdviceMode adviceMode) {
		<span class="hljs-keyword">switch</span> (adviceMode) {
			<span class="hljs-keyword">case</span> PROXY:
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[] {AutoProxyRegistrar.class.getName(), ProxyTransactionManagementConfiguration.class.getName()};
			<span class="hljs-keyword">case</span> ASPECTJ:
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[] {TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME};
			<span class="hljs-keyword">default</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
		}
	}

}
</code></pre><p><code>@EnableTransactionManagement</code> 注解默认使用 <code>PROXY</code> 来增强事务，那这个switch结构中就应该返回两个类的全限定类名：<code>AutoProxyRegistrar</code> 、<code>ProxyTransactionManagementConfiguration</code> ，可以看得出来，声明式事务最终起作用是上述两个组件的功能。下面咱分别来看这两个类。</p>
<h2 class="heading">4. AutoProxyRegistrar</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoProxyRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>{
        <span class="hljs-keyword">boolean</span> candidateFound = <span class="hljs-keyword">false</span>;
        Set&lt;String&gt; annoTypes = importingClassMetadata.getAnnotationTypes();
        <span class="hljs-keyword">for</span> (String annoType : annoTypes) {
            AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType);
            <span class="hljs-keyword">if</span> (candidate == <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">continue</span>;
            }
            Object mode = candidate.get(<span class="hljs-string">"mode"</span>);
            Object proxyTargetClass = candidate.get(<span class="hljs-string">"proxyTargetClass"</span>);
            <span class="hljs-keyword">if</span> (mode != <span class="hljs-keyword">null</span> &amp;&amp; proxyTargetClass != <span class="hljs-keyword">null</span> &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp;
                    Boolean.class == proxyTargetClass.getClass()) {
                candidateFound = <span class="hljs-keyword">true</span>;
                <span class="hljs-comment">// PROXY模式下会额外注册Bean</span>
                <span class="hljs-keyword">if</span> (mode == AdviceMode.PROXY) {
                    AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);
                    <span class="hljs-keyword">if</span> ((Boolean) proxyTargetClass) {
                        AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
                        <span class="hljs-keyword">return</span>;
                    }
                }
            }
        }
        <span class="hljs-keyword">if</span> (!candidateFound) {
            String name = getClass().getSimpleName();
            <span class="hljs-comment">// logger......</span>
        }
    }

}
</code></pre><p>它又实现了 <code>ImportBeanDefinitionRegistrar</code> ，又是手动向IOC容器中导入组件。</p>
<p>注意中间部分的一个if判断（已用注释标明）：如果 <code>@EnableTransactionManagement</code> 注解中设置 <code>adviceMode</code> 为 <code>PROXY</code> （默认<code>PROXY</code>），则会利用 <code>AopUtils</code> 创建组件，并且如果 <code>@EnableTransactionManagement</code> 设置 <code>proxyTargetClass</code> 为true，则还会额外导入组件（默认为false）。下面咱看看它又向容器里注册了什么组件。</p>
<h3 class="heading">4.1 AopUtils.registerAutoProxyCreatorIfNecessary</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerAutoProxyCreatorIfNecessary</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>{
    <span class="hljs-keyword">return</span> registerAutoProxyCreatorIfNecessary(registry, <span class="hljs-keyword">null</span>);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerAutoProxyCreatorIfNecessary</span><span class="hljs-params">(BeanDefinitionRegistry registry,
        @Nullable Object source)</span> </span>{
    <span class="hljs-keyword">return</span> registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);
}

<span class="hljs-meta">@Nullable</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerOrEscalateApcAsRequired</span><span class="hljs-params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry,
        @Nullable Object source)</span> </span>{

    Assert.notNull(registry, <span class="hljs-string">"BeanDefinitionRegistry must not be null"</span>);

    <span class="hljs-keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
        <span class="hljs-keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) {
            <span class="hljs-keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());
            <span class="hljs-keyword">int</span> requiredPriority = findPriorityForClass(cls);
            <span class="hljs-keyword">if</span> (currentPriority &lt; requiredPriority) {
                apcDefinition.setBeanClassName(cls.getName());
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    RootBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition(cls);
    beanDefinition.setSource(source);
    beanDefinition.getPropertyValues().add(<span class="hljs-string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);
    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
    <span class="hljs-keyword">return</span> beanDefinition;
}
</code></pre><p>从上面的方法一级一级向下执行，最终来到 <code>registerOrEscalateApcAsRequired</code> 方法（注意在第二层方法中传入了一个 <code>InfrastructureAdvisorAutoProxyCreator.class</code> （基础增强器自动代理创建器），可能下面就是注册这个类型的组件）。</p>
<p>（仔细观察一下，这种类名的命名风格分明就是AOP组件的命名诶。。。先保留这个疑问，继续往下看）</p>
<p>先看看它传的这个 <code>InfrastructureAdvisorAutoProxyCreator</code> 类是什么东西吧：</p>
<h4 class="heading">4.1.1 InfrastructureAdvisorAutoProxyCreator</h4>
<p>文档注释原文翻译：</p>
<blockquote>
<p>Auto-proxy creator that considers infrastructure Advisor beans only, ignoring any application-defined Advisors.</p>
<p>自动代理创建器，仅考虑基础结构Advisor类型的Bean，而忽略任何应用程序定义的Advisor。</p>
</blockquote>
<p>注释解释的不是很清楚，咱再看看这个类的继承结构：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InfrastructureAdvisorAutoProxyCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAdvisorAutoProxyCreator</span>
<span class="hljs-title">public</span> <span class="hljs-title">abstract</span> <span class="hljs-title">class</span> <span class="hljs-title">AbstractAdvisorAutoProxyCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAutoProxyCreator</span>
<span class="hljs-title">public</span> <span class="hljs-title">abstract</span> <span class="hljs-title">class</span> <span class="hljs-title">AbstractAutoProxyCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProxyProcessorSupport</span>
		<span class="hljs-keyword">implements</span> <span class="hljs-title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="hljs-title">BeanFactoryAware</span>
</span></code></pre><p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/18/16dddfaa5cadb119~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>可以发现它也是个后置处理器，并且是在Bean创建前后执行的后置处理器（<code>InstantiationAwareBeanPostProcessor</code>），而且它来自 <code>spring-aop</code> 包。那既然是这样，它与之前AOP部分咱看到的思路就完全一致了（该类/父类中一定会有寻找增强器、过滤增强器，最终生成代理包装Bean为代理对象的方法）。</p>
<p>回到上面的 <code>AopUtils</code> 类，<code>registerAutoProxyCreatorIfNecessary</code> 方法注册了一个 <code>InfrastructureAdvisorAutoProxyCreator</code> ，跟之前咱在AOP部分看到的 <code>@EnableAspectJAutoProxy</code> 注解注册的 <code>AnnotationAwareAspectJAutoProxyCreator</code> 几乎完全一致了，那下面的方法也不用看了，思路真的完全一致。</p>
<h2 class="heading">5. ProxyTransactionManagementConfiguration</h2>
<p>注意这个配置类还继承了父类，父类的配置也会被加载。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTransactionManagementConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTransactionManagementConfiguration</span> </span>{

	<span class="hljs-meta">@Bean</span>(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)
	<span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)
	<span class="hljs-function"><span class="hljs-keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="hljs-title">transactionAdvisor</span><span class="hljs-params">()</span> </span>{
		BeanFactoryTransactionAttributeSourceAdvisor advisor = <span class="hljs-keyword">new</span> BeanFactoryTransactionAttributeSourceAdvisor();
		advisor.setTransactionAttributeSource(transactionAttributeSource());
		advisor.setAdvice(transactionInterceptor());
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.enableTx != <span class="hljs-keyword">null</span>) {
			advisor.setOrder(<span class="hljs-keyword">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="hljs-string">"order"</span>));
		}
		<span class="hljs-keyword">return</span> advisor;
	}

	<span class="hljs-meta">@Bean</span>
	<span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)
	<span class="hljs-function"><span class="hljs-keyword">public</span> TransactionAttributeSource <span class="hljs-title">transactionAttributeSource</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationTransactionAttributeSource();
	}

	<span class="hljs-meta">@Bean</span>
	<span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)
	<span class="hljs-function"><span class="hljs-keyword">public</span> TransactionInterceptor <span class="hljs-title">transactionInterceptor</span><span class="hljs-params">()</span> </span>{
		TransactionInterceptor interceptor = <span class="hljs-keyword">new</span> TransactionInterceptor();
		interceptor.setTransactionAttributeSource(transactionAttributeSource());
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.txManager != <span class="hljs-keyword">null</span>) {
			interceptor.setTransactionManager(<span class="hljs-keyword">this</span>.txManager);
		}
		<span class="hljs-keyword">return</span> interceptor;
	}

}
</code></pre><p>很明显它向IOC容器中注册了3个Bean。一个一个来看：</p>
<h3 class="heading">5.1 transactionAdvisor：事务增强器</h3>
<p><code>BeanFactoryTransactionAttributeSourceAdvisor</code> 的文档注释原文翻译：</p>
<blockquote>
<p>Advisor driven by a TransactionAttributeSource, used to include a transaction advice bean for methods that are transactional.</p>
<p>由 <code>TransactionAttributeSource</code> 驱动的增强器，用于为开启事务的Bean的方法附加事务通知。</p>
</blockquote>
<p>文档注释大概是描述是它给业务方法增强事务通知，咱先放一边。注意看这个类名的最后：<strong>Advisor</strong> ，它是一个增强器！</p>
<p>看一眼这个类的继承和一些成员：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanFactoryPointcutAdvisor</span> </span>{

	<span class="hljs-meta">@Nullable</span>
	<span class="hljs-keyword">private</span> TransactionAttributeSource transactionAttributeSource;

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionAttributeSourcePointcut pointcut = <span class="hljs-keyword">new</span> TransactionAttributeSourcePointcut() {
		<span class="hljs-meta">@Override</span>
		<span class="hljs-meta">@Nullable</span>
		<span class="hljs-function"><span class="hljs-keyword">protected</span> TransactionAttributeSource <span class="hljs-title">getTransactionAttributeSource</span><span class="hljs-params">()</span> </span>{
			<span class="hljs-keyword">return</span> transactionAttributeSource;
		}
	};
</code></pre><p>从这部分源码中可以得知非常关键的点：它是<strong>利用切入点来增强方法</strong> （源码中看到了<strong>pointcut</strong>）。源码中的<strong>pointcut</strong>属性的创建又要借助 <code>TransactionAttributeSource</code> 。这部分依赖关系如下：</p>
<p><code>Advisor → → →依赖→ → → Pointcut → → →依赖→ → → Source</code></p>
<h4 class="heading">5.1.1 TransactionAttributeSourcePointcut</h4>
<p>通过前面AOP部分的阅读，咱也知道，所有的切入点类都会实现 <code>Pointcut</code> 接口，<code>TransactionAttributeSourcePointcut</code> 的类继承和部分源码：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionAttributeSourcePointcut</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StaticMethodMatcherPointcut</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetClass)</span> </span>{
		<span class="hljs-keyword">if</span> (TransactionalProxy.class.isAssignableFrom(targetClass) ||
				PlatformTransactionManager.class.isAssignableFrom(targetClass) ||
				PersistenceExceptionTranslator.class.isAssignableFrom(targetClass)) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		}
		TransactionAttributeSource tas = getTransactionAttributeSource();
		<span class="hljs-keyword">return</span> (tas == <span class="hljs-keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="hljs-keyword">null</span>);
	}
</code></pre><p>它实现了 <code>ClassFilter</code> 接口（<code>matches</code> 是重写的方法，源码不再展开）， <code>matches</code> 方法有两部分判断逻辑：是否为 <code>TransactionalProxy</code> 、<code>PlatformTransactionManager</code> 、<code>PersistenceExceptionTranslator</code> 的实现类，以及让 <code>TransactionAttributeSource</code> 获取事务属性看是否为空。前半部分好理解，后半部分需要借助 <code>TransactionAttributeSource</code> 来判断，正好配置类中事务增强器的下边就要创建一个 <code>AnnotationTransactionAttributeSource</code> ，那咱就继续往下看。</p>
<h3 class="heading">5.2 AnnotationTransactionAttributeSource：注解事务配置源</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)
<span class="hljs-function"><span class="hljs-keyword">public</span> TransactionAttributeSource <span class="hljs-title">transactionAttributeSource</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationTransactionAttributeSource();
}
</code></pre><p>创建出来的只是一个普通的 <code>AnnotationTransactionAttributeSource</code> 而已，它的文档注释原文翻译：</p>
<blockquote>
<p>Implementation of the org.springframework.transaction.interceptor.TransactionAttributeSource interface for working with transaction metadata in JDK 1.5+ annotation format.
This class reads Spring's JDK 1.5+ Transactional annotation and exposes corresponding transaction attributes to Spring's transaction infrastructure. Also supports JTA 1.2's javax.transaction.Transactional and EJB3's javax.ejb.TransactionAttribute annotation (if present). This class may also serve as base class for a custom TransactionAttributeSource, or get customized through TransactionAnnotationParser strategies.</p>
<p>org.springframework.transaction.interceptor.TransactionAttributeSource接口的实现，用于处理JDK 1.5+注释格式的事务元数据。</p>
<p>此类读取Spring的 <code>@Transactional</code> 注解，并将相应的事务属性公开给Spring的事务基础结构。此外，还支持JTA 1.2的 <code>javax.transaction.Transactional</code> 和EJB3的 <code>javax.ejb.TransactionAttribute</code> 注解（如果存在）。此类也可用作自定义 <code>TransactionAttributeSource</code> 的基类，或通过 <code>TransactionAnnotationParser</code> 策略进行自定义。</p>
</blockquote>
<p>说了这么多，我们只关心一句话：它读取 <code>@Transactional</code> 注解。由此可见 <code>AnnotationTransactionAttributeSource</code> 是读取 <code>@Transactional</code> 注解的。</p>
<p>上面的Bean在创建时直接调了构造方法，这个构造方法咱还是要看一下的：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationTransactionAttributeSource</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">true</span>);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationTransactionAttributeSource</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> publicMethodsOnly)</span> </span>{
    <span class="hljs-keyword">this</span>.publicMethodsOnly = publicMethodsOnly;
    <span class="hljs-keyword">this</span>.annotationParsers = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">this</span>.annotationParsers.add(<span class="hljs-keyword">new</span> SpringTransactionAnnotationParser());
    <span class="hljs-keyword">if</span> (jta12Present) {
        <span class="hljs-keyword">this</span>.annotationParsers.add(<span class="hljs-keyword">new</span> JtaTransactionAnnotationParser());
    }
    <span class="hljs-keyword">if</span> (ejb3Present) {
        <span class="hljs-keyword">this</span>.annotationParsers.add(<span class="hljs-keyword">new</span> Ejb3TransactionAnnotationParser());
    }
}
</code></pre><p>注意下面重载的构造方法中，它给 <code>annotationParsers</code> 中添加了一个 <code>SpringTransactionAnnotationParser</code> 。</p>
<h4 class="heading">5.2.1 SpringTransactionAnnotationParser</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringTransactionAnnotationParser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TransactionAnnotationParser</span>, <span class="hljs-title">Serializable</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@Nullable</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TransactionAttribute <span class="hljs-title">parseTransactionAnnotation</span><span class="hljs-params">(AnnotatedElement ae)</span> </span>{
        <span class="hljs-comment">// 搜索被标注的元素（类、方法）上是否最终标注了@Transactional注解</span>
        AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(
                ae, Transactional.class, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">if</span> (attributes != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> parseTransactionAnnotation(attributes);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> TransactionAttribute <span class="hljs-title">parseTransactionAnnotation</span><span class="hljs-params">(Transactional ann)</span> </span>{
        <span class="hljs-keyword">return</span> parseTransactionAnnotation(AnnotationUtils.getAnnotationAttributes(ann, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>));
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> TransactionAttribute <span class="hljs-title">parseTransactionAnnotation</span><span class="hljs-params">(AnnotationAttributes attributes)</span> </span>{
        RuleBasedTransactionAttribute rbta = <span class="hljs-keyword">new</span> RuleBasedTransactionAttribute();
        <span class="hljs-comment">// 解析事务传播行为</span>
        Propagation propagation = attributes.getEnum(<span class="hljs-string">"propagation"</span>);
        rbta.setPropagationBehavior(propagation.value());
        <span class="hljs-comment">// 解析事务隔离级别</span>
        Isolation isolation = attributes.getEnum(<span class="hljs-string">"isolation"</span>);
        rbta.setIsolationLevel(isolation.value());
        <span class="hljs-comment">// 解析超时</span>
        rbta.setTimeout(attributes.getNumber(<span class="hljs-string">"timeout"</span>).intValue());
        <span class="hljs-comment">// 解析只读事务</span>
        rbta.setReadOnly(attributes.getBoolean(<span class="hljs-string">"readOnly"</span>));
        rbta.setQualifier(attributes.getString(<span class="hljs-string">"value"</span>));
        ArrayList&lt;RollbackRuleAttribute&gt; rollBackRules = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-comment">// 解析回滚异常</span>
        Class&lt;?&gt;[] rbf = attributes.getClassArray(<span class="hljs-string">"rollbackFor"</span>);
        <span class="hljs-keyword">for</span> (Class&lt;?&gt; rbRule : rbf) {
            RollbackRuleAttribute rule = <span class="hljs-keyword">new</span> RollbackRuleAttribute(rbRule);
            rollBackRules.add(rule);
        }
        String[] rbfc = attributes.getStringArray(<span class="hljs-string">"rollbackForClassName"</span>);
        <span class="hljs-keyword">for</span> (String rbRule : rbfc) {
            RollbackRuleAttribute rule = <span class="hljs-keyword">new</span> RollbackRuleAttribute(rbRule);
            rollBackRules.add(rule);
        }
        <span class="hljs-comment">// 解析不回滚异常的“白名单”</span>
        Class&lt;?&gt;[] nrbf = attributes.getClassArray(<span class="hljs-string">"noRollbackFor"</span>);
        <span class="hljs-keyword">for</span> (Class&lt;?&gt; rbRule : nrbf) {
            NoRollbackRuleAttribute rule = <span class="hljs-keyword">new</span> NoRollbackRuleAttribute(rbRule);
            rollBackRules.add(rule);
        }
        String[] nrbfc = attributes.getStringArray(<span class="hljs-string">"noRollbackForClassName"</span>);
        <span class="hljs-keyword">for</span> (String rbRule : nrbfc) {
            NoRollbackRuleAttribute rule = <span class="hljs-keyword">new</span> NoRollbackRuleAttribute(rbRule);
            rollBackRules.add(rule);
        }
        rbta.getRollbackRules().addAll(rollBackRules);
        <span class="hljs-keyword">return</span> rbta;
    }
}
</code></pre><p>这里面的核心方法如上述源码，可以发现它的核心功能是<strong>解析 <code>@Transactional</code> 注解的信息</strong>！</p>
<p>至此上面的配置类中需要的事务增强器、事务切入点、事务配置源、事务注解解析器都解析完，回到配置类中，还有一个拦截器：</p>
<h3 class="heading">5.3 TransactionInterceptor</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)
<span class="hljs-function"><span class="hljs-keyword">public</span> TransactionInterceptor <span class="hljs-title">transactionInterceptor</span><span class="hljs-params">()</span> </span>{
    TransactionInterceptor interceptor = <span class="hljs-keyword">new</span> TransactionInterceptor();
    interceptor.setTransactionAttributeSource(transactionAttributeSource());
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.txManager != <span class="hljs-keyword">null</span>) {
        interceptor.setTransactionManager(<span class="hljs-keyword">this</span>.txManager);
    }
    <span class="hljs-keyword">return</span> interceptor;
}
</code></pre><p>在Bean的创建过程中，它也把事务配置源保存起来了，并且还注入了事务管理器。而 <code>TransactionInterceptor</code> 本身的类定义：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TransactionAspectSupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">Serializable</span>
</span></code></pre><p>发现它实现了 <code>MethodInterceptor</code> ！它也是一个AOP的增强器。那它的核心作用大概率就是控制事务咯？咱先不着急，它的工作原理咱到下一篇再看，本篇先把需要配置的组件都解析完。</p>
<hr>
<p><code>ProxyTransactionManagementConfiguration</code> 的配置读完之后，别忘了它还继承了一个父类，下面咱看看这个父类里都干了什么：</p>
<h2 class="heading">6. AbstractTransactionManagementConfiguration的配置</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractTransactionManagementConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportAware</span> </span>{

    <span class="hljs-meta">@Nullable</span>
    <span class="hljs-keyword">protected</span> AnnotationAttributes enableTx;

    <span class="hljs-meta">@Nullable</span>
    <span class="hljs-keyword">protected</span> PlatformTransactionManager txManager;


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImportMetadata</span><span class="hljs-params">(AnnotationMetadata importMetadata)</span> </span>{
        <span class="hljs-keyword">this</span>.enableTx = AnnotationAttributes.fromMap(
                importMetadata.getAnnotationAttributes(EnableTransactionManagement.class.getName(), <span class="hljs-keyword">false</span>));
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.enableTx == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(
                    <span class="hljs-string">"@EnableTransactionManagement is not present on importing class "</span> + importMetadata.getClassName());
        }
    }

    <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setConfigurers</span><span class="hljs-params">(Collection&lt;TransactionManagementConfigurer&gt; configurers)</span> </span>{
        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(configurers)) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">if</span> (configurers.size() &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Only one TransactionManagementConfigurer may exist"</span>);
        }
        TransactionManagementConfigurer configurer = configurers.iterator().next();
        <span class="hljs-keyword">this</span>.txManager = configurer.annotationDrivenTransactionManager();
    }


    <span class="hljs-meta">@Bean</span>(name = TransactionManagementConfigUtils.TRANSACTIONAL_EVENT_LISTENER_FACTORY_BEAN_NAME)
    <span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TransactionalEventListenerFactory <span class="hljs-title">transactionalEventListenerFactory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransactionalEventListenerFactory();
    }

}
</code></pre><p>可以发现在最底下它又创建了一个组件，类型是 <code>TransactionalEventListenerFactory</code> 。</p>
<h3 class="heading">6.1 TransactionalEventListenerFactory</h3>
<p>它的文档注释原文翻译：</p>
<blockquote>
<p>EventListenerFactory implementation that handles TransactionalEventListener annotated methods.</p>
<p>EventListenerFactory的实现类，用于处理带有 <code>@TransactionalEventListener</code> 注解的方法。</p>
</blockquote>
<p>发现它又提到了一个注解：<code>@TransactionalEventListener</code> ，实际上 <code>TransactionalEventListenerFactory</code> 这个组件是做事务监听机制的。</p>
<p>【如果小伙伴还不是很了解 <code>@TransactionalEventListener</code> ，请继续往下看，熟悉的小伙伴请跳过6.1节】</p>
<h4 class="heading">6.1.1 【扩展】@TransactionalEventListener</h4>
<p>自 SpringFramework4.2 之后，出现了一种能在事务动作发生前后注入监听器的机制。</p>
<p>举几个应用场景的例子：</p>
<ul>
<li>执行完数据库操作后发送消息</li>
<li>执行数据库操作之前记录日志</li>
<li>业务逻辑出错时事务回滚之后发邮件警报</li>
</ul>
<p>类似于这种事务动作执行前后进行附加操作的问题，在SpringFramework4.2之后就可以通过 <code>@TransactionalEventListener</code> 注解来实现。</p>
<p><code>@TransactionalEventListener</code> 可提供4种监听时机，来执行附加操作：</p>
<ul>
<li>BEFORE_COMMIT：提交之前</li>
<li>AFTER_COMMIT：提交之后</li>
<li>AFTER_ROLLBACK：回滚之后</li>
<li>AFTER_COMPLETION：事务完成之后</li>
</ul>
<h4 class="heading">6.1.2 @TransactionalEventListener的使用方式简单Demo</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoService</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> USerDao userDao;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ApplicationEventPublisher applicationEventPublisher;

    <span class="hljs-meta">@Transactional</span>(rollbackFor = Exception.class)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 执行清空用户的数据库操作</span>
        userDao.deleteAll();

        <span class="hljs-comment">// 使用事件广播器来广播 用户清除事件</span>
        applicationEventPublisher.publishEvent(<span class="hljs-keyword">new</span> UserCleanEvent());
    }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTransactionListener</span> </span>{

    <span class="hljs-meta">@TransactionalEventListener</span>(phase = TransactionPhase.AFTER_COMMIT)
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTestEvent</span><span class="hljs-params">(UserCleanEvent event)</span> </span>{
        System.out.println(<span class="hljs-string">"UserCleanEvent detected ......"</span>);
    }

}

<span class="hljs-comment">// 定义 用户清除事件，它需要继承ApplicationEvent </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserCleanEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> </span>{

}
</code></pre><h2 class="heading">小结</h2>
<ol>
<li>Spring的注解事务底层是借助AOP的机制，创建了一个 <code>InfrastructureAdvisorAutoProxyCreator</code> 组件来创建代理对象。</li>
<li>注解事务要想生效，需要<strong>事务增强器、事务切入点解析器、事务配置源、事务拦截器</strong>等组件。</li>
</ol>
<p>【至此，注解事务驱动的自动装配就分析完毕了，下一篇咱要看上面提到的事务拦截器是如何工作的】</p>
</div>
</body></html>