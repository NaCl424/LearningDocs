<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>AOP：注解使用AOP基础与@EnableAspectJAutoProxy的作用</h1>
<h1 class="heading">18. AOP：注解使用AOP基础与@EnableAspectJAutoProxy的作用</h1>
<p>【第1章节先回顾注解使用AOP的一些基础，熟悉的小伙伴请直接看第2章节】</p>
<h2 class="heading">1. 注解AOP基础</h2>
<h3 class="heading">1.1 AOP的通知类型</h3>
<ul>
<li><code>@Before</code>：前置通知（logStart）</li>
<li><code>@After</code>：后置通知（logEnd）</li>
<li><code>@AfterReturning</code>：返回通知（logReturn，方法正常返回）</li>
<li><code>@AfterThrowing</code>：异常通知（logException，方法抛出异常）</li>
<li><code>@Around</code>：环绕通知（编程式推进目标方法运行）</li>
</ul>
<p>前四种注解都属于<strong>声明式AOP</strong>，<code>@Around</code> 属于<strong>编程式AOP</strong>。</p>
<h3 class="heading">1.2 AOP的重要概念</h3>
<p>在开始研究AOP原理之前，小伙伴们咱一起回顾下AOP的重要核心概念术语：</p>
<ul>
<li><strong>JoinPoint</strong>（连接点）：可能被拦截到的点，在Spring中指的是类中的任意方法（SpringFramework 只支持方法类型的连接点）</li>
<li><strong>Pointcut</strong>（切入点）：要对哪些 <strong>JoinPoint</strong> 进行拦截的定义（可以简单理解为已经被增强的方法）（哪些切入点要被增强，需要由切入点表达式来描述）</li>
<li><strong>Advice</strong>（通知 / 增强）：拦截到 <strong>JoinPoint</strong> 之后所要做的事情（额外要执行的代码）
<ul>
<li>通知的类型就是上面所说的5种</li>
</ul>
</li>
<li><strong>Target</strong>（目标对象）：需要被代理的目标对象</li>
<li><strong>Introduction</strong>（引入）：一种特殊的通知，它能在不修改原有类代码的前提下，在运行期为原始类动态地添加一些属性或方法</li>
<li><strong>Weaving</strong>（织入）：把增强应用到目标对象，创建代理对象的过程（SpringAOP用动态代理织入，而 Aspect 可以采用编译期织入和类装载期织入）</li>
<li><strong>Proxy</strong>（代理）：一个类被AOP织入增强后，就产生一个结果代理类</li>
<li><strong>Aspect</strong>（切面）：<strong>切入点</strong>和<strong>通知</strong>的结合</li>
</ul>
<h3 class="heading">1.3 Spring与Aspect</h3>
<p>在标注Aspect系列的注解时，需要编写切入点表达式，如：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Before</span>(<span class="hljs-string">"execution(public String method(Integer, String))"</span>)
</code></pre><p>如果需要抽取公共的切入点表达式，可以声明空方法，并在方法上声明 <code>@PointCut</code> 注解，注解中声明公共的切入点表达式，之后在本类中的其他方法上，如果要使用该切入点表达式，只需要在 Aspect注解 中标注方法名即可。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@PointCut</span>(<span class="hljs-string">"execution(public String method(..))"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointCut</span><span class="hljs-params">()</span> </span>{ }

<span class="hljs-meta">@Before</span>(<span class="hljs-string">"pointCut()"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBefore</span><span class="hljs-params">()</span> </span>{ }
</code></pre><p>如果需要在其他外部类中使用<strong>某个类的通用切入点表达式</strong>，需要使用<strong>切入点表达式所在类的全限定类名+方法名</strong>。</p>
<p>编写切面类时，需要在类上声明 <strong>@Aspect</strong> 注解，被标注Aspect系列的注解的方法上可以在参数里放入一些形参：</p>
<ul>
<li>@Before：<code>JoinPoint</code></li>
<li>@After：<code>JoinPoint</code></li>
<li>@AfterReturning：<code>JoinPoint</code>（必须放在第一位），<code>Object result</code>（需在 <code>@AfterReturning</code> 中声明 <code>returning</code> 属性）</li>
<li>@AfterThrowing：<code>JoinPoint</code>（必须放在第一位），<code>Exception exception</code>（需在 <code>@AfterThrowing</code> 中声明 <code>throwing</code> 属性）</li>
</ul>
<p>以下是一个综合使用Demo：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>{
    
    <span class="hljs-comment">// 切入com.example.demo下面的一级包下面的所有类的所有方法</span>
    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"execution(public * com.example.demo.*.*(..))"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>{
        System.out.println(<span class="hljs-string">"doBefore run..."</span>);
    }
    
    <span class="hljs-comment">// 切入被@LogBack标注的方法</span>
    <span class="hljs-meta">@After</span>(<span class="hljs-string">"@annotation(com.example.demo.LogBack)"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfter</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>{
        System.out.println(<span class="hljs-string">"doAfter run..."</span>);
    }
    
    <span class="hljs-comment">// 切入com.example.demo.service.DemoService类的所有方法中第一个参数为Serializable类型的方法</span>
    <span class="hljs-meta">@AfterReturning</span>(value = <span class="hljs-string">"execution(public * com.example.demo.service.DemoService.*(java.io.Serializable, ..))"</span>, returning = <span class="hljs-string">"result"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfterReturning</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> </span>{
        System.out.println(<span class="hljs-string">"doAfterReturning run, result: "</span> + result);
    }
    
    <span class="hljs-comment">// 切入com.example.demo下所有的controller包下面的所有类的所有方法</span>
    <span class="hljs-meta">@AfterThrowing</span>(value = <span class="hljs-string">"execution(public * com.example.demo..controller.*(..))"</span>, throwing = <span class="hljs-string">"ex"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfterThrowing</span><span class="hljs-params">(JoinPoint joinPoint, Exception ex)</span> </span>{
        System.out.println(<span class="hljs-string">"doAfterThrowing catch exception: "</span> + ex.getMessage());
    }
    
    <span class="hljs-comment">// 切入com.example.demo.controller.DemoController的所有返回值为String的方法</span>
    <span class="hljs-meta">@Around</span>(<span class="hljs-string">"execution(public String com.example.demo.controller.DemoController.*(..))"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doAround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> </span>{
        System.out.println(<span class="hljs-string">"doAround run..."</span>);
        Object result = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            System.out.println(<span class="hljs-string">"method before invoke..."</span>);
            result = joinPoint.proceed();
            System.out.println(<span class="hljs-string">"method invoked, result: "</span> + result);
        } <span class="hljs-keyword">catch</span> (Throwable throwable) {
            System.out.println(<span class="hljs-string">"method throws Exception: "</span> + throwable.getMessage());
            throwable.printStackTrace();
        }
        <span class="hljs-keyword">return</span> result;
    }
    
}
</code></pre><p>之后要在主启动类上标注一个注解，告诉IOC容器开启AOP：<strong><code>@EnableAspectJAutoProxy</code></strong> 。</p>
<hr>
<p>既然到这里已经提到了这个关键的注解，那咱就来分析这个注解都干了什么吧。</p>
<h2 class="heading">2. @EnableAspectJAutoProxy的作用</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Import</span>(AspectJAutoProxyRegistrar.class)
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAspectJAutoProxy {

    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">proxyTargetClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">exposeProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;

}
</code></pre><p>这个注解标注了 <code>@Import</code> ，它导入了一个 <code>AspectJAutoProxyRegistrar</code> 。这个类的文档注释原文翻译：</p>
<blockquote>
<p>Registers an AnnotationAwareAspectJAutoProxyCreator against the current BeanDefinitionRegistry as appropriate based on a given @EnableAspectJAutoProxy annotation.</p>
<p>根据给定的 <code>@EnableAspectJAutoProxy</code> 注解，根据当前 <code>BeanDefinitionRegistry</code> 在适当的位置注册 <code>AnnotationAwareAspectJAutoProxyCreator</code> 。</p>
</blockquote>
<p>从文档注释中可以发现它要在IOC容器中注册一个 <code>AnnotationAwareAspectJAutoProxyCreator</code> 。暂且不关注这个类是干嘛的，先进这个 <code>AspectJAutoProxyRegistrar</code> 中看一下它是如何实现的。</p>
<h3 class="heading">2.1 AspectJAutoProxyRegistrar</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectJAutoProxyRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(
            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>{
        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);

        AnnotationAttributes enableAspectJAutoProxy =
                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
        <span class="hljs-keyword">if</span> (enableAspectJAutoProxy != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">"proxyTargetClass"</span>)) {
                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
            }
            <span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">"exposeProxy"</span>)) {
                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
            }
        }
    }

}
</code></pre><p>它实现了 <code>ImportBeanDefinitionRegistrar</code> 接口，会编程式的向IOC容器中注册组件。下面的 <code>registerBeanDefinitions</code> 方法中分为两个步骤：注册 <code>AspectJAnnotationAutoProxyCreator</code> ，解析 <code>@EnableAspectJAutoProxy</code> 注解。</p>
<h4 class="heading">2.1.1 AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary</h4>
<p>这个方法会一直往下调，最终调到 <code>registerOrEscalateApcAsRequired</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Nullable</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>{
    <span class="hljs-keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, <span class="hljs-keyword">null</span>);
}

<span class="hljs-meta">@Nullable</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="hljs-params">(
        BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>{
    <span class="hljs-comment">// 注意在这个方法中已经把AnnotationAwareAspectJAutoProxyCreator的字节码传入方法了</span>
    <span class="hljs-keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AUTO_PROXY_CREATOR_BEAN_NAME =
        <span class="hljs-string">"org.springframework.aop.config.internalAutoProxyCreator"</span>;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerOrEscalateApcAsRequired</span><span class="hljs-params">(
        Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>{

    Assert.notNull(registry, <span class="hljs-string">"BeanDefinitionRegistry must not be null"</span>);

    <span class="hljs-keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
        <span class="hljs-keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) {
            <span class="hljs-keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());
            <span class="hljs-keyword">int</span> requiredPriority = findPriorityForClass(cls);
            <span class="hljs-keyword">if</span> (currentPriority &lt; requiredPriority) {
                apcDefinition.setBeanClassName(cls.getName());
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    RootBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition(cls);
    beanDefinition.setSource(source);
    beanDefinition.getPropertyValues().add(<span class="hljs-string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);
    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
    <span class="hljs-keyword">return</span> beanDefinition;
}
</code></pre><p>下面的方法就是创建 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的核心方法，可以发现逻辑还是比较简单的。方法进入后先判断IOC容器中是否包含一个特定的Bean，如果没有，下面直接用 <code>RootBeanDefinition</code> 创建。</p>
<h4 class="heading">2.1.2 解析@EnableAspectJAutoProxy注解</h4>
<pre><code class="hljs java" lang="java">    AnnotationAttributes enableAspectJAutoProxy =
            AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
    <span class="hljs-keyword">if</span> (enableAspectJAutoProxy != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">"proxyTargetClass"</span>)) {
            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
        }
        <span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">"exposeProxy"</span>)) {
            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
        }
    }
</code></pre><p>这部分因为默认的 <code>@EnableAspectJAutoProxy</code> 中两个属性默认均为false，故这部分不起作用。</p>
<p>至此，可以发现，<code>@EnableAspectJAutoProxy</code> 的根本作用是在IOC容器中注册了一个 <code>AnnotationAwareAspectJAutoProxyCreator</code> 。下面来解析这个类的作用。</p>
<h2 class="heading">3. AnnotationAwareAspectJAutoProxyCreator的作用时机</h2>
<p>先看一眼这个类的文档注释原文翻译：</p>
<blockquote>
<p>AspectJAwareAdvisorAutoProxyCreator subclass that processes all AspectJ annotation aspects in the current application context, as well as Spring Advisors.
Any AspectJ annotated classes will automatically be recognized, and their advice applied if Spring AOP's proxy-based model is capable of applying it. This covers method execution joinpoints.
If the <code>&lt;aop:include&gt;</code> element is used, only @AspectJ beans with names matched by an include pattern will be considered as defining aspects to use for Spring auto-proxying.
Processing of Spring Advisors follows the rules established in org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.</p>
<p><code>AspectJAwareAdvisorAutoProxyCreator</code>子类，用于处理当前应用程序上下文中的所有 <code>@AspectJ</code> 注解的切面，以及Spring的Advisor。</p>
<p>如果Spring AOP的基于代理的模型能够应用任何被 <code>@AspectJ</code> 注解标注的类，那么它们的增强方法将被自动识别。这涵盖了方法执行的切入点表达式。</p>
<p>如果使用<code>&lt;aop:include&gt;</code>元素，则只有名称与包含模式匹配的被 <code>@AspectJ</code> 标注的Bean将被视为定义要用于Spring自动代理的方面。</p>
<p>Spring Advisor的处理遵循 <code>AbstractAdvisorAutoProxyCreator</code> 中建立的规则。</p>
</blockquote>
<p>很明显它就是基于注解的AspectJ增强代理创建器。它的类继承结构如下：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationAwareAspectJAutoProxyCreator</span> 
    <span class="hljs-keyword">extends</span> <span class="hljs-title">AspectJAwareAdvisorAutoProxyCreator</span>

<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">AspectJAwareAdvisorAutoProxyCreator</span> 
    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAdvisorAutoProxyCreator</span>

<span class="hljs-title">public</span> <span class="hljs-title">abstract</span> <span class="hljs-title">class</span> <span class="hljs-title">AbstractAdvisorAutoProxyCreator</span> 
    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAutoProxyCreator</span>

<span class="hljs-title">public</span> <span class="hljs-title">abstract</span> <span class="hljs-title">class</span> <span class="hljs-title">AbstractAutoProxyCreator</span> 
    <span class="hljs-keyword">extends</span> <span class="hljs-title">ProxyProcessorSupport</span> 
    <span class="hljs-keyword">implements</span> <span class="hljs-title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="hljs-title">BeanFactoryAware</span>

<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ProxyProcessorSupport</span> 
    <span class="hljs-keyword">extends</span> <span class="hljs-title">ProxyConfig</span> 
    <span class="hljs-keyword">implements</span> <span class="hljs-title">Ordered</span>, <span class="hljs-title">BeanClassLoaderAware</span>, <span class="hljs-title">AopInfrastructureBean</span>
</span></code></pre><p>下面的图可以更清晰的看出它的层次结构：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/17/16dd82ede7044be8~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>从这里面可以获得两个信息：</p>
<ul>
<li>实现了 <strong><code>SmartInstantiationAwareBeanPostProcessor</code></strong> ，可以做组件的 <strong>创建前后、初始化前后的后置处理工作</strong> 。</li>
<li>实现了 <strong><code>BeanFactoryAware</code></strong> ，可以将 <strong><code>BeanFactory</code></strong> 注入到组件中</li>
</ul>
<h3 class="heading">3.0 SmartInstantiationAwareBeanPostProcessor</h3>
<p>这个接口的文档注释原文翻译：</p>
<blockquote>
<p>Extension of the InstantiationAwareBeanPostProcessor interface, adding a callback for predicting the eventual type of a processed bean.
NOTE: This interface is a special purpose interface, mainly for internal use within the framework. In general, application-provided post-processors should simply implement the plain BeanPostProcessor interface or derive from the InstantiationAwareBeanPostProcessorAdapter class.</p>
<p>扩展 <code>InstantiationAwareBeanPostProcessor</code> 接口，添加了用于预测已处理bean的最终类型的回调。
注意：此接口是专用接口，主要供框架内部使用。通常，应用程序提供的后处理器应简单地实现纯 <code>BeanPostProcessor</code> 接口或从 <code>InstantiationAwareBeanPostProcessorAdapter</code> 类派生。</p>
</blockquote>
<p>它扩展了 <code>InstantiationAwareBeanPostProcessor</code> 接口，这个接口之前咱在IOC部分介绍过，它用于组件的创建前后做后置处理，恰好AOP的核心是用代理对象代替普通对象，用这种后置处理器刚好能完成需求。</p>
<hr>
<p>下面将结合IOC容器的启动原理，研究 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的创建时机和作用流程。</p>
<h3 class="heading">3.1 SpringBoot引导创建IOC容器</h3>
<p>根据前面的SpringBoot启动IOC容器的原理，最终会在一系列初始化后进入IOC容器的refresh方法。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// AbstractApplicationContext</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>{
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) {
        <span class="hljs-comment">// ......</span>

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span>
            <span class="hljs-comment">// 4. 准备BeanFactory完成后进行的后置处理</span>
            postProcessBeanFactory(beanFactory);

            <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span>
            <span class="hljs-comment">// 5. 执行BeanFactory创建后的后置处理器</span>
            invokeBeanFactoryPostProcessors(beanFactory);

            <span class="hljs-comment">// Register bean processors that intercept bean creation.</span>
            <span class="hljs-comment">// 6. 注册Bean的后置处理器</span>
            registerBeanPostProcessors(beanFactory);

            <span class="hljs-comment">// ......</span>
    }
}
</code></pre><p>Bean的后置处理器注册都集中在第6步：<code>registerBeanPostProcessors</code></p>
<h3 class="heading">3.2 registerBeanPostProcessors</h3>
<p>（省略了部分与AOP无关的源码）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{
    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="hljs-keyword">this</span>);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(
        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>{

    <span class="hljs-comment">// ......</span>
    <span class="hljs-comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span>
    <span class="hljs-comment">// Ordered, and the rest.</span>
    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-comment">// 根据PriorityOrdered、Ordered接口，对这些BeanPostProcessor进行归类</span>
    <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) {
        <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            priorityOrderedPostProcessors.add(pp);
            <span class="hljs-comment">// MergedBeanDefinitionPostProcessor类型的后置处理器被单独放在一个集合中，说明该接口比较特殊</span>
            <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) {
                internalPostProcessors.add(pp);
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) {
            orderedPostProcessorNames.add(ppName);
        }
        <span class="hljs-keyword">else</span> {
            nonOrderedPostProcessorNames.add(ppName);
        }
    }

    <span class="hljs-comment">// ......</span>

    <span class="hljs-comment">// Next, register the BeanPostProcessors that implement Ordered.</span>
    <span class="hljs-comment">// 注册实现了Ordered接口的BeanPostProcessor</span>
    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (String ppName : orderedPostProcessorNames) {
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        orderedPostProcessors.add(pp);
        <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    sortPostProcessors(orderedPostProcessors, beanFactory);
    registerBeanPostProcessors(beanFactory, orderedPostProcessors);

    <span class="hljs-comment">// ......</span>
}
</code></pre><p>之前看 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的类继承和接口实现，发现它实现了 <code>Ordered</code> 接口，会在实际分类时进入 <code>orderedPostProcessorNames</code> 集合中。</p>
<p>通过Debug，发现实现了 <code>Ordered</code> 接口的就它一个。。。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/17/16dd82eb58570bc7~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>之后要调用下面一段源码中，这里要直接 <strong>getBean</strong> 来创建 <code>AnnotationAwareAspectJAutoProxyCreator</code>  了！</p>
<h3 class="heading">3.3 getBean → doCreateBean</h3>
<p>根据前面的IOC原理，肯定会执行一系列操作：<strong>getBean → doGetBean → createBean → doCreateBean</strong> 。最终创建这个后置处理器，放入IOC容器中，此部分还没有涉及到AOP的实际创建时机，我们暂且略过。</p>
<h2 class="heading">小结</h2>
<ol>
<li>注解AOP的使用需要在切面类上标注 <code>@Aspect</code> 和 <code>@Component</code> 。</li>
<li>启动AOP的核心是向容器中注册了一个 <code>AnnotationAwareAspectJAutoProxyCreator</code> 。</li>
</ol>
<p>【至此我们了解了 <code>AnnotationAwareAspectJAutoProxyCreator</code> ，下一篇咱来看AOP的核心：<code>AnnotationAwareAspectJAutoProxyCreator</code> 如何创建代理对象】</p>
</div>
</body></html>