<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>IOC：创建、初始化IOC容器</h1>
<h1 class="heading">10. IOC：创建、初始化IOC容器</h1>
<p>【接前章】</p>
<p>（本篇文章篇幅较长且有重要内容 <strong><code>BeanDefinition</code></strong>，小伙伴一定要仔细阅读和理解）</p>
<h2 class="heading">4. run：启动SpringApplication</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-comment">// 4.6 如果有配置 spring.beaninfo.ignore，则将该配置设置进系统参数</span>
        configureIgnoreBeanInfo(environment);
        <span class="hljs-comment">// 4.7 打印SpringBoot的banner</span>
        Banner printedBanner = printBanner(environment);
        <span class="hljs-comment">// 4.8 创建ApplicationContext</span>
        context = createApplicationContext();
        <span class="hljs-comment">// 初始化异常报告器</span>
        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
                <span class="hljs-keyword">new</span> Class[] { ConfigurableApplicationContext.class }, context);
        <span class="hljs-comment">// 4.9 初始化IOC容器</span>
        prepareContext(context, environment, listeners, applicationArguments, printedBanner);
        <span class="hljs-comment">// ...</span>
}
</code></pre><h3 class="heading">4.6 configureIgnoreBeanInfo：设置系统参数</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String IGNORE_BEANINFO_PROPERTY_NAME = <span class="hljs-string">"spring.beaninfo.ignore"</span>;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureIgnoreBeanInfo</span><span class="hljs-params">(ConfigurableEnvironment environment)</span> </span>{
    <span class="hljs-keyword">if</span> (System.getProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME) == <span class="hljs-keyword">null</span>) {
        Boolean ignore = environment.getProperty(<span class="hljs-string">"spring.beaninfo.ignore"</span>, Boolean.class, Boolean.TRUE);
        System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, ignore.toString());
    }
}
</code></pre><p>它提到了一个配置：<code>spring.beaninfo.ignore</code>，我们没见过他也没配置过，那就只好借助文档注释。在文档注释中有一句话比较关键：</p>
<blockquote>
<p>"spring.beaninfo.ignore", with a value of "true" skipping the search for BeanInfo classes (typically for scenarios where no such classes are being defined for beans in the application in the first place).</p>
<p><code>"spring.beaninfo.ignore"</code> 的值为“true”，则跳过对BeanInfo类的搜索（通常用于未定义此类的情况）首先是应用中的bean）。</p>
</blockquote>
<p>由此可知，它是控制是否跳过 <code>BeanInfo</code> 类的搜索，并且由源码可知默认值是true，不作过多研究。</p>
<h3 class="heading">4.7 printBanner：打印Banner</h3>
<p>在阅读这部分源码之前，先看看 <code>Banner</code> 到底是什么。</p>
<p>【如果小伙伴仅仅是知道 <code>Banner</code>，不妨继续往下看看。对 <code>Banner</code> 很熟悉的小伙伴可以跳过4.7.0节】</p>
<h4 class="heading">4.7.0 Banner和它的实现类</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Banner</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printBanner</span><span class="hljs-params">(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out)</span></span>;

    <span class="hljs-keyword">enum</span> Mode {
        OFF,
        CONSOLE,
        LOG
    }
}
</code></pre><p>它是一个接口，并且内置了一个枚举类型，代表 Banner 输出的模式（关闭、控制台打印、日志输出）。</p>
<p>借助IDEA，发现它有几个实现类：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/16/16dd225385844100~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>第一眼应该关注的就是这个 <code>SpringBootBanner</code> ，我看它最熟悉。翻看它的源码：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootBanner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Banner</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BANNER = { <span class="hljs-string">""</span>, <span class="hljs-string">"  .   ____          _            __ _ _"</span>,
            <span class="hljs-string">" /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\"</span>, <span class="hljs-string">"( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\"</span>,
            <span class="hljs-string">" \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )"</span>, <span class="hljs-string">"  '  |____| .__|_| |_|_| |_\\__, | / / / /"</span>,
            <span class="hljs-string">" =========|_|==============|___/=/_/_/_/"</span> };

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPRING_BOOT = <span class="hljs-string">" :: Spring Boot :: "</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STRAP_LINE_SIZE = <span class="hljs-number">42</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printBanner</span><span class="hljs-params">(Environment environment, Class&lt;?&gt; sourceClass, PrintStream printStream)</span> </span>{
        <span class="hljs-comment">// 先打印Banner内容</span>
        <span class="hljs-keyword">for</span> (String line : BANNER) {
            printStream.println(line);
        }
         <span class="hljs-comment">// 打印SpringBoot的版本</span>
        String version = SpringBootVersion.getVersion();
        version = (version != <span class="hljs-keyword">null</span>) ? <span class="hljs-string">" (v"</span> + version + <span class="hljs-string">")"</span> : <span class="hljs-string">""</span>;
        StringBuilder padding = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">while</span> (padding.length() &lt; STRAP_LINE_SIZE - (version.length() + SPRING_BOOT.length())) {
            padding.append(<span class="hljs-string">" "</span>);
        }

        printStream.println(AnsiOutput.toString(AnsiColor.GREEN, SPRING_BOOT, AnsiColor.DEFAULT, padding.toString(),
                AnsiStyle.FAINT, version));
        printStream.println();
    }

}
</code></pre><p>看到了上面一堆奇怪但又有些熟悉的东西，常量名是 <code>BANNER</code>，它就是在默认情况下打印在控制台的 <code>Banner</code>。</p>
<p>它重写的 <code>printBanner</code> 方法，就是拿输出对象，把定义好的 Banner 和 SpringBoot 的版本号打印出去，逻辑比较简单。</p>
<hr>
<p>回到 <code>printBanner</code> 中，看它的源码：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> Banner.Mode bannerMode = Banner.Mode.CONSOLE;

<span class="hljs-function"><span class="hljs-keyword">private</span> Banner <span class="hljs-title">printBanner</span><span class="hljs-params">(ConfigurableEnvironment environment)</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bannerMode == Banner.Mode.OFF) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
    <span class="hljs-comment">// Banner文件资源加载</span>
    ResourceLoader resourceLoader = (<span class="hljs-keyword">this</span>.resourceLoader != <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">this</span>.resourceLoader
            : <span class="hljs-keyword">new</span> DefaultResourceLoader(getClassLoader());
    <span class="hljs-comment">// 使用BannerPrinter打印Banner</span>
    SpringApplicationBannerPrinter bannerPrinter = <span class="hljs-keyword">new</span> SpringApplicationBannerPrinter(resourceLoader, <span class="hljs-keyword">this</span>.banner);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bannerMode == Mode.LOG) {
        <span class="hljs-keyword">return</span> bannerPrinter.print(environment, <span class="hljs-keyword">this</span>.mainApplicationClass, logger);
    }
    <span class="hljs-keyword">return</span> bannerPrinter.print(environment, <span class="hljs-keyword">this</span>.mainApplicationClass, System.out);
}
</code></pre><p>首先判断当前是否关闭了 Banner 输出，而默认值是打在控制台上。</p>
<p>之后要获取 <code>ResourceLoader</code>，它的作用大概可以猜测到是加载资源的。</p>
<h4 class="heading">4.7.1 ResourceLoader</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResourceLoader</span> </span>{

    <span class="hljs-comment">/** Pseudo URL prefix for loading from the class path: "classpath:". */</span>
    String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;

    <span class="hljs-function">Resource <span class="hljs-title">getResource</span><span class="hljs-params">(String location)</span></span>;

    <span class="hljs-meta">@Nullable</span>
    <span class="hljs-function">ClassLoader <span class="hljs-title">getClassLoader</span><span class="hljs-params">()</span></span>;

}
</code></pre><p>它的文档注释原文翻译：</p>
<blockquote>
<p>Strategy interface for loading resources (e.. class path or file system resources).</p>
<p>用于加载资源（例如类路径或文件系统资源）的策略接口。</p>
</blockquote>
<p>从接口定义和文档注释，已经基本证实了我们的猜测是正确的。上面方法默认创建的是 <code>DefaultResourceLoader</code>，看它的 <code>getResource</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Resource <span class="hljs-title">getResource</span><span class="hljs-params">(String location)</span> </span>{
    Assert.notNull(location, <span class="hljs-string">"Location must not be null"</span>);

    <span class="hljs-keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) {
        Resource resource = protocolResolver.resolve(location, <span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> resource;
        }
    }

    <span class="hljs-comment">// 处理前缀</span>
    <span class="hljs-keyword">if</span> (location.startsWith(<span class="hljs-string">"/"</span>)) {
        <span class="hljs-keyword">return</span> getResourceByPath(location);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// try块中加载资源</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Try to parse the location as a URL...</span>
            URL url = <span class="hljs-keyword">new</span> URL(location);
            <span class="hljs-keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="hljs-keyword">new</span> FileUrlResource(url) : <span class="hljs-keyword">new</span> UrlResource(url));
        }
        <span class="hljs-keyword">catch</span> (MalformedURLException ex) {
            <span class="hljs-comment">// No URL -&gt; resolve as resource path.</span>
            <span class="hljs-keyword">return</span> getResourceByPath(location);
        }
    }
}
</code></pre><p>前面的实现都可以不看，注意最后的try块中，它借助URL类来加载资源，这种方式已经跟 classLoader 的方式差不太多了，至此石锤我们的猜测是正确的。</p>
<hr>
<p>回到 <code>printBanner</code> 中：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// ...</span>
    ResourceLoader resourceLoader = (<span class="hljs-keyword">this</span>.resourceLoader != <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">this</span>.resourceLoader
            : <span class="hljs-keyword">new</span> DefaultResourceLoader(getClassLoader());
    SpringApplicationBannerPrinter bannerPrinter = <span class="hljs-keyword">new</span> SpringApplicationBannerPrinter(resourceLoader, <span class="hljs-keyword">this</span>.banner);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bannerMode == Mode.LOG) {
        <span class="hljs-keyword">return</span> bannerPrinter.print(environment, <span class="hljs-keyword">this</span>.mainApplicationClass, logger);
    }
    <span class="hljs-keyword">return</span> bannerPrinter.print(environment, <span class="hljs-keyword">this</span>.mainApplicationClass, System.out);
</code></pre><p>获取到 <code>ResourceLoader</code> 后，下面要创建一个 <code>SpringApplicationBannerPrinter</code> ，默认情况下最终调用到最后的return中。</p>
<h4 class="heading">4.7.2 SpringApplicationBannerPrinter#print</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Banner <span class="hljs-title">print</span><span class="hljs-params">(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out)</span> </span>{
    Banner banner = getBanner(environment);
    banner.printBanner(environment, sourceClass, out);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PrintedBanner(banner, sourceClass);
}
</code></pre><p>首先它要获取 <code>Banner</code>，之后打印 <code>Banner</code>，最后把 <code>Banner</code> 封装成 <code>PrintedBanner</code> 返回。</p>
<h5 class="heading">4.7.2.1 getBanner：获取Banner</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Banner DEFAULT_BANNER = <span class="hljs-keyword">new</span> SpringBootBanner();

<span class="hljs-function"><span class="hljs-keyword">private</span> Banner <span class="hljs-title">getBanner</span><span class="hljs-params">(Environment environment)</span> </span>{
    Banners banners = <span class="hljs-keyword">new</span> Banners();
    <span class="hljs-comment">// 先加载图片Banner和文字Banner</span>
    banners.addIfNotNull(getImageBanner(environment));
    banners.addIfNotNull(getTextBanner(environment));
    <span class="hljs-comment">// 只要有一个，就返回</span>
    <span class="hljs-keyword">if</span> (banners.hasAtLeastOneBanner()) {
        <span class="hljs-keyword">return</span> banners;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fallbackBanner != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.fallbackBanner;
    }
    <span class="hljs-comment">// 都没有，返回默认的</span>
    <span class="hljs-keyword">return</span> DEFAULT_BANNER;
}
</code></pre><p>很明显它要先试着找有没有 <code>图片Banner</code> 和 <code>文字Banner</code> ，如果都没有，则会取默认的 Banner，而这个 Banner 恰好就是一开始看到的，也是我们最熟悉的 Banner。</p>
<p>以获取 文字Banner 为例，看看它是怎么拿的：</p>
<h5 class="heading">4.7.2.2 getTextBanner</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BANNER_LOCATION_PROPERTY = <span class="hljs-string">"spring.banner.location"</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_BANNER_LOCATION = <span class="hljs-string">"banner.txt"</span>;

<span class="hljs-function"><span class="hljs-keyword">private</span> Banner <span class="hljs-title">getTextBanner</span><span class="hljs-params">(Environment environment)</span> </span>{
    String location = environment.getProperty(BANNER_LOCATION_PROPERTY, DEFAULT_BANNER_LOCATION);
    Resource resource = <span class="hljs-keyword">this</span>.resourceLoader.getResource(location);
    <span class="hljs-keyword">if</span> (resource.exists()) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResourceBanner(resource);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>首先它要看你有没有显式的在 <code>application.properties</code> 中配置 <code>spring.banner.location</code> 这个属性，如果有，就加载它，否则加载默认的位置，叫 <code>banner.txt</code>。</p>
<p>由此可见 SpringBoot 的设计原则：<strong>约定大于配置</strong>。</p>
<p>拿到 Banner 后，打印，返回，Banner 部分结束。</p>
<h3 class="heading">4.8 createApplicationContext：创建IOC容器</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_CONTEXT_CLASS = <span class="hljs-string">"org.springframework.context."</span>
        + <span class="hljs-string">"annotation.AnnotationConfigApplicationContext"</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = <span class="hljs-string">"org.springframework.boot."</span>
        + <span class="hljs-string">"web.servlet.context.AnnotationConfigServletWebServerApplicationContext"</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = <span class="hljs-string">"org.springframework."</span>
        + <span class="hljs-string">"boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext"</span>;

<span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title">createApplicationContext</span><span class="hljs-params">()</span> </span>{
    Class&lt;?&gt; contextClass = <span class="hljs-keyword">this</span>.applicationContextClass;
    <span class="hljs-keyword">if</span> (contextClass == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 根据Web应用类型决定实例化哪个IOC容器</span>
            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.webApplicationType) {
                <span class="hljs-keyword">case</span> SERVLET:
                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> REACTIVE:
                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
            }
        }
        <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(
                    <span class="hljs-string">"Unable create a default ApplicationContext, "</span> + <span class="hljs-string">"please specify an ApplicationContextClass"</span>,
                    ex);
        }
    }
    <span class="hljs-keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
}
</code></pre><p>可以发现都是创建的基于Annotation的 <strong>ApplicationContext</strong>。</p>
<p>（如果是非Web环境，创建的 <code>ApplicationContext</code> 与常规用 SpringFramework 时使用的注解驱动IOC容器一致）</p>
<p>注意 <code>BeanFactory</code> 在这里已经被创建了：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericApplicationContext</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>.beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();
}
</code></pre><p>之前分析过，默认导入 <code>spring-boot-start-web</code> 时，<strong>Servlet</strong>环境生效，故上面导入的类为：<code>AnnotationConfigServletWebServerApplicationContext</code> 。这个类将在后续的分析中大量出现。</p>
<p>到这里，咱对三种类型的运行时环境、IOC容器的类型归纳一下：</p>
<ul>
<li>Servlet - <code>StandardServletEnvironment</code> - <code>AnnotationConfigServletWebServerApplicationContext</code></li>
<li>Reactive - <code>StandardReactiveWebEnvironment</code> - <code>AnnotationConfigReactiveWebServerApplicationContext</code></li>
<li>None - <code>StandardEnvironment</code> - <code>AnnotationConfigApplicationContext</code></li>
</ul>
<h3 class="heading">4.9 prepareContext：初始化IOC容器</h3>
<p>先大体浏览这部分源码的内容，其中几个复杂的地方我们单独来看。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,
        SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>{
    <span class="hljs-comment">// 将创建好的应用环境设置到IOC容器中</span>
    context.setEnvironment(environment);
    <span class="hljs-comment">// 4.9.1 IOC容器的后置处理</span>
    postProcessApplicationContext(context);
    <span class="hljs-comment">// 4.9.2 执行Initializer</span>
    applyInitializers(context);
    <span class="hljs-comment">// 【回调】SpringApplicationRunListeners的contextPrepared方法（在创建和准备ApplicationContext之后，但在加载之前）</span>
    listeners.contextPrepared(context);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) {
        logStartupInfo(context.getParent() == <span class="hljs-keyword">null</span>);
        logStartupProfileInfo(context);
    }
    <span class="hljs-comment">// Add boot specific singleton beans</span>
    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
    <span class="hljs-comment">// 创建两个组件：在控制台打印Banner的，之前把main方法中参数封装成对象的组件</span>
    beanFactory.registerSingleton(<span class="hljs-string">"springApplicationArguments"</span>, applicationArguments);
    <span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-keyword">null</span>) {
        beanFactory.registerSingleton(<span class="hljs-string">"springBootBanner"</span>, printedBanner);
    }
    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) {
        ((DefaultListableBeanFactory) beanFactory)
                .setAllowBeanDefinitionOverriding(<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding);
    }
    <span class="hljs-comment">// Load the sources</span>
    <span class="hljs-comment">// 4.9.3 加载主启动类</span>
    Set&lt;Object&gt; sources = getAllSources();
    Assert.notEmpty(sources, <span class="hljs-string">"Sources must not be empty"</span>);
    <span class="hljs-comment">// 4.9.4 注册主启动类</span>
    load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]));
    <span class="hljs-comment">// 【回调】SpringApplicationRunListeners的contextLoaded方法（ApplicationContext已加载但在刷新之前）</span>
    listeners.contextLoaded(context);
}
</code></pre><h4 class="heading">4.9.1 postProcessApplicationContext：IOC容器的后置处理</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// 留意一下这个名，后面Debug的时候会看到</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CONFIGURATION_BEAN_NAME_GENERATOR =
			<span class="hljs-string">"org.springframework.context.annotation.internalConfigurationBeanNameGenerator"</span>;

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessApplicationContext</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>{
    <span class="hljs-comment">// 注册BeanName生成器</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanNameGenerator != <span class="hljs-keyword">null</span>) {
        context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,
                <span class="hljs-keyword">this</span>.beanNameGenerator);
    }
    <span class="hljs-comment">// 设置资源加载器和类加载器</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resourceLoader != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> GenericApplicationContext) {
            ((GenericApplicationContext) context).setResourceLoader(<span class="hljs-keyword">this</span>.resourceLoader);
        }
        <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> DefaultResourceLoader) {
            ((DefaultResourceLoader) context).setClassLoader(<span class="hljs-keyword">this</span>.resourceLoader.getClassLoader());
        }
    }
    <span class="hljs-comment">// 设置类型转换器</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.addConversionService) {
        context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance());
    }
}
</code></pre><p>它设置了几个组件：</p>
<ul>
<li>如果 <code>beanNameGenerator</code> 不为空，则把它注册到IOC容器中。 <code>BeanNameGenerator</code> 是Bean的name生成器，指定的 <code>CONFIGURATION_BEAN_NAME_GENERATOR</code> 在修改首字母大写后无法从IDEA索引到，暂且放置一边。</li>
<li><code>ResourceLoader</code> 和 <code>ClassLoader</code>，这些都在前面准备好了</li>
<li><code>ConversionService</code>，用于类型转换的工具，前面也准备好了，并且还做了容器共享</li>
</ul>
<h4 class="heading">4.9.2 applyInitializers：执行Initializer</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyInitializers</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>{
    <span class="hljs-keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) {
        Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),
                ApplicationContextInitializer.class);
        Assert.isInstanceOf(requiredType, context, <span class="hljs-string">"Unable to call initializer."</span>);
        initializer.initialize(context);
    }
}
</code></pre><p>这个方法会获取到所有 Initializer，调用initialize方法。而这些 Initializer，其实就是刚创建 <code>SpringApplication</code> 时准备的那些 <code>ApplicationContextInitializer</code>。</p>
<p>通过Debug发现默认情况下确实是那6个 Initializer ：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/17/16dd99427f3fe9bc~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<hr>
<p>来到 prepareContext 的最后几行：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Load the sources</span>
    <span class="hljs-comment">// 4.9.3 加载主启动类</span>
    Set&lt;Object&gt; sources = getAllSources();
    Assert.notEmpty(sources, <span class="hljs-string">"Sources must not be empty"</span>);
    <span class="hljs-comment">// 4.9.4 注册主启动类</span>
    load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]));
</code></pre><h4 class="heading">4.9.3 getAllSources</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> Set&lt;Class&lt;?&gt;&gt; primarySources;
<span class="hljs-keyword">private</span> Set&lt;String&gt; sources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();

<span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title">getAllSources</span><span class="hljs-params">()</span> </span>{
    Set&lt;Object&gt; allSources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
    <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.primarySources)) {
        allSources.addAll(<span class="hljs-keyword">this</span>.primarySources);
    }
    <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.sources)) {
        allSources.addAll(<span class="hljs-keyword">this</span>.sources);
    }
    <span class="hljs-keyword">return</span> Collections.unmodifiableSet(allSources);
}
</code></pre><p>它要加载 primarySources 和 sources 。</p>
<p>在之前分析的时候， primarySources 已经被设置过了，就是主启动类。sources 不清楚也没见过，通过Debug发现它确实为空。</p>
<p>也就是说，getAllSources 实际上是把主启动类加载进来了。</p>
<p>加载进来之后，就要注册进去，来到load方法：</p>
<h4 class="heading">4.9.4 【复杂】load</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">load</span><span class="hljs-params">(ApplicationContext context, Object[] sources)</span> </span>{
    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
        logger.debug(<span class="hljs-string">"Loading source "</span> + StringUtils.arrayToCommaDelimitedString(sources));
    }
    BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);
    <span class="hljs-comment">// 设置BeanName生成器，通过Debug发现此时它还没有被注册</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanNameGenerator != <span class="hljs-keyword">null</span>) {
        loader.setBeanNameGenerator(<span class="hljs-keyword">this</span>.beanNameGenerator);
    }
    <span class="hljs-comment">// 设置资源加载器</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resourceLoader != <span class="hljs-keyword">null</span>) {
        loader.setResourceLoader(<span class="hljs-keyword">this</span>.resourceLoader);
    }
    <span class="hljs-comment">// 设置运行环境</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment != <span class="hljs-keyword">null</span>) {
        loader.setEnvironment(<span class="hljs-keyword">this</span>.environment);
    }
    loader.load();
}
</code></pre><p>在调用 <code>createBeanDefinitionLoader</code> 方法之前，它先获取了 <code>BeanDefinitionRegistry</code> 。</p>
<h5 class="heading">4.9.4.1 getBeanDefinitionRegistry</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> BeanDefinitionRegistry <span class="hljs-title">getBeanDefinitionRegistry</span><span class="hljs-params">(ApplicationContext context)</span> </span>{
    <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry) {
        <span class="hljs-keyword">return</span> (BeanDefinitionRegistry) context;
    }
    <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> AbstractApplicationContext) {
        <span class="hljs-keyword">return</span> (BeanDefinitionRegistry) ((AbstractApplicationContext) context).getBeanFactory();
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Could not locate BeanDefinitionRegistry"</span>);
}
</code></pre><p>发现它在拿IOC容器进行类型判断和强转。</p>
<p>前面分析了，我们最终拿到的IOC容器是 <code>AnnotationConfigServletWebServerApplicationContext</code>，它的类继承结构：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationConfigServletWebServerApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServletWebServerApplicationContext</span>
		<span class="hljs-keyword">implements</span> <span class="hljs-title">AnnotationConfigRegistry</span>
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ServletWebServerApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericWebApplicationContext</span>
		<span class="hljs-keyword">implements</span> <span class="hljs-title">ConfigurableWebServerApplicationContext</span>
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">GenericWebApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericApplicationContext</span>
		<span class="hljs-keyword">implements</span> <span class="hljs-title">ConfigurableWebApplicationContext</span>, <span class="hljs-title">ThemeSource</span>
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">GenericApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistry</span>
</span></code></pre><p>它继承自 <code>GenericApplicationContext</code>，而 <code>GenericApplicationContext</code> 就继承了 <code>AbstractApplicationContext</code>，实现了 <code>BeanDefinitionRegistry</code> 接口。</p>
<p>所以上面的源码实际上<strong>把IOC容器返回去了</strong>。</p>
<h5 class="heading">4.9.4.2 createBeanDefinitionLoader</h5>
<p>拿到IOC容器后，进入 <code>createBeanDefinitionLoader</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> BeanDefinitionLoader <span class="hljs-title">createBeanDefinitionLoader</span><span class="hljs-params">(BeanDefinitionRegistry registry, Object[] sources)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanDefinitionLoader(registry, sources);
}
</code></pre><p>源码非常简单，直接new了一个 <code>BeanDefinitionLoader</code> 。那 <code>BeanDefinitionLoader</code> 的构造方法都干了什么呢？</p>
<pre><code class="hljs java" lang="java">BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) {
    Assert.notNull(registry, <span class="hljs-string">"Registry must not be null"</span>);
    Assert.notEmpty(sources, <span class="hljs-string">"Sources must not be empty"</span>);
    <span class="hljs-keyword">this</span>.sources = sources;
    <span class="hljs-comment">// 注册BeanDefinition解析器</span>
    <span class="hljs-keyword">this</span>.annotatedReader = <span class="hljs-keyword">new</span> AnnotatedBeanDefinitionReader(registry);
    <span class="hljs-keyword">this</span>.xmlReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(registry);
    <span class="hljs-keyword">if</span> (isGroovyPresent()) {
        <span class="hljs-keyword">this</span>.groovyReader = <span class="hljs-keyword">new</span> GroovyBeanDefinitionReader(registry);
    }
    <span class="hljs-keyword">this</span>.scanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(registry);
    <span class="hljs-keyword">this</span>.scanner.addExcludeFilter(<span class="hljs-keyword">new</span> ClassExcludeFilter(sources));
}
</code></pre><p>这里面发现了几个关键的组件：<code>AnnotatedBeanDefinitionReader</code>（注解驱动的Bean定义解析器）、<code>XmlBeanDefinitionReader</code>（Xml定义的Bean定义解析器）、<code>ClassPathBeanDefinitionScanner</code>（类路径下的Bean定义扫描器），还有一个我们不用的 <code>GroovyBeanDefinitionReader</code>（它需要经过isGroovyPresent方法，而这个方法需要判断classpath下是否有 <code>groovy.lang.MetaClass</code> 类）。</p>
<p><code>BeanDefinitionLoader</code> 的文档注释原文翻译：</p>
<blockquote>
<p>Loads bean definitions from underlying sources, including XML and JavaConfig. Acts as a simple facade over AnnotatedBeanDefinitionReader, XmlBeanDefinitionReader and ClassPathBeanDefinitionScanner.</p>
<p>从基础源（包括XML和JavaConfig）加载bean定义。充当 <code>AnnotatedBeanDefinitionReader</code>，<code>XmlBeanDefinitionReader</code> 和 <code>ClassPathBeanDefinitionScanner</code> 的简单外观（整合，外观模式）。</p>
</blockquote>
<p>正好呼应了上面的组件，而且它使用了外观模式，将这几个组件整合了起来。</p>
<h5 class="heading">4.9.4.3 load</h5>
<p>创建好解析器后，在上面的源码中，它又往loader中设置了 beanNameGenerator、resourceLoader、environment，最后调用了它的load方法。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (Object source : <span class="hljs-keyword">this</span>.sources) {
        count += load(source);
    }
    <span class="hljs-keyword">return</span> count;
}
</code></pre><p>它拿到所有的 sources（其实就主启动类一个），继续调用重载的load方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">load</span><span class="hljs-params">(Object source)</span> </span>{
    Assert.notNull(source, <span class="hljs-string">"Source must not be null"</span>);
    <span class="hljs-comment">// 根据传入source的类型，决定如何解析</span>
    <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> Class&lt;?&gt;) {
        <span class="hljs-keyword">return</span> load((Class&lt;?&gt;) source);
    }
    <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> Resource) {
        <span class="hljs-keyword">return</span> load((Resource) source);
    }
    <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> Package) {
        <span class="hljs-keyword">return</span> load((Package) source);
    }
    <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> CharSequence) {
        <span class="hljs-keyword">return</span> load((CharSequence) source);
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Invalid source type "</span> + source.getClass());
}
</code></pre><p>它会根据传入的 source 的类型，来决定用哪种方式加载。主启动类属于 <code>Class</code> 类型，于是继续调用重载的方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;?&gt; source)</span> </span>{
    <span class="hljs-keyword">if</span> (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) {
        <span class="hljs-comment">// Any GroovyLoaders added in beans{} DSL can contribute beans here</span>
        GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);
        load(loader);
    }
    <span class="hljs-comment">// 如果它是一个Component，则用注解解析器来解析它</span>
    <span class="hljs-keyword">if</span> (isComponent(source)) {
        <span class="hljs-keyword">this</span>.annotatedReader.register(source);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre><p>上面的 Groovy 相关的我们不关心，下面它要检测是否为一个 <strong>Component</strong>。</p>
<p>回想主启动类，它被 <code>@SpringBootApplication</code> 注解标注，而 <code>@SpringBootApplication</code> 组合了一个 <code>@SpringBootConfiguration</code>，它又组合了一个 <code>@Configuration</code> 注解，<code>@Configuration</code> 的底层就是一个 <code>@Component</code> 。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@SpringBootConfiguration</span>
<span class="hljs-meta">@EnableAutoConfiguration</span>
<span class="hljs-meta">@ComponentScan</span>(excludeFilters = { <span class="hljs-meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		<span class="hljs-meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication
  
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration
  
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Configuration
</code></pre><p>所以主启动类是一个 Component，进入 <code>annotatedReader</code> 的 <code>register</code> 方法中。</p>
<h5 class="heading">4.9.4.4 annotatedReader.register</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>{
    doRegisterBean(beanClass, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
}
</code></pre><p>【<strong>规律总结</strong>】SpringFramework 和 SpringBoot中 有很多类似于 <strong>xxx</strong> 方法和 <strong>doXXX</strong> 方法。一般情况下，xxx方法负责引导到 <strong>doXXX</strong> 方法，<strong>doXXX</strong> 方法负责真正的逻辑和工作。</p>
<p>进入 <code>doRegisterBean</code> 中：</p>
<h5 class="heading">4.9.4.5 doRegisterBean</h5>
<p>（源码较长，不太复杂的部分直接在源码上标注单行注释了）</p>
<pre><code class="hljs java" lang="java">&lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,
        @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>{

    <span class="hljs-comment">// 包装为BeanDefinition</span>
    AnnotatedGenericBeanDefinition abd = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) {
        <span class="hljs-keyword">return</span>;
    }

    abd.setInstanceSupplier(instanceSupplier);
    <span class="hljs-comment">// 解析Scope信息，决定作用域</span>
    ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);
    abd.setScope(scopeMetadata.getScopeName());
    <span class="hljs-comment">// 生成Bean的名称</span>
    String beanName = (name != <span class="hljs-keyword">null</span> ? name : <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="hljs-keyword">this</span>.registry));

    <span class="hljs-comment">// 解析BeanDefinition的注解</span>
    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
    <span class="hljs-keyword">if</span> (qualifiers != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) {
            <span class="hljs-keyword">if</span> (Primary.class == qualifier) {
                abd.setPrimary(<span class="hljs-keyword">true</span>);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Lazy.class == qualifier) {
                abd.setLazyInit(<span class="hljs-keyword">true</span>);
            }
            <span class="hljs-keyword">else</span> {
                abd.addQualifier(<span class="hljs-keyword">new</span> AutowireCandidateQualifier(qualifier));
            }
        }
    }
    <span class="hljs-comment">// 使用定制器修改这个BeanDefinition</span>
    <span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) {
        customizer.customize(abd);
    }

    <span class="hljs-comment">// 使用BeanDefinitionHolder，将BeanDefinition注册到IOC容器中</span>
    BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(abd, beanName);
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);
}
</code></pre><p>其中 <code>AnnotationConfigUtils.processCommonDefinitionAnnotations</code> 的实现：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCommonDefinitionAnnotations</span><span class="hljs-params">(AnnotatedBeanDefinition abd)</span> </span>{
    processCommonDefinitionAnnotations(abd, abd.getMetadata());
}

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCommonDefinitionAnnotations</span><span class="hljs-params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>{
    <span class="hljs-comment">// 解析@Lazy</span>
    AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
    <span class="hljs-keyword">if</span> (lazy != <span class="hljs-keyword">null</span>) {
        abd.setLazyInit(lazy.getBoolean(<span class="hljs-string">"value"</span>));
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (abd.getMetadata() != metadata) {
        lazy = attributesFor(abd.getMetadata(), Lazy.class);
        <span class="hljs-keyword">if</span> (lazy != <span class="hljs-keyword">null</span>) {
            abd.setLazyInit(lazy.getBoolean(<span class="hljs-string">"value"</span>));
        }
    }

    <span class="hljs-comment">// 解析@Primary</span>
    <span class="hljs-keyword">if</span> (metadata.isAnnotated(Primary.class.getName())) {
        abd.setPrimary(<span class="hljs-keyword">true</span>);
    }
    <span class="hljs-comment">// 解析@DependsOn</span>
    AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
    <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) {
        abd.setDependsOn(dependsOn.getStringArray(<span class="hljs-string">"value"</span>));
    }

    <span class="hljs-comment">// 解析@Role</span>
    AnnotationAttributes role = attributesFor(metadata, Role.class);
    <span class="hljs-keyword">if</span> (role != <span class="hljs-keyword">null</span>) {
        abd.setRole(role.getNumber(<span class="hljs-string">"value"</span>).intValue());
    }
    <span class="hljs-comment">// 解析@Description</span>
    AnnotationAttributes description = attributesFor(metadata, Description.class);
    <span class="hljs-keyword">if</span> (description != <span class="hljs-keyword">null</span>) {
        abd.setDescription(description.getString(<span class="hljs-string">"value"</span>));
    }
}
</code></pre><p>原来这部分是在解析一些咱之前学习 SpringFramework 时候接触的注解啊！</p>
<p>最终会将这个 BeanDefinition 注册到IOC容器中，调用 <code>BeanDefinitionReaderUtils</code> 的 <code>registerBeanDefinition</code> 方法。</p>
<h5 class="heading">4.9.4.6 BeanDefinitionReaderUtils.registerBeanDefinition</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(
        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span>
        <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>{

    <span class="hljs-comment">// Register bean definition under primary name.</span>
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    <span class="hljs-comment">// Register aliases for bean name, if any.</span>
    String[] aliases = definitionHolder.getAliases();
    <span class="hljs-keyword">if</span> (aliases != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}
</code></pre><p>第7行，看到了 <code>registry.registerBeanDefinition</code>，有没有想起来之前在之前介绍手动装配时的 <code>ImportBeanDefinitionRegistrar</code>？（第5篇 自动装配原理中，4.1.4小节）</p>
<p>在这里它就是这么把Bean的定义信息注册进IOC容器的。其中，Bean的名称和别名在这个方法也被分开处理。</p>
<hr>
<p>看到这里，小伙伴们可能会疑惑，这个 <strong>BeanDefinition</strong> 是个什么东西，它在IOC容器中起到了什么作用呢？</p>
<h4 class="heading">4.9.5 【重要】BeanDefinition</h4>
<p>它的文档注释原文翻译：</p>
<blockquote>
<p>A BeanDefinition describes a bean instance, which has property values, constructor argument values, and further information supplied by concrete implementations.
This is just a minimal interface: The main intention is to allow a BeanFactoryPostProcessor such as PropertyPlaceholderConfigurer to introspect and modify property values and other bean metadata.</p>
<p><code>BeanDefinition</code> 描述了一个bean实例，该实例具有属性值，构造函数参数值以及具体实现所提供的更多信息。</p>
<p>这只是一个最小的接口：主要目的是允许 <code>BeanFactoryPostProcessor</code> （例如 <code>PropertyPlaceholderConfigurer</code> ）内省和修改属性值和其他bean元数据。</p>
</blockquote>
<p>从文档注释中可以看出，它是描述Bean的实例的一个定义信息，但它不是真正的Bean。这个接口还定义了很多方法，不一一列举，全部的方法定义小伙伴们可以自行从IDE中了解。</p>
<ul>
<li><code>String getBeanClassName();</code></li>
<li><code>String getScope();</code></li>
<li><code>String[] getDependsOn();</code></li>
<li><code>String getInitMethodName();</code></li>
<li><code>boolean isSingleton();</code></li>
<li>.....</li>
</ul>
<p><code>SpringFramework</code> 设计的这种机制会在后续的Bean加载和创建时起到非常关键的作用，小伙伴们一定要留意。</p>
<p>下面提到了一个 <code>BeanPostProcessor</code> ，这个概念我们到下一篇再了解。</p>
<h2 class="heading">小结</h2>
<ol>
<li>Banner在初始化运行时环境之后，创建IOC容器之前打印。</li>
<li>SpringApplication 会根据前面确定好的应用类型，创建对应的IOC容器。</li>
<li>IOC容器在刷新之前会进行初始化、加载主启动类等预处理工作。</li>
</ol>
<p>【至此，主启动类也被注册进IOC容器中，IOC容器已经准备好，下面的几篇将是IOC容器最核心的部分：<strong>refresh</strong>】</p>
</div>
</body></html>