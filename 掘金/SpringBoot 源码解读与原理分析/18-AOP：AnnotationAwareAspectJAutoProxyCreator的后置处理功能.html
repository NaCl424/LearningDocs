<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>AOP：AnnotationAwareAspectJAutoProxyCreator的后置处理功能</h1>
<h1 class="heading">19. AOP：AnnotationAwareAspectJAutoProxyCreator的后置处理功能</h1>
<p>【接前章】</p>
<h2 class="heading">4. AnnotationAwareAspectJAutoProxyCreator的后置处理功能</h2>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code> 创建并注册到IOC容器中，接下来的切面类和被切类方法会受到它的影响。</p>
<p>下面由一个被切面的Bean为主线，研究它的创建流程。</p>
<h3 class="heading">4.1 refresh → createBean</h3>
<p>这部分依次走 <strong>refresh → finishBeanFactoryInitialization → preInstantiateSingletons → getBean → doGetBean → createBean</strong> 方法。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span>
        <span class="hljs-keyword">throws</span> BeanCreationException </span>{

    <span class="hljs-comment">// ......</span>

    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span>
        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
        <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> bean;
        }
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,
                <span class="hljs-string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);
    }

    <span class="hljs-comment">// doCreateBean ......</span>
}
</code></pre><p>中间的try块中，之前咱在IOC原理中提到过，它就是AOP创建代理对象的入口。</p>
<p>注意看 resolveBeforeInstantiation 方法上面的单行注释：</p>
<blockquote>
<p>Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</p>
<p>给后置处理器一个机会，来生成一个代理对象，代替普通的目标对象。</p>
</blockquote>
<p>换言之，它希望后置处理器能在此创建代理对象，而不是普通的单例Bean。</p>
<h3 class="heading">4.2 resolveBeforeInstantiation</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">resolveBeforeInstantiation</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> </span>{
    Object bean = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
        <span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span>
        <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);
            <span class="hljs-keyword">if</span> (targetType != <span class="hljs-keyword">null</span>) {
                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
                <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) {
                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
                }
            }
        }
        mbd.beforeInstantiationResolved = (bean != <span class="hljs-keyword">null</span>);
    }
    <span class="hljs-keyword">return</span> bean;
}
</code></pre><p>这段源码中先检查是否有 <code>InstantiationAwareBeanPostProcessor</code> ，如果有，就调用 <code>applyBeanPostProcessorsBeforeInstantiation</code> 方法，给这些后置处理器机会，让它创建真正的代理对象。</p>
<h3 class="heading">4.3 applyBeanPostProcessorsBeforeInstantiation</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">applyBeanPostProcessorsBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>{
    <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {
        <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
            <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">return</span> result;
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>到这里发现是真正执行 <code>InstantiationAwareBeanPostProcessor</code> 的 <code>postProcessBeforeInstantiation</code> 方法了。</p>
<p>来到 <code>AnnotationAwareAspectJAutoProxyCreator</code> ，搜索 <code>postProcessBeforeInstantiation</code> 方法，发现这个方法在 <code>AbstractAutoProxyCreator</code> 中定义。</p>
<h3 class="heading">4.4 AbstractAutoProxyCreator#postProcessBeforeInstantiation</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>{
    <span class="hljs-comment">// 缓存机制</span>
    Object cacheKey = getCacheKey(beanClass, beanName);

  
    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) {
        <span class="hljs-comment">// 判断该Bean是否已经被增强（advisedBeans为已经增强过的Bean）</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisedBeans.containsKey(cacheKey)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-comment">// 4.4.1, 4.4.2 判断是否为基础类型（isInfrastructureClass），或者需要跳过的Bean</span>
        <span class="hljs-keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
            <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
    }

    <span class="hljs-comment">// Create proxy here if we have a custom TargetSource.</span>
    <span class="hljs-comment">// Suppresses unnecessary default instantiation of the target bean:</span>
    <span class="hljs-comment">// The TargetSource will handle target instances in a custom fashion.</span>
    <span class="hljs-comment">// 如果我们有一个自定义的TargetSource，则在此处创建代理。</span>
    <span class="hljs-comment">// 这段源码要抑制目标bean的不必要的默认实例化：TargetSource将以自定义方式处理目标实例。</span>
    <span class="hljs-comment">// 4.4.3 自定义目标资源，对于单实例Bean必定会返回null</span>
    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);
    <span class="hljs-keyword">if</span> (targetSource != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName)) {
            <span class="hljs-keyword">this</span>.targetSourcedBeans.add(beanName);
        }
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);
        <span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());
        <span class="hljs-keyword">return</span> proxy;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>这段源码中有几个检查性质的步骤，一一来看：</p>
<h4 class="heading">4.4.1 isInfrastructureClass：判断Bean是否为基础类型</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// AnnotationAwareAspectJAutoProxyCreator</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInfrastructureClass</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>{
    <span class="hljs-comment">// 一大段文档注释</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">super</span>.isInfrastructureClass(beanClass) ||
            (<span class="hljs-keyword">this</span>.aspectJAdvisorFactory != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.aspectJAdvisorFactory.isAspect(beanClass)));
}

<span class="hljs-comment">// AbstractAutoProxyCreator</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInfrastructureClass</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>{
    <span class="hljs-keyword">boolean</span> retVal = Advice.class.isAssignableFrom(beanClass) ||
            Pointcut.class.isAssignableFrom(beanClass) ||
            Advisor.class.isAssignableFrom(beanClass) ||
            AopInfrastructureBean.class.isAssignableFrom(beanClass);
    <span class="hljs-keyword">if</span> (retVal &amp;&amp; logger.isTraceEnabled()) {
        logger.trace(<span class="hljs-string">"Did not attempt to auto-proxy infrastructure class ["</span> + beanClass.getName() + <span class="hljs-string">"]"</span>);
    }
    <span class="hljs-keyword">return</span> retVal;
}
</code></pre><p>在  上有一大串单行注释，我单独摘到下面，咱一块来看：</p>
<blockquote>
<p>Previously we setProxyTargetClass(true) in the constructor, but that has too broad an impact. Instead we now override isInfrastructureClass to avoid proxying aspects. I'm not entirely happy with that as there is no good reason not to advise aspects, except that it causes advice invocation to go through a proxy, and if the aspect implements e.g the Ordered interface it will be proxied by that interface and fail at runtime as the advice method is not defined on the interface. We could potentially relax the restriction about not advising aspects in the future.</p>
<p>以前我们在构造函数中有 <code>setProxyTargetClass(true)</code>，但是影响范围太广。相反，我们现在重写 <code>isInfrastructureClass</code> 方法，以避免代理切面。我对此并不完全满意，因为没有充分的理由不增强那些切面，只是它会导致增强方法只能通过代理调用，并且如果方面实现了例如 <code>Ordered</code> 接口，它将被该接口代理并在以下位置失败运行时，因为未在切面上定义增强方法。我们将来可能会放宽对非增强切面的限制。</p>
</blockquote>
<p>这段解释不是很好理解，但从上面的调用机制可以看出应该是重构过，不然也不会出现子类重写的现象（当然这是咱的推测）。还是来看方法实现吧。</p>
<p>这个方法会调用到父类的方法，而父类的方法会判断Bean的class是否为一些指定的类型（<code>Advice</code> 、<code>PointCut</code> 、<code>Advisor</code> 、<code>AopInfrastructureBean</code>）的子类。很显然我们在用注解AOP的时候都是打 <code>@Aspect</code> 注解，没有继承操作，故这部分返回false。</p>
<p>后面还有一段：<code>this.aspectJAdvisorFactory.isAspect(beanClass)</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAspect</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>{
    <span class="hljs-keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAspectAnnotation</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>{
    <span class="hljs-keyword">return</span> (AnnotationUtils.findAnnotation(clazz, Aspect.class) != <span class="hljs-keyword">null</span>);
}
</code></pre><p>很明显它要判断Bean的class上是否标注了 <code>@Aspect</code>，很明显切面类在这个判断中会返回true，故整体返回true，非切面类返回false。</p>
<h4 class="heading">4.4.2 shouldSkip：Bean是否需要跳过</h4>
<p>这一步有一个很重要的操作在这里面一起进行了：<strong>创建增强器</strong>。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// AspectJAwareAdvisorAutoProxyCreator</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>{
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider optimization by caching the list of the aspect names</span>
    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();
    <span class="hljs-keyword">for</span> (Advisor advisor : candidateAdvisors) {
        <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;
                ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldSkip(beanClass, beanName);
}

<span class="hljs-comment">// AbstractAutoProxyCreator</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>{
    <span class="hljs-keyword">return</span> AutoProxyUtils.isOriginalInstance(beanName, beanClass);
}
</code></pre><p>上面的方法是扩展了下面父类的方法。父类的方法很简单，它就是判断<strong>目标对象是不是原始对象</strong>（没有经过代理）。咱着重看子类重写的上面那段预判断。</p>
<h5 class="heading">4.4.2.1 findCandidateAdvisors：加载增强器</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// AnnotationAwareAspectJAutoProxyCreator</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findCandidateAdvisors</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Add all the Spring advisors found according to superclass rules.</span>
    <span class="hljs-comment">// 添加所有根据父类的规则找到的Spring的增强器</span>
    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">super</span>.findCandidateAdvisors();
    <span class="hljs-comment">// Build Advisors for all AspectJ aspects in the bean factory.</span>
    <span class="hljs-comment">// 给所有BeanFactory中的AspectJ切面构建增强器</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder != <span class="hljs-keyword">null</span>) {
        advisors.addAll(<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());
    }
    <span class="hljs-keyword">return</span> advisors;
}

<span class="hljs-comment">// AbstractAdvisorAutoProxyCreator</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findCandidateAdvisors</span><span class="hljs-params">()</span> </span>{
    Assert.state(<span class="hljs-keyword">this</span>.advisorRetrievalHelper != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No BeanFactoryAdvisorRetrievalHelper available"</span>);
    <span class="hljs-comment">// 4.4.2.2 获取、创建增强器的Bean</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.advisorRetrievalHelper.findAdvisorBeans();
}
</code></pre><p>上面子类重写的方法也很简单，先调父类的方法取出一组增强器，再从IOC容器中找出所有标注 <code>@Aspect</code> 的组件一起添加上。</p>
<p>而父类的方法是用一个 <code>advisorRetrievalHelper</code> 组件来调 <code>findAdvisorBeans</code> 方法：</p>
<h5 class="heading">4.4.2.2 advisorRetrievalHelper.findAdvisorBeans：获取、创建增强器的Bean</h5>
<p>（关键源码的注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">findAdvisorBeans</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Determine list of advisor bean names, if not cached already.</span>
    <span class="hljs-comment">// 确定增强器bean名称的列表（如果尚未缓存）</span>
    String[] advisorNames = <span class="hljs-keyword">this</span>.cachedAdvisorBeanNames;
    <span class="hljs-keyword">if</span> (advisorNames == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span>
        <span class="hljs-comment">// uninitialized to let the auto-proxy creator apply to them!</span>
        <span class="hljs-comment">// 不要在这里初始化FactoryBeans：我们需要保留所有未初始化的常规bean，以使自动代理创建者对其应用</span>
        <span class="hljs-comment">// 其实这里只是把那些类型为Advisor的Bean都找出来而已</span>
        advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
                <span class="hljs-keyword">this</span>.beanFactory, Advisor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">this</span>.cachedAdvisorBeanNames = advisorNames;
    }
    <span class="hljs-comment">// 如果当前IOC容器中没有任何增强器类Bean，直接返回</span>
    <span class="hljs-keyword">if</span> (advisorNames.length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    }

    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-comment">// 有增强器类Bean，循环它们</span>
    <span class="hljs-keyword">for</span> (String name : advisorNames) {
        <span class="hljs-keyword">if</span> (isEligibleBean(name)) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) {
                <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
                    logger.trace(<span class="hljs-string">"Skipping currently created advisor '"</span> + name + <span class="hljs-string">"'"</span>);
                }
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 利用getBean把这些增强器先创建出来</span>
                    advisors.add(<span class="hljs-keyword">this</span>.beanFactory.getBean(name, Advisor.class));
                }
                <span class="hljs-keyword">catch</span> (BeanCreationException ex) {
                    Throwable rootCause = ex.getMostSpecificCause();
                    <span class="hljs-keyword">if</span> (rootCause <span class="hljs-keyword">instanceof</span> BeanCurrentlyInCreationException) {
                        BeanCreationException bce = (BeanCreationException) rootCause;
                        String bceBeanName = bce.getBeanName();
                        <span class="hljs-comment">// 这里可能也会引发循环依赖，如果这里正在创建这个增强器了，直接continue</span>
                        <span class="hljs-keyword">if</span> (bceBeanName != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.beanFactory.isCurrentlyInCreation(bceBeanName)) {
                            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
                                logger.trace(<span class="hljs-string">"Skipping advisor '"</span> + name +
                                        <span class="hljs-string">"' with dependency on currently created bean: "</span> + ex.getMessage());
                            }
                            <span class="hljs-comment">// Ignore: indicates a reference back to the bean we're trying to advise.</span>
                            <span class="hljs-comment">// We want to find advisors other than the currently created bean itself.</span>
                            <span class="hljs-keyword">continue</span>;
                        }
                    }
                    <span class="hljs-keyword">throw</span> ex;
                }
            }
        }
    }
    <span class="hljs-keyword">return</span> advisors;
}
</code></pre><p>可以发现这部分源码只是把那些增强器先创建、初始化出来，放入IOC容器中就完事了。</p>
<hr>
<p>上面的方法返回后，要准备构建增强器了，它要调 <code>aspectJAdvisorsBuilder.buildAspectJAdvisors</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findCandidateAdvisors</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 添加所有根据父类的规则找到的Spring的增强器</span>
    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">super</span>.findCandidateAdvisors();
    <span class="hljs-comment">// Build Advisors for all AspectJ aspects in the bean factory.</span>
    <span class="hljs-comment">// 给所有BeanFactory中的AspectJ切面构建增强器</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder != <span class="hljs-keyword">null</span>) {
        advisors.addAll(<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());
    }
    <span class="hljs-keyword">return</span> advisors;
}
</code></pre><h5 class="heading">4.4.2.3 【创建增强器】aspectJAdvisorsBuilder.buildAspectJAdvisors</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// 在当前的BeanFactory中查找带有@AspectJ注解的切面类Bean，然后返回代表它们的增强器列表。为每个AspectJ通知方法创建一个增强器</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">buildAspectJAdvisors</span><span class="hljs-params">()</span> </span>{
    List&lt;String&gt; aspectNames = <span class="hljs-keyword">this</span>.aspectBeanNames;

    <span class="hljs-comment">// 提取增强通知</span>
    <span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
            aspectNames = <span class="hljs-keyword">this</span>.aspectBeanNames;
            <span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-keyword">null</span>) {
                List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
                aspectNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
                <span class="hljs-comment">// 获取IOC容器中的所有Bean</span>
                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
                        <span class="hljs-keyword">this</span>.beanFactory, Object.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
                <span class="hljs-keyword">for</span> (String beanName : beanNames) {
                    <span class="hljs-keyword">if</span> (!isEligibleBean(beanName)) {
                        <span class="hljs-keyword">continue</span>;
                    }
                    <span class="hljs-comment">// We must be careful not to instantiate beans eagerly as in this case they</span>
                    <span class="hljs-comment">// would be cached by the Spring container but would not have been weaved.</span>
                    <span class="hljs-comment">// 我们必须小心，不要急于实例化bean，因为在这种情况下，IOC容器会缓存它们，但不会被织入增强器</span>
                    <span class="hljs-comment">// 这一部分的功能是在不创建Bean的情况下获取Bean的类型，防止因为增强器还没有创建，导致对象没有被成功代理</span>
                    Class&lt;?&gt; beanType = <span class="hljs-keyword">this</span>.beanFactory.getType(beanName);
                    <span class="hljs-keyword">if</span> (beanType == <span class="hljs-keyword">null</span>) {
                        <span class="hljs-keyword">continue</span>;
                    }
                    <span class="hljs-comment">// 如果当前循环的Bean是一个切面类</span>
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisorFactory.isAspect(beanType)) {
                        aspectNames.add(beanName);
                        <span class="hljs-comment">// 包装@Aspect注解的元数据</span>
                        AspectMetadata amd = <span class="hljs-keyword">new</span> AspectMetadata(beanType, beanName);
                        <span class="hljs-comment">// 默认使用单实例创建切面类</span>
                        <span class="hljs-keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
                            MetadataAwareAspectInstanceFactory factory =
                                    <span class="hljs-keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="hljs-keyword">this</span>.beanFactory, beanName);
                            <span class="hljs-comment">// 4.4.2.4 如果切面类是一个单实例Bean，则会缓存所有增强器</span>
                            List&lt;Advisor&gt; classAdvisors = <span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory);
                            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isSingleton(beanName)) {
                                <span class="hljs-keyword">this</span>.advisorsCache.put(beanName, classAdvisors);
                            }
                            <span class="hljs-comment">// 否则只会缓存增强器创建工厂，由增强器工厂来创建增强器</span>
                            <span class="hljs-keyword">else</span> {
                                <span class="hljs-keyword">this</span>.aspectFactoryCache.put(beanName, factory);
                            }
                            advisors.addAll(classAdvisors);
                        }
                        <span class="hljs-keyword">else</span> {
                            <span class="hljs-comment">// Per target or per this.</span>
                            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isSingleton(beanName)) {
                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Bean with name '"</span> + beanName +
                                        <span class="hljs-string">"' is a singleton, but aspect instantiation model is not singleton"</span>);
                            }
                            MetadataAwareAspectInstanceFactory factory =
                                    <span class="hljs-keyword">new</span> PrototypeAspectInstanceFactory(<span class="hljs-keyword">this</span>.beanFactory, beanName);
                            <span class="hljs-keyword">this</span>.aspectFactoryCache.put(beanName, factory);
                            advisors.addAll(<span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory));
                        }
                    }
                }
                <span class="hljs-keyword">this</span>.aspectBeanNames = aspectNames;
                <span class="hljs-keyword">return</span> advisors;
            }
        }
    }

    <span class="hljs-comment">// 如果aspectNames不为null，证明之前已经创建过了，直接读缓存即可</span>
    <span class="hljs-keyword">if</span> (aspectNames.isEmpty()) {
        <span class="hljs-keyword">return</span> Collections.emptyList();
    }
    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (String aspectName : aspectNames) {
        List&lt;Advisor&gt; cachedAdvisors = <span class="hljs-keyword">this</span>.advisorsCache.get(aspectName);
        <span class="hljs-keyword">if</span> (cachedAdvisors != <span class="hljs-keyword">null</span>) {
            advisors.addAll(cachedAdvisors);
        }
        <span class="hljs-keyword">else</span> {
            MetadataAwareAspectInstanceFactory factory = <span class="hljs-keyword">this</span>.aspectFactoryCache.get(aspectName);
            advisors.addAll(<span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory));
        }
    }
    <span class="hljs-keyword">return</span> advisors;
}
</code></pre><p>概括一下上面的增强器创建思路：</p>
<ol>
<li>获取IOC容器中的所有Bean</li>
<li>从所有的Bean中找带有 <code>@Aspect</code> 注解的Bean</li>
<li>根据Bean中定义的通知（Advice，即被五种通知类型标注的方法），创建增强器</li>
<li>将增强器放入缓存，以备后续加载</li>
</ol>
<p>注意源码中有一步我标注了序号：<code>advisorFactory.getAdvisors</code> ：</p>
<h5 class="heading">4.4.2.4 advisorFactory.getAdvisors：缓存Bean中的所有增强器</h5>
<p>（关键部分注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">getAdvisors</span><span class="hljs-params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>{
    <span class="hljs-comment">// 目标Aspect类</span>
    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
    <span class="hljs-comment">// 代理对象Bean的name</span>
    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();
    <span class="hljs-comment">// 校验Aspect类上是不是标注了@Aspect注解</span>
    validate(aspectClass);

    <span class="hljs-comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span>
    <span class="hljs-comment">// so that it will only instantiate once.</span>
    <span class="hljs-comment">// 我们需要用装饰器包装MetadataAwareAspectInstanceFactory，使其仅实例化一次</span>
    <span class="hljs-comment">// 这部分是使用了装饰者模式，把aspectInstanceFactory包装起来，保证增强器不会多次实例化</span>
    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =
            <span class="hljs-keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);

    <span class="hljs-comment">// 筛选没有标注@Pointcut注解的方法，并创建增强器</span>
    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) {
        <span class="hljs-comment">// 4.4.2.5 真正创建增强器</span>
        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);
        <span class="hljs-keyword">if</span> (advisor != <span class="hljs-keyword">null</span>) {
            advisors.add(advisor);
        }
    }

    <span class="hljs-comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span>
    <span class="hljs-comment">// 通过在装饰者内部的开始加入SyntheticInstantiationAdvisor增强器，达到延迟初始化切面bean的目的</span>
    <span class="hljs-keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
        Advisor instantiationAdvisor = <span class="hljs-keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);
        advisors.add(<span class="hljs-number">0</span>, instantiationAdvisor);
    }

    <span class="hljs-comment">// Find introduction fields.</span>
    <span class="hljs-comment">// 对@DeclareParent注解功能的支持（引入）</span>
    <span class="hljs-keyword">for</span> (Field field : aspectClass.getDeclaredFields()) {
        Advisor advisor = getDeclareParentsAdvisor(field);
        <span class="hljs-keyword">if</span> (advisor != <span class="hljs-keyword">null</span>) {
            advisors.add(advisor);
        }
    }

    <span class="hljs-keyword">return</span> advisors;
}
</code></pre><p>这部分的核心就是中间部分的 <code>getAdvisor</code>：获取/创建增强器（可以类比<strong>getBean</strong>）。</p>
<h5 class="heading">4.4.2.5 getAdvisor：真正创建增强器</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title">getAdvisor</span><span class="hljs-params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,
        <span class="hljs-keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>{
    <span class="hljs-comment">// 校验@Aspect注解等</span>
    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());

    <span class="hljs-comment">// 4.4.2.6 解析切入点</span>
    AspectJExpressionPointcut expressionPointcut = getPointcut(
            candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());
    <span class="hljs-keyword">if</span> (expressionPointcut == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">// 将切入点和通知包装成一个切面</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,
            <span class="hljs-keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);
}
</code></pre><p>这个方法中先是解析切入点，之后把<strong>切入点</strong>和<strong>通知</strong>包装成一个<strong>切面</strong>（回想AOP的术语）。</p>
<p>注意有一点咱多留意一下：</p>
<p>【切入点】<code>AspectJExpressionPointcut</code> 的类结构与实现</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectJExpressionPointcut</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpressionPointcut</span>
		<span class="hljs-keyword">implements</span> <span class="hljs-title">ClassFilter</span>, <span class="hljs-title">IntroductionAwareMethodMatcher</span>, <span class="hljs-title">BeanFactoryAware</span>
</span></code></pre><p>注意它实现了一个接口：<code>ClassFilter</code> ，而这个 <code>ClassFilter</code> 的接口声明：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">/**
 * 限制切入点或简介与给定目标类集匹配的过滤器。
 * 可以用作切入点的一部分，也可以用作IntroductionAdvisor的整个目标。
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ClassFilter</span> </span>{
	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span></span>;
	ClassFilter TRUE = TrueClassFilter.INSTANCE;
}
</code></pre><p>文档注释和接口方法声明都很明确了，这个接口的作用是<strong>筛选切入点</strong>的。</p>
<h5 class="heading">4.4.2.6 getPointcut：解析切入点</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> AspectJExpressionPointcut <span class="hljs-title">getPointcut</span><span class="hljs-params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> </span>{
    <span class="hljs-comment">// 4.4.2.7 获取切入点的注解通知类型</span>
    AspectJAnnotation&lt;?&gt; aspectJAnnotation =
            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
    <span class="hljs-keyword">if</span> (aspectJAnnotation == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    AspectJExpressionPointcut ajexp =
            <span class="hljs-keyword">new</span> AspectJExpressionPointcut(candidateAspectClass, <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>], <span class="hljs-keyword">new</span> Class&lt;?&gt;[<span class="hljs-number">0</span>]);
    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span>) {
        ajexp.setBeanFactory(<span class="hljs-keyword">this</span>.beanFactory);
    }
    <span class="hljs-keyword">return</span> ajexp;
}
</code></pre><p>第一行要根据方法来解析它使用的通知注解，后面就是包装 <code>AspectJExpressionPointcut</code> 对象了。</p>
<h5 class="heading">4.4.2.7 AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod：获取切入点的注解通知类型</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Class&lt;?&gt;[] ASPECTJ_ANNOTATION_CLASSES = <span class="hljs-keyword">new</span> Class&lt;?&gt;[] {
        Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class};

<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) {
    <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : ASPECTJ_ANNOTATION_CLASSES) {
        AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) clazz);
        <span class="hljs-keyword">if</span> (foundAnnotation != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> foundAnnotation;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>它会找这里面所有的注解，并确定出一个，返回去。</p>
<p>至此可以发现底层解析AOP注解通知的核心。</p>
<hr>
<h5 class="heading">4.4.2.8 回到shouldSkip方法</h5>
<p>解析注解通知，包装成切面，缓存到IOC容器中，回到 <code>findCandidateAdvisors</code> 方法中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findCandidateAdvisors</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 添加所有根据父类的规则找到的Spring的增强器</span>
    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">super</span>.findCandidateAdvisors();
    <span class="hljs-comment">// 给所有BeanFactory中的AspectJ切面构建增强器</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder != <span class="hljs-keyword">null</span>) {
        advisors.addAll(<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());
    }
    <span class="hljs-keyword">return</span> advisors;
}
</code></pre><p>此时已经加载好增强器，直接返回出去，回到 <code>shouldSkip</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// AspectJAwareAdvisorAutoProxyCreator</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>{
    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();
    <span class="hljs-keyword">for</span> (Advisor advisor : candidateAdvisors) {
        <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;
                ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldSkip(beanClass, beanName);
}
</code></pre><p>它会循环这些切面，并确定正在创建的Bean的name是否与切面相同，如果发现有相同的，则代表要跳过Bean的创建。</p>
<p>至此，可以解析出判断Bean的基础类型，和是否应该跳过Bean的创建。</p>
<h4 class="heading">4.4.3 getCustomTargetSource</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> TargetSource <span class="hljs-title">getCustomTargetSource</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>{
    <span class="hljs-comment">// We can't create fancy target sources for directly registered singletons.</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.customTargetSourceCreators != <span class="hljs-keyword">null</span> &amp;&amp;
            <span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.beanFactory.containsBean(beanName)) {
        <span class="hljs-keyword">for</span> (TargetSourceCreator tsc : <span class="hljs-keyword">this</span>.customTargetSourceCreators) {
            TargetSource ts = tsc.getTargetSource(beanClass, beanName);
            <span class="hljs-keyword">if</span> (ts != <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// Found a matching TargetSource.</span>
                <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
                    logger.trace(<span class="hljs-string">"TargetSourceCreator ["</span> + tsc +
                            <span class="hljs-string">"] found custom TargetSource for bean with name '"</span> + beanName + <span class="hljs-string">"'"</span>);
                }
                <span class="hljs-keyword">return</span> ts;
            }
        }
    }

    <span class="hljs-comment">// No custom TargetSource found.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>这段源码中的if判断就已经给拦截死了：<code>this.beanFactory.containsBean(beanName)</code> 。本来是给单实例Bean创建代理对象，结果要先从IOC容器中找现在有没有了，那自然没有，直接返回null。这也解释了为什么上面的 <code>postProcessBeforeInstantiation</code> 方法会直接返回null。</p>
<h4 class="heading">4.4.4 并没有创建代理对象，直接返回出去了</h4>
<p>Debug发现 <code>postProcessBeforeInstantiation</code> 方法并没有创建出Bean实例来，下一步回到 <code>createBean</code> 方法中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> </span>{
    <span class="hljs-comment">// ......</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span>
        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
        <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> bean;
        }
    }
    <span class="hljs-comment">// catch ......</span>

    <span class="hljs-keyword">try</span> {
        Object beanInstance = doCreateBean(beanName, mbdToUse, args);
        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
            logger.trace(<span class="hljs-string">"Finished creating instance of bean '"</span> + beanName + <span class="hljs-string">"'"</span>);
        }
        <span class="hljs-keyword">return</span> beanInstance;
    }
    <span class="hljs-comment">// catch ......</span>
}
</code></pre><p>上面发现bean为null，下面的判断也不会进，会往下执行 <code>doCreateBean</code> 。</p>
<h3 class="heading">4.5 doCreateBean</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> @Nullable Object[] args)</span>
        <span class="hljs-keyword">throws</span> BeanCreationException </span>{
    <span class="hljs-comment">// ......</span>
    Object exposedObject = bean;
    <span class="hljs-keyword">try</span> {
        populateBean(beanName, mbd, instanceWrapper);
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }
    <span class="hljs-comment">// ......</span>
}
</code></pre><p>进到 <code>initializeBean</code> 方法，<code>BeanPostProcessor</code> 会在这里执行 <code>postProcessAfterInitialization</code> 方法。</p>
<h3 class="heading">4.6 initializeBean</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>{
    <span class="hljs-comment">// ......</span>
    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) {
        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    }
    <span class="hljs-keyword">return</span> wrappedBean;
}
</code></pre><p>进入 <code>applyBeanPostProcessorsAfterInitialization</code> 方法，执行 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization</code> 方法：</p>
<h3 class="heading">4.7 AbstractAutoProxyCreator#postProcessAfterInitialization</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(@Nullable Object bean, String beanName)</span> </span>{
    <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) {
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) {
            <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);
        }
    }
    <span class="hljs-keyword">return</span> bean;
}
</code></pre><p>这里面关键的方法也是最里头的 <code>wrapIfNecessary</code> 方法：</p>
<h3 class="heading">4.8 wrapIfNecessary</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">wrapIfNecessary</span><span class="hljs-params">(Object bean, String beanName, Object cacheKey)</span> </span>{
    <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) {
        <span class="hljs-keyword">return</span> bean;
    }
    <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(<span class="hljs-keyword">this</span>.advisedBeans.get(cacheKey))) {
        <span class="hljs-keyword">return</span> bean;
    }
    <span class="hljs-keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
        <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);
        <span class="hljs-keyword">return</span> bean;
    }

    <span class="hljs-comment">// Create proxy if we have advice.</span>
    <span class="hljs-comment">// 如果需要增强，创建代理对象</span>
    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="hljs-keyword">null</span>);
    <span class="hljs-keyword">if</span> (specificInterceptors != DO_NOT_PROXY) {
        <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);
        Object proxy = createProxy(
                bean.getClass(), beanName, specificInterceptors, <span class="hljs-keyword">new</span> SingletonTargetSource(bean));
        <span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());
        <span class="hljs-keyword">return</span> proxy;
    }

    <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);
    <span class="hljs-keyword">return</span> bean;
}
</code></pre><p>在这部分前三个if结构都是跟之前看到的 <code>postProcessBeforeInstantiation</code> 部分一样的，不再赘述。</p>
<p>这个方法中的单行注释标注，要在这里创建代理对象。下面的 <code>getAdvicesAndAdvisorsForBean</code> 方法，要先获取该类被切的增强器：</p>
<h4 class="heading">4.8.1 getAdvicesAndAdvisorsForBean</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Nullable</span>
<span class="hljs-keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, <span class="hljs-meta">@Nullable</span> TargetSource targetSource) {
    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);
    <span class="hljs-keyword">if</span> (advisors.isEmpty()) {
        <span class="hljs-keyword">return</span> DO_NOT_PROXY;
    }
    <span class="hljs-keyword">return</span> advisors.toArray();
}
</code></pre><p>这里就是拿之前收集好的增强器。但通过Debug时发现增强器的集合中除了前面定义的Before增强器，还有一个 <strong><code>ExposeInvocationInterceptor</code></strong> 。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/18/16ddc845fef1a0a6~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<h5 class="heading">4.8.1.0 ExposeInvocationInterceptor</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExposeInvocationInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">PriorityOrdered</span>, <span class="hljs-title">Serializable</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;MethodInvocation&gt; invocation =
            <span class="hljs-keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="hljs-string">"Current AOP method invocation"</span>);

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
        MethodInvocation oldInvocation = invocation.get();
        invocation.set(mi);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> mi.proceed();
        }
        <span class="hljs-keyword">finally</span> {
            invocation.set(oldInvocation);
        }
    }

}
</code></pre><p>它实现了 <code>MethodInterceptor</code> 接口，<code>invoke</code> 方法中它只干了一件事，暂时咱可以这么理解：<strong>把当前执行的目标方法放入 <code>ThreadLocal</code> 中</strong>。</p>
<p>回过头来，看看 <code>findEligibleAdvisors</code> 方法的内部实现：</p>
<h4 class="heading">4.8.2 findEligibleAdvisors</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findEligibleAdvisors</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>{
    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();
    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
    extendAdvisors(eligibleAdvisors);
    <span class="hljs-keyword">if</span> (!eligibleAdvisors.isEmpty()) {
        eligibleAdvisors = sortAdvisors(eligibleAdvisors);
    }
    <span class="hljs-keyword">return</span> eligibleAdvisors;
}
</code></pre><p>首先要获取所有之前收集好的增强器，通过Debug发现是只有那一个before增强器。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/18/16ddc84858ee12b3~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>之后 <code>findAdvisorsThatCanApply</code> 方法要过滤出<strong>可以代理的增强器</strong>（也就是能切该Bean的切面），这部分就是使用<strong>切入点表达式</strong>与当前Bean中方法进行匹配。解析切入点表达式的部分很复杂，小册在这里不作过多研究，有兴趣的小伙伴可以深入分析一下。</p>
<p><code>findAdvisorsThatCanApply</code> 方法执行完后，下面还要再调一个 <code>extendAdvisors</code> 方法：</p>
<h4 class="heading">4.8.3 extendAdvisors</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extendAdvisors</span><span class="hljs-params">(List&lt;Advisor&gt; candidateAdvisors)</span> </span>{
    AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(candidateAdvisors);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">makeAdvisorChainAspectJCapableIfNecessary</span><span class="hljs-params">(List&lt;Advisor&gt; advisors)</span> </span>{
    <span class="hljs-comment">// Don't add advisors to an empty list; may indicate that proxying is just not required</span>
    <span class="hljs-keyword">if</span> (!advisors.isEmpty()) {
        <span class="hljs-keyword">boolean</span> foundAspectJAdvice = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">for</span> (Advisor advisor : advisors) {
            <span class="hljs-comment">// Be careful not to get the Advice without a guard, as this might eagerly</span>
            <span class="hljs-comment">// instantiate a non-singleton AspectJ aspect...</span>
            <span class="hljs-keyword">if</span> (isAspectJAdvice(advisor)) {
                foundAspectJAdvice = <span class="hljs-keyword">true</span>;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">if</span> (foundAspectJAdvice &amp;&amp; !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) {
            <span class="hljs-comment">// 附加了一个ExposeInvocationInterceptor</span>
            advisors.add(<span class="hljs-number">0</span>, ExposeInvocationInterceptor.ADVISOR);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
</code></pre><p>源码中发现最后的一个if结构中，在整个增强器的列表最前面插入了一个 <code>ExposeInvocationInterceptor</code> 类型的增强器。</p>
<h3 class="heading">4.9 回到wrapIfNecessary</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">wrapIfNecessary</span><span class="hljs-params">(Object bean, String beanName, Object cacheKey)</span> </span>{
    <span class="hljs-comment">// ......</span>
    <span class="hljs-comment">// 如果需要增强，创建代理对象</span>
    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="hljs-keyword">null</span>);
    <span class="hljs-keyword">if</span> (specificInterceptors != DO_NOT_PROXY) {
        <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);
        Object proxy = createProxy(
                bean.getClass(), beanName, specificInterceptors, <span class="hljs-keyword">new</span> SingletonTargetSource(bean));
        <span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());
        <span class="hljs-keyword">return</span> proxy;
    }
    <span class="hljs-comment">// ......</span>
}
</code></pre><p>拿到增强器后，判断增强器不为空后，下面要调用 <code>createProxy</code> 方法来真正的创建代理对象。</p>
<h3 class="heading">4.10 createProxy</h3>
<p>（关键步骤的注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createProxy</span><span class="hljs-params">(Class&lt;?&gt; beanClass, @Nullable String beanName,
        @Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>{

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory) {
        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="hljs-keyword">this</span>.beanFactory, beanName, beanClass);
    }

    <span class="hljs-comment">// 创建代理工厂，使用它来创建代理对象</span>
    ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();
    <span class="hljs-comment">// 从当前执行的AbstractAutoProxyCreator中复制一些配置</span>
    proxyFactory.copyFrom(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">if</span> (!proxyFactory.isProxyTargetClass()) {
        <span class="hljs-keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) {
            proxyFactory.setProxyTargetClass(<span class="hljs-keyword">true</span>);
        }
        <span class="hljs-keyword">else</span> {
            evaluateProxyInterfaces(beanClass, proxyFactory);
        }
    }

    <span class="hljs-comment">// 4.10.1 组合所有增强器</span>
    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
    <span class="hljs-comment">// 将增强器放入代理工厂</span>
    proxyFactory.addAdvisors(advisors);
    proxyFactory.setTargetSource(targetSource);
    customizeProxyFactory(proxyFactory);

    proxyFactory.setFrozen(<span class="hljs-keyword">this</span>.freezeProxy);
    <span class="hljs-keyword">if</span> (advisorsPreFiltered()) {
        proxyFactory.setPreFiltered(<span class="hljs-keyword">true</span>);
    }

    <span class="hljs-comment">// 4.10.2 真正创建代理对象</span>
    <span class="hljs-keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());
}
</code></pre><p>这里面有两个很重要的步骤：组合增强器 → 创建代理对象。</p>
<h4 class="heading">4.10.1 buildAdvisors：组合所有增强器</h4>
<p>（关键步骤的注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">protected</span> Advisor[] buildAdvisors(<span class="hljs-meta">@Nullable</span> String beanName, <span class="hljs-meta">@Nullable</span> Object[] specificInterceptors) {
    <span class="hljs-comment">// Handle prototypes correctly...</span>
    <span class="hljs-comment">// 解析通用拦截器</span>
    Advisor[] commonInterceptors = resolveInterceptorNames();

    List&lt;Object&gt; allInterceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">if</span> (specificInterceptors != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 把传入的增强器放入AOP拦截器列表中</span>
        allInterceptors.addAll(Arrays.asList(specificInterceptors));
        <span class="hljs-keyword">if</span> (commonInterceptors.length &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.applyCommonInterceptorsFirst) {
                allInterceptors.addAll(<span class="hljs-number">0</span>, Arrays.asList(commonInterceptors));
            }
            <span class="hljs-keyword">else</span> {
                allInterceptors.addAll(Arrays.asList(commonInterceptors));
            }
        }
    }
    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
        <span class="hljs-keyword">int</span> nrOfCommonInterceptors = commonInterceptors.length;
        <span class="hljs-keyword">int</span> nrOfSpecificInterceptors = (specificInterceptors != <span class="hljs-keyword">null</span> ? specificInterceptors.length : <span class="hljs-number">0</span>);
        logger.trace(<span class="hljs-string">"Creating implicit proxy for bean '"</span> + beanName + <span class="hljs-string">"' with "</span> + nrOfCommonInterceptors +
                <span class="hljs-string">" common interceptors and "</span> + nrOfSpecificInterceptors + <span class="hljs-string">" specific interceptors"</span>);
    }

    <span class="hljs-comment">// 4.10.1.1 增强器对象转换为真正的Advisor增强器对象</span>
    Advisor[] advisors = <span class="hljs-keyword">new</span> Advisor[allInterceptors.size()];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; allInterceptors.size(); i++) {
        advisors[i] = <span class="hljs-keyword">this</span>.advisorAdapterRegistry.wrap(allInterceptors.get(i));
    }
    <span class="hljs-keyword">return</span> advisors;
}
</code></pre><p>这部分的思路也是比较简单的，它除了用参数传递过来的一组增强器，还会去找一些通用的拦截器作为增强器，最后组合在一起封装为一组 <code>Advisor</code> 增强器对象，返回出去。最前面获取到的通用拦截器，通过Debug发现压根就没有：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/18/16ddc84b617dc107~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>那相当于还是将参数中传入的两个增强器进行最下面的 <code>wrap</code> 操作。</p>
<h5 class="heading">4.10.1.1 advisorAdapterRegistry.wrap</h5>
<p>来到 <code>DefaultAdvisorAdapterRegistry</code> ：（注释已完全标注在源码中，不再附加文字解释。）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title">wrap</span><span class="hljs-params">(Object adviceObject)</span> <span class="hljs-keyword">throws</span> UnknownAdviceTypeException </span>{
    <span class="hljs-comment">// 如果要封装的对象本身就是Advisor类型，那无需处理，直接强转返回</span>
    <span class="hljs-keyword">if</span> (adviceObject <span class="hljs-keyword">instanceof</span> Advisor) {
        <span class="hljs-keyword">return</span> (Advisor) adviceObject;
    }
    <span class="hljs-comment">// 如果传入的对象不是Advisor，也不是Advice，那无法处理，要抛出异常</span>
    <span class="hljs-keyword">if</span> (!(adviceObject <span class="hljs-keyword">instanceof</span> Advice)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAdviceTypeException(adviceObject);
    }
    Advice advice = (Advice) adviceObject;
    <span class="hljs-comment">// MethodInterceptor类型的增强器，会使用DefaultPointcutAdvisor包装</span>
    <span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> MethodInterceptor) {
        <span class="hljs-comment">// So well-known it doesn't even need an adapter.</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultPointcutAdvisor(advice);
    }
    <span class="hljs-comment">// 如果传入的增强器可以被适配器适配，那也可以包装</span>
    <span class="hljs-keyword">for</span> (AdvisorAdapter adapter : <span class="hljs-keyword">this</span>.adapters) {
        <span class="hljs-comment">// Check that it is supported.</span>
        <span class="hljs-keyword">if</span> (adapter.supportsAdvice(advice)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultPointcutAdvisor(advice);
        }
    }
    <span class="hljs-comment">// 其他类型，无法处理，抛出异常</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAdviceTypeException(advice);
}
</code></pre><h4 class="heading">4.10.2 回到createProxy</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createProxy</span><span class="hljs-params">(Class&lt;?&gt; beanClass, @Nullable String beanName,
        @Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>{
    <span class="hljs-comment">// ......</span>

    <span class="hljs-comment">// 组合所有增强器</span>
    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
    <span class="hljs-comment">// 将增强器放入代理工厂</span>
    proxyFactory.addAdvisors(advisors);
    <span class="hljs-comment">// ......</span>

    <span class="hljs-comment">// 真正创建代理对象</span>
    <span class="hljs-keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());
}
</code></pre><p>一切准备就绪后，要真正创建代理对象了，调用 <code>proxyFactory.getProxy</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(@Nullable ClassLoader classLoader)</span> </span>{
    <span class="hljs-keyword">return</span> createAopProxy().getProxy(classLoader);
}
</code></pre><p>发现它分为两步，拆开来看。</p>
<h5 class="heading">4.10.2.1 createAopProxy</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.active) {
        activate();
    }
    <span class="hljs-keyword">return</span> getAopProxyFactory().createAopProxy(<span class="hljs-keyword">this</span>);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> AopProxyFactory <span class="hljs-title">getAopProxyFactory</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.aopProxyFactory;
}
</code></pre><p>这里面最后的 return 方法又分为两步，第一步只是取到当前类成员的 <code>aopProxyFactory</code> 方法，第二步是调 <code>ProxyFactory</code> 的 <code>createAopProxy</code> 方法。</p>
<h5 class="heading">4.10.2.2 DefaultAopProxyFactory#createAopProxy</h5>
<p>来到 <code>DefaultAopProxyFactory</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>{
    <span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
        Class&lt;?&gt; targetClass = config.getTargetClass();
        <span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">"TargetSource cannot determine target class: "</span> +
                    <span class="hljs-string">"Either an interface or a target is required for proxy creation."</span>);
        }
        <span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);
    }
}
</code></pre><p>源码中已经很明显的看到我们熟悉的东西：<strong>jdk动态代理</strong>，和<strong>cglib动态代理</strong>了。判断逻辑也很简单，跟我们之前学习两种代理方式的工作场景时一样：<strong>如果目标对象有接口，用jdk动态代理；没有接口，用cglib动态代理</strong>。</p>
<hr>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createProxy</span><span class="hljs-params">(Class&lt;?&gt; beanClass, @Nullable String beanName,
        @Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>{
    <span class="hljs-comment">// ......</span>
    <span class="hljs-comment">// 真正创建代理对象</span>
    <span class="hljs-keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());
}
</code></pre><p>创建好代理工厂，下一步就要创建真正的代理对象了。咱们以 jdk动态代理 为例，看一下它的创建原理：</p>
<h5 class="heading">4.10.2.3 [jdk] getProxy</h5>
<p>来到 <code>JdkDynamicAopProxy</code> 类：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(@Nullable ClassLoader classLoader)</span> </span>{
    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
        logger.trace(<span class="hljs-string">"Creating JDK dynamic proxy: "</span> + <span class="hljs-keyword">this</span>.advised.getTargetSource());
    }
    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="hljs-keyword">this</span>.advised, <span class="hljs-keyword">true</span>);
    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
    <span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="hljs-keyword">this</span>);
}
</code></pre><p>看最后一步：<strong><code>Proxy.newProxyInstance</code></strong> ，这是最底层的原理，也是我们一开始学动态代理时接触的方式。</p>
<p>【cglib动态代理在底层的实现实在是复杂而且通过Debug也无法找到根源，有兴趣的小伙伴可以Debug跟进一下看到底怎么回事（断点可打在CglibAopProxy的205行 [createProxyClassAndInstance]方法上面），这一步是创建代理对象，但里面走着走着就走丢了，莫名其妙的就创建好了（这就是操作字节码我们无法观察的地方了）】</p>
<h2 class="heading">一张图概括</h2>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/11/16e589479a787924~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<h2 class="heading">小结</h2>
<ol>
<li><code>AbstractAutoProxyCreator</code> 的 <code>postProcessBeforeInstantiation</code> 方法并没有创建代理对象，而是通过 <code>postProcessAfterInitialization</code> 创建。</li>
<li>AOP创建的核心方法在 <code>AbstractAutoProxyCreator</code> 的 <code>wrapIfNecessary</code> 方法。</li>
<li>AOP增强方法的核心是增强器，而增强器的创建在创建目标对象之前。</li>
</ol>
<p>【至此，目标对象已经被AOP代理，下一篇咱来看在jdk动态代理和cglib动态代理下，AOP底层的调用链机制】</p>
</div>
</body></html>