<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>AOP：jdk动态代理&Cglib的执行调用链</h1>
<h1 class="heading">20. AOP：jdk动态代理&amp;Cglib的执行调用链</h1>
<p>【接前章】</p>
<h2 class="heading">5. 目标方法执行的调用链</h2>
<p>经过代理之后的代理对象被放在IOC容器后，再调用目标方法，将会按照代理后的对象的调用链来执行。</p>
<h3 class="heading">5.1 jdk的invoke方法 - JdkDynamicAopProxy</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    Object oldProxy = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">boolean</span> setProxyContext = <span class="hljs-keyword">false</span>;

    TargetSource targetSource = <span class="hljs-keyword">this</span>.advised.targetSource;
    Object target = <span class="hljs-keyword">null</span>;

    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) {
            <span class="hljs-comment">// The target does not implement the equals(Object) method itself.</span>
            <span class="hljs-comment">// 不代理目标对象的equals(Object)方法</span>
            <span class="hljs-keyword">return</span> equals(args[<span class="hljs-number">0</span>]);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) {
            <span class="hljs-comment">// The target does not implement the hashCode() method itself.</span>
            <span class="hljs-comment">// 不代理目标对象的hashCode()方法</span>
            <span class="hljs-keyword">return</span> hashCode();
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) {
            <span class="hljs-comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span>
            <span class="hljs-comment">// 5.1.0 DecoratingProxy</span>
            <span class="hljs-keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="hljs-keyword">this</span>.advised);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;
                method.getDeclaringClass().isAssignableFrom(Advised.class)) {
            <span class="hljs-comment">// Service invocations on ProxyConfig with the proxy config...</span>
            <span class="hljs-comment">// 目标对象本身就是实现了Advised接口，也不代理（不当代理的代理，不当切面的切面）</span>
            <span class="hljs-keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="hljs-keyword">this</span>.advised, method, args);
        }

        Object retVal;

        <span class="hljs-comment">// 如果配置了代理对象可以暴露，这里会允许在线程内共享这个代理对象</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advised.exposeProxy) {
            <span class="hljs-comment">// Make invocation available if necessary.</span>
            oldProxy = AopContext.setCurrentProxy(proxy);
            setProxyContext = <span class="hljs-keyword">true</span>;
        }

        <span class="hljs-comment">// Get as late as possible to minimize the time we "own" the target,</span>
        <span class="hljs-comment">// in case it comes from a pool.</span>
        target = targetSource.getTarget();
        Class&lt;?&gt; targetClass = (target != <span class="hljs-keyword">null</span> ? target.getClass() : <span class="hljs-keyword">null</span>);

        <span class="hljs-comment">// Get the interception chain for this method.</span>
        <span class="hljs-comment">// 5.1.1 获取当前方法需要织入的切面逻辑的调用链</span>
        List&lt;Object&gt; chain = <span class="hljs-keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

        <span class="hljs-comment">// Check whether we have any advice. If we don't, we can fallback on direct</span>
        <span class="hljs-comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span>
        <span class="hljs-keyword">if</span> (chain.isEmpty()) {
            <span class="hljs-comment">// We can skip creating a MethodInvocation: just invoke the target directly</span>
            <span class="hljs-comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span>
            <span class="hljs-comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span>
            <span class="hljs-comment">// 调用链为空，直接执行目标方法</span>
            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// We need to create a method invocation...</span>
            <span class="hljs-comment">// 5.1.2 获取目标对象的调用链逻辑，并且对该增强器链进行调用</span>
            MethodInvocation invocation =
                    <span class="hljs-keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
            <span class="hljs-comment">// Proceed to the joinpoint through the interceptor chain.</span>
            retVal = invocation.proceed();
        }

        <span class="hljs-comment">// Massage return value if necessary.</span>
        Class&lt;?&gt; returnType = method.getReturnType();
        <span class="hljs-comment">// 如果返回值是目标对象本身，并且要执行的目标方法的返回值是代理对象的类型，则返回代理对象本身</span>
        <span class="hljs-comment">// 简言之，如果返回值的类型是目标对象所属类，就把代理对象返回出去</span>
        <span class="hljs-keyword">if</span> (retVal != <span class="hljs-keyword">null</span> &amp;&amp; retVal == target &amp;&amp;
                returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;
                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
            <span class="hljs-comment">// Special case: it returned "this" and the return type of the method</span>
            <span class="hljs-comment">// is type-compatible. Note that we can't help if the target sets</span>
            <span class="hljs-comment">// a reference to itself in another returned object.</span>
            retVal = proxy;
        }
        <span class="hljs-comment">// 如果返回值满足其为空，不是Void类型，并且是基本数据类型，则抛出异常（基本数据类型的返回值不可能为空）</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retVal == <span class="hljs-keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopInvocationException(
                    <span class="hljs-string">"Null return value from advice does not match primitive return type for: "</span> + method);
        }
        <span class="hljs-keyword">return</span> retVal;
    }
    <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; !targetSource.isStatic()) {
            <span class="hljs-comment">// Must have come from TargetSource.</span>
            targetSource.releaseTarget(target);
        }
        <span class="hljs-keyword">if</span> (setProxyContext) {
            <span class="hljs-comment">// Restore old proxy.</span>
            AopContext.setCurrentProxy(oldProxy);
        }
    }
}
</code></pre><p>源码中前面的一组if-else if中出现了一个很陌生的概念：<code>DecoratingProxy</code> 。为了研究它，我们要先回到上一篇的最后部分，来看看 <code>getProxy</code> 方法还有什么名堂。</p>
<h4 class="heading">5.1.0 getProxy与DecoratingProxy</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(@Nullable ClassLoader classLoader)</span> </span>{
    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
        logger.trace(<span class="hljs-string">"Creating JDK dynamic proxy: "</span> + <span class="hljs-keyword">this</span>.advised.getTargetSource());
    }
    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="hljs-keyword">this</span>.advised, <span class="hljs-keyword">true</span>);
    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
    <span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="hljs-keyword">this</span>);
}
</code></pre><p>除了最后一句话我们很熟悉以外，注意倒数第三行，它获取了一组 <code>proxiedInterfaces</code> ，通过Debug发现它除了目标对象实现的接口以外，还有3个新的接口：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/18/16ddcff6fd22893c~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>里面发现了上面咱看到的那个陌生的 <code>DecoratingProxy</code> 接口。咱先来研究研究这三个新的接口都是什么吧。</p>
<h5 class="heading">5.1.0.1 SpringProxy</h5>
<p>文档注释原文翻译：</p>
<blockquote>
<p>Marker interface implemented by all AOP proxies. Used to detect whether or not objects are Spring-generated proxies.</p>
<p>由所有AOP代理实现的标记接口。用于检测对象是否是Spring生成的代理。</p>
</blockquote>
<p>很简单，用它来标记这是SpringAOP生成的代理对象。</p>
<h5 class="heading">5.1.0.2 Advised</h5>
<p>文档注释原文翻译：</p>
<blockquote>
<p>Interface to be implemented by classes that hold the configuration of a factory of AOP proxies. This configuration includes the Interceptors and other advice, Advisors, and the proxied interfaces.
Any AOP proxy obtained from Spring can be cast to this interface to allow manipulation of its AOP advice.</p>
<p>由包含AOP代理工厂配置的类实现的接口。此配置包括拦截器和其他通知，增强器以及代理接口。</p>
<p>从Spring获得的任何AOP代理都可以转换为该接口，以允许对其AOP通知进行操作。</p>
</blockquote>
<p>注释中描述的意思大概可以这样理解：它封装了生成代理对象所需要的所有信息，包括拦截器、通知、增强器等。</p>
<h5 class="heading">5.1.0.3 DecoratingProxy</h5>
<p>文档注释原文翻译：</p>
<blockquote>
<p>Interface to be implemented by decorating proxies, in particular Spring AOP proxies but potentially also custom proxies with decorator semantics.
Note that this interface should just be implemented if the decorated class is not within the hierarchy of the proxy class to begin with. In particular, a "target-class" proxy such as a Spring AOP CGLIB proxy should not implement it since any lookup on the target class can simply be performed on the proxy class there anyway.</p>
<p>通过装饰代理（尤其是Spring的AOP代理）实现的接口，但也可能具有装饰器语义的自定义代理。</p>
<p>请注意，仅当装饰的类不在代理类的层次结构中时才应实现此接口。特别是，诸如SpringAOP的CGLIB代理之类的“目标类”代理不应该实现它，因为无论如何都可以在该代理类上简单地对目标类进行任何查找。</p>
</blockquote>
<p>这段文档注释不是很好理解，咱来看看接口中的定义：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecoratingProxy</span> </span>{

	<span class="hljs-comment">// 返回当前代理对象的目标对象的Class类型</span>
	Class&lt;?&gt; getDecoratedClass();

}
</code></pre><p>看到这个方法，这下可以很容易理解了，实现了这个接口，可以保证能从代理对象中很方便的取到目标对象的所属类。</p>
<p>知道了这三个接口的意义，那回到那段if-else中：</p>
<pre><code class="hljs java" lang="java">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) {
            <span class="hljs-comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span>
            <span class="hljs-keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="hljs-keyword">this</span>.advised);
        }
</code></pre><p>自然就可以看懂了：如果当前方法是Spring织入的 <code>DecoratingProxy</code> 接口中的方法，则返回目标对象的Class类型。</p>
<hr>
<h4 class="heading">5.1.1 获取增强器调用链</h4>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Get the interception chain for this method.</span>
    <span class="hljs-comment">// 获取当前方法需要织入的切面逻辑的调用链</span>
    List&lt;Object&gt; chain = <span class="hljs-keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
</code></pre><p>进入到 <code>AdvisedSupport</code> 中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>{
    MethodCacheKey cacheKey = <span class="hljs-keyword">new</span> MethodCacheKey(method);
    List&lt;Object&gt; cached = <span class="hljs-keyword">this</span>.methodCache.get(cacheKey);
    <span class="hljs-keyword">if</span> (cached == <span class="hljs-keyword">null</span>) {
        cached = <span class="hljs-keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(
                <span class="hljs-keyword">this</span>, method, targetClass);
        <span class="hljs-keyword">this</span>.methodCache.put(cacheKey, cached);
    }
    <span class="hljs-keyword">return</span> cached;
}
</code></pre><p>这里面的核心方法是if结构中的 <code>advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// DefaultAdvisorChainFactory</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(
        Advised config, Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>{

    <span class="hljs-comment">// This is somewhat tricky... We have to process introductions first,</span>
    <span class="hljs-comment">// but we need to preserve order in the ultimate list.</span>
    <span class="hljs-comment">// 增强器适配器注册器，它会根据增强器来解析，返回拦截器数组</span>
    AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();
    Advisor[] advisors = config.getAdvisors();
    List&lt;Object&gt; interceptorList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(advisors.length);
    Class&lt;?&gt; actualClass = (targetClass != <span class="hljs-keyword">null</span> ? targetClass : method.getDeclaringClass());
    Boolean hasIntroductions = <span class="hljs-keyword">null</span>;

    <span class="hljs-keyword">for</span> (Advisor advisor : advisors) {
        <span class="hljs-comment">// PointcutAdvisor 就是在@Aspect标注的切面类中声明的那些通知方法的封装</span>
        <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> PointcutAdvisor) {
            <span class="hljs-comment">// Add it conditionally.</span>
            PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;
            <span class="hljs-keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {
                MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();
                <span class="hljs-keyword">boolean</span> match;
                <span class="hljs-keyword">if</span> (mm <span class="hljs-keyword">instanceof</span> IntroductionAwareMethodMatcher) {
                    <span class="hljs-keyword">if</span> (hasIntroductions == <span class="hljs-keyword">null</span>) {
                        hasIntroductions = hasMatchingIntroductions(advisors, actualClass);
                    }
                    match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);
                }
                <span class="hljs-keyword">else</span> {
                    match = mm.matches(method, actualClass);
                }
                <span class="hljs-keyword">if</span> (match) {
                    <span class="hljs-comment">// 5.1.1.1 适配器根据增强器来获取方法拦截器列表</span>
                    MethodInterceptor[] interceptors = registry.getInterceptors(advisor);
                    <span class="hljs-keyword">if</span> (mm.isRuntime()) {
                        <span class="hljs-comment">// Creating a new object instance in the getInterceptors() method</span>
                        <span class="hljs-comment">// isn't a problem as we normally cache created chains.</span>
                        <span class="hljs-keyword">for</span> (MethodInterceptor interceptor : interceptors) {
                            interceptorList.add(<span class="hljs-keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));
                        }
                    }
                    <span class="hljs-keyword">else</span> {
                        interceptorList.addAll(Arrays.asList(interceptors));
                    }
                }
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) {
            IntroductionAdvisor ia = (IntroductionAdvisor) advisor;
            <span class="hljs-keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {
                Interceptor[] interceptors = registry.getInterceptors(advisor);
                interceptorList.addAll(Arrays.asList(interceptors));
            }
        }
        <span class="hljs-keyword">else</span> {
            Interceptor[] interceptors = registry.getInterceptors(advisor);
            interceptorList.addAll(Arrays.asList(interceptors));
        }
    }

    <span class="hljs-keyword">return</span> interceptorList;
}
</code></pre><p>源码部分可以简单概括成几步：</p>
<ol>
<li>获取全局增强器适配器。</li>
<li>遍历所有增强器，如果增强器的类型是 <code>PointcutAdvisor</code> ，并且能匹配这个切入点，则拿适配器去解析增强器，返回一组方法拦截器，添加到拦截器列表中。</li>
<li>如果类型是引入类型、其他类型，同样最终添加到拦截器列表中。</li>
</ol>
<p>其中 <code>PointcutAdvisor</code> 类型要转换为 <code>MethodInterceptor</code> 类型，需要借助适配器，调用 <code>registry.getInterceptors</code> 方法。</p>
<h5 class="heading">5.1.1.1 registry.getInterceptors</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> MethodInterceptor[] getInterceptors(Advisor advisor) <span class="hljs-keyword">throws</span> UnknownAdviceTypeException {
    List&lt;MethodInterceptor&gt; interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">3</span>);
    Advice advice = advisor.getAdvice();
    <span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> MethodInterceptor) {
        interceptors.add((MethodInterceptor) advice);
    }
    <span class="hljs-keyword">for</span> (AdvisorAdapter adapter : <span class="hljs-keyword">this</span>.adapters) {
        <span class="hljs-keyword">if</span> (adapter.supportsAdvice(advice)) {
            interceptors.add(adapter.getInterceptor(advisor));
        }
    }
    <span class="hljs-keyword">if</span> (interceptors.isEmpty()) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAdviceTypeException(advisor.getAdvice());
    }
    <span class="hljs-keyword">return</span> interceptors.toArray(<span class="hljs-keyword">new</span> MethodInterceptor[<span class="hljs-number">0</span>]);
}
</code></pre><p>源码逻辑也比较简单，通知本身就是 <code>MethodInterceptor</code> 对象时，不需要转换；如果通知能被 <code>AdvisorAdapter</code> 适配，也可以添加进去。</p>
<h4 class="heading">5.1.2 核心调用逻辑</h4>
<p>方法拦截器都获取好了，下面来看核心的增强器链的调用逻辑：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// We need to create a method invocation...</span>
    <span class="hljs-comment">// 获取目标对象的调用链逻辑，并且对该增强器链进行调用</span>
    MethodInvocation invocation =
            <span class="hljs-keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
    <span class="hljs-comment">// Proceed to the joinpoint through the interceptor chain.</span>
    retVal = invocation.proceed();
</code></pre><p>进入到 <code>ReflectiveMethodInvocation</code> 的 <code>proceed</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    <span class="hljs-comment">// We start with an index of -1 and increment early.</span>
    <span class="hljs-comment">// 拦截器链全部调用完，再调用目标方法</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentInterceptorIndex == <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> invokeJoinpoint();
    }

    <span class="hljs-comment">// 增加计数器，得到下一个通知或者拦截器</span>
    Object interceptorOrInterceptionAdvice =
            <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="hljs-keyword">this</span>.currentInterceptorIndex);
    <span class="hljs-keyword">if</span> (interceptorOrInterceptionAdvice <span class="hljs-keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) {
        <span class="hljs-comment">// Evaluate dynamic method matcher here: static part will already have</span>
        <span class="hljs-comment">// been evaluated and found to match.</span>
        InterceptorAndDynamicMethodMatcher dm =
                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
        Class&lt;?&gt; targetClass = (<span class="hljs-keyword">this</span>.targetClass != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.targetClass : <span class="hljs-keyword">this</span>.method.getDeclaringClass());
        <span class="hljs-keyword">if</span> (dm.methodMatcher.matches(<span class="hljs-keyword">this</span>.method, targetClass, <span class="hljs-keyword">this</span>.arguments)) {
            <span class="hljs-keyword">return</span> dm.interceptor.invoke(<span class="hljs-keyword">this</span>);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Dynamic matching failed.</span>
            <span class="hljs-comment">// Skip this interceptor and invoke the next in the chain.</span>
            <span class="hljs-keyword">return</span> proceed();
        }
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// It's an interceptor, so we just invoke it: The pointcut will have</span>
        <span class="hljs-comment">// been evaluated statically before this object was constructed.</span>
        <span class="hljs-comment">// 调用拦截器的方法</span>
        <span class="hljs-keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="hljs-keyword">this</span>);
    }
}
</code></pre><p>这段方法看上去逻辑有点复杂但又不太复杂。它提到了一个计数器的概念，用于记录当前拦截器链中调用的位置，以便拦截器链中的拦截器可以有序地调用。</p>
<p>咱们来通过一个实例尝试模拟一下：</p>
<h5 class="heading">5.1.2.1 proceed方法进入</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentInterceptorIndex == <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> invokeJoinpoint();
    }
</code></pre><p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/18/16ddcff88ccb45d3~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>此时 <code>-1 ≠ (2 -1)</code> ，不进入 <code>invokeJoinpoint</code> 方法。</p>
<h5 class="heading">5.1.2.2 下标索引值++</h5>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentInterceptorIndex == <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> invokeJoinpoint();
    }

    Object interceptorOrInterceptionAdvice =
            <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="hljs-keyword">this</span>.currentInterceptorIndex);
    <span class="hljs-keyword">if</span> (interceptorOrInterceptionAdvice <span class="hljs-keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) {
</code></pre><p>中间的代码中有对 <code>currentInterceptorIndex</code> 的+1操作，此时 <code>currentInterceptorIndex = 0</code> 。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/18/16ddcff9e16f12a1~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<h5 class="heading">5.1.2.3 下面的if判断</h5>
<p>看上图，此时取出的拦截器是 <code>ExposeInvocationInterceptor</code> ，而它的类定义：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExposeInvocationInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">PriorityOrdered</span>, <span class="hljs-title">Serializable</span>
</span></code></pre><p>很明显它不是 <code>InterceptorAndDynamicMethodMatcher</code> ，跳过，进入else结构：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="hljs-keyword">this</span>);
    }
</code></pre><p>它要执行当前的这个拦截器：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// ExposeInvocationInterceptor</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    MethodInvocation oldInvocation = invocation.get();
    invocation.set(mi);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> mi.proceed();
    }
    <span class="hljs-keyword">finally</span> {
        invocation.set(oldInvocation);
    }
}
</code></pre><p>执行方法之后，进入try块，继续执行 <code>MethodInvocation</code> 的 <code>proceed</code> 方法。</p>
<h5 class="heading">5.1.2.4 回到proceed方法</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentInterceptorIndex == <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> invokeJoinpoint();
    }
</code></pre><p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/18/16ddcffb645c8bb9~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>此时 <code>0 ≠ (2 -1)</code> ，不进入 <code>invokeJoinpoint</code> 方法。</p>
<h5 class="heading">5.1.2.5 下标索引值++</h5>
<pre><code class="hljs java" lang="java">    Object interceptorOrInterceptionAdvice =
            <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="hljs-keyword">this</span>.currentInterceptorIndex);
    <span class="hljs-keyword">if</span> (interceptorOrInterceptionAdvice <span class="hljs-keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) {
</code></pre><p>如前面一样的操作，又对 <code>currentInterceptorIndex</code> 进行+1操作后，此时 <code>currentInterceptorIndex = 1</code> 。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/18/16ddcffd27309668~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<h5 class="heading">5.1.2.6 下面的if判断</h5>
<p>看上图，此时取出的拦截器是 <code>MethodBeforeAdviceInterceptor</code> ，而它的类定义：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodBeforeAdviceInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">BeforeAdvice</span>, <span class="hljs-title">Serializable</span>
</span></code></pre><p>很明显它也不是 <code>InterceptorAndDynamicMethodMatcher</code> ，跳过，进入else结构：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="hljs-keyword">this</span>);
    }
</code></pre><p>它要执行当前的这个拦截器：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// MethodBeforeAdviceInterceptor</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    <span class="hljs-keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
    <span class="hljs-keyword">return</span> mi.proceed();
}
</code></pre><p>执行方法之后，进入try块，继续执行 <code>MethodInvocation</code> 的 <code>proceed</code> 方法。</p>
<h5 class="heading">5.1.2.7 又回到proceed方法</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentInterceptorIndex == <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> invokeJoinpoint();
    }
</code></pre><p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/18/16ddcffec0a7f849~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>此时 <code>1 = 1</code> ，进入 <code>invokeJoinpoint</code> 方法：</p>
<h5 class="heading">5.1.2.8 执行目标对象的切入点</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">invokeJoinpoint</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    <span class="hljs-keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="hljs-keyword">this</span>.target, <span class="hljs-keyword">this</span>.method, <span class="hljs-keyword">this</span>.arguments);
}
</code></pre><p>它利用AOP的工具类，来反射执行切入点方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">invokeJoinpointUsingReflection</span><span class="hljs-params">(@Nullable Object target, Method method, Object[] args)</span>
        <span class="hljs-keyword">throws</span> Throwable </span>{

    <span class="hljs-comment">// Use reflection to invoke the method.</span>
    <span class="hljs-keyword">try</span> {
        ReflectionUtils.makeAccessible(method);
        <span class="hljs-keyword">return</span> method.invoke(target, args);
    }
    <span class="hljs-comment">// catch ...</span>
}
</code></pre><h5 class="heading">5.1.2.9 执行切入点</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IService</span> </span>{
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"test run..."</span>);
    }
    
}
</code></pre><p>此时才真正的执行test方法。</p>
<p>好了走完这个全程，由此我们可以得出算法逻辑：</p>
<p><strong>利用一个全局索引值，决定每次执行的拦截器，当所有拦截器都执行完时，索引值刚好等于 <code>size() - 1</code>，此时就可以执行真正的目标方法了</strong> 。</p>
<p>最后用一张图来更好地理解这段逻辑：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/11/16e5911707f0fb6b~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<hr>
<p>以上就是jdk动态代理的全部内容，下面咱再来看cglib的调用链原理：</p>
<h3 class="heading">5.2 cglib的intercept方法 - CglibAopProxy.DynamicAdvisedInterceptor</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Nullable</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    Object oldProxy = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">boolean</span> setProxyContext = <span class="hljs-keyword">false</span>;
    Object target = <span class="hljs-keyword">null</span>;
    TargetSource targetSource = <span class="hljs-keyword">this</span>.advised.getTargetSource();
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advised.exposeProxy) {
            <span class="hljs-comment">// Make invocation available if necessary.</span>
            oldProxy = AopContext.setCurrentProxy(proxy);
            setProxyContext = <span class="hljs-keyword">true</span>;
        }
        <span class="hljs-comment">// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...</span>
        target = targetSource.getTarget();
        Class&lt;?&gt; targetClass = (target != <span class="hljs-keyword">null</span> ? target.getClass() : <span class="hljs-keyword">null</span>);
        <span class="hljs-comment">// 获取当前方法需要织入的切面逻辑的调用链（与jdk动态代理一致）</span>
        List&lt;Object&gt; chain = <span class="hljs-keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
        Object retVal;
        <span class="hljs-comment">// Check whether we only have one InvokerInterceptor: that is,</span>
        <span class="hljs-comment">// no real advice, but just reflective invocation of the target.</span>
        <span class="hljs-keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) {
            <span class="hljs-comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span>
            <span class="hljs-comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span>
            <span class="hljs-comment">// it does nothing but a reflective operation on the target, and no hot</span>
            <span class="hljs-comment">// swapping or fancy proxying.</span>
            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
            retVal = methodProxy.invoke(target, argsToUse);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// We need to create a method invocation...</span>
            <span class="hljs-comment">// 5.2.1 创建CglibMethodInvocation，执行目标方法代理</span>
            retVal = <span class="hljs-keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();
        }
        retVal = processReturnType(proxy, target, method, retVal);
        <span class="hljs-keyword">return</span> retVal;
    }
    <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; !targetSource.isStatic()) {
            targetSource.releaseTarget(target);
        }
        <span class="hljs-keyword">if</span> (setProxyContext) {
            <span class="hljs-comment">// Restore old proxy.</span>
            AopContext.setCurrentProxy(oldProxy);
        }
    }
}
</code></pre><p>发现执行逻辑与jdk动态代理几乎完全一致，核心原理和使用的类也一致，不再赘述，小伙伴们可自行编写测试Demo来实际Debug一圈，体会AOP的执行机制。</p>
<h3 class="heading">5.3 Aspect中的四种通知在源码中的实现</h3>
<h4 class="heading">5.3.1 @Before</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodBeforeAdviceInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">Serializable</span> </span>{
	<span class="hljs-keyword">private</span> MethodBeforeAdvice advice;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
		<span class="hljs-keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );
		<span class="hljs-keyword">return</span> mi.proceed();
	}

}
</code></pre><p>先执行前置通知，再执行目标方法。</p>
<h4 class="heading">5.3.2 @After</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectJAfterAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAspectJAdvice</span>
		<span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">AfterAdvice</span>, <span class="hljs-title">Serializable</span> </span>{

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">return</span> mi.proceed();
		}
		<span class="hljs-keyword">finally</span> {
			invokeAdviceMethod(getJoinPointMatch(), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
		}
	}
}
</code></pre><p>执行目标方法后，在finally中执行后置方法。</p>
<h4 class="heading">5.3.3 @AfterReturning</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterReturningAdviceInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">AfterAdvice</span>, <span class="hljs-title">Serializable</span> </span>{
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AfterReturningAdvice advice;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
		Object retVal = mi.proceed();
		<span class="hljs-keyword">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());
		<span class="hljs-keyword">return</span> retVal;
	}

}
</code></pre><p>返回值后置处理中不设置try-catch，说明不出现任何异常时才会触发该后置通知。</p>
<h4 class="heading">5.3.4 @AfterThrowing</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectJAfterThrowingAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAspectJAdvice</span>
		<span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">AfterAdvice</span>, <span class="hljs-title">Serializable</span> </span>{

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">return</span> mi.proceed();
		}
		<span class="hljs-keyword">catch</span> (Throwable ex) {
			<span class="hljs-keyword">if</span> (shouldInvokeOnThrowing(ex)) {
				invokeAdviceMethod(getJoinPointMatch(), <span class="hljs-keyword">null</span>, ex);
			}
			<span class="hljs-keyword">throw</span> ex;
		}
	}
}
</code></pre><p>出现异常时，进入该后置通知，因为设置了try-catch，所以这里catch中根据是否标注了异常通知，进行相应的后置处理。</p>
<h2 class="heading">小结</h2>
<ol>
<li>jdk动态代理借助接口实现，并且在创建代理对象之前还注入了额外的接口。</li>
<li>cglib动态代理的实现机制与jdk动态代理几乎完全一致。</li>
<li>两种动态代理的核心思想都是获取增强器调用链，然后链式执行增强器（拦截器）。</li>
<li>执行拦截器链时，为保证拦截器链能有序执行，会引入下标索引机制。</li>
</ol>
<p>【至此，AOP的核心部分已经解析完毕。接下来咱来看一个AOP的最经典应用：Spring事务控制。通过了解Spring的事务控制机制，可以更深入的了解AOP，以及事务的控制原理】</p>
</div>
</body></html>