<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>WebMvc：DispatcherServlet的工作原理</h1>
<h1 class="heading">26. WebMvc：DispatcherServlet的工作原理</h1>
<p>这一篇的内容算是面试中可能比较经常问的基础吧，<code>DispatcherServlet</code> 的工作流程步骤简直跟背圣经一样，背的熟不如来源码底层一探究竟。</p>
<h2 class="heading">0. DispatcherServlet工作流程步骤</h2>
<ol>
<li>浏览器向服务器发起请求，由 <code>DispatcherServlet</code> 接收请求；</li>
<li><code>DispatcherServlet</code> 委托 <code>HandlerMapping</code>，根据 url 来选择一个合适的 Controller 中的方法；</li>
<li><code>HandlerMapping</code> 找到合适的 Controller 后，并根据已配置的拦截器，整理出一个 Handler，返回给 <code>DispatcherServlet</code>；</li>
<li><code>DispatcherServlet</code> 收到 Handler 后委托 <code>HandlerAdapter</code>，将该请求代理给 <code>HandlerMapping</code> 选定的 Controller 中的 Handler；</li>
<li>Handler 收到请求后，实际执行 Controller 中的方法，执行完毕后会返回 ModelAndView；</li>
<li>Controller 方法执行完毕后会返回 <code>ModelAndView</code>；</li>
<li><code>HandlerAdapter</code> 收到 Handler 返回的 <code>ModelAndView</code> 后返回给 <code>DispatcherServlet</code>；</li>
<li><code>DispatcherServlet</code> 拿到 <code>ModelAndView</code> 后委托 <code>ViewResolver</code>，由 <code>ViewResolver</code> 负责渲染视图；</li>
<li><code>ViewResolver</code> 渲染视图完成后，返回给 <code>DispatcherServlet</code>，由 <code>DispatcherServlet</code> 负责响应视图。</li>
</ol>
<p>下面来根据一个测试Demo来实际Debug演示 <code>DispatcherServlet</code> 的工作流程机制（为保证视图能正常渲染，demo中附加导入了 <strong>thymeleaf</strong> 的依赖）。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>{
    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/test"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"test"</span>;
    }
}
</code></pre><p>这是一个再简单不过的 Controller 类了。Debug启动 SpringBoot 应用，浏览器发送 <code>/test</code> 请求，并在 <code>DispatcherServlet</code> 的 <code>service</code> 方法（实际上是 <strong><code>HttpServlet</code></strong>）打断点开始Debug。</p>
<h2 class="heading">1. HttpServlet#service</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span>
    <span class="hljs-keyword">throws</span> ServletException, IOException </span>{

    HttpServletRequest  request;
    HttpServletResponse response;

    <span class="hljs-keyword">try</span> {
        request = (HttpServletRequest) req;
        response = (HttpServletResponse) res;
    } <span class="hljs-keyword">catch</span> (ClassCastException e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(lStrings.getString(<span class="hljs-string">"http.non_http"</span>));
    }
    service(request, response);
}
</code></pre><p>这部分很简单，相当于把请求类型转为http，后调用重载的方法。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span>
    <span class="hljs-keyword">throws</span> ServletException, IOException </span>{

    String method = req.getMethod();

    <span class="hljs-keyword">if</span> (method.equals(METHOD_GET)) {
        <span class="hljs-keyword">long</span> lastModified = getLastModified(req);
        <span class="hljs-keyword">if</span> (lastModified == -<span class="hljs-number">1</span>) {
            <span class="hljs-comment">// servlet doesn't support if-modified-since, no reason</span>
            <span class="hljs-comment">// to go through further expensive logic</span>
            doGet(req, resp);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">long</span> ifModifiedSince;
            <span class="hljs-keyword">try</span> {
                ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
            } <span class="hljs-keyword">catch</span> (IllegalArgumentException iae) {
                <span class="hljs-comment">// Invalid date header - proceed as if none was set</span>
                ifModifiedSince = -<span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>)) {
                <span class="hljs-comment">// If the servlet mod time is later, call doGet()</span>
                <span class="hljs-comment">// Round down to the nearest second for a proper compare</span>
                <span class="hljs-comment">// A ifModifiedSince of -1 will always be less</span>
                maybeSetLastModified(resp, lastModified);
                doGet(req, resp);
            } <span class="hljs-keyword">else</span> {
                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
            }
        }

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_HEAD)) {
        <span class="hljs-keyword">long</span> lastModified = getLastModified(req);
        maybeSetLastModified(resp, lastModified);
        doHead(req, resp);

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_POST)) {
        doPost(req, resp);

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_PUT)) {
        doPut(req, resp);

    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_DELETE)) {
        doDelete(req, resp);

    } <span class="hljs-comment">// ......</span>
}
</code></pre><p>这还是属于 <code>HttpServlet</code> 的源码，它会根据请求类型来转发请求，由于 <code>HttpServlet</code> 采用模板方法模式，而模板方法是在 <code>DispatcherServlet</code> 中实现，上面的测试Demo选用GET方式，最终来到 <code>doGet</code> 方法。</p>
<h2 class="heading">2. doGet</h2>
<p>来到 <code>DispatcherServlet</code> 的父类 <code>FrameworkServlet</code> ，发现 <code>doGet</code> 、<code>doPost</code> 等方法的方法体都只有一句话：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span>
        <span class="hljs-keyword">throws</span> ServletException, IOException </span>{
    processRequest(request, response);
}

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span>
        <span class="hljs-keyword">throws</span> ServletException, IOException </span>{
    processRequest(request, response);
}
</code></pre><p>发现核心方法都是 <code>processRequest</code> ，那就去这个方法：</p>
<h2 class="heading">3. processRequest</h2>
<p>（关键步骤的注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span>
        <span class="hljs-keyword">throws</span> ServletException, IOException </span>{

    <span class="hljs-comment">// 记录请求接收时间</span>
    <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();
    Throwable failureCause = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">// 3.1 得到当前线程的LocaleContext</span>
    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
    LocaleContext localeContext = buildLocaleContext(request);

    <span class="hljs-comment">// 3.2 得到当前线程的RequestAttributes</span>
    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="hljs-keyword">new</span> RequestBindingInterceptor());

    <span class="hljs-comment">// 3.3 初始化ContextHolder，传入新封装好的请求参数和上下文，目的是线程隔离</span>
    initContextHolders(request, localeContext, requestAttributes);

    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 4. 进入DispatcherServlet</span>
        doService(request, response);
    }
    <span class="hljs-keyword">catch</span> (ServletException | IOException ex) {
        failureCause = ex;
        <span class="hljs-keyword">throw</span> ex;
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        failureCause = ex;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Request processing failed"</span>, ex);
    }

    <span class="hljs-keyword">finally</span> {
        <span class="hljs-comment">// 重新获得当前线程的LocaleContext和RequestAttributes</span>
        resetContextHolders(request, previousLocaleContext, previousAttributes);
        <span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-keyword">null</span>) {
            requestAttributes.requestCompleted();
        }
        logResult(request, response, failureCause, asyncManager);
        <span class="hljs-comment">// 发布ServletRequestHandledEvent事件</span>
        publishRequestHandledEvent(request, response, startTime, failureCause);
    }
}
</code></pre><p>咱以try-catch块为分界，前面的部分是隔离当前线程，最后的finally块又是恢复当前线程，由此可以发现 SpringWebMvc 在处理之前已经做好了<strong>线程隔离</strong>。</p>
<p>中间的 <code>doService</code> 方法，就是真正处理请求的部分。</p>
<p>【由此可以发现一个 SpringWebMvc 的设计思想：<strong>父类把处理流程抽象化，子类负责每个流程的具体实现</strong>】</p>
<p>上面源码中有几个标注的部分，简单看一眼都是怎么隔离线程的：</p>
<h3 class="heading">3.1 LocaleContextHolder.getLocaleContext</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;LocaleContext&gt; localeContextHolder = <span class="hljs-keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="hljs-string">"LocaleContext"</span>);

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocaleContext <span class="hljs-title">getLocaleContext</span><span class="hljs-params">()</span> </span>{
    LocaleContext localeContext = localeContextHolder.get();
    <span class="hljs-keyword">if</span> (localeContext == <span class="hljs-keyword">null</span>) {
        localeContext = inheritableLocaleContextHolder.get();
    }
    <span class="hljs-keyword">return</span> localeContext;
}
</code></pre><p>可以发现 <code>localeContextHolder</code> 是 <code>ThreadLocal</code> 类型，是取的当前线程。</p>
<h3 class="heading">3.2 RequestContextHolder.getRequestAttributes</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder = <span class="hljs-keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="hljs-string">"Request attributes"</span>);

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestAttributes <span class="hljs-title">getRequestAttributes</span><span class="hljs-params">()</span> </span>{
    RequestAttributes attributes = requestAttributesHolder.get();
    <span class="hljs-keyword">if</span> (attributes == <span class="hljs-keyword">null</span>) {
        attributes = inheritableRequestAttributesHolder.get();
    }
    <span class="hljs-keyword">return</span> attributes;
}
</code></pre><p><code>requestAttributesHolder</code> 也是 <code>ThreadLocal</code> 类型，它也是取的当前线程。</p>
<h3 class="heading">3.3 initContextHolders</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initContextHolders</span><span class="hljs-params">(HttpServletRequest request,
        @Nullable LocaleContext localeContext, @Nullable RequestAttributes requestAttributes)</span> </span>{

    <span class="hljs-keyword">if</span> (localeContext != <span class="hljs-keyword">null</span>) {
        LocaleContextHolder.setLocaleContext(localeContext, <span class="hljs-keyword">this</span>.threadContextInheritable);
    }
    <span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-keyword">null</span>) {
        RequestContextHolder.setRequestAttributes(requestAttributes, <span class="hljs-keyword">this</span>.threadContextInheritable);
    }
}
</code></pre><p>可以发现这里面是将新的 <code>localeContext</code> 、<code>requestAttributes</code> 设置到当前线程，原有线程中的对象被暂时缓存在 <code>processRequest</code> 方法中。</p>
<hr>
<p>下面进入 <code>DispatcherServlet</code> 的核心：<strong><code>doService</code></strong> 方法。</p>
<h2 class="heading">4. doService</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    logRequest(request);

    <span class="hljs-comment">// Keep a snapshot of the request attributes in case of an include,</span>
    <span class="hljs-comment">// to be able to restore the original attributes after the include.</span>
    Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">// 4.1 判断请求参数中是否存在javax.servlet.include.request_uri</span>
    <span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) {
        attributesSnapshot = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();
        <span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) {
            String attrName = (String) attrNames.nextElement();
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {
                attributesSnapshot.put(attrName, request.getAttribute(attrName));
            }
        }
    }

    <span class="hljs-comment">// Make framework objects available to handlers and view objects.</span>
    <span class="hljs-comment">// 将IOC容器及特定组件放入request供开发使用</span>
    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.localeResolver);
    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.themeResolver);
    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

    <span class="hljs-comment">// 4.2 flashMapManager</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flashMapManager != <span class="hljs-keyword">null</span>) {
        FlashMap inputFlashMap = <span class="hljs-keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);
        <span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-keyword">null</span>) {
            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
        }
        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> FlashMap());
        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-keyword">this</span>.flashMapManager);
    }

    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 5. doDispatch</span>
        doDispatch(request, response);
    }
    <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
            <span class="hljs-comment">// Restore the original attribute snapshot, in case of an include.</span>
            <span class="hljs-keyword">if</span> (attributesSnapshot != <span class="hljs-keyword">null</span>) {
                restoreAttributesAfterInclude(request, attributesSnapshot);
            }
        }
    }
}
</code></pre><p><code>doService</code> 方法中的核心是try-catch中继续往 DispatcherServlet 最核心的方法中调用，但调用之前它又额外干了几件事，咱一一来看。</p>
<h3 class="heading">4.1 WebUtils.isIncludeRequest</h3>
<p>这个方法的内容我们比较陌生：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String INCLUDE_REQUEST_URI_ATTRIBUTE = <span class="hljs-string">"javax.servlet.include.request_uri"</span>;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIncludeRequest</span><span class="hljs-params">(ServletRequest request)</span> </span>{
    <span class="hljs-keyword">return</span> (request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE) != <span class="hljs-keyword">null</span>);
}
</code></pre><p>它会从 request 中查看是否有 <code>"javax.servlet.include.request_uri"</code> 这个属性，那它又是什么呢？</p>
<p>这又要回到 Servlet 规范中来解释了。</p>
<p>翻看 Servlet3.0 的规范文档，在9.3.1章节中有这样一段描述：</p>
<blockquote>
<p>Except for servlets obtained by using the  getNamedDispatcher method, a servlet that has been invoked by another servlet using the  include method of RequestDispatcher has access to the path by which it was invoked.</p>
<ul>
<li>javax.servlet.include.request_uri</li>
<li>javax.servlet.include.context_path</li>
<li>javax.servlet.include.servlet_path</li>
<li>javax.servlet.include.path_info</li>
<li>javax.servlet.include.query_string</li>
</ul>
<p>These attributes are accessible from the included servlet via the getAttribute method on the request object and their values must be equal to the request URI, context path, servlet path, path info, and query string of the included servlet, respectively. If the request is subsequently included, these attributes are replaced for that include.</p>
</blockquote>
<p>这里面刚好提到了 <code>javax.servlet.include.request_uri</code> 。</p>
<p>这段规范中的描述大概可以这么理解：已经被另一个 <code>Servlet</code> 使用 <code>RequestDispatcher</code> 的 <code>include</code> 方法调用过的 <code>Servlet</code>，有权访问被调用过的 <code>Servlet</code>的路径。</p>
<p>等会。。。include。。咱在之前学习jsp的时候有过这样一个标签：<code>&lt;jsp:incluede page="xxx.jsp"/&gt;</code> ，用它可以组合其它页面。</p>
<p>那到这里就大概可以猜测出，判断是否有这个属性，是<strong>为了区别页面的加载是否由include标签而来</strong>。</p>
<h3 class="heading">4.2 flashMapManager</h3>
<p>这个 <code>flashMapManager</code> 我们也很陌生，而且通过Debug发现它不为null：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df6b67d0e2321a~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>对此我们就要产生疑惑了，它又是什么？</p>
<h4 class="heading">4.2.1 FlashMapManager的产生背景</h4>
<p>做过开发的小伙伴都知道登录操作吧，咱都知道登录是<strong>POST</strong>请求，最终跳转到主页必须是一个redirect的<strong>GET</strong>请求，以防止表单重复提交。但是这样还是会存在一个问题，如果提交表单时传入的一些数据，在重定向的GET请求还要拿到来渲染到页面上，这个问题就不好解决了。传统的解决方案是把要渲染的数据作为url中的参数一起组合进请求路径，但这样做url太长，而且内容长度也有限。</p>
<p><code>SpringWebMvc3.1</code> 版本以后引入了 <code>FlashMapManager</code> 来解决这个问题。它引入了一个 <code>Flash Attribute</code> 的机制，可以在重定向跳转时将需要渲染的数据暂时放入 session 中，这样浏览器即便刷新也不会影响数据渲染。</p>
<h4 class="heading">4.2.2 SessionFlashMapManager</h4>
<p>上面的背景中也描述了，默认暂时会放入 session 域来保证数据渲染，<code>SpringWebMvc</code> 提供的默认实现也就是基于 session 的 <code>FlashMapManager</code> 。</p>
<p>从类继承结构来看，它又是体现了WebMvc的类设计思想：<strong>父类抽象化流程，子类实现</strong>。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df6b69d3eb133c~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>更细致的使用，小伙伴们可以自行搜索相关资料，小册这里只起引入作用。</p>
<hr>
<p><code>doService</code> 方法中上面的准备工作都完成后，下面进入 <code>doDispatch</code> 方法：</p>
<h2 class="heading">5. doDispatch</h2>
<p>暂且不看源码实现，先看一眼文档注释原文翻译：</p>
<blockquote>
<p>Process the actual dispatching to the handler.
The handler will be obtained by applying the servlet's HandlerMappings in order. The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters to find the first that supports the handler class.
All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers themselves to decide which methods are acceptable.</p>
<p>真正地调度处理器。</p>
<p>通过按顺序应用 Servlet 的 <code>HandlerMappings</code> 可以获得处理程序。通过查询Servlet安装的所有 <code>HandlerAdapter</code> 来查找支持该处理程序类的第一个 <code>HandlerAdapter</code>，从而获得 <code>HandlerAdapter</code> 。</p>
<p>所有HTTP方法都由该方法处理。由 <code>HandlerAdapters</code> 或处理程序本身来决定可接受的方法。</p>
</blockquote>
<p>这段文档注释几乎把 <code>DispatcherServlet</code> 的核心处理流程的前半部分都描述到位了。下面是方法实现：（关键步骤已在源码中标号）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">boolean</span> multipartRequestParsed = <span class="hljs-keyword">false</span>;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    <span class="hljs-keyword">try</span> {
        ModelAndView mv = <span class="hljs-keyword">null</span>;
        Exception dispatchException = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 5.1 文件上传解析</span>
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            <span class="hljs-comment">// Determine handler for the current request.</span>
            <span class="hljs-comment">// 5.2 获取Handler，Handler中包含真正地处理器（Controller中的方法）和一组HandlerInterceptor拦截器</span>
            mappedHandler = getHandler(processedRequest);
            <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-keyword">null</span>) {
                noHandlerFound(processedRequest, response);
                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-comment">// Determine handler adapter for the current request.</span>
            <span class="hljs-comment">// 5.3 获取HandlerAdapter</span>
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            <span class="hljs-comment">// Process last-modified header, if supported by the handler.</span>
            String method = request.getMethod();
            <span class="hljs-keyword">boolean</span> isGet = <span class="hljs-string">"GET"</span>.equals(method);
            <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">"HEAD"</span>.equals(method)) {
                <span class="hljs-keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {
                    <span class="hljs-keyword">return</span>;
                }
            }

            <span class="hljs-comment">// 5.4 回调拦截器</span>
            <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {
                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-comment">// Actually invoke the handler.</span>
            <span class="hljs-comment">// 5.5 执行Handler，返回ModelAndView</span>
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {
                <span class="hljs-keyword">return</span>;
            }

            applyDefaultViewName(processedRequest, mv);
            <span class="hljs-comment">// 5.6 回调拦截器</span>
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
        <span class="hljs-keyword">catch</span> (Exception ex) {
            dispatchException = ex;
        }
        <span class="hljs-keyword">catch</span> (Throwable err) {
            <span class="hljs-comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span>
            <span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span>
            dispatchException = <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler dispatch failed"</span>, err);
        }
        <span class="hljs-comment">// 5.7 处理视图，解析异常</span>
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    <span class="hljs-keyword">catch</span> (Exception ex) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    <span class="hljs-keyword">catch</span> (Throwable err) {
        triggerAfterCompletion(processedRequest, response, mappedHandler,
                <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler processing failed"</span>, err));
    }
    <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {
            <span class="hljs-comment">// Instead of postHandle and afterCompletion</span>
            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// 5.8 回调拦截器</span>
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Clean up any resources used by a multipart request.</span>
            <span class="hljs-keyword">if</span> (multipartRequestParsed) {
                cleanupMultipart(processedRequest);
            }
        }
    }
}
</code></pre><p>下面咱分步骤来看，体会步骤的执行流程：</p>
<h3 class="heading">5.1 checkMultipart：文件上传解析</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> HttpServletRequest <span class="hljs-title">checkMultipart</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> MultipartException </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.multipartResolver != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.multipartResolver.isMultipart(request)) {
        <span class="hljs-keyword">if</span> (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (request.getDispatcherType().equals(DispatcherType.REQUEST)) {
                logger.trace(<span class="hljs-string">"Request already resolved to MultipartHttpServletRequest, e.g. by MultipartFilter"</span>);
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasMultipartException(request)) {
            logger.debug(<span class="hljs-string">"Multipart resolution previously failed for current request - "</span> +
                    <span class="hljs-string">"skipping re-resolution for undisturbed error rendering"</span>);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.multipartResolver.resolveMultipart(request);
            }
            <span class="hljs-keyword">catch</span> (MultipartException ex) {
                <span class="hljs-keyword">if</span> (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != <span class="hljs-keyword">null</span>) {
                    logger.debug(<span class="hljs-string">"Multipart resolution failed for error dispatch"</span>, ex);
                    <span class="hljs-comment">// Keep processing error dispatch with regular request handle below</span>
                }
                <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">throw</span> ex;
                }
            }
        }
    }
    <span class="hljs-comment">// If not returned before: return original request.</span>
    <span class="hljs-keyword">return</span> request;
}
</code></pre><p>上面的源码逻辑比较简单，它要判断当前是否有可以处理 Multipart 类型的 Resolver，并且判断当前 request 是否为 <code>MultipartRequest</code> ，最终会执行 <code>multipartResolver.resolveMultipart</code> 方法。</p>
<h4 class="heading">5.1.1 multipartResolver.resolveMultipart</h4>
<p>根据Debug发现<code>multipartResolver</code> 的类型是 <code>StandardServletMultipartResolver</code> ，翻看它的 <code>resolveMultipart</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> MultipartHttpServletRequest <span class="hljs-title">resolveMultipart</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> MultipartException </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StandardMultipartHttpServletRequest(request, <span class="hljs-keyword">this</span>.resolveLazily);
}
</code></pre><p>它直接创建了一个 <code>StandardMultipartHttpServletRequest</code> ，那它跟普通的 <code>HttpServletRequest</code> 有什么扩展的地方呢？</p>
<h4 class="heading">5.1.2 StandardMultipartHttpServletRequest</h4>
<p>它上面只是调了个构造方法而已，那构造方法中大概率会有扩展部分：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StandardMultipartHttpServletRequest</span><span class="hljs-params">(HttpServletRequest request, <span class="hljs-keyword">boolean</span> lazyParsing)</span>
        <span class="hljs-keyword">throws</span> MultipartException </span>{
    <span class="hljs-keyword">super</span>(request);
    <span class="hljs-keyword">if</span> (!lazyParsing) {
        parseRequest(request);
    }
}
</code></pre><p>它这里有个 <code>parseRequest</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseRequest</span><span class="hljs-params">(HttpServletRequest request)</span> </span>{
    <span class="hljs-keyword">try</span> {
        Collection&lt;Part&gt; parts = request.getParts();
        <span class="hljs-keyword">this</span>.multipartParameterNames = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(parts.size());
        MultiValueMap&lt;String, MultipartFile&gt; files = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(parts.size());
        <span class="hljs-keyword">for</span> (Part part : parts) {
            String headerValue = part.getHeader(HttpHeaders.CONTENT_DISPOSITION);
            ContentDisposition disposition = ContentDisposition.parse(headerValue);
            String filename = disposition.getFilename();
            <span class="hljs-keyword">if</span> (filename != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">if</span> (filename.startsWith(<span class="hljs-string">"=?"</span>) &amp;&amp; filename.endsWith(<span class="hljs-string">"?="</span>)) {
                    filename = MimeDelegate.decode(filename);
                }
                files.add(part.getName(), <span class="hljs-keyword">new</span> StandardMultipartFile(part, filename));
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.multipartParameterNames.add(part.getName());
            }
        }
        setMultipartFiles(files);
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        handleParseFailure(ex);
    }
}
</code></pre><p>可以发现到这里开始解析 <code>MultipartRequest</code> 中的文件了。由于咱测试的是GET请求页面跳转，这部分就不展开描述了，感兴趣的小伙伴可以写一个POST表单来测一下这部分是如何解析上传文件的。</p>
<h3 class="heading">5.2 getHandler：搜索第一个可用的Handler</h3>
<pre><code class="hljs java" lang="java">    processedRequest = checkMultipart(request);
    multipartRequestParsed = (processedRequest != request);

    <span class="hljs-comment">// Determine handler for the current request.</span>
    mappedHandler = getHandler(processedRequest);
    <span class="hljs-comment">// ......</span>
</code></pre><p>文件解析完毕后，下一步就要获取处理器映射器了。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.handlerMappings != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (HandlerMapping mapping : <span class="hljs-keyword">this</span>.handlerMappings) {
            HandlerExecutionChain handler = mapping.getHandler(request);
            <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">return</span> handler;
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>可以很明显的看出，这部分是要从所有 的<code>HandlerMapping</code> 组件中选择一个能适配当前 <strong>uri</strong> 的，并组合请求的核心处理方法（<code>Controller</code>）和拦截器，返回给 <code>DispatcherServlet</code> 。这个方法的核心是 <code>mapping.getHandler</code> ，而所有的 <code>HandlerMapping</code> 都继承自 <code>AbstractHandlerMapping</code> ，<code>getHandler</code> 方法也只在 <code>AbstractHandlerMapping</code> 中定义：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> HandlerExecutionChain <span class="hljs-title">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// 【核心】5.2.1 获得处理器映射器</span>
    Object handler = getHandlerInternal(request);
    <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) {
        handler = getDefaultHandler();
    }
    <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
    <span class="hljs-comment">// Bean name or resolved handler?</span>
    <span class="hljs-comment">// 如果取到的Handler是一个String，则会认为要从IOC容器中获得对应的Bean</span>
    <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) {
        String handlerName = (String) handler;
        handler = obtainApplicationContext().getBean(handlerName);
    }

    <span class="hljs-comment">// 5.2.2 获得拦截器链</span>
    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);

    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
        logger.trace(<span class="hljs-string">"Mapped to "</span> + handler);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (logger.isDebugEnabled() &amp;&amp; !request.getDispatcherType().equals(DispatcherType.ASYNC)) {
        logger.debug(<span class="hljs-string">"Mapped to "</span> + executionChain.getHandler());
    }

    <span class="hljs-comment">// 处理跨域</span>
    <span class="hljs-keyword">if</span> (CorsUtils.isCorsRequest(request)) {
        CorsConfiguration globalConfig = <span class="hljs-keyword">this</span>.corsConfigurationSource.getCorsConfiguration(request);
        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);
        CorsConfiguration config = (globalConfig != <span class="hljs-keyword">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);
        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);
    }

    <span class="hljs-keyword">return</span> executionChain;
}
</code></pre><p>这个方法的第一步就要先根据 <strong>uri</strong> 获取能处理它的 <code>Handler</code> ，之后拿这个 <code>handler</code> 跟一组拦截器组合形成 <code>HandlerExecutionChain</code> ，最后处理跨域情况。首先进入 <code>getHandlerInternal</code> 方法：</p>
<h4 class="heading">5.2.1 getHandlerInternal</h4>
<p>对于解析普通请求 uri 的，都会跳转到 <code>AbstractHandlerMethodMapping</code> 中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title">getHandlerInternal</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// 获取要搜索的uri</span>
    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
    <span class="hljs-comment">// 加锁处理</span>
    <span class="hljs-keyword">this</span>.mappingRegistry.acquireReadLock();
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 5.2.1.1 搜索处理器方法（真正处理请求的RequestMapping）</span>
        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);
        <span class="hljs-comment">// 5.2.1.2 将方法分离出来，单独形成一个Bean</span>
        <span class="hljs-keyword">return</span> (handlerMethod != <span class="hljs-keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="hljs-keyword">null</span>);
    }
    <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">this</span>.mappingRegistry.releaseReadLock();
    }
}
</code></pre><p>上面解析好本次请求的uri后，加锁处理，接下来进入try块，开始真正的寻找能处理该请求的Controller方法，找到之后包装为一个单独的Bean。先看看搜索是怎么实现的：</p>
<h5 class="heading">5.2.1.1 lookupHandlerMethod</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title">lookupHandlerMethod</span><span class="hljs-params">(String lookupPath, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    List&lt;Match&gt; matches = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-comment">// 根据uri获取对应的RequestMapping信息（T的类型为RequestMappingInfo）</span>
    List&lt;T&gt; directPathMatches = <span class="hljs-keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);
    <span class="hljs-keyword">if</span> (directPathMatches != <span class="hljs-keyword">null</span>) {
        addMatchingMappings(directPathMatches, matches, request);
    }
    <span class="hljs-keyword">if</span> (matches.isEmpty()) {
        <span class="hljs-comment">// No choice but to go through all mappings...</span>
        addMatchingMappings(<span class="hljs-keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);
    }

    <span class="hljs-comment">// 排序选择最适合的Handler</span>
    <span class="hljs-keyword">if</span> (!matches.isEmpty()) {
        Comparator&lt;Match&gt; comparator = <span class="hljs-keyword">new</span> MatchComparator(getMappingComparator(request));
        matches.sort(comparator);
        Match bestMatch = matches.get(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (matches.size() &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
                logger.trace(matches.size() + <span class="hljs-string">" matching mappings: "</span> + matches);
            }
            <span class="hljs-keyword">if</span> (CorsUtils.isPreFlightRequest(request)) {
                <span class="hljs-keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;
            }
            Match secondBestMatch = matches.get(<span class="hljs-number">1</span>);
            <span class="hljs-keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="hljs-number">0</span>) {
                Method m1 = bestMatch.handlerMethod.getMethod();
                Method m2 = secondBestMatch.handlerMethod.getMethod();
                String uri = request.getRequestURI();
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(
                        <span class="hljs-string">"Ambiguous handler methods mapped for '"</span> + uri + <span class="hljs-string">"': {"</span> + m1 + <span class="hljs-string">", "</span> + m2 + <span class="hljs-string">"}"</span>);
            }
        }
        request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);
        handleMatch(bestMatch.mapping, lookupPath, request);
        <span class="hljs-keyword">return</span> bestMatch.handlerMethod;
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> handleNoMatch(<span class="hljs-keyword">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);
    }
}
</code></pre><p>在走完第二行时，从 <code>mappingRegistry</code> 中取出所有 Mapping 后，通过Debug发现已经能看到所有映射好的路径和对应的 Controller 中方法了。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df6b6c55766f18~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>之后的部分要根据所有能匹配上的 Handler ，选择一个最适合的，最后返回出去。具体的思路小册不详细展开了，逻辑不算复杂，小伙伴们可以实际的测试一次来Debug走一遍，大概有个印象即可，实际开发中也不会说两个Controller方法处理一个 <code>url+method</code> 。</p>
<h5 class="heading">5.2.1.2 handlerMethod.createWithResolvedBean</h5>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">try</span> {
        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);
        <span class="hljs-keyword">return</span> (handlerMethod != <span class="hljs-keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="hljs-keyword">null</span>);
    }
</code></pre><p>搜索到最适合的 <code>HandlerMethod</code> 后，要处理 <code>handlerMethod</code> 对象中封装的 bean 属性为 <code>beanName</code> 时的特殊情况：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> HandlerMethod <span class="hljs-title">createWithResolvedBean</span><span class="hljs-params">()</span> </span>{
    Object handler = <span class="hljs-keyword">this</span>.bean;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bean <span class="hljs-keyword">instanceof</span> String) {
        Assert.state(<span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span>, <span class="hljs-string">"Cannot resolve bean name without BeanFactory"</span>);
        String beanName = (String) <span class="hljs-keyword">this</span>.bean;
        handler = <span class="hljs-keyword">this</span>.beanFactory.getBean(beanName);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HandlerMethod(<span class="hljs-keyword">this</span>, handler);
}
</code></pre><p>这里面的处理逻辑也很简单，它会判断当前 <code>handlerMethod</code> 的 bean 属性是否为 <code>String</code>，如果是，会从IOC容器中找到这个 <code>beanName</code> 对应的Bean，之后走下面的return，new出来一个 <code>HandlerMethod</code> 对象。值得注意的是，这个构造方法中保存的属性比较多：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HandlerMethod</span><span class="hljs-params">(HandlerMethod handlerMethod, Object handler)</span> </span>{
    Assert.notNull(handlerMethod, <span class="hljs-string">"HandlerMethod is required"</span>);
    Assert.notNull(handler, <span class="hljs-string">"Handler object is required"</span>);
    <span class="hljs-keyword">this</span>.bean = handler;
    <span class="hljs-keyword">this</span>.beanFactory = handlerMethod.beanFactory;
    <span class="hljs-keyword">this</span>.beanType = handlerMethod.beanType;
    <span class="hljs-keyword">this</span>.method = handlerMethod.method;
    <span class="hljs-keyword">this</span>.bridgedMethod = handlerMethod.bridgedMethod;
    <span class="hljs-keyword">this</span>.parameters = handlerMethod.parameters;
    <span class="hljs-keyword">this</span>.responseStatus = handlerMethod.responseStatus;
    <span class="hljs-keyword">this</span>.responseStatusReason = handlerMethod.responseStatusReason;
    <span class="hljs-keyword">this</span>.resolvedFromHandlerMethod = handlerMethod;
}
</code></pre><p>这基本上把能存的都存好了。至此我们发现，<code>getHandlerInternal</code> 方法完成的工作是<strong>将可以处理当前请求的 Controller 方法找出来，封装成一个 <code>HandlerMethod</code> 对象</strong>。</p>
<h4 class="heading">5.2.2 getHandlerExecutionChain</h4>
<pre><code class="hljs java" lang="java">HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);
</code></pre><p>HandlerMethod 获取到之后，下一步还需要组合所有可以作用于当前请求的拦截器（这个思想很类似于AOP中对Bean的后置处理，产生代理对象）：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title">getHandlerExecutionChain</span><span class="hljs-params">(Object handler, HttpServletRequest request)</span> </span>{
    HandlerExecutionChain chain = (handler <span class="hljs-keyword">instanceof</span> HandlerExecutionChain ?
            (HandlerExecutionChain) handler : <span class="hljs-keyword">new</span> HandlerExecutionChain(handler));

    String lookupPath = <span class="hljs-keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);
    <span class="hljs-keyword">for</span> (HandlerInterceptor interceptor : <span class="hljs-keyword">this</span>.adaptedInterceptors) {
        <span class="hljs-keyword">if</span> (interceptor <span class="hljs-keyword">instanceof</span> MappedInterceptor) {
            MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;
            <span class="hljs-keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="hljs-keyword">this</span>.pathMatcher)) {
                chain.addInterceptor(mappedInterceptor.getInterceptor());
            }
        }
        <span class="hljs-keyword">else</span> {
            chain.addInterceptor(interceptor);
        }
    }
    <span class="hljs-keyword">return</span> chain;
}
</code></pre><p>这一步的思路也比较简单，它会把所有的拦截器都取出来，并且匹配是否为 <code>MappedInterceptor</code> 类型，还要匹配是否能处理当前请求 <strong>uri</strong> ，逻辑不很复杂。至于这里面的关键类 <code>HandlerExecutionChain</code> ，咱到后面执行的时候再看。</p>
<h3 class="heading">5.3 getHandlerAdapter：根据Handler找对应的Adapter</h3>
<pre><code class="hljs java" lang="java">    mappedHandler = getHandler(processedRequest);
    <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-keyword">null</span>) {
        noHandlerFound(processedRequest, response);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Determine handler adapter for the current request.</span>
    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
</code></pre><p>上一步确定好真正能处理当前请求的 <code>Controller</code> 和对应的方法后，接下来要借助 <code>HandlerAdapter</code> 来找到对应的这个 <code>Controller</code> 和方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerAdapter <span class="hljs-title">getHandlerAdapter</span><span class="hljs-params">(Object handler)</span> <span class="hljs-keyword">throws</span> ServletException </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.handlerAdapters != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (HandlerAdapter adapter : <span class="hljs-keyword">this</span>.handlerAdapters) {
            <span class="hljs-comment">// 5.3.1 判断是否能处理当前Handler</span>
            <span class="hljs-keyword">if</span> (adapter.supports(handler)) {
                <span class="hljs-keyword">return</span> adapter;
            }
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"No adapter for handler ["</span> + handler +
            <span class="hljs-string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);
}
</code></pre><p>逻辑也很简单，它会找所有的 <code>HandlerAdapter</code> ，来判断谁能处理当前的 <code>handler</code> 。当进入该方法时，发现当前一共有3个 <code>HandlerAdapter</code>：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df6b6e3f574bf5~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>这里面判断是否能处理，核心方法是 <code>adapter.supports</code> ：</p>
<h4 class="heading">5.3.1 adapter.supports</h4>
<p>咱直接进到 <code>DemoController</code> 的这个 <code>Handler</code> 吧，它的类型是 <code>RequestMappingHandlerAdapter</code> ，它的 <code>support</code> 方法来自父类 <code>AbstractHandlerMethodAdapter</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Object handler)</span> </span>{
    <span class="hljs-keyword">return</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));
}

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsInternal</span><span class="hljs-params">(HandlerMethod handlerMethod)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
</code></pre><p>这个方法倒是简单，它只判断一下 <code>handler</code> 的类型是不是 <code>HandlerMethod</code> ，因为后面的 <code>supportsInternal</code> 方法稳定返回 <strong>true</strong> 。上面的截图中很明显 <code>handler</code> 是 <code>HandlerMethod</code> 类型，故这部分会直接返回当前 <code>DemoController</code> 对应的 <code>HandlerAdapter</code> 。</p>
<h3 class="heading">5.4 applyPreHandle：执行Controller方法前回调拦截器</h3>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Determine handler adapter for the current request.</span>
    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

    <span class="hljs-comment">// Process last-modified header, if supported by the handler.</span>
    <span class="hljs-comment">// ......</span>

    <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {
        <span class="hljs-keyword">return</span>;
    }
</code></pre><p>上面取到 <code>adapter</code> 后，先不着急用它，先把 <code>handler</code> 中的拦截器都调一遍：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">applyPreHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    HandlerInterceptor[] interceptors = getInterceptors();
    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; interceptors.length; i++) {
            HandlerInterceptor interceptor = interceptors[i];
            <span class="hljs-keyword">if</span> (!interceptor.preHandle(request, response, <span class="hljs-keyword">this</span>.handler)) {
                triggerAfterCompletion(request, response, <span class="hljs-keyword">null</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
            <span class="hljs-keyword">this</span>.interceptorIndex = i;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
</code></pre><p>第一行先取出所有的拦截器，通过Debug发现此时有两个拦截器：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df6b702f231834~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>接下来的逻辑就是取到拦截器，回调 <code>preHandle</code> 方法，如果拦截器返回true，代表继续向后执行剩余的拦截器；如果返回false，代表拦截器将该方法拦截，不执行后续的拦截器和 <code>Controller</code> 中的方法。这部分逻辑也比较简单，而且咱之前学SpringWebMvc时也了解拦截器这部分如何编写。</p>
<p>下面看看这两个拦截器都是什么吧：</p>
<h4 class="heading">5.4.1 ConversionServiceExposingInterceptor</h4>
<p>文档注释原文翻译：</p>
<blockquote>
<p>Interceptor that places the configured ConversionService in request scope so it's available during request processing. The request attribute name is "org.springframework.core.convert.ConversionService", the value of ConversionService.class.getName().</p>
<p>Mainly for use within JSP tags such as the spring:eval tag.</p>
<p>将已配置的 <code>ConversionService</code> 放置在请求范围内的拦截器，以便在请求处理期间可用。请求属性名称是 <code>" org.springframework.core.convert.ConversionService"</code>，即 <code>ConversionService.class.getName()</code> 的值。</p>
<p>主要用于 <code>spring:eval</code> 标签的使用。</p>
</blockquote>
<p>最后一句已经解释到位了，它是配个 <code>spring:eval</code> 标签用的，而且是在jsp页面里用的，SpringBoot 都默认不用jsp了，咱也不展开描述了。不过咱可以从类名上大概获取一个信息：<code>ConversionService</code> ，它跟类型转换有关系，了解到这里就可以了。</p>
<h4 class="heading">5.4.2 ResourceUrlProviderExposingInterceptor</h4>
<p>文档注释原文翻译：</p>
<blockquote>
<p>An interceptor that exposes the ResourceUrlProvider instance it is configured with as a request attribute.</p>
<p>该拦截器会将 <code>ResourceUrlProvider</code> 实例放入 request 的属性中。</p>
</blockquote>
<p>文档注释描述的也比较清楚，看一眼它的源码能更好的理解文档注释的含义：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESOURCE_URL_PROVIDER_ATTR = ResourceUrlProvider.class.getName();

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span>
        <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 只是调了setAttribute而已</span>
        request.setAttribute(RESOURCE_URL_PROVIDER_ATTR, <span class="hljs-keyword">this</span>.resourceUrlProvider);
    }
    <span class="hljs-keyword">catch</span> (ResourceUrlEncodingFilter.LookupPathIndexException ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletRequestBindingException(ex.getMessage(), ex);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
</code></pre><h3 class="heading">5.5 【核心】ha.handle</h3>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Actually invoke the handler.</span>
    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
</code></pre><p>上面的拦截器都执行完了，下面要真正的拿 <code>HandlerAdapter</code> 来执行目标 <code>Controller</code> 的方法了。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ModelAndView <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span>
        <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);
}
</code></pre><p>它会直接调用到 <code>handleInternal</code> 方法：</p>
<h4 class="heading">5.5.1 handleInternal</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">handleInternal</span><span class="hljs-params">(HttpServletRequest request,
        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    ModelAndView mav;
    checkRequest(request);

    <span class="hljs-comment">// Execute invokeHandlerMethod in synchronized block if required.</span>
    <span class="hljs-comment">// 同步Session的配置</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.synchronizeOnSession) {
        HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) {
            Object mutex = WebUtils.getSessionMutex(session);
            <span class="hljs-keyword">synchronized</span> (mutex) {
                mav = invokeHandlerMethod(request, response, handlerMethod);
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// No HttpSession available -&gt; no mutex necessary</span>
            mav = invokeHandlerMethod(request, response, handlerMethod);
        }
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// No synchronization on session demanded at all...</span>
        <span class="hljs-comment">// 默认不同步，直接走invokeHandlerMethod方法</span>
        mav = invokeHandlerMethod(request, response, handlerMethod);
    }

    <span class="hljs-keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) {
        <span class="hljs-keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
            applyCacheSeconds(response, <span class="hljs-keyword">this</span>.cacheSecondsForSessionAttributeHandlers);
        }
        <span class="hljs-keyword">else</span> {
            prepareResponse(response);
        }
    }
    <span class="hljs-keyword">return</span> mav;
}
</code></pre><p>这部分动作中有对 Session 同步的内容，咱暂且不关心，在一般情况下都会直接来到else中执行 <code>invokeHandlerMethod</code> 方法：</p>
<h4 class="heading">5.5.2 invokeHandlerMethod</h4>
<p>（关键步骤的注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">invokeHandlerMethod</span><span class="hljs-params">(HttpServletRequest request,
        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception </span>{

    ServletWebRequest webRequest = <span class="hljs-keyword">new</span> ServletWebRequest(request, response);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 5.5.2.1 参数绑定器初始化</span>
        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
        <span class="hljs-comment">// 5.5.2.2 参数预绑定</span>
        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);

        <span class="hljs-comment">// 5.5.2.3 创建方法执行对象</span>
        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.argumentResolvers != <span class="hljs-keyword">null</span>) {
            invocableMethod.setHandlerMethodArgumentResolvers(<span class="hljs-keyword">this</span>.argumentResolvers);
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.returnValueHandlers != <span class="hljs-keyword">null</span>) {
            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="hljs-keyword">this</span>.returnValueHandlers);
        }
        invocableMethod.setDataBinderFactory(binderFactory);
        invocableMethod.setParameterNameDiscoverer(<span class="hljs-keyword">this</span>.parameterNameDiscoverer);

        <span class="hljs-comment">// 创建ModelAndView的容器</span>
        ModelAndViewContainer mavContainer = <span class="hljs-keyword">new</span> ModelAndViewContainer();
        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
        modelFactory.initModel(webRequest, mavContainer, invocableMethod);
        mavContainer.setIgnoreDefaultModelOnRedirect(<span class="hljs-keyword">this</span>.ignoreDefaultModelOnRedirect);

        AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);
        asyncWebRequest.setTimeout(<span class="hljs-keyword">this</span>.asyncRequestTimeout);

        <span class="hljs-comment">// 处理异步请求</span>
        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
        asyncManager.setTaskExecutor(<span class="hljs-keyword">this</span>.taskExecutor);
        asyncManager.setAsyncWebRequest(asyncWebRequest);
        asyncManager.registerCallableInterceptors(<span class="hljs-keyword">this</span>.callableInterceptors);
        asyncManager.registerDeferredResultInterceptors(<span class="hljs-keyword">this</span>.deferredResultInterceptors);

        <span class="hljs-keyword">if</span> (asyncManager.hasConcurrentResult()) {
            Object result = asyncManager.getConcurrentResult();
            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="hljs-number">0</span>];
            asyncManager.clearConcurrentResult();
            LogFormatUtils.traceDebug(logger, traceOn -&gt; {
                String formatted = LogFormatUtils.formatValue(result, !traceOn);
                <span class="hljs-keyword">return</span> <span class="hljs-string">"Resume with async result ["</span> + formatted + <span class="hljs-string">"]"</span>;
            });
            invocableMethod = invocableMethod.wrapConcurrentResult(result);
        }

        <span class="hljs-comment">// 5.5.3 执行Controller的方法</span>
        invocableMethod.invokeAndHandle(webRequest, mavContainer);
        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-comment">// 包装ModelAndView</span>
        <span class="hljs-keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);
    }
    <span class="hljs-keyword">finally</span> {
        webRequest.requestCompleted();
    }
}
</code></pre><p>中间几个步骤展开来看：</p>
<h5 class="heading">5.5.2.1 getDataBinderFactory：参数绑定器初始化</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MethodFilter INIT_BINDER_METHODS = method -&gt;
        AnnotatedElementUtils.hasAnnotation(method, InitBinder.class);

<span class="hljs-function"><span class="hljs-keyword">private</span> WebDataBinderFactory <span class="hljs-title">getDataBinderFactory</span><span class="hljs-params">(HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();
    Set&lt;Method&gt; methods = <span class="hljs-keyword">this</span>.initBinderCache.get(handlerType);
    <span class="hljs-keyword">if</span> (methods == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 方法过滤</span>
        methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS);
        <span class="hljs-keyword">this</span>.initBinderCache.put(handlerType, methods);
    }
    List&lt;InvocableHandlerMethod&gt; initBinderMethods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-comment">// Global methods first</span>
    <span class="hljs-keyword">this</span>.initBinderAdviceCache.forEach((clazz, methodSet) -&gt; {
        <span class="hljs-keyword">if</span> (clazz.isApplicableToBeanType(handlerType)) {
            Object bean = clazz.resolveBean();
            <span class="hljs-keyword">for</span> (Method method : methodSet) {
                initBinderMethods.add(createInitBinderMethod(bean, method));
            }
        }
    });
    <span class="hljs-keyword">for</span> (Method method : methods) {
        Object bean = handlerMethod.getBean();
        initBinderMethods.add(createInitBinderMethod(bean, method));
    }
    <span class="hljs-keyword">return</span> createDataBinderFactory(initBinderMethods);
}
</code></pre><p>注意最上面 <code>INIT_BINDER_METHODS</code> 的判断规则是方法上是否有 <code>@InitBinder</code> 注解。</p>
<p>看方法实现，这个方法会拿一个 <code>MethodFilter</code> ，去准备执行的 <code>Controller</code> 中寻找有没有提前显式绑定参数的方法。过滤的方法调用在第一个if结构中的 <code>MethodIntrospector.selectMethods</code> 。其实从这里来看，就已经明白这一步的规则了，<strong>它会预初始化这个 <code>Controller</code> 中的一个 <code>WebDataBinder</code> ，来对这个控制器中的数据绑定器做定制修改</strong>。通常情况下我们不会操作 <code>WebDataBinder</code> ，此处不会有动作发生，直接返回。</p>
<p>（如果小伙伴对 <code>WebDataBinder</code> 和 <code>@InitBinder</code> 不了解，可以借助搜索引擎查阅一些资料，小册不再展开介绍）</p>
<h5 class="heading">5.5.2.2 getModelFactory：参数预绑定</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MethodFilter MODEL_ATTRIBUTE_METHODS = method -&gt;
        (!AnnotatedElementUtils.hasAnnotation(method, RequestMapping.class) &amp;&amp;
                AnnotatedElementUtils.hasAnnotation(method, ModelAttribute.class));

<span class="hljs-function"><span class="hljs-keyword">private</span> ModelFactory <span class="hljs-title">getModelFactory</span><span class="hljs-params">(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory)</span> </span>{
    SessionAttributesHandler sessionAttrHandler = getSessionAttributesHandler(handlerMethod);
    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();
    Set&lt;Method&gt; methods = <span class="hljs-keyword">this</span>.modelAttributeCache.get(handlerType);
    <span class="hljs-keyword">if</span> (methods == <span class="hljs-keyword">null</span>) {
        methods = MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);
        <span class="hljs-keyword">this</span>.modelAttributeCache.put(handlerType, methods);
    }
    List&lt;InvocableHandlerMethod&gt; attrMethods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-comment">// Global methods first</span>
    <span class="hljs-keyword">this</span>.modelAttributeAdviceCache.forEach((clazz, methodSet) -&gt; {
        <span class="hljs-keyword">if</span> (clazz.isApplicableToBeanType(handlerType)) {
            Object bean = clazz.resolveBean();
            <span class="hljs-keyword">for</span> (Method method : methodSet) {
                attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));
            }
        }
    });
    <span class="hljs-keyword">for</span> (Method method : methods) {
        Object bean = handlerMethod.getBean();
        attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelFactory(attrMethods, binderFactory, sessionAttrHandler);
}
</code></pre><p>如果只是看方法实现，那思路几乎跟上面一样，但注意看这一次的过滤器 <code>MODEL_ATTRIBUTE_METHODS</code>：它要确定那些 <strong>不带 <code>@RequestMapping</code> 但带 <code>@ModelAttribute</code> 的方法</strong>。这个在 SpringWebMvc 中也有初始化的作用：<strong>进入 <code>Controller</code> 的指定方法之前，标有 <code>@ModelAttribute</code> 注解的方法会先执行</strong>。</p>
<p>（如果小伙伴对 <code>@ModelAttribute</code> 不太了解，可以借助搜索引擎查阅一些资料，实际动手写一些简单Demo体会一下作用，小册不再展开介绍）</p>
<h5 class="heading">5.5.2.3 createInvocableHandlerMethod：创建方法执行对象</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ServletInvocableHandlerMethod <span class="hljs-title">createInvocableHandlerMethod</span><span class="hljs-params">(HandlerMethod handlerMethod)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServletInvocableHandlerMethod(handlerMethod);
}
</code></pre><p>可以看出只是将 <code>HandlerMethod</code> 封装为 <code>ServletInvocableHandlerMethod</code> 而已，它封装的目的是为了下面能执行重写的 <code>invokeAndHandle</code> 方法。</p>
<hr>
<p>上面的方法（参数预绑定，异步处理等）都执行完毕后，来到 <code>invokeAndHandle</code> 方法：</p>
<h4 class="heading">5.5.3 invocableMethod.invokeAndHandle</h4>
<p>先暂且不看下面的源码，第一句就是重点：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAndHandle</span><span class="hljs-params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
        Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// 5.5.4 反射调用</span>
    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
    <span class="hljs-comment">// ......</span>
}
</code></pre><h4 class="heading">5.5.4 invokeForRequest</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invokeForRequest</span><span class="hljs-params">(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
        Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
        logger.trace(<span class="hljs-string">"Arguments: "</span> + Arrays.toString(args));
    }
    <span class="hljs-keyword">return</span> doInvoke(args);
}
</code></pre><p>这个方法分为两步：参数取值，反射调用 <code>Controller</code> 。其中参数取值和类型转换的过程从 <code>getMethodArgumentValues</code> 方法开始：</p>
<h5 class="heading">5.5.4.1 getMethodArgumentValues</h5>
<p>（关键部分的注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="hljs-meta">@Nullable</span> ModelAndViewContainer mavContainer,
        Object... providedArgs) <span class="hljs-keyword">throws</span> Exception {
    <span class="hljs-comment">// 获取目标Controller中方法的参数类型</span>
    MethodParameter[] parameters = getMethodParameters();
    <span class="hljs-keyword">if</span> (ObjectUtils.isEmpty(parameters)) {
        <span class="hljs-keyword">return</span> EMPTY_ARGS;
    }

    Object[] args = <span class="hljs-keyword">new</span> Object[parameters.length];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parameters.length; i++) {
        MethodParameter parameter = parameters[i];
        parameter.initParameterNameDiscovery(<span class="hljs-keyword">this</span>.parameterNameDiscoverer);
        <span class="hljs-comment">// 获得参数值</span>
        args[i] = findProvidedArgument(parameter, providedArgs);
        <span class="hljs-keyword">if</span> (args[i] != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-comment">// 5.5.4.2 判断参数解析器是否能处理当前参数类型</span>
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resolvers.supportsParameter(parameter)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(formatArgumentError(parameter, <span class="hljs-string">"No suitable resolver"</span>));
        }
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 5.5.4.3 参数可以被解析，将参数转换为Controller中目标方法对应位置的参数类型</span>
            args[i] = <span class="hljs-keyword">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="hljs-keyword">this</span>.dataBinderFactory);
        }
        <span class="hljs-keyword">catch</span> (Exception ex) {
            <span class="hljs-comment">// Leave stack trace for later, exception may actually be resolved and handled...</span>
            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
                String exMsg = ex.getMessage();
                <span class="hljs-keyword">if</span> (exMsg != <span class="hljs-keyword">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) {
                    logger.debug(formatArgumentError(parameter, exMsg));
                }
            }
            <span class="hljs-keyword">throw</span> ex;
        }
    }
    <span class="hljs-keyword">return</span> args;
}
</code></pre><p>可以发现上面的思路还是比较清晰的，首先获取值，之后判断是否可以处理，如果可以，转换；解析不了，抛出异常。</p>
<p>这里咱以一个实例来看：<strong>String转int</strong> 。</p>
<h5 class="heading">5.5.4.2 resolvers.supportsParameter：判断是否可以处理</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>{
    <span class="hljs-keyword">return</span> getArgumentResolver(parameter) != <span class="hljs-keyword">null</span>;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> HandlerMethodArgumentResolver <span class="hljs-title">getArgumentResolver</span><span class="hljs-params">(MethodParameter parameter)</span> </span>{
    HandlerMethodArgumentResolver result = <span class="hljs-keyword">this</span>.argumentResolverCache.get(parameter);
    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (HandlerMethodArgumentResolver resolver : <span class="hljs-keyword">this</span>.argumentResolvers) {
            <span class="hljs-keyword">if</span> (resolver.supportsParameter(parameter)) {
                result = resolver;
                <span class="hljs-keyword">this</span>.argumentResolverCache.put(parameter, result);
                <span class="hljs-keyword">break</span>;
            }
        }
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre><p>这部分判断是否能处理当前参数，实际上就是把所有的 <code>HandlerMethodArgumentResolver</code> 都拿出来检验一遍，如果找到了能处理的，会将当前参数和对应的 <code>ArgumentResolver</code> 绑定起来，方便下一次快速获取。</p>
<h5 class="heading">5.5.4.3 resolvers.resolveArgument：转换参数</h5>
<p>参数确定好，接下来转换参数：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
        NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>{

    HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
    <span class="hljs-keyword">if</span> (resolver == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unsupported parameter type ["</span> +
                parameter.getParameterType().getName() + <span class="hljs-string">"]. supportsParameter should be called first."</span>);
    }
    <span class="hljs-keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
}
</code></pre><p>上面取到前一步缓存的 <code>ArgumentResolver</code> （类型为 <code>RequestParamMethodArgumentResolver</code> ），去调它的 <code>resolveArgument</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
        NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>{

    NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);
    MethodParameter nestedParameter = parameter.nestedIfOptional();

    <span class="hljs-comment">// 获取实际参数的key</span>
    Object resolvedName = resolveStringValue(namedValueInfo.name);
    <span class="hljs-keyword">if</span> (resolvedName == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(
                <span class="hljs-string">"Specified name must not resolve to null: ["</span> + namedValueInfo.name + <span class="hljs-string">"]"</span>);
    }

    <span class="hljs-comment">// 5.5.4.4 获取实际参数的值</span>
    Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);
    <span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (namedValueInfo.defaultValue != <span class="hljs-keyword">null</span>) {
            arg = resolveStringValue(namedValueInfo.defaultValue);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) {
            handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);
        }
        arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="hljs-keyword">null</span>) {
        arg = resolveStringValue(namedValueInfo.defaultValue);
    }

    <span class="hljs-keyword">if</span> (binderFactory != <span class="hljs-keyword">null</span>) {
        WebDataBinder binder = binderFactory.createBinder(webRequest, <span class="hljs-keyword">null</span>, namedValueInfo.name);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 5.5.4.5 参数类型转换</span>
            arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);
        }
        <span class="hljs-keyword">catch</span> (ConversionNotSupportedException ex) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(),
                    namedValueInfo.name, parameter, ex.getCause());
        }
        <span class="hljs-keyword">catch</span> (TypeMismatchException ex) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MethodArgumentTypeMismatchException(arg, ex.getRequiredType(),
                    namedValueInfo.name, parameter, ex.getCause());

        }
    }

    handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);

    <span class="hljs-keyword">return</span> arg;
}
</code></pre><p>方法实现中的大体思路也很清晰：先获取参数的key，后根据key获取value，最后拿value去做必要的类型转换。重要的两步是获取value和类型转换，分开来看：</p>
<h5 class="heading">5.5.4.4 resolveName：获取参数的值</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">resolveName</span><span class="hljs-params">(String name, MethodParameter parameter, NativeWebRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    HttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);

    <span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span>) {
        Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);
        <span class="hljs-keyword">if</span> (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) {
            <span class="hljs-keyword">return</span> mpArg;
        }
    }

    Object arg = <span class="hljs-keyword">null</span>;
    MultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);
    <span class="hljs-keyword">if</span> (multipartRequest != <span class="hljs-keyword">null</span>) {
        List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);
        <span class="hljs-keyword">if</span> (!files.isEmpty()) {
            arg = (files.size() == <span class="hljs-number">1</span> ? files.get(<span class="hljs-number">0</span>) : files);
        }
    }
    <span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span>) {
        String[] paramValues = request.getParameterValues(name);
        <span class="hljs-keyword">if</span> (paramValues != <span class="hljs-keyword">null</span>) {
            arg = (paramValues.length == <span class="hljs-number">1</span> ? paramValues[<span class="hljs-number">0</span>] : paramValues);
        }
    }
    <span class="hljs-keyword">return</span> arg;
}
</code></pre><p>可以发现第一行和最后的一个if结构，是 <code>HttpServletRequest</code> 的原生API操作，可以由此取到参数的值。</p>
<h5 class="heading">5.5.4.5 binder.convertIfNecessary：参数类型转换</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">convertIfNecessary</span><span class="hljs-params">(@Nullable Object value, @Nullable Class&lt;T&gt; requiredType,
        @Nullable MethodParameter methodParam)</span> <span class="hljs-keyword">throws</span> TypeMismatchException </span>{
    <span class="hljs-keyword">return</span> getTypeConverter().convertIfNecessary(value, requiredType, methodParam);
}

<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">convertIfNecessary</span><span class="hljs-params">(@Nullable Object value, @Nullable Class&lt;T&gt; requiredType,
        @Nullable MethodParameter methodParam)</span> <span class="hljs-keyword">throws</span> TypeMismatchException </span>{
    <span class="hljs-keyword">return</span> convertIfNecessary(value, requiredType,
            (methodParam != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)));
}

<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">convertIfNecessary</span><span class="hljs-params">(@Nullable Object value, @Nullable Class&lt;T&gt; requiredType,
        @Nullable TypeDescriptor typeDescriptor)</span> <span class="hljs-keyword">throws</span> TypeMismatchException </span>{
    Assert.state(<span class="hljs-keyword">this</span>.typeConverterDelegate != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No TypeConverterDelegate"</span>);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.typeConverterDelegate.convertIfNecessary(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, value, requiredType, typeDescriptor);
    }
    <span class="hljs-keyword">catch</span> (ConverterNotFoundException | IllegalStateException ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConversionNotSupportedException(value, requiredType, ex);
    }
    <span class="hljs-keyword">catch</span> (ConversionException | IllegalArgumentException ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeMismatchException(value, requiredType, ex);
    }
}
</code></pre><p><code>binder</code> 的方法一路调到底下，它会利用 <code>typeConverterDelegate</code> 来做实际的参数类型转换。由于 <code>typeConverterDelegate</code> 中的参数转换逻辑很复杂，小册不作记录，小伙伴们可以借助IDE自行Debug体会一下参数转换的过程。</p>
<hr>
<p>参数处理完成后，接下来就可以真正的调用 Controller 中的方法了：</p>
<h4 class="heading">5.5.5 【反射】doInvoke</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doInvoke</span><span class="hljs-params">(Object... args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    ReflectionUtils.makeAccessible(getBridgedMethod());
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> getBridgedMethod().invoke(getBean(), args);
    }
    <span class="hljs-comment">// catch ......</span>
}
</code></pre><p>发现了原生的反射机制，这里会真正的执行 Controller 里的方法。</p>
<h4 class="heading">5.5.6 Controller执行完成后</h4>
<p>回到 <code>invocableMethod.invokeAndHandle</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAndHandle</span><span class="hljs-params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
        Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
    setResponseStatus(webRequest);

    <span class="hljs-keyword">if</span> (returnValue == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="hljs-keyword">null</span> || mavContainer.isRequestHandled()) {
            disableContentCachingIfNecessary(webRequest);
            mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);
            <span class="hljs-keyword">return</span>;
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) {
        mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span>;
    }

    mavContainer.setRequestHandled(<span class="hljs-keyword">false</span>);
    Assert.state(<span class="hljs-keyword">this</span>.returnValueHandlers != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No return value handlers"</span>);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 5.5.6.1 处理返回值</span>
        <span class="hljs-keyword">this</span>.returnValueHandlers.handleReturnValue(
                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
    }
    <span class="hljs-keyword">catch</span> (Exception ex) {
        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
            logger.trace(formatErrorForReturnValue(returnValue), ex);
        }
        <span class="hljs-keyword">throw</span> ex;
    }
}
</code></pre><p><code>Controller</code> 的目标方法执行完毕后，回到 <code>invokeAndHandle</code> 方法，</p>
<h5 class="heading">5.5.6.1 returnValueHandlers.handleReturnValue</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(@Nullable Object returnValue, MethodParameter returnType,
        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
    <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unknown return value type: "</span> + returnType.getParameterType().getName());
    }
    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
}
</code></pre><p>首先它会从所有的 <code>ReturnValueHandler</code> 中匹配一个最合适的来处理 <code>Controller</code> 的目标方法的返回值：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> HandlerMethodReturnValueHandler <span class="hljs-title">selectHandler</span><span class="hljs-params">(@Nullable Object value, MethodParameter returnType)</span> </span>{
    <span class="hljs-keyword">boolean</span> isAsyncValue = isAsyncReturnValue(value, returnType);
    <span class="hljs-keyword">for</span> (HandlerMethodReturnValueHandler handler : <span class="hljs-keyword">this</span>.returnValueHandlers) {
        <span class="hljs-keyword">if</span> (isAsyncValue &amp;&amp; !(handler <span class="hljs-keyword">instanceof</span> AsyncHandlerMethodReturnValueHandler)) {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">if</span> (handler.supportsReturnType(returnType)) {
            <span class="hljs-keyword">return</span> handler;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>通过Debug，发现如果返回视图，则会使用 <code>ViewNameMethodReturnValueHandler</code> 作为 <code>ReturnValueHandler</code> 。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df6b72050c4e7e~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<h5 class="heading">5.5.6.2 handler.handleReturnValue</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(@Nullable Object returnValue, MethodParameter returnType,
        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-keyword">if</span> (returnValue <span class="hljs-keyword">instanceof</span> CharSequence) {
        String viewName = returnValue.toString();
        mavContainer.setViewName(viewName);
        <span class="hljs-keyword">if</span> (isRedirectViewName(viewName)) {
            mavContainer.setRedirectModelScenario(<span class="hljs-keyword">true</span>);
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (returnValue != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// should not happen</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"Unexpected return type: "</span> +
                returnType.getParameterType().getName() + <span class="hljs-string">" in method: "</span> + returnType.getMethod());
    }
}
</code></pre><p>这部分逻辑也很简单，它会判断返回值是否属于 <code>CharSequence</code> 类型，如果是，会给 <code>ModelAndViewContainer</code> 中设置 <code>viewName</code> 。</p>
<h4 class="heading">5.5.7 回到invokeHandlerMethod方法</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">invokeHandlerMethod</span><span class="hljs-params">(HttpServletRequest request,
        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// ......</span>
        invocableMethod.invokeAndHandle(webRequest, mavContainer);
        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);
    }
    <span class="hljs-keyword">finally</span> {
        webRequest.requestCompleted();
    }
}
</code></pre><p>回到 <code>invokeHandlerMethod</code> 后，最后一步就是获取 <code>ModelAndView</code> 了：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> ModelAndView <span class="hljs-title">getModelAndView</span><span class="hljs-params">(ModelAndViewContainer mavContainer,
        ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception </span>{

    modelFactory.updateModel(webRequest, mavContainer);
    <span class="hljs-keyword">if</span> (mavContainer.isRequestHandled()) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
    ModelMap model = mavContainer.getModel();
    ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());
    <span class="hljs-keyword">if</span> (!mavContainer.isViewReference()) {
        mav.setView((View) mavContainer.getView());
    }
    <span class="hljs-keyword">if</span> (model <span class="hljs-keyword">instanceof</span> RedirectAttributes) {
        Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();
        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
        <span class="hljs-keyword">if</span> (request != <span class="hljs-keyword">null</span>) {
            RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
        }
    }
    <span class="hljs-keyword">return</span> mav;
}
</code></pre><p>从方法实现中发现它其实底层也是现new出来的 <code>ModelAndView</code> 对象，之后把 <code>ModelAndViewContainer</code> 中的东西都设置到 <code>ModelAndView</code> 中，最后返回。</p>
<h4 class="heading">5.5.8 回到handleInternal方法</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HEADER_CACHE_CONTROL = <span class="hljs-string">"Cache-Control"</span>;

<span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">handleInternal</span><span class="hljs-params">(HttpServletRequest request,
        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// ......</span>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// No synchronization on session demanded at all...</span>
        mav = invokeHandlerMethod(request, response, handlerMethod);
    }

    <span class="hljs-keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) {
        <span class="hljs-keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
            applyCacheSeconds(response, <span class="hljs-keyword">this</span>.cacheSecondsForSessionAttributeHandlers);
        }
        <span class="hljs-keyword">else</span> {
            prepareResponse(response);
        }
    }

    <span class="hljs-keyword">return</span> mav;
}
</code></pre><p>方法执行完返回 <code>ModelAndView</code> 后，最后一步要根据 header 中是否有 <code>"Cache-Control"</code> 来决定最后的跳转。很明显默认请求下不会带缓存相关的请求头，进入最后一步 <code>prepareResponse</code> 方法：</p>
<h5 class="heading">5.5.8.1 prepareResponse</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareResponse</span><span class="hljs-params">(HttpServletResponse response)</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cacheControl != <span class="hljs-keyword">null</span>) {
        applyCacheControl(response, <span class="hljs-keyword">this</span>.cacheControl);
    }
    <span class="hljs-keyword">else</span> {
        applyCacheSeconds(response, <span class="hljs-keyword">this</span>.cacheSeconds);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.varyByRequestHeaders != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (String value : getVaryRequestHeadersToAdd(response, <span class="hljs-keyword">this</span>.varyByRequestHeaders)) {
            response.addHeader(<span class="hljs-string">"Vary"</span>, value);
        }
    }
}
</code></pre><p>可以发现也是跟缓存相关的简单设置，逻辑很简单，不再深入研究。</p>
<h3 class="heading">5.6 回到doDispatch</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// .....</span>
    <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// ......</span>
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {
                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-comment">// 如果ModelAndView不为空，但viewName为空时，指定默认view的名称</span>
            applyDefaultViewName(processedRequest, mv);
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
    <span class="hljs-comment">// ......</span>
}
</code></pre><p>在处理默认 viewName 后，下面会回调拦截器的 <code>postHandle</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">applyPostHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)</span>
        <span class="hljs-keyword">throws</span> Exception </span>{
    HandlerInterceptor[] interceptors = getInterceptors();
    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = interceptors.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            HandlerInterceptor interceptor = interceptors[i];
            interceptor.postHandle(request, response, <span class="hljs-keyword">this</span>.handler, mv);
        }
    }
}
</code></pre><h3 class="heading">5.7 processDispatchResult：处理视图，解析异常</h3>
<pre><code class="hljs java" lang="java">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
</code></pre><p>这一步算是 <code>doDispatch</code> 的最后一步：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,
        @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
        @Nullable Exception exception)</span> <span class="hljs-keyword">throws</span> Exception </span>{

    <span class="hljs-keyword">boolean</span> errorView = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// 5.7.1 如果有抛出异常，则根据异常的类型处理ModelAndView</span>
    <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> ModelAndViewDefiningException) {
            logger.debug(<span class="hljs-string">"ModelAndViewDefiningException encountered"</span>, exception);
            mv = ((ModelAndViewDefiningException) exception).getModelAndView();
        }
        <span class="hljs-keyword">else</span> {
            Object handler = (mappedHandler != <span class="hljs-keyword">null</span> ? mappedHandler.getHandler() : <span class="hljs-keyword">null</span>);
            mv = processHandlerException(request, response, handler, exception);
            errorView = (mv != <span class="hljs-keyword">null</span>);
        }
    }

    <span class="hljs-comment">// Did the handler return a view to render?</span>
    <span class="hljs-keyword">if</span> (mv != <span class="hljs-keyword">null</span> &amp;&amp; !mv.wasCleared()) {
        <span class="hljs-comment">// 5.7.2 渲染结果视图</span>
        render(mv, request, response);
        <span class="hljs-keyword">if</span> (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
            logger.trace(<span class="hljs-string">"No view rendering, null ModelAndView returned."</span>);
        }
    }

    <span class="hljs-keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
        <span class="hljs-comment">// Concurrent handling started during a forward</span>
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) {
        mappedHandler.triggerAfterCompletion(request, response, <span class="hljs-keyword">null</span>);
    }
}
</code></pre><p>这段源码主要分两部分：处理异常，渲染结果视图。分别来看：</p>
<h4 class="heading">5.7.1 处理异常</h4>
<p>修改测试Controller里的方法，加入一个除零异常，重新Debug后发现抛出的异常直到 <code>processDispatchResult</code> 方法传入时，还是刚抛出的 <code>ArithmeticException</code> ，它自然不属于 <code>ModelAndViewDefiningException</code> 类型，进入else：</p>
<pre><code class="hljs java" lang="java">    Object handler = (mappedHandler != <span class="hljs-keyword">null</span> ? mappedHandler.getHandler() : <span class="hljs-keyword">null</span>);
    mv = processHandlerException(request, response, handler, exception);
    errorView = (mv != <span class="hljs-keyword">null</span>);
</code></pre><p>上面先把出现异常的 Controller 和目标方法获取到，下面会根据这个异常来执行 <code>processHandlerException</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">processHandlerException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,
        @Nullable Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>{

    <span class="hljs-comment">// Success and error responses may use different content types</span>
    request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);

    <span class="hljs-comment">// Check registered HandlerExceptionResolvers...</span>
    <span class="hljs-comment">// 遍历所有可以处理异常的异常处理器</span>
    ModelAndView exMv = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.handlerExceptionResolvers != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (HandlerExceptionResolver resolver : <span class="hljs-keyword">this</span>.handlerExceptionResolvers) {
            exMv = resolver.resolveException(request, response, handler, ex);
            <span class="hljs-keyword">if</span> (exMv != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">break</span>;
            }
        }
    }
    <span class="hljs-comment">// 如果有成功处理，则返回异常视图</span>
    <span class="hljs-keyword">if</span> (exMv != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (exMv.isEmpty()) {
            request.setAttribute(EXCEPTION_ATTRIBUTE, ex);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-comment">// We might still need view name translation for a plain error model...</span>
        <span class="hljs-keyword">if</span> (!exMv.hasView()) {
            String defaultViewName = getDefaultViewName(request);
            <span class="hljs-keyword">if</span> (defaultViewName != <span class="hljs-keyword">null</span>) {
                exMv.setViewName(defaultViewName);
            }
        }
        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
            logger.trace(<span class="hljs-string">"Using resolved error view: "</span> + exMv, ex);
        }
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Using resolved error view: "</span> + exMv);
        }
        WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());
        <span class="hljs-keyword">return</span> exMv;
    }

    <span class="hljs-comment">// 无法处理该异常，继续抛出</span>
    <span class="hljs-keyword">throw</span> ex;
}
</code></pre><p>默认情况下，如果没有额外注册异常处理器，IOC容器中只会有两个处理器：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df6b7439b14e1f~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>而且通过Debug，发现这两个 <code>ExceptionResolver</code> 都无法处理这个除零异常，最终到方法最底部继续 throw 出去。</p>
<h5 class="heading">5.7.1.1 手动注册一个异常处理器后的效果</h5>
<p>在测试工程中加入一个异常处理器：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@ControllerAdvice</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArithmeticExceptionHandler</span> </span>{
    <span class="hljs-meta">@ExceptionHandler</span>(ArithmeticException.class)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resolve</span><span class="hljs-params">(ArithmeticException e)</span> </span>{
        <span class="hljs-comment">// 异常处理逻辑</span>
    }
}
</code></pre><p>重新Debug来到 processDispatchResult 方法，进入到 processHandlerException 中：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">for</span> (HandlerExceptionResolver resolver : <span class="hljs-keyword">this</span>.handlerExceptionResolvers) {
        exMv = resolver.resolveException(request, response, handler, ex);
        <span class="hljs-keyword">if</span> (exMv != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">break</span>;
        }
    }
</code></pre><p>这一段还是会获取那两个处理器，但在这里面有了一个新的变化，进到 <code>HandlerExceptionResolverComposite</code> 的 <code>resolveException</code> 中：</p>
<h5 class="heading">5.7.1.2 HandlerExceptionResolverComposite.resolveException</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(
        HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resolvers != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (HandlerExceptionResolver handlerExceptionResolver : <span class="hljs-keyword">this</span>.resolvers) {
            ModelAndView mav = handlerExceptionResolver.resolveException(request, response, handler, ex);
            <span class="hljs-keyword">if</span> (mav != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">return</span> mav;
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>它会循环获取一组 <code>HandlerExceptionResolver</code> ，通过Debug发现它有3个：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df6b7642c281cb~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>第一个我们看上去会有一种既熟悉又陌生的感觉：我们在做异常处理的时候用的注解就是 <code>@ExceptionHandler</code> ，所以一定会从这个 <code>ExceptionResolver</code> 中进去：</p>
<h5 class="heading">5.7.1.3 ExceptionHandlerExceptionResolver</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(
        HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>{
    <span class="hljs-keyword">if</span> (shouldApplyTo(request, handler)) {
        prepareResponse(ex, response);
        ModelAndView result = doResolveException(request, response, handler, ex);
        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// Print debug message when warn logger is not enabled.</span>
            <span class="hljs-keyword">if</span> (logger.isDebugEnabled() &amp;&amp; (<span class="hljs-keyword">this</span>.warnLogger == <span class="hljs-keyword">null</span> || !<span class="hljs-keyword">this</span>.warnLogger.isWarnEnabled())) {
                logger.debug(<span class="hljs-string">"Resolved ["</span> + ex + <span class="hljs-string">"]"</span> + (result.isEmpty() ? <span class="hljs-string">""</span> : <span class="hljs-string">" to "</span> + result));
            }
            <span class="hljs-comment">// Explicitly configured warn logger in logException method.</span>
            logException(ex, request);
        }
        <span class="hljs-keyword">return</span> result;
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}
</code></pre><p>又看到了 doXXX方法，直接直接来看 <code>doResolveException</code> ：</p>
<h5 class="heading">5.7.1.4 doResolveException</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ModelAndView <span class="hljs-title">doResolveException</span><span class="hljs-params">(
        HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>{
    <span class="hljs-keyword">return</span> doResolveHandlerMethodException(request, response, (HandlerMethod) handler, ex);
}

<span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">doResolveHandlerMethodException</span><span class="hljs-params">(HttpServletRequest request,
        HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception)</span> </span>{
    ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);
    <span class="hljs-comment">// ......</span>

    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Using @ExceptionHandler "</span> + exceptionHandlerMethod);
        }
        Throwable cause = exception.getCause();
        <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// Expose cause as provided argument as well</span>
            exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Otherwise, just the given exception as-is</span>
            exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, handlerMethod);
        }
    }
    <span class="hljs-comment">// catch and other ......</span>
}
</code></pre><p>不重要的片段已经省略掉了，注意看这个 <code>doResolveHandlerMethodException</code> 的设计，是不是有那么一点似曾相识？是不是很像前面5.5.2章节中 <code>invokeHandlerMethod</code> 的设计？它先创建 <code>ServletInvocableHandlerMethod</code> ，后执行方法，而且执行的方法还都叫 <code>invokeAndHandle</code> ，实际Debug进去发现就是跟之前的一致。</p>
<p>至此，自定义异常处理器的执行流程完毕。</p>
<hr>
<h4 class="heading">5.7.2 render：渲染视图</h4>
<p>回到 <code>processDispatchResult</code> 方法的中间部分：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">if</span> (mv != <span class="hljs-keyword">null</span> &amp;&amp; !mv.wasCleared()) {
        <span class="hljs-comment">// 5.7.2 渲染结果视图</span>
        render(mv, request, response);
        <span class="hljs-keyword">if</span> (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    }
</code></pre><p>它要拿到 <code>ModelAndView</code> 对象，来实际渲染：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">render</span><span class="hljs-params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// Determine locale for request and apply it to the response.</span>
    <span class="hljs-comment">// 国际化处理</span>
    Locale locale =
            (<span class="hljs-keyword">this</span>.localeResolver != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.localeResolver.resolveLocale(request) : request.getLocale());
    response.setLocale(locale);

    View view;
    String viewName = mv.getViewName();
    <span class="hljs-keyword">if</span> (viewName != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// We need to resolve the view name.</span>
        <span class="hljs-comment">// 5.7.2.1 解析viewName获取对应View</span>
        view = resolveViewName(viewName, mv.getModelInternal(), locale, request);
        <span class="hljs-comment">// 如果没有解析到View，则抛出异常</span>
        <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Could not resolve view with name '"</span> + mv.getViewName() +
                    <span class="hljs-string">"' in servlet with name '"</span> + getServletName() + <span class="hljs-string">"'"</span>);
        }
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// No need to lookup: the ModelAndView object contains the actual View object.</span>
        view = mv.getView();
        <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"ModelAndView ["</span> + mv + <span class="hljs-string">"] neither contains a view name nor a "</span> +
                    <span class="hljs-string">"View object in servlet with name '"</span> + getServletName() + <span class="hljs-string">"'"</span>);
        }
    }

    <span class="hljs-comment">// Delegate to the View object for rendering.</span>
    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
        logger.trace(<span class="hljs-string">"Rendering view ["</span> + view + <span class="hljs-string">"] "</span>);
    }
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (mv.getStatus() != <span class="hljs-keyword">null</span>) {
            response.setStatus(mv.getStatus().value());
        }
        <span class="hljs-comment">// 5.7.2.3 带入Model的数据来真正渲染视图</span>
        view.render(mv.getModelInternal(), request, response);
    }
    <span class="hljs-keyword">catch</span> (Exception ex) {
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Error rendering view ["</span> + view + <span class="hljs-string">"]"</span>, ex);
        }
        <span class="hljs-keyword">throw</span> ex;
    }
}
</code></pre><p>这部分渲染要先处理国际化，接下来才是借助 <code>ViewResolver</code> 来获取视图，之后由视图来组合数据，进行渲染。先来看看 ViewResolver是如何解析出 View 的：</p>
<h5 class="heading">5.7.2.1 resolveViewName</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, @Nullable Map&lt;String, Object&gt; model,
        Locale locale, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (ViewResolver viewResolver : <span class="hljs-keyword">this</span>.viewResolvers) {
            View view = viewResolver.resolveViewName(viewName, locale);
            <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">return</span> view;
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>通过Debug发现默认有5个 <code>ViewResolver</code> ：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df6b77e3a9df29~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>之前咱介绍过，<code>ContentNegotiatingViewResolver</code> 是最高级的 <code>ViewResolver</code> ，来看它的 <code>resolveViewName</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
    Assert.state(attrs <span class="hljs-keyword">instanceof</span> ServletRequestAttributes, <span class="hljs-string">"No current ServletRequestAttributes"</span>);
    List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());
    <span class="hljs-keyword">if</span> (requestedMediaTypes != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 5.7.2.2 搜索所有匹配的View</span>
        List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);
        <span class="hljs-comment">// 选一个最合适的</span>
        View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);
        <span class="hljs-keyword">if</span> (bestView != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> bestView;
        }
    }

    <span class="hljs-comment">// log......</span>
}
</code></pre><p>源码中的思路很简单，它会先从当前所有的 <code>View</code> 中找出来所有可以匹配上的 <code>View</code> ，之后再从这里面选一个最合适的，返回出去。</p>
<h5 class="heading">5.7.2.2 getCandidateViews：搜索所有匹配的View</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;View&gt; <span class="hljs-title">getCandidateViews</span><span class="hljs-params">(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)</span>
        <span class="hljs-keyword">throws</span> Exception </span>{

    List&lt;View&gt; candidateViews = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers != <span class="hljs-keyword">null</span>) {
        Assert.state(<span class="hljs-keyword">this</span>.contentNegotiationManager != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No ContentNegotiationManager set"</span>);
        <span class="hljs-comment">// 借助ViewResolver</span>
        <span class="hljs-keyword">for</span> (ViewResolver viewResolver : <span class="hljs-keyword">this</span>.viewResolvers) {
            View view = viewResolver.resolveViewName(viewName, locale);
            <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) {
                candidateViews.add(view);
            }
            <span class="hljs-keyword">for</span> (MediaType requestedMediaType : requestedMediaTypes) {
                List&lt;String&gt; extensions = <span class="hljs-keyword">this</span>.contentNegotiationManager.resolveFileExtensions(requestedMediaType);
                <span class="hljs-keyword">for</span> (String extension : extensions) {
                    String viewNameWithExtension = viewName + <span class="hljs-string">'.'</span> + extension;
                    view = viewResolver.resolveViewName(viewNameWithExtension, locale);
                    <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) {
                        candidateViews.add(view);
                    }
                }
            }
        }
    }
    <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.defaultViews)) {
        candidateViews.addAll(<span class="hljs-keyword">this</span>.defaultViews);
    }
    <span class="hljs-keyword">return</span> candidateViews;
}
</code></pre><p>发现它会拿剩余的所有的 <code>ViewResolver</code> 去匹配 <code>View</code> 对象，之后根据下面的 <code>MediaType</code> 过滤来决定是否可以被渲染。</p>
<p>这也就解释了前面 <code>ContentNegotiatingViewResolver</code> 的功能，它负责分发给真正的 <code>ViewResolver</code> 。</p>
<p>当最合适的 View 选出来之后，通过Debug发现它确实来自 <code>ContentNegotiatingViewResolver</code> ，而且 <code>View</code> 的类型是 <code>ThymeleafView</code>：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df6b7a59b6d099~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<h5 class="heading">5.7.2.3 回到render：view.render</h5>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (mv.getStatus() != <span class="hljs-keyword">null</span>) {
            response.setStatus(mv.getStatus().value());
        }
        <span class="hljs-comment">// 带入Model的数据来真正渲染视图</span>
        view.render(mv.getModelInternal(), request, response);
    }
</code></pre><p>找到 <code>View</code> 后下面要实际带入 <code>Model</code> 的数据来渲染视图了。</p>
<p>由于 <code>ThymeleafView</code> 中的渲染逻辑很复杂且带有 <strong>Thymeleaf</strong> 的语法，小册不展开解析了，感兴趣的小伙伴可以Debug进去看一眼，感受模板引擎的复杂。</p>
<h3 class="heading">5.8 applyAfterConcurrentHandlingStarted：回调拦截器</h3>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {
            <span class="hljs-comment">// Instead of postHandle and afterCompletion</span>
            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) {
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Clean up any resources used by a multipart request.</span>
            <span class="hljs-keyword">if</span> (multipartRequestParsed) {
                cleanupMultipart(processedRequest);
            }
        }
    }
</code></pre><p>很明显跟之前一样，它又会回调拦截器：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">applyAfterConcurrentHandlingStarted</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>{
    HandlerInterceptor[] interceptors = getInterceptors();
    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = interceptors.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">if</span> (interceptors[i] <span class="hljs-keyword">instanceof</span> AsyncHandlerInterceptor) {
                <span class="hljs-keyword">try</span> {
                    AsyncHandlerInterceptor asyncInterceptor = (AsyncHandlerInterceptor) interceptors[i];
                    asyncInterceptor.afterConcurrentHandlingStarted(request, response, <span class="hljs-keyword">this</span>.handler);
                }
                <span class="hljs-keyword">catch</span> (Throwable ex) {
                    logger.error(<span class="hljs-string">"Interceptor ["</span> + interceptors[i] + <span class="hljs-string">"] failed in afterConcurrentHandlingStarted"</span>, ex);
                }
            }
        }
    }
}
</code></pre><p>不过这一次回调的方法都是 <code>AsyncHandlerInterceptor</code> 类型的 <code>afterConcurrentHandlingStarted</code> 方法，它用来处理异步请求，感兴趣的小伙伴们可以接触一下这个类型的拦截器。</p>
<hr>
<p>至此，<code>doDispatch</code> 方法执行完毕。</p>
<h2 class="heading">6. @ResponseBody响应json数据的原理</h2>
<p>上面是响应视图，在前后端分离的微服务开发时都是用 <code>@RestController</code> 或 <code>@ResponseBody</code> 来响应json数据而不是视图。这部分对应的原理要追回到5.5.6章节的 <code>invocableMethod.invokeAndHandle</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAndHandle</span><span class="hljs-params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
        Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
    <span class="hljs-comment">// ......</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 处理返回值</span>
        <span class="hljs-keyword">this</span>.returnValueHandlers.handleReturnValue(
                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
    }
    <span class="hljs-comment">// ......</span>
}
</code></pre><p>在处理返回值时，就不再使用 <code>ViewNameMethodReturnValueHandler</code> 作为 <code>ReturnValueHandler</code> 了，而是使用 <code>RequestResponseBodyMethodProcessor</code>：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df6b7c425f2db1~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>接下来进入它的 <code>handleReturnValue</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(@Nullable Object returnValue, MethodParameter returnType,
        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span>
        <span class="hljs-keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>{
    mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);
    ServletServerHttpRequest inputMessage = createInputMessage(webRequest);
    ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);

    <span class="hljs-comment">// Try even with null return value. ResponseBodyAdvice could get involved.</span>
    writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);
}
</code></pre><p>可以发现最后一句是直接写响应内容了。这个 writeWithMessageConverters 方法很复杂，感兴趣的小伙伴可以跟进去看一下，它最终也是用的 response 的 outputStream 来写入响应内容。</p>
<h2 class="heading">流程图</h2>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/2/16e2a32296c5f67c~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<h2 class="heading">小结</h2>
<ol>
<li><code>DispatcherServlet</code> 最终继承了 <code>HttpServlet</code> ，核心方法是 <code>doDispatch</code> 。</li>
<li><code>DispatcherServlet</code> 的核心流程是先获取 <code>HandlerMapping</code> ，后获取 <code>HandlerAdapter</code> ，最终执行目标 Controller 的方法，最终返回 View 或响应 json。</li>
</ol>
<p>【至此，<code>DispatcherServlet</code> 的核心工作原理解析完毕，下一篇咱来看看它内置的嵌入式Web容器是如何创建的，以及内部如何配置它的】</p>
</div>
</body></html>