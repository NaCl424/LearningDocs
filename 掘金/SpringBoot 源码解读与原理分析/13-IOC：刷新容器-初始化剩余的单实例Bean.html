<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>IOC：刷新容器-初始化剩余的单实例Bean</h1>
<h1 class="heading">14. IOC：刷新容器-初始化剩余的单实例Bean</h1>
<p>（这部分是Bean的初始化全程剖析，篇幅巨长，小伙伴们可以分段理解，这里面涉及到的原理实在是太多了，这也解释了为什么Spring的IOC是如此的牛啤）</p>
<p>【接前章】</p>
<p>这一篇我们只看这一个方法：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span>
    finishBeanFactoryInitialization(beanFactory);
</code></pre><h2 class="heading">11. finishBeanFactoryInitialization：初始化单实例Bean</h2>
<p>源码分为好几部分，前面的部分都不算很关键，注释已标注在源码中，最后一句代码是核心关键点：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{
    <span class="hljs-comment">// Initialize conversion service for this context.</span>
    <span class="hljs-comment">// 初始化ConversionService，这个ConversionService是用于类型转换的服务接口。</span>
    <span class="hljs-comment">// 它的工作，是将配置文件/properties中的数据，进行类型转换，得到Spring真正想要的数据类型。</span>
    <span class="hljs-keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
        beanFactory.setConversionService(
                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
    }

    <span class="hljs-comment">// Register a default embedded value resolver if no bean post-processor</span>
    <span class="hljs-comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span>
    <span class="hljs-comment">// at this point, primarily for resolution in annotation attribute values.</span>
    <span class="hljs-comment">// 嵌入式值解析器EmbeddedValueResolver的组件注册，它负责解析占位符和表达式</span>
    <span class="hljs-keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) {
        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));
    }

    <span class="hljs-comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span>
    <span class="hljs-comment">// 尽早初始化LoadTimeWeaverAware类型的bean，以允许尽早注册其变换器。</span>
    <span class="hljs-comment">// 这部分与LoadTimeWeaverAware有关部分，它实际上是与AspectJ有关</span>
    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">for</span> (String weaverAwareName : weaverAwareNames) {
        getBean(weaverAwareName);
    }

    <span class="hljs-comment">// Stop using the temporary ClassLoader for type matching.</span>
    <span class="hljs-comment">// 停用临时类加载器（单行注释解释的很清楚）</span>
    beanFactory.setTempClassLoader(<span class="hljs-keyword">null</span>);

    <span class="hljs-comment">// Allow for caching all bean definition metadata, not expecting further changes.</span>
    <span class="hljs-comment">// 允许缓存所有bean定义元数据</span>
    beanFactory.freezeConfiguration();

    <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span>
    <span class="hljs-comment">// 【初始化】实例化所有非延迟加载的单例Bean</span>
    beanFactory.preInstantiateSingletons();
}
</code></pre><h3 class="heading">11.1 preInstantiateSingletons</h3>
<p>它跳转到了 <code>DefaultListableBeanFactory</code> 的 <code>preInstantiateSingletons</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) {
        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Pre-instantiating singletons in "</span> + <span class="hljs-keyword">this</span>);
    }

    <span class="hljs-comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span>
    <span class="hljs-comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span>
    <span class="hljs-comment">// 拿到了所有的Bean定义信息，这些信息已经在前面的步骤中都准备完毕了</span>
    List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames);

    <span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span>
    <span class="hljs-comment">// 这里面有一些Bean已经在之前的步骤中已经创建过了，这里只创建剩余的那些非延迟加载的单例Bean</span>
    <span class="hljs-keyword">for</span> (String beanName : beanNames) {
        <span class="hljs-comment">// 合并父BeanFactory中同名的BeanDefinition，</span>
        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
        <span class="hljs-comment">// 这个Bean不是抽象Bean、是单例Bean、是非延迟加载的Bean</span>
        <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {
            <span class="hljs-comment">// 是否为工厂Bean（如果是工厂Bean，还需要实现FactoryBean接口）</span>
            <span class="hljs-keyword">if</span> (isFactoryBean(beanName)) {
                <span class="hljs-comment">// 如果是工厂Bean：判断该工厂Bean是否需要被迫切加载，如果需要，则直接实例化该工厂Bean</span>
                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) {
                    <span class="hljs-keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
                    <span class="hljs-keyword">boolean</span> isEagerInit;
                    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) {
                        isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
                                        ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                                getAccessControlContext());
                    }
                    <span class="hljs-keyword">else</span> {
                        isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;
                                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
                    }
                    <span class="hljs-keyword">if</span> (isEagerInit) {
                        getBean(beanName);
                    }
                }
            }
            <span class="hljs-comment">// 如果不是工厂Bean，直接调用getBean方法</span>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 11.2 getBean</span>
                getBean(beanName);
            }
        }
    }

    <span class="hljs-comment">// Trigger post-initialization callback for all applicable beans...</span>
    <span class="hljs-comment">// 到这里，所有非延迟加载的单实例Bean都已经创建好。</span>
    <span class="hljs-comment">// 如果有Bean实现了SmartInitializingSingleton接口，还会去回调afterSingletonsInstantiated方法</span>
    <span class="hljs-keyword">for</span> (String beanName : beanNames) {
        Object singletonInstance = getSingleton(beanName);
        <span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) {
            <span class="hljs-keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
            <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) {
                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
                    smartSingleton.afterSingletonsInstantiated();
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                }, getAccessControlContext());
            }
            <span class="hljs-keyword">else</span> {
                smartSingleton.afterSingletonsInstantiated();
            }
        }
    }
}
</code></pre><p>上面的一系列判断后（判断逻辑已标注在源码上），如果不是工厂Bean，则会来到一个我们超级熟悉的方法： <strong><code>getBean</code></strong> ：</p>
<h3 class="heading">11.2 【核心】getBean</h3>
<p>（源码超级长。。。）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
    <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);
}

<span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doGetBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, @Nullable <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType,
        @Nullable <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span> <span class="hljs-keyword">throws</span> BeansException </span>{

    <span class="hljs-comment">// 11.2.1 此处是解决别名 -&gt; BeanName的映射，getBean时可以传入bean的别名，此处可以根据别名找到BeanName</span>
    <span class="hljs-keyword">final</span> String beanName = transformedBeanName(name);
    Object bean;

    <span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span>
    <span class="hljs-comment">// 先尝试从之前实例化好的Bean中找有没有这个Bean，如果能找到，说明已经被实例化了，可以直接返回</span>
    <span class="hljs-comment">// 11.2.2 getSingleton</span>
    Object sharedInstance = getSingleton(beanName);
    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-keyword">null</span> &amp;&amp; args == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) {
                logger.debug(<span class="hljs-string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +
                        <span class="hljs-string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);
            }
            <span class="hljs-keyword">else</span> {
                logger.debug(<span class="hljs-string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="hljs-string">"'"</span>);
            }
        }
        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-keyword">null</span>);
    }

    <span class="hljs-comment">// 11.2.3 上面get不到bean</span>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Fail if we're already creating this bean instance:</span>
        <span class="hljs-comment">// We're assumably within a circular reference.</span>
        <span class="hljs-comment">// 如果搜不到，但该Bean正在被创建，说明产生了循环引用且无法处理，只能抛出异常</span>
        <span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);
        }

        <span class="hljs-comment">// Check if bean definition exists in this factory.</span>
        <span class="hljs-comment">// 检查这个Bean对应的BeanDefinition在IOC容器中是否存在</span>
        BeanFactory parentBeanFactory = getParentBeanFactory();
        <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) {
            <span class="hljs-comment">// Not found -&gt; check parent.</span>
            <span class="hljs-comment">// 如果检查不存在，看看父容器有没有（Web环境会存在父子容器现象）</span>
            String nameToLookup = originalBeanName(name);
            <span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) {
                <span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                        nameToLookup, requiredType, args, typeCheckOnly);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// Delegation to parent with explicit args.</span>
                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span>
                <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);
            }
        }

        <span class="hljs-comment">// 11.2.4 走到这个地方，证明Bean确实要被创建了，标记Bean被创建</span>
        <span class="hljs-comment">// 该设计是防止多线程同时到这里，引发多次创建的问题</span>
        <span class="hljs-keyword">if</span> (!typeCheckOnly) {
            markBeanAsCreated(beanName);
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 11.2.5 合并BeanDefinition</span>
            <span class="hljs-keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
            checkMergedBeanDefinition(mbd, beanName, args);

            <span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span>
            <span class="hljs-comment">// 处理当前bean的bean依赖（@DependsOn注解的依赖）</span>
            <span class="hljs-comment">// 在创建一个Bean之前，可能这个Bean需要依赖其他的Bean。</span>
            <span class="hljs-comment">// 通过这个步骤，可以先递归的将这个Bean显式声明的需要的其他Bean先创建出来。</span>
            <span class="hljs-comment">// 通过bean标签的depends-on属性或@DependsOn注解进行显式声明。</span>
            String[] dependsOn = mbd.getDependsOn();
            <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">for</span> (String dep : dependsOn) {
                    <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,
                                <span class="hljs-string">"Circular depends-on relationship between '"</span> + beanName + <span class="hljs-string">"' and '"</span> + dep + <span class="hljs-string">"'"</span>);
                    }
                    registerDependentBean(dep, beanName);
                    getBean(dep);
                }
            }

            <span class="hljs-comment">// Create bean instance.</span>
            <span class="hljs-comment">// 作用域为singleton，单实例Bean，创建</span>
            <span class="hljs-keyword">if</span> (mbd.isSingleton()) {
                <span class="hljs-comment">// 11.3,7 匿名内部类执行完成后的getSingleton调用</span>
                sharedInstance = getSingleton(beanName, () -&gt; {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">// 11.4 createBean</span>
                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);
                    }
                    <span class="hljs-keyword">catch</span> (BeansException ex) {
                        <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span>
                        <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span>
                        <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span>
                        destroySingleton(beanName);
                        <span class="hljs-keyword">throw</span> ex;
                    }
                });
                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
            }

            <span class="hljs-comment">// 作用域为prototype类型</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) {
                <span class="hljs-comment">// It's a prototype -&gt; create a new instance.</span>
                Object prototypeInstance = <span class="hljs-keyword">null</span>;
                <span class="hljs-keyword">try</span> {
                    beforePrototypeCreation(beanName);
                    prototypeInstance = createBean(beanName, mbd, args);
                }
                <span class="hljs-keyword">finally</span> {
                    afterPrototypeCreation(beanName);
                }
                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
            }

            <span class="hljs-comment">// 作用域既不是singleton，又不是prototype，那就按照实际情况来创建吧。</span>
            <span class="hljs-keyword">else</span> {
                String scopeName = mbd.getScope();
                <span class="hljs-keyword">final</span> Scope scope = <span class="hljs-keyword">this</span>.scopes.get(scopeName);
                <span class="hljs-keyword">if</span> (scope == <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No Scope registered for scope name '"</span> + scopeName + <span class="hljs-string">"'"</span>);
                }
                <span class="hljs-keyword">try</span> {
                    Object scopedInstance = scope.get(beanName, () -&gt; {
                        beforePrototypeCreation(beanName);
                        <span class="hljs-keyword">try</span> {
                            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);
                        }
                        <span class="hljs-keyword">finally</span> {
                            afterPrototypeCreation(beanName);
                        }
                    });
                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                }
                <span class="hljs-keyword">catch</span> (IllegalStateException ex) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,
                            <span class="hljs-string">"Scope '"</span> + scopeName + <span class="hljs-string">"' is not active for the current thread; consider "</span> +
                            <span class="hljs-string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,
                            ex);
                }
            }
        }
        <span class="hljs-keyword">catch</span> (BeansException ex) {
            cleanupAfterBeanCreationFailure(beanName);
            <span class="hljs-keyword">throw</span> ex;
        }
    }

    <span class="hljs-comment">// Check if required type matches the type of the actual bean instance.</span>
    <span class="hljs-comment">// 检查所需的类型是否与实际bean实例的类型匹配，类型不匹配则抛出异常</span>
    <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) {
        <span class="hljs-keyword">try</span> {
            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
            <span class="hljs-keyword">if</span> (convertedBean == <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
            }
            <span class="hljs-keyword">return</span> convertedBean;
        }
        <span class="hljs-keyword">catch</span> (TypeMismatchException ex) {
            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
                logger.debug(<span class="hljs-string">"Failed to convert bean '"</span> + name + <span class="hljs-string">"' to required type '"</span> +
                        ClassUtils.getQualifiedName(requiredType) + <span class="hljs-string">"'"</span>, ex);
            }
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
        }
    }
    <span class="hljs-keyword">return</span> (T) bean;
}
</code></pre><p>这部分源码超级长！先大概浏览一下上面的源码和主干注释，下面咱们分段来看。</p>
<h4 class="heading">11.2.1 transformedBeanName：别名-BeanName的映射</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doGetBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, @Nullable <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType,
        @Nullable <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span> <span class="hljs-keyword">throws</span> BeansException </span>{

    <span class="hljs-keyword">final</span> String beanName = transformedBeanName(name);
    Object bean;
</code></pre><p><code>transformedBeanName</code> 方法往下调：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">transformedBeanName</span><span class="hljs-params">(String name)</span> </span>{
    <span class="hljs-keyword">return</span> canonicalName(BeanFactoryUtils.transformedBeanName(name));
}

<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">canonicalName</span><span class="hljs-params">(String name)</span> </span>{
    String canonicalName = name;
    <span class="hljs-comment">// Handle aliasing...</span>
    String resolvedName;
    <span class="hljs-keyword">do</span> {
        resolvedName = <span class="hljs-keyword">this</span>.aliasMap.get(canonicalName);
        <span class="hljs-keyword">if</span> (resolvedName != <span class="hljs-keyword">null</span>) {
            canonicalName = resolvedName;
        }
    }
    <span class="hljs-keyword">while</span> (resolvedName != <span class="hljs-keyword">null</span>);
    <span class="hljs-keyword">return</span> canonicalName;
}
</code></pre><p>发现它就是拿aliasMap去一个个的取，找别名映射的BeanName，找不到就返回原始名。</p>
<h4 class="heading">11.2.2 getSingleton：尝试获取单实例Bean（解决循环依赖）</h4>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span>
    <span class="hljs-comment">// 先尝试从之前实例化好的Bean中找有没有这个Bean，如果能找到，说明已经被实例化了，可以直接返回</span>
    Object sharedInstance = getSingleton(beanName);
    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-keyword">null</span> &amp;&amp; args == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) {
                logger.debug(<span class="hljs-string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +
                        <span class="hljs-string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);
            }
            <span class="hljs-keyword">else</span> {
                logger.debug(<span class="hljs-string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="hljs-string">"'"</span>);
            }
        }
        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-keyword">null</span>);
    }
</code></pre><p>可以发现这段代码是在处理重复实例化的。IOC容器会对单实例Bean单独存储，这个地方就是从IOC容器中找是否已经被实例化。由于<strong>这部分源码复杂度过高</strong>，咱们在下一篇咱专门研究IOC容器如何解决循环依赖的。</p>
<h4 class="heading">11.2.3 创建前的检查</h4>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">//上面get不到bean</span>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Fail if we're already creating this bean instance:</span>
        <span class="hljs-comment">// We're assumably within a circular reference.</span>
        <span class="hljs-comment">// 如果搜不到，但该Bean正在被创建，说明产生了循环引用且无法处理，只能抛出异常</span>
        <span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);
        }

        <span class="hljs-comment">// Check if bean definition exists in this factory.</span>
        <span class="hljs-comment">// 检查这个Bean对应的BeanDefinition在IOC容器中是否存在</span>
        BeanFactory parentBeanFactory = getParentBeanFactory();
        <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) {
            <span class="hljs-comment">// Not found -&gt; check parent.</span>
            <span class="hljs-comment">// 如果检查不存在，看看父容器有没有（Web环境会存在父子容器现象）</span>
            String nameToLookup = originalBeanName(name);
            <span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) {
                <span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                        nameToLookup, requiredType, args, typeCheckOnly);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// Delegation to parent with explicit args.</span>
                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span>
                <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);
            }
        }
</code></pre><p>这里面有一个检查循环依赖的方法：  <code>isPrototypeCurrentlyInCreation</code>：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// 返回指定的原型bean是否当前正在创建（在当前线程内）</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototypeCurrentlyInCreation</span><span class="hljs-params">(String beanName)</span> </span>{
    Object curVal = <span class="hljs-keyword">this</span>.prototypesCurrentlyInCreation.get();
    <span class="hljs-keyword">return</span> (curVal != <span class="hljs-keyword">null</span> &amp;&amp;
            (curVal.equals(beanName) || (curVal <span class="hljs-keyword">instanceof</span> Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));
}
</code></pre><p>它这个方法是创建原型Bean时会校验的。如果当前线程中在创建一个 <strong>scope=prototype</strong> 的Bean，并且当前要创建的Bean跟这个线程中创建的Bean的name一致，则会认为出现了多实例Bean的循环依赖，会引发异常。</p>
<h4 class="heading">11.2.4 标记准备创建的Bean</h4>
<pre><code class="hljs java" lang="java">        <span class="hljs-comment">// 走到这个地方，证明Bean确实要被创建了，标记Bean被创建</span>
        <span class="hljs-comment">// 该设计是防止多线程同时到这里，引发多次创建的问题</span>
        <span class="hljs-keyword">if</span> (!typeCheckOnly) {
            markBeanAsCreated(beanName);
        }
</code></pre><p>这里的标记过程：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">markBeanAsCreated</span><span class="hljs-params">(String beanName)</span> </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.alreadyCreated.contains(beanName)) {
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.mergedBeanDefinitions) {
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.alreadyCreated.contains(beanName)) {
                <span class="hljs-comment">// Let the bean definition get re-merged now that we're actually creating</span>
                <span class="hljs-comment">// the bean... just in case some of its metadata changed in the meantime.</span>
                clearMergedBeanDefinition(beanName);
                <span class="hljs-keyword">this</span>.alreadyCreated.add(beanName);
            }
        }
    }
}
</code></pre><p>最后一句：<code>this.alreadyCreated.add(beanName);</code> ，已经足够理解了。IOC容器会把所有创建过的Bean的name都存起来。</p>
<h4 class="heading">11.2.5 合并BeanDefinition，处理显式依赖</h4>
<pre><code class="hljs java" lang="java">        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 合并BeanDefinition</span>
            <span class="hljs-keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
            checkMergedBeanDefinition(mbd, beanName, args);

            <span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span>
            <span class="hljs-comment">// 处理当前bean的bean依赖（@DependsOn注解的依赖）</span>
            <span class="hljs-comment">// 在创建一个Bean之前，可能这个Bean需要依赖其他的Bean。</span>
            <span class="hljs-comment">// 通过这个步骤，可以先递归的将这个Bean显式声明的需要的其他Bean先创建出来。</span>
            <span class="hljs-comment">// 通过bean标签的depends-on属性或@DependsOn注解进行显式声明。</span>
            String[] dependsOn = mbd.getDependsOn();
            <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">for</span> (String dep : dependsOn) {
                    <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,
                                <span class="hljs-string">"Circular depends-on relationship between '"</span> + beanName + <span class="hljs-string">"' and '"</span> + dep + <span class="hljs-string">"'"</span>);
                    }
                    registerDependentBean(dep, beanName);
                    getBean(dep);
                }
            }
</code></pre><p>这部分会解析 <code>@DependsOn</code> 注解标注声明的Bean，并预先的构建它，被依赖的Bean也是通过 <code>getBean</code> 方法来创建，思路一致，不再赘述。</p>
<h4 class="heading">11.2.6 准备创建Bean</h4>
<pre><code class="hljs java" lang="java">            <span class="hljs-comment">// Create bean instance.</span>
            <span class="hljs-comment">// 作用域为singleton，单实例Bean，创建</span>
            <span class="hljs-keyword">if</span> (mbd.isSingleton()) {
                <span class="hljs-comment">// 匿名内部类执行完成后的getSingleton调用</span>
                sharedInstance = getSingleton(beanName, () -&gt; {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);
                    }
                    <span class="hljs-keyword">catch</span> (BeansException ex) {
                        <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span>
                        <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span>
                        <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span>
                        destroySingleton(beanName);
                        <span class="hljs-keyword">throw</span> ex;
                    }
                });
                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
            }
</code></pre><p>在try块中，要真正的创建Bean了。注意 <code>createBean</code> 方法是通过 <code>getSingleton</code> 方法传入匿名内部类，调用的 <code>createBean</code> 方法。先来看 <code>getSingleton</code> 方法：</p>
<h3 class="heading">11.3 getSingleton</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>{
    Assert.notNull(beanName, <span class="hljs-string">"Bean name must not be null"</span>);
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) {
        <span class="hljs-comment">// 先试着从已经加载好的单实例Bean缓存区中获取是否有当前BeanName的Bean，显然没有</span>
        Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);
        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.singletonsCurrentlyInDestruction) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationNotAllowedException(beanName,
                        <span class="hljs-string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +
                        <span class="hljs-string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);
            }
            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
                logger.debug(<span class="hljs-string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="hljs-string">"'"</span>);
            }
            <span class="hljs-comment">// 11.3.1 标记当前bean</span>
            beforeSingletonCreation(beanName);
            <span class="hljs-keyword">boolean</span> newSingleton = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">boolean</span> recordSuppressedExceptions = (<span class="hljs-keyword">this</span>.suppressedExceptions == <span class="hljs-keyword">null</span>);
            <span class="hljs-keyword">if</span> (recordSuppressedExceptions) {
                <span class="hljs-keyword">this</span>.suppressedExceptions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 11.4 创建Bean</span>
                singletonObject = singletonFactory.getObject();
                newSingleton = <span class="hljs-keyword">true</span>;
            }
            <span class="hljs-keyword">catch</span> (IllegalStateException ex) {
                <span class="hljs-comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span>
                <span class="hljs-comment">// if yes, proceed with it since the exception indicates that state.</span>
                singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);
                <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">throw</span> ex;
                }
            }
            <span class="hljs-keyword">catch</span> (BeanCreationException ex) {
                <span class="hljs-keyword">if</span> (recordSuppressedExceptions) {
                    <span class="hljs-keyword">for</span> (Exception suppressedException : <span class="hljs-keyword">this</span>.suppressedExceptions) {
                        ex.addRelatedCause(suppressedException);
                    }
                }
                <span class="hljs-keyword">throw</span> ex;
            }
            <span class="hljs-keyword">finally</span> {
                <span class="hljs-keyword">if</span> (recordSuppressedExceptions) {
                    <span class="hljs-keyword">this</span>.suppressedExceptions = <span class="hljs-keyword">null</span>;
                }
                afterSingletonCreation(beanName);
            }
            <span class="hljs-keyword">if</span> (newSingleton) {
                <span class="hljs-comment">// 将这个创建好的Bean放到单实例Bean缓存区中</span>
                addSingleton(beanName, singletonObject);
            }
        }
        <span class="hljs-keyword">return</span> singletonObject;
    }
}
</code></pre><p>注意这里做了很重要的一步：如果当前准备创建的Bean还没有在IOC容器中，就标记一下它：</p>
<h4 class="heading">11.3.1 beforeSingletonCreation</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeSingletonCreation</span><span class="hljs-params">(String beanName)</span> </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-keyword">this</span>.singletonsCurrentlyInCreation.add(beanName)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);
    }
}
</code></pre><p>注意if的判断结构中，有一个 <code>this.singletonsCurrentlyInCreation.add(beanName)</code> ，它的作用就是把当前准备创建的beanName放入 <code>singletonsCurrentlyInCreation</code> 中。它的作用是解决循环依赖，咱下一篇专门来解释循环依赖的处理。</p>
<h3 class="heading">11.4 createBean</h3>
<p>注意跳转到的类：<strong><code>AbstractAutowireCapableBeanFactory</code></strong></p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span>
        <span class="hljs-keyword">throws</span> BeanCreationException </span>{

    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
        logger.debug(<span class="hljs-string">"Creating instance of bean '"</span> + beanName + <span class="hljs-string">"'"</span>);
    }
    RootBeanDefinition mbdToUse = mbd;

    <span class="hljs-comment">// Make sure bean class is actually resolved at this point, and</span>
    <span class="hljs-comment">// clone the bean definition in case of a dynamically resolved Class</span>
    <span class="hljs-comment">// which cannot be stored in the shared merged bean definition.</span>
    <span class="hljs-comment">// 先拿到这个Bean的定义信息，获取Bean的类型</span>
    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
    <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-keyword">null</span>) {
        mbdToUse = <span class="hljs-keyword">new</span> RootBeanDefinition(mbd);
        mbdToUse.setBeanClass(resolvedClass);
    }

    <span class="hljs-comment">// Prepare method overrides.</span>
    <span class="hljs-comment">// 方法重写的准备工作</span>
    <span class="hljs-comment">// 利用反射，对该Bean对应类及其父类的方法定义进行获取和加载，确保能够正确实例化出该对象</span>
    <span class="hljs-keyword">try</span> {
        mbdToUse.prepareMethodOverrides();
    }
    <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
                beanName, <span class="hljs-string">"Validation of method overrides failed"</span>, ex);
    }

    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span>
        <span class="hljs-comment">// 11.5 给BeanPostProcessors一个机会，来返回代理而不是目标bean实例</span>
        <span class="hljs-comment">// 这个步骤是确保可以创建的是被增强的代理对象而不是原始对象（AOP）</span>
        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
        <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">//如果动态代理创建完毕，将直接返回该Bean</span>
            <span class="hljs-keyword">return</span> bean;
        }
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,
                <span class="hljs-string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);
    }

    <span class="hljs-comment">// 如果不需要创建动态代理对象，则执行下面的doCreateBean</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 11.6 doCreateBean</span>
        Object beanInstance = doCreateBean(beanName, mbdToUse, args);
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Finished creating instance of bean '"</span> + beanName + <span class="hljs-string">"'"</span>);
        }
        <span class="hljs-keyword">return</span> beanInstance;
    }
    <span class="hljs-keyword">catch</span> (BeanCreationException ex) {
        <span class="hljs-comment">// A previously detected exception with proper bean creation context already...</span>
        <span class="hljs-keyword">throw</span> ex;
    }
    <span class="hljs-keyword">catch</span> (ImplicitlyAppearedSingletonException ex) {
        <span class="hljs-comment">// An IllegalStateException to be communicated up to DefaultSingletonBeanRegistry...</span>
        <span class="hljs-keyword">throw</span> ex;
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">"Unexpected exception during bean creation"</span>, ex);
    }
}
</code></pre><p>这段源码中重要的部分已经标注了注释，这里面两个重要的部分：<strong>AOP的入口</strong>，<strong>真正创建Bean的入口</strong>。</p>
<h3 class="heading">11.5 resolveBeforeInstantiation：AOP</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">resolveBeforeInstantiation</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> </span>{
    Object bean = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
        <span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);
            <span class="hljs-keyword">if</span> (targetType != <span class="hljs-keyword">null</span>) {
                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
                <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) {
                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
                }
            }
        }
        mbd.beforeInstantiationResolved = (bean != <span class="hljs-keyword">null</span>);
    }
    <span class="hljs-keyword">return</span> bean;
}
</code></pre><p><strong><code>InstantiationAwareBeanPostProcessor</code></strong> 是 <code>BeanPostProcessor</code> 的子接口，它的文档注释：</p>
<blockquote>
<p>Subinterface of BeanPostProcessor that adds a before-instantiation callback, and a callback after instantiation but before explicit properties are set or autowiring occurs.
Typically used to suppress default instantiation for specific target beans, for example to create proxies with special TargetSources (pooling targets, lazily initializing targets, etc), or to implement additional injection strategies such as field injection.
NOTE: This interface is a special purpose interface, mainly for internal use within the framework. It is recommended to implement the plain BeanPostProcessor interface as far as possible, or to derive from InstantiationAwareBeanPostProcessorAdapter in order to be shielded from extensions to this interface.</p>
<p><code>BeanPostProcessor</code> 的子接口，它添加实例化之前的回调，以及在实例化之后但在设置显式属性或发生自动装配之前的回调。</p>
<p>通常用于抑制特定目标Bean的默认实例化，例如创建具有特殊 <code>TargetSource</code> 的代理（池目标，延迟初始化目标等），或实现其他注入策略，例如字段注入。</p>
<p>注意：此接口是专用接口，主要供框架内部使用。建议尽可能实现普通的 <code>BeanPostProcessor</code> 接口，或从 <code>InstantiationAwareBeanPostProcessorAdapter</code> 派生，以免对该接口进行扩展。</p>
</blockquote>
<p>划重点：<strong>抑制特定目标Bean的默认实例化</strong>。也就是说这个接口对应的部分是真正的<strong>AOP创建代理对象</strong>的部分！</p>
<p>关于AOP的部分，后面有专门的篇章来分析AOP的原理，此处先跳过。</p>
<h3 class="heading">11.6 doCreateBean</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> @Nullable Object[] args)</span>
        <span class="hljs-keyword">throws</span> BeanCreationException </span>{

    <span class="hljs-comment">// Instantiate the bean.</span>
    <span class="hljs-comment">// 实例化Bean，并创建一个BeanWrapper，对Bean进行包装</span>
    BeanWrapper instanceWrapper = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">if</span> (mbd.isSingleton()) {
        instanceWrapper = <span class="hljs-keyword">this</span>.factoryBeanInstanceCache.remove(beanName);
    }
    <span class="hljs-comment">// 确保已经实例化的Bean中没有当前要创建的bean，而且不是工厂Bean，才可以开始创建</span>
    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 11.6.1 createBeanInstance</span>
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }
    <span class="hljs-keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();
    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
    <span class="hljs-keyword">if</span> (beanType != NullBean.class) {
        mbd.resolvedTargetType = beanType;
    }

    <span class="hljs-comment">// Allow post-processors to modify the merged bean definition.</span>
    <span class="hljs-comment">// MergedBeanDefinitionPostProcessor可以修改Bean的定义</span>
    <span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) {
        <span class="hljs-keyword">if</span> (!mbd.postProcessed) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 这个方法只允许MergedBeanDefinitionPostProcessor执行</span>
                <span class="hljs-comment">// MergedBeanDefinitionPostProcessor也是BeanPostProcessor的子接口，之前介绍过了</span>
                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            }
            <span class="hljs-keyword">catch</span> (Throwable ex) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,
                        <span class="hljs-string">"Post-processing of merged bean definition failed"</span>, ex);
            }
            mbd.postProcessed = <span class="hljs-keyword">true</span>;
        }
    }

    <span class="hljs-comment">// Eagerly cache singletons to be able to resolve circular references</span>
    <span class="hljs-comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span>
    <span class="hljs-comment">// 缓存单例对象，以便能够解析循环引用，甚至在生命周期接口(如BeanFactoryAware)触发时也是如此</span>
    <span class="hljs-keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences &amp;&amp;
            isSingletonCurrentlyInCreation(beanName));
    <span class="hljs-keyword">if</span> (earlySingletonExposure) {
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Eagerly caching bean '"</span> + beanName +
                    <span class="hljs-string">"' to allow for resolving potential circular references"</span>);
        }
        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
    }

    <span class="hljs-comment">// Initialize the bean instance.</span>
    <span class="hljs-comment">// 给Bean赋值</span>
    Object exposedObject = bean;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 11.6.2 populateBean：属性赋值和自动注入</span>
        populateBean(beanName, mbd, instanceWrapper);
        <span class="hljs-comment">// 11.6.3 initializeBean：初始化Bean</span>
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
            <span class="hljs-keyword">throw</span> (BeanCreationException) ex;
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                    mbd.getResourceDescription(), beanName, <span class="hljs-string">"Initialization of bean failed"</span>, ex);
        }
    }

    <span class="hljs-comment">// 又获取那个单例Bean，前面已经创建好了，但还没有缓存到IOC容器中，所以这里仍然返回null，故这部分是会跳过的</span>
    <span class="hljs-keyword">if</span> (earlySingletonExposure) {
        Object earlySingletonReference = getSingleton(beanName, <span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (exposedObject == bean) {
                exposedObject = earlySingletonReference;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
                String[] dependentBeans = getDependentBeans(beanName);
                Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);
                <span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) {
                    <span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                        actualDependentBeans.add(dependentBean);
                    }
                }
                <span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName,
                            <span class="hljs-string">"Bean with name '"</span> + beanName + <span class="hljs-string">"' has been injected into other beans ["</span> +
                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                            <span class="hljs-string">"] in its raw version as part of a circular reference, but has eventually been "</span> +
                            <span class="hljs-string">"wrapped. This means that said other beans do not use the final version of the "</span> +
                            <span class="hljs-string">"bean. This is often the result of over-eager type matching - consider using "</span> +
                            <span class="hljs-string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);
                }
            }
        }
    }

    <span class="hljs-comment">// Register bean as disposable.</span>
    <span class="hljs-comment">// 注册Bean的销毁方法，销毁方法在IOC容器关闭后再销毁</span>
    <span class="hljs-keyword">try</span> {
        registerDisposableBeanIfNecessary(beanName, bean, mbd);
    }
    <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                mbd.getResourceDescription(), beanName, <span class="hljs-string">"Invalid destruction signature"</span>, ex);
    }

    <span class="hljs-keyword">return</span> exposedObject;
}
</code></pre><p>源码中发现Bean的创建需要几个重要的步骤：</p>
<ol>
<li>createBeanInstance：创建Bean对象</li>
<li>addSingletonFactory：Bean放入缓存（涉及到循环依赖，下一篇详细介绍）</li>
<li>populateBean：属性复制和自动注入</li>
<li>initializeBean：初始化后处理</li>
</ol>
<h4 class="heading">11.6.1 【真正实例化】createBeanInstance</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title">createBeanInstance</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>{
    <span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span>
    <span class="hljs-comment">// 解析Bean的类型</span>
    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);

    <span class="hljs-keyword">if</span> (beanClass != <span class="hljs-keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,
                <span class="hljs-string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());
    }

    <span class="hljs-comment">// 11.6.1.1 判断是否有用于创建bean实例的特殊的回调方法</span>
    <span class="hljs-comment">// 如果存在，会使用特殊的callback回调方法，通过这个callback创建bean</span>
    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();
    <span class="hljs-keyword">if</span> (instanceSupplier != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);
    }

    <span class="hljs-comment">// 11.6.1.2 判断是否有工厂方法，如果存在，会尝试调用该Bean定义信息中的工厂方法来获取实例</span>
    <span class="hljs-comment">// 如果使用注解方式注册的Bean，会跳到该Bean的注册方法中（配置类中定义的那些Bean）</span>
    <span class="hljs-keyword">if</span> (mbd.getFactoryMethodName() != <span class="hljs-keyword">null</span>)  {
        <span class="hljs-keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);
    }

    <span class="hljs-comment">// Shortcut when re-creating the same bean...</span>
    <span class="hljs-comment">// 一个类可能有多个构造器，所以Spring得根据参数个数、类型确定需要调用的构造器</span>
    <span class="hljs-keyword">boolean</span> resolved = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">boolean</span> autowireNecessary = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span> (args == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) {
            <span class="hljs-keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// 在使用构造器创建实例后，会将解析过后确定下来的构造器或工厂方法保存在缓存中，避免再次创建相同bean时再次解析，导致循环依赖</span>
                resolved = <span class="hljs-keyword">true</span>;
                autowireNecessary = mbd.constructorArgumentsResolved;
            }
        }
    }
    
    <span class="hljs-keyword">if</span> (resolved) {
        <span class="hljs-comment">// 构造器注入创建Bean</span>
        <span class="hljs-keyword">if</span> (autowireNecessary) {
            <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 普通创建</span>
            <span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);
        }
    }

    <span class="hljs-comment">// Need to determine the constructor...</span>
    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
    <span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span> ||
            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
        <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);
    }

    <span class="hljs-comment">// No special handling: simply use no-arg constructor.</span>
    <span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);
}
</code></pre><p>这里面的几个重要环节简单总结：</p>
<h5 class="heading">11.6.1.1 getInstanceSupplier：特殊的callback回调方法</h5>
<p>这两个方法来自 <code>AbstractBeanDefinition</code>：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInstanceSupplier</span><span class="hljs-params">(@Nullable Supplier&lt;?&gt; instanceSupplier)</span> </span>{
    <span class="hljs-keyword">this</span>.instanceSupplier = instanceSupplier;
}

<span class="hljs-meta">@Nullable</span>
<span class="hljs-keyword">public</span> Supplier&lt;?&gt; getInstanceSupplier() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.instanceSupplier;
}
</code></pre><p>它只是简单地get和set而已，那它这个 <code>Supplier</code> 又是从哪里来的呢？借助IDEA，发现在 <code>GenericApplicationContext</code> 中有一个调用：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(@Nullable String beanName, Class&lt;T&gt; beanClass,
        @Nullable Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> </span>{

    ClassDerivedBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> ClassDerivedBeanDefinition(beanClass);
    <span class="hljs-keyword">if</span> (supplier != <span class="hljs-keyword">null</span>) {
        beanDefinition.setInstanceSupplier(supplier);
    }
    <span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) {
        customizer.customize(beanDefinition);
    }

    String nameToUse = (beanName != <span class="hljs-keyword">null</span> ? beanName : beanClass.getName());
    registerBeanDefinition(nameToUse, beanDefinition);
}
</code></pre><p>这个方法我们还是比较熟悉的，它用来向 <code>BeanFactory</code> 中注册 Bean 的定义信息。这个方法又是从哪里调用的呢？继续借助IDEA查看：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/16/16dd4bf8577947bd~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>发现在 <code>GenericApplicationContext</code> 中只有这一个地方有传入 supplier，其余的地方都是null。再索引这个方法的调用位置，发现跟上面图中的 <code>DefaultControllerSpec</code> 位置差不多了，都在这个类中。而这个类所在包是 <code>org.springframework.test</code>，是测试包中，我们不作关心。</p>
<p>那到这里来看，这个 <code>Supplier</code> 通常就是null了。</p>
<h5 class="heading">11.6.1.2 instantiateUsingFactoryMethod：工厂方法</h5>
<p>这个工厂方法的由来，需要我们回到整个 <code>refresh</code> 方法的第5步：<code>invokeBeanFactoryPostProcessors</code> 。还记得当时在处理 <code>BeanFactory</code> 时回调了一组 <code>BeanDefinitionRegistryPostProcessor</code> 吗？它执行了一个很关键的后置处理器：<code>ConfigurationClassPostProcessor</code> 。不太记得的小伙伴请先翻回<strong>第12篇5.2章节</strong>回顾一下这部分，重要的环节是5.2.4章节。</p>
<p>在5.2.4章节中介绍了 <code>@Bean</code> 注解标注的方法的解析过程，这里面就有一个工厂方法的设置。那回到 <code>doCreateBean</code> 中，这里的 <code>instantiateUsingFactoryMethod</code> 方法就是对这种被 <code>@Bean</code> 注解标注的Bean进行创建。这个方法比较简单：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title">instantiateUsingFactoryMethod</span><span class="hljs-params">(
        String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs)</span> </span>{

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConstructorResolver(<span class="hljs-keyword">this</span>).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);
}
</code></pre><p>从方法名就可以很容易看出它是借助一个构造器处理器，来执行这个工厂方法中定义的Bean。这个方法的内容实在是太长了（220行+），我把关键的部分标注上注释，小伙伴们大概看一下整体思路就可以了：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanWrapper <span class="hljs-title">instantiateUsingFactoryMethod</span><span class="hljs-params">(
        String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs)</span> </span>{

    <span class="hljs-comment">// 构造BeanWrapper</span>
    BeanWrapperImpl bw = <span class="hljs-keyword">new</span> BeanWrapperImpl();
    <span class="hljs-keyword">this</span>.beanFactory.initBeanWrapper(bw);

    Object factoryBean;
    Class&lt;?&gt; factoryClass;
    <span class="hljs-keyword">boolean</span> isStatic;

    <span class="hljs-comment">// 获取工厂方法名称</span>
    String factoryBeanName = mbd.getFactoryBeanName();
    <span class="hljs-keyword">if</span> (factoryBeanName != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (factoryBeanName.equals(beanName)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,
                    <span class="hljs-string">"factory-bean reference points back to the same bean definition"</span>);
        }
        <span class="hljs-comment">// 如果工厂方法不为空，则获取工厂实例，并标记该工厂方法不是静态方法</span>
        factoryBean = <span class="hljs-keyword">this</span>.beanFactory.getBean(factoryBeanName);
        <span class="hljs-keyword">if</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.beanFactory.containsSingleton(beanName)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ImplicitlyAppearedSingletonException();
        }
        factoryClass = factoryBean.getClass();
        isStatic = <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// It's a static factory method on the bean class.</span>
        <span class="hljs-comment">// 如果获取不到工厂方法名，则这应该是一个静态工厂，需要提供完整的工厂全限定类名，否则会抛出异常</span>
        <span class="hljs-keyword">if</span> (!mbd.hasBeanClass()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,
                    <span class="hljs-string">"bean definition declares neither a bean class nor a factory-bean reference"</span>);
        }
        factoryBean = <span class="hljs-keyword">null</span>;
        factoryClass = mbd.getBeanClass();
        isStatic = <span class="hljs-keyword">true</span>;
    }

    Method factoryMethodToUse = <span class="hljs-keyword">null</span>;
    ArgumentsHolder argsHolderToUse = <span class="hljs-keyword">null</span>;
    Object[] argsToUse = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">// 这个explicitArgs是从这个方法的参数中传过来的，它是从getBean方法中传过来的</span>
    <span class="hljs-comment">// 默认情况下getBean只有BeanName（AbstractBeanFactory的getBean(String name)方法），故这里为null</span>
    <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-keyword">null</span>) {
        argsToUse = explicitArgs;
    }
    <span class="hljs-keyword">else</span> {
        Object[] argsToResolve = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) {
            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;
            <span class="hljs-keyword">if</span> (factoryMethodToUse != <span class="hljs-keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) {
                <span class="hljs-comment">// Found a cached factory method...</span>
                argsToUse = mbd.resolvedConstructorArguments;
                <span class="hljs-keyword">if</span> (argsToUse == <span class="hljs-keyword">null</span>) {
                    argsToResolve = mbd.preparedConstructorArguments;
                }
            }
        }
        <span class="hljs-keyword">if</span> (argsToResolve != <span class="hljs-keyword">null</span>) {
            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, <span class="hljs-keyword">true</span>);
        }
    }

    <span class="hljs-comment">// 上面的东西统统没有，进入下面的结构体中</span>
    <span class="hljs-keyword">if</span> (factoryMethodToUse == <span class="hljs-keyword">null</span> || argsToUse == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// Need to determine the factory method...</span>
        <span class="hljs-comment">// Try all methods with this name to see if they match the given arguments.</span>
        factoryClass = ClassUtils.getUserClass(factoryClass);

        <span class="hljs-comment">// 获取配置类中所有的方法（包括父类），称为候选方法</span>
        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);
        List&lt;Method&gt; candidateList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (Method candidate : rawCandidates) {
            <span class="hljs-keyword">if</span> (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) {
                candidateList.add(candidate);
            }
        }

        <span class="hljs-comment">// 因为@Bean只对当前要创建的Bean标注了一次，所以这里candidateList的大小必为1</span>
        <span class="hljs-keyword">if</span> (candidateList.size() == <span class="hljs-number">1</span> &amp;&amp; explicitArgs == <span class="hljs-keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) {
            Method uniqueCandidate = candidateList.get(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="hljs-number">0</span>) {
                mbd.factoryMethodToIntrospect = uniqueCandidate;
                <span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) {
                    mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;
                    mbd.constructorArgumentsResolved = <span class="hljs-keyword">true</span>;
                    mbd.resolvedConstructorArguments = EMPTY_ARGS;
                }
                bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS));
                <span class="hljs-keyword">return</span> bw;
            }
        }

        <span class="hljs-comment">// 按照构造方法参数的数量降序排序</span>
        Method[] candidates = candidateList.toArray(<span class="hljs-keyword">new</span> Method[<span class="hljs-number">0</span>]);
        AutowireUtils.sortFactoryMethods(candidates);

        ConstructorArgumentValues resolvedValues = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">boolean</span> autowiring = (mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);
        <span class="hljs-keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;
        Set&lt;Method&gt; ambiguousFactoryMethods = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">int</span> minNrOfArgs;
        <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-keyword">null</span>) {
            minNrOfArgs = explicitArgs.length;
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// We don't have arguments passed in programmatically, so we need to resolve the</span>
            <span class="hljs-comment">// arguments specified in the constructor arguments held in the bean definition.</span>
            <span class="hljs-comment">// 没有以编程方式在getBean方法中传递参数，因此需要解析在bean定义中保存的构造函数参数中指定的参数</span>
            <span class="hljs-keyword">if</span> (mbd.hasConstructorArgumentValues()) {
                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
                resolvedValues = <span class="hljs-keyword">new</span> ConstructorArgumentValues();
                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
            }
            <span class="hljs-keyword">else</span> {
                minNrOfArgs = <span class="hljs-number">0</span>;
            }
        }

        LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">for</span> (Method candidate : candidates) {
            <span class="hljs-comment">// 解析被@Bean标注的方法的参数</span>
            Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();

            <span class="hljs-keyword">if</span> (paramTypes.length &gt;= minNrOfArgs) {
                ArgumentsHolder argsHolder;

                <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-keyword">null</span>) {
                    <span class="hljs-comment">// Explicit arguments given -&gt; arguments length must match exactly.</span>
                    <span class="hljs-keyword">if</span> (paramTypes.length != explicitArgs.length) {
                        <span class="hljs-keyword">continue</span>;
                    }
                    argsHolder = <span class="hljs-keyword">new</span> ArgumentsHolder(explicitArgs);
                }
                <span class="hljs-comment">// getBean中没有传入参数，这里需要解析构造方法中的参数</span>
                <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// Resolved constructor arguments: type conversion and/or autowiring necessary.</span>
                    <span class="hljs-comment">// 解决的构造函数参数：类型转换、自动装配是必需的</span>
                    <span class="hljs-keyword">try</span> {
                        String[] paramNames = <span class="hljs-keyword">null</span>;
                        ParameterNameDiscoverer pnd = <span class="hljs-keyword">this</span>.beanFactory.getParameterNameDiscoverer();
                        <span class="hljs-keyword">if</span> (pnd != <span class="hljs-keyword">null</span>) {
                            paramNames = pnd.getParameterNames(candidate);
                        }
                        <span class="hljs-comment">// 在已经解析的构造函数参数值的情况下，创建一个参数持有者对象</span>
                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw,
                                paramTypes, paramNames, candidate, autowiring, candidates.length == <span class="hljs-number">1</span>);
                    }
                    <span class="hljs-keyword">catch</span> (UnsatisfiedDependencyException ex) {
                        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
                            logger.trace(<span class="hljs-string">"Ignoring factory method ["</span> + candidate + <span class="hljs-string">"] of bean '"</span> + beanName + <span class="hljs-string">"': "</span> + ex);
                        }
                        <span class="hljs-comment">// Swallow and try next overloaded factory method.</span>
                        <span class="hljs-keyword">if</span> (causes == <span class="hljs-keyword">null</span>) {
                            causes = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
                        }
                        causes.add(ex);
                        <span class="hljs-keyword">continue</span>;
                    }
                }

                <span class="hljs-comment">// 【扩展】解析构造方法的参数时使用严格模式还是宽松模式</span>
                <span class="hljs-keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?
                        argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
                <span class="hljs-comment">// Choose this factory method if it represents the closest match.</span>
                <span class="hljs-keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) {
                    factoryMethodToUse = candidate;
                    argsHolderToUse = argsHolder;
                    argsToUse = argsHolder.arguments;
                    minTypeDiffWeight = typeDiffWeight;
                    ambiguousFactoryMethods = <span class="hljs-keyword">null</span>;
                }
                <span class="hljs-comment">// Find out about ambiguity: In case of the same type difference weight</span>
                <span class="hljs-comment">// for methods with the same number of parameters, collect such candidates</span>
                <span class="hljs-comment">// and eventually raise an ambiguity exception.</span>
                <span class="hljs-comment">// However, only perform that check in non-lenient constructor resolution mode,</span>
                <span class="hljs-comment">// and explicitly ignore overridden methods (with the same parameter signature).</span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (factoryMethodToUse != <span class="hljs-keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;
                        !mbd.isLenientConstructorResolution() &amp;&amp;
                        paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;
                        !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {
                    <span class="hljs-keyword">if</span> (ambiguousFactoryMethods == <span class="hljs-keyword">null</span>) {
                        ambiguousFactoryMethods = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
                        ambiguousFactoryMethods.add(factoryMethodToUse);
                    }
                    ambiguousFactoryMethods.add(candidate);
                }
            }
        }

        <span class="hljs-comment">// 如果发现没有可执行的工厂方法，进行一系列检查后可能会抛出异常</span>
        <span class="hljs-keyword">if</span> (factoryMethodToUse == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (causes != <span class="hljs-keyword">null</span>) {
                UnsatisfiedDependencyException ex = causes.removeLast();
                <span class="hljs-keyword">for</span> (Exception cause : causes) {
                    <span class="hljs-keyword">this</span>.beanFactory.onSuppressedException(cause);
                }
                <span class="hljs-keyword">throw</span> ex;
            }
            List&lt;String&gt; argTypes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(minNrOfArgs);
            <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">for</span> (Object arg : explicitArgs) {
                    argTypes.add(arg != <span class="hljs-keyword">null</span> ? arg.getClass().getSimpleName() : <span class="hljs-string">"null"</span>);
                }
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (resolvedValues != <span class="hljs-keyword">null</span>) {
                Set&lt;ValueHolder&gt; valueHolders = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount());
                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());
                valueHolders.addAll(resolvedValues.getGenericArgumentValues());
                <span class="hljs-keyword">for</span> (ValueHolder value : valueHolders) {
                    String argType = (value.getType() != <span class="hljs-keyword">null</span> ? ClassUtils.getShortName(value.getType()) :
                            (value.getValue() != <span class="hljs-keyword">null</span> ? value.getValue().getClass().getSimpleName() : <span class="hljs-string">"null"</span>));
                    argTypes.add(argType);
                }
            }
            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,
                    <span class="hljs-string">"No matching factory method found: "</span> +
                    (mbd.getFactoryBeanName() != <span class="hljs-keyword">null</span> ?
                        <span class="hljs-string">"factory bean '"</span> + mbd.getFactoryBeanName() + <span class="hljs-string">"'; "</span> : <span class="hljs-string">""</span>) +
                    <span class="hljs-string">"factory method '"</span> + mbd.getFactoryMethodName() + <span class="hljs-string">"("</span> + argDesc + <span class="hljs-string">")'. "</span> +
                    <span class="hljs-string">"Check that a method with the specified name "</span> +
                    (minNrOfArgs &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">"and arguments "</span> : <span class="hljs-string">""</span>) +
                    <span class="hljs-string">"exists and that it is "</span> +
                    (isStatic ? <span class="hljs-string">"static"</span> : <span class="hljs-string">"non-static"</span>) + <span class="hljs-string">"."</span>);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">void</span>.class == factoryMethodToUse.getReturnType()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,
                    <span class="hljs-string">"Invalid factory method '"</span> + mbd.getFactoryMethodName() +
                    <span class="hljs-string">"': needs to have a non-void return type!"</span>);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ambiguousFactoryMethods != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,
                    <span class="hljs-string">"Ambiguous factory method matches found in bean '"</span> + beanName + <span class="hljs-string">"' "</span> +
                    <span class="hljs-string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): "</span> +
                    ambiguousFactoryMethods);
        }

        <span class="hljs-keyword">if</span> (explicitArgs == <span class="hljs-keyword">null</span> &amp;&amp; argsHolderToUse != <span class="hljs-keyword">null</span>) {
            mbd.factoryMethodToIntrospect = factoryMethodToUse;
            argsHolderToUse.storeCache(mbd, factoryMethodToUse);
        }
    }

    Assert.state(argsToUse != <span class="hljs-keyword">null</span>, <span class="hljs-string">"Unresolved factory method arguments"</span>);
    <span class="hljs-comment">// 实例化Bean，包装BeanWraper</span>
    bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, factoryMethodToUse, argsToUse));
    <span class="hljs-keyword">return</span> bw;
}
</code></pre><p>源码好长，但总结下来就干了一件事：确定工厂方法 + 实例化、包装 <code>BeanWrapper</code> 。</p>
<p>源码中提到了一个比较有意思的概念：<strong>解析构造方法参数的严格模式/宽松模式</strong>。</p>
<h5 class="heading">11.6.1.3 【扩展】严格模式/宽松模式</h5>
<p>咱们单独把这一段摘出来：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?
            argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
    <span class="hljs-comment">// Choose this factory method if it represents the closest match.</span>
    <span class="hljs-keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) {
        factoryMethodToUse = candidate;
        argsHolderToUse = argsHolder;
        argsToUse = argsHolder.arguments;
        minTypeDiffWeight = typeDiffWeight;
        ambiguousFactoryMethods = <span class="hljs-keyword">null</span>;
    }
</code></pre><p>默认情况下 <code>lenientConstructorResolution</code> 的值为<strong>true</strong>， 为严格模式。下面先看一眼这两种模式下的计算规则：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// 严格模式</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTypeDifferenceWeight</span><span class="hljs-params">(Class&lt;?&gt;[] paramTypes)</span> </span>{
    <span class="hljs-comment">// If valid arguments found, determine type difference weight.</span>
    <span class="hljs-comment">// Try type difference weight on both the converted arguments and</span>
    <span class="hljs-comment">// the raw arguments. If the raw weight is better, use it.</span>
    <span class="hljs-comment">// Decrease raw weight by 1024 to prefer it over equal converted weight.</span>
    <span class="hljs-comment">// 如果找到有效的参数，请确定类型差异权重。尝试对转换后的参数和原始参数都使用类型差异权重。</span>
    <span class="hljs-comment">// 如果原始权重更好，请使用它。将原始权重减少1024，以使其优于相等的转换权重。</span>
    
    <span class="hljs-comment">// 先拿转换之后的参数对比</span>
    <span class="hljs-keyword">int</span> typeDiffWeight = MethodInvoker.getTypeDifferenceWeight(paramTypes, <span class="hljs-keyword">this</span>.arguments);
    <span class="hljs-comment">// 再拿原始参数对比</span>
    <span class="hljs-keyword">int</span> rawTypeDiffWeight = MethodInvoker.getTypeDifferenceWeight(paramTypes, <span class="hljs-keyword">this</span>.rawArguments) - <span class="hljs-number">1024</span>;
    <span class="hljs-comment">// 由值确定选哪一个，值越小越接近参数声明类型</span>
    <span class="hljs-keyword">return</span> (rawTypeDiffWeight &lt; typeDiffWeight ? rawTypeDiffWeight : typeDiffWeight);
}

<span class="hljs-comment">// 宽松模式</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAssignabilityWeight</span><span class="hljs-params">(Class&lt;?&gt;[] paramTypes)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; paramTypes.length; i++) {
        <span class="hljs-keyword">if</span> (!ClassUtils.isAssignableValue(paramTypes[i], <span class="hljs-keyword">this</span>.arguments[i])) {
            <span class="hljs-keyword">return</span> Integer.MAX_VALUE;
        }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; paramTypes.length; i++) {
        <span class="hljs-keyword">if</span> (!ClassUtils.isAssignableValue(paramTypes[i], <span class="hljs-keyword">this</span>.rawArguments[i])) {
            <span class="hljs-keyword">return</span> Integer.MAX_VALUE - <span class="hljs-number">512</span>;
        }
    }
    <span class="hljs-keyword">return</span> Integer.MAX_VALUE - <span class="hljs-number">1024</span>;
}
</code></pre><ul>
<li>严格模式下，必须要求参数类型完全一致
<ul>
<li>这个方法的实现涉及到算法，不作细致研究，小伙伴们了解即可，感兴趣的小伙伴可以Debug运行看一下机制。</li>
</ul>
</li>
<li>宽松模式，只要参数是声明类型或子类型即可
<ul>
<li>如果使用宽松模式，会出现一个问题：如果构造方法中传入两个接口，而这两个接口分别有两个实现类，此时IOC容器会觉得这两个对象都可以放到这两个参数中，造成权重一致，出现<strong>构造方法歧义</strong>。</li>
</ul>
</li>
</ul>
<h4 class="heading">11.6.2 populateBean：属性赋值和自动注入</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>{
    <span class="hljs-keyword">if</span> (bw == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (mbd.hasPropertyValues()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                    mbd.getResourceDescription(), beanName, <span class="hljs-string">"Cannot apply property values to null instance"</span>);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Skip property population phase for null instance.</span>
            <span class="hljs-keyword">return</span>;
        }
    }

    <span class="hljs-comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span>
    <span class="hljs-comment">// state of the bean before properties are set. This can be used, for example,</span>
    <span class="hljs-comment">// to support styles of field injection.</span>
    <span class="hljs-keyword">boolean</span> continueWithPropertyPopulation = <span class="hljs-keyword">true</span>;

    <span class="hljs-comment">// 执行所有InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法</span>
    <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
        <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {
            <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) {
                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                <span class="hljs-keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                    continueWithPropertyPopulation = <span class="hljs-keyword">false</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
    }

    <span class="hljs-keyword">if</span> (!continueWithPropertyPopulation) {
        <span class="hljs-keyword">return</span>;
    }

    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="hljs-keyword">null</span>);

    <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
        MutablePropertyValues newPvs = <span class="hljs-keyword">new</span> MutablePropertyValues(pvs);

        <span class="hljs-comment">// Add property values based on autowire by name if applicable.</span>
        <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
            autowireByName(beanName, mbd, bw, newPvs);
        }

        <span class="hljs-comment">// Add property values based on autowire by type if applicable.</span>
        <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
            autowireByType(beanName, mbd, bw, newPvs);
        }

        pvs = newPvs;
    }

    <span class="hljs-keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
    <span class="hljs-keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);

    <span class="hljs-comment">// 11.6.2.1 又拿了那些InstantiationAwareBeanPostProcessor，不过这次执行的方法不同：postProcessPropertyValues</span>
    <span class="hljs-comment">// 这些InstantiationAwareBeanPostProcessor其中有一个能实现 @Autowired、@Value 等注入</span>
    <span class="hljs-keyword">if</span> (hasInstAwareBpps || needsDepCheck) {
        <span class="hljs-keyword">if</span> (pvs == <span class="hljs-keyword">null</span>) {
            pvs = mbd.getPropertyValues();
        }
        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
        <span class="hljs-keyword">if</span> (hasInstAwareBpps) {
            <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {
                <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) {
                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
                    <span class="hljs-keyword">if</span> (pvs == <span class="hljs-keyword">null</span>) {
                        <span class="hljs-keyword">return</span>;
                    }
                }
            }
        }
        <span class="hljs-keyword">if</span> (needsDepCheck) {
            checkDependencies(beanName, mbd, filteredPds, pvs);
        }
    }

    <span class="hljs-comment">// 11.6.2. 使用setter方式，给Bean赋值和自动注入</span>
    <span class="hljs-keyword">if</span> (pvs != <span class="hljs-keyword">null</span>) {
        applyPropertyValues(beanName, mbd, bw, pvs);
    }
}
</code></pre><p>在源码中，通过那一组 <code>InstantiationAwareBeanPostProcessor</code> 就可以实现 <code>@Autowired</code> 、<code>@Value</code> 等自动注入。</p>
<p>如果是通过 <code>setter</code> 的方式进行自动注入，会走最后的一个if结构，调用 <code>applyPropertyValues</code> 方法。</p>
<p>下面分别分析这两种注入机制。</p>
<h5 class="heading">11.6.2.1 @Autowired 的自动注入</h5>
<p>咱在之前13篇的6.1.1章节中介绍过一个后置处理器：<strong><code>AutowiredAnnotationBeanPostProcessor</code></strong> 。咱之前也说过，它就是实现 <code>@Autowired</code> 的自动注入。</p>
<p>它的类定义：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutowiredAnnotationBeanPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InstantiationAwareBeanPostProcessorAdapter</span>
		<span class="hljs-keyword">implements</span> <span class="hljs-title">MergedBeanDefinitionPostProcessor</span>, <span class="hljs-title">PriorityOrdered</span>, <span class="hljs-title">BeanFactoryAware</span>
<span class="hljs-title">public</span> <span class="hljs-title">abstract</span> <span class="hljs-title">class</span> <span class="hljs-title">InstantiationAwareBeanPostProcessorAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmartInstantiationAwareBeanPostProcessor</span>
<span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">SmartInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span>
</span></code></pre><p>它集成了 <code>InstantiationAwareBeanPostProcessorAdapter</code> ，而 <code>InstantiationAwareBeanPostProcessorAdapter</code> 又实现了 <code>SmartInstantiationAwareBeanPostProcessor</code> 接口，<code>SmartInstantiationAwareBeanPostProcessor</code> 接口最终继承了 <code>InstantiationAwareBeanPostProcessor</code> 接口。那上面看到的核心回调方法就是 <code>postProcessProperties</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span> </span>{
    InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
    <span class="hljs-keyword">try</span> {
        metadata.inject(bean, beanName, pvs);
    }
    <span class="hljs-keyword">catch</span> (BeanCreationException ex) {
        <span class="hljs-keyword">throw</span> ex;
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"Injection of autowired dependencies failed"</span>, ex);
    }
    <span class="hljs-keyword">return</span> pvs;
}
</code></pre><p>第一句咱们之前看过了，知道是构建自动注入的元数据，下面的 <code>inject</code> 方法是真正的自动注入。</p>
<h5 class="heading">11.6.2.2 [Autowired] inject</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    Collection&lt;InjectedElement&gt; checkedElements = <span class="hljs-keyword">this</span>.checkedElements;
    Collection&lt;InjectedElement&gt; elementsToIterate =
            (checkedElements != <span class="hljs-keyword">null</span> ? checkedElements : <span class="hljs-keyword">this</span>.injectedElements);
    <span class="hljs-keyword">if</span> (!elementsToIterate.isEmpty()) {
        <span class="hljs-keyword">for</span> (InjectedElement element : elementsToIterate) {
            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
                logger.trace(<span class="hljs-string">"Processing injected element of bean '"</span> + beanName + <span class="hljs-string">"': "</span> + element);
            }
            element.inject(target, beanName, pvs);
        }
    }
}
</code></pre><p>这里面最底下调了 <code>element.inject</code> 方法。借助IDEA，在打开这个方法时发现这个方法有两个子类重写了这个方法，分别是 <code>AutowiredFieldElement</code> 和 <code>AutowiredMethodElement</code> 。很明显它们是给属性注入和方法注入的。我们以属性注入为例分析（关键源码的注释已标注在源码中）：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    Field field = (Field) <span class="hljs-keyword">this</span>.member;
    Object value;
    <span class="hljs-comment">// 如果这个值在前面的注入中有缓存过，直接取缓存</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cached) {
        value = resolvedCachedArgument(beanName, <span class="hljs-keyword">this</span>.cachedFieldValue);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 没有缓存，要在下面的try块中利用BeanFactory处理依赖关系</span>
        DependencyDescriptor desc = <span class="hljs-keyword">new</span> DependencyDescriptor(field, <span class="hljs-keyword">this</span>.required);
        desc.setContainingClass(bean.getClass());
        Set&lt;String&gt; autowiredBeanNames = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">1</span>);
        Assert.state(beanFactory != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No BeanFactory available"</span>);
        TypeConverter typeConverter = beanFactory.getTypeConverter();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 【关联创建】value应该被找出 / 创建出</span>
            value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
        }
        <span class="hljs-keyword">catch</span> (BeansException ex) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsatisfiedDependencyException(<span class="hljs-keyword">null</span>, beanName, <span class="hljs-keyword">new</span> InjectionPoint(field), ex);
        }
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
            <span class="hljs-comment">// 处理完成后要对这个属性进行缓存</span>
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.cached) {
                <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span> || <span class="hljs-keyword">this</span>.required) {
                    <span class="hljs-keyword">this</span>.cachedFieldValue = desc;
                    <span class="hljs-comment">// 把这个依赖的Bean添加到BeanFactory的依赖关系映射上缓存起来</span>
                    registerDependentBeans(beanName, autowiredBeanNames);
                    <span class="hljs-keyword">if</span> (autowiredBeanNames.size() == <span class="hljs-number">1</span>) {
                        String autowiredBeanName = autowiredBeanNames.iterator().next();
                        <span class="hljs-keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;
                                beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {
                            <span class="hljs-keyword">this</span>.cachedFieldValue = <span class="hljs-keyword">new</span> ShortcutDependencyDescriptor(
                                    desc, autowiredBeanName, field.getType());
                        }
                    }
                }
                <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">this</span>.cachedFieldValue = <span class="hljs-keyword">null</span>;
                }
                <span class="hljs-keyword">this</span>.cached = <span class="hljs-keyword">true</span>;
            }
        }
    }
    <span class="hljs-comment">// 如果找到 / 创建好了value，就给它注入</span>
    <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) {
        ReflectionUtils.makeAccessible(field);
        field.set(bean, value);
    }
}
</code></pre><p>上面的检查完成后，在try块中的核心方法可以用来关联创建被依赖的Bean：<code>beanFactory.resolveDependency</code> 。</p>
<h5 class="heading">11.6.2.3 [Autowired] beanFactory.resolveDependency</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
        @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException </span>{

    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
    <span class="hljs-keyword">if</span> (Optional.class == descriptor.getDependencyType()) {
        <span class="hljs-keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||
            ObjectProvider.class == descriptor.getDependencyType()) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
    }
    <span class="hljs-keyword">else</span> {
        Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
                descriptor, requestingBeanName);
        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) {
            result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
        }
        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre><p>上面的一些if-else结构判断都是检验被标注 <code>@Autowired</code> 注解的属性类型，显然上面的一些类型一般都不用，直接来看下面的最后一个else结构：它调用 <code>doResolveDependency</code> 方法来解决依赖：</p>
<h5 class="heading">11.6.2.4 [Autowired] doResolveDependency</h5>
<p>（核心步骤的注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doResolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String beanName,
        @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException </span>{

    InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 该方法默认是调用DependencyDescriptor的方法，没有子类，默认实现是返回null</span>
        Object shortcut = descriptor.resolveShortcut(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">if</span> (shortcut != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> shortcut;
        }

        Class&lt;?&gt; type = descriptor.getDependencyType();
        <span class="hljs-comment">// 处理@Value注解</span>
        Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
        <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) {
                String strVal = resolveEmbeddedValue((String) value);
                BeanDefinition bd = (beanName != <span class="hljs-keyword">null</span> &amp;&amp; containsBean(beanName) ?
                        getMergedBeanDefinition(beanName) : <span class="hljs-keyword">null</span>);
                value = evaluateBeanDefinitionString(strVal, bd);
            }
            TypeConverter converter = (typeConverter != <span class="hljs-keyword">null</span> ? typeConverter : getTypeConverter());
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());
            }
            <span class="hljs-keyword">catch</span> (UnsupportedOperationException ex) {
                <span class="hljs-comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span>
                <span class="hljs-keyword">return</span> (descriptor.getField() != <span class="hljs-keyword">null</span> ?
                        converter.convertIfNecessary(value, type, descriptor.getField()) :
                        converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
            }
        }

        <span class="hljs-comment">// 处理数组、集合、Map等</span>
        Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
        <span class="hljs-keyword">if</span> (multipleBeans != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> multipleBeans;
        }

        <span class="hljs-comment">// 从现有的已经创建好的Bean实例中找可以匹配到该自动注入的字段上的Bean</span>
        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);
        <span class="hljs-keyword">if</span> (matchingBeans.isEmpty()) {
            <span class="hljs-keyword">if</span> (isRequired(descriptor)) {
                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }

        String autowiredBeanName;
        Object instanceCandidate;

        <span class="hljs-comment">// 如果找到了，超过1个，会决定使用哪个Bean更合适，如果真的分辨不出来，则会抛出异常</span>
        <span class="hljs-keyword">if</span> (matchingBeans.size() &gt; <span class="hljs-number">1</span>) {
            autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
            <span class="hljs-keyword">if</span> (autowiredBeanName == <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
                    <span class="hljs-keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);
                }
                <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span>
                    <span class="hljs-comment">// possibly it was meant to be an empty collection of multiple regular beans</span>
                    <span class="hljs-comment">// (before 4.3 in particular when we didn't even look for collection beans).</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                }
            }
            instanceCandidate = matchingBeans.get(autowiredBeanName);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// We have exactly one match.</span>
            <span class="hljs-comment">// 匹配不到，要走下面的创建流程</span>
            Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();
            autowiredBeanName = entry.getKey();
            instanceCandidate = entry.getValue();
        }

        <span class="hljs-keyword">if</span> (autowiredBeanNames != <span class="hljs-keyword">null</span>) {
            autowiredBeanNames.add(autowiredBeanName);
        }
        <span class="hljs-comment">// 关联创建</span>
        <span class="hljs-keyword">if</span> (instanceCandidate <span class="hljs-keyword">instanceof</span> Class) {
            instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="hljs-keyword">this</span>);
        }
        Object result = instanceCandidate;
        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> NullBean) {
            <span class="hljs-keyword">if</span> (isRequired(descriptor)) {
                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
            }
            result = <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());
        }
        <span class="hljs-keyword">return</span> result;
    }
    <span class="hljs-keyword">finally</span> {
        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
    }
}
</code></pre><p>注意看源码中靠下部分的 <code>descriptor.resolveCandidate(autowiredBeanName, type, this);</code> ，在一开始什么Bean都匹配不到的情况下，Debug发现会来到这里，而这个方法的实现：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveCandidate</span><span class="hljs-params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span>
        <span class="hljs-keyword">throws</span> BeansException </span>{
    <span class="hljs-keyword">return</span> beanFactory.getBean(beanName);
}
</code></pre><p>它回到<strong>getBean</strong>中，开始关联创建。</p>
<p>创建好后，回到 <code>inject</code> 方法：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// 如果找到 / 创建好了value，就给它注入</span>
    <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) {
        ReflectionUtils.makeAccessible(field);
        field.set(bean, value);
    }
</code></pre><p>利用反射注入属性值。至此，可以发现 <code>@Autowired</code> 的自动注入和关联创建流程。</p>
<h5 class="heading">11.6.2.5 [setter] applyPropertyValues</h5>
<p>使用setter方法，前面的一大段都不走了，直接来到最后的 <code>applyPropertyValues</code> 方法。</p>
<p>进入到 <code>applyPropertyValues</code> 方法中（不太关键的部分注释已标注在源码中）：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyPropertyValues</span><span class="hljs-params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>{
    <span class="hljs-comment">// 没有任何要属性赋值/自动注入，直接返回</span>
    <span class="hljs-keyword">if</span> (pvs.isEmpty()) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> &amp;&amp; bw <span class="hljs-keyword">instanceof</span> BeanWrapperImpl) {
        ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());
    }

    MutablePropertyValues mpvs = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">// 需要转换的属性</span>
    List&lt;PropertyValue&gt; original;

    <span class="hljs-keyword">if</span> (pvs <span class="hljs-keyword">instanceof</span> MutablePropertyValues) {
        mpvs = (MutablePropertyValues) pvs;
        <span class="hljs-keyword">if</span> (mpvs.isConverted()) {
            <span class="hljs-comment">// Shortcut: use the pre-converted values as-is.</span>
            <span class="hljs-keyword">try</span> {
                bw.setPropertyValues(mpvs);
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">catch</span> (BeansException ex) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                        mbd.getResourceDescription(), beanName, <span class="hljs-string">"Error setting property values"</span>, ex);
            }
        }
        original = mpvs.getPropertyValueList();
    }
    <span class="hljs-keyword">else</span> {
        original = Arrays.asList(pvs.getPropertyValues());
    }

    <span class="hljs-comment">// 类型转换器是可以自定义的</span>
    TypeConverter converter = getCustomTypeConverter();
    <span class="hljs-keyword">if</span> (converter == <span class="hljs-keyword">null</span>) {
        converter = bw;
    }
    <span class="hljs-comment">// BeanDefinitionValueResolver是真正实现属性赋值和自动注入的</span>
    BeanDefinitionValueResolver valueResolver = <span class="hljs-keyword">new</span> BeanDefinitionValueResolver(<span class="hljs-keyword">this</span>, beanName, mbd, converter);

    <span class="hljs-comment">// Create a deep copy, resolving any references for values.</span>
    List&lt;PropertyValue&gt; deepCopy = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(original.size());
    <span class="hljs-keyword">boolean</span> resolveNecessary = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">for</span> (PropertyValue pv : original) {
        <span class="hljs-keyword">if</span> (pv.isConverted()) {
            deepCopy.add(pv);
        }
        <span class="hljs-keyword">else</span> {
            String propertyName = pv.getName();
            Object originalValue = pv.getValue();
            <span class="hljs-comment">// 11.6.2.6 【核心】解析、注入值</span>
            Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
            Object convertedValue = resolvedValue;
            <span class="hljs-keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;
                    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
            <span class="hljs-keyword">if</span> (convertible) {
                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
            }
            <span class="hljs-comment">// Possibly store converted value in merged bean definition,</span>
            <span class="hljs-comment">// in order to avoid re-conversion for every created bean instance.</span>
            <span class="hljs-comment">// 将已经转换过的值放入缓存，避免重复解析降低效率</span>
            <span class="hljs-keyword">if</span> (resolvedValue == originalValue) {
                <span class="hljs-keyword">if</span> (convertible) {
                    pv.setConvertedValue(convertedValue);
                }
                deepCopy.add(pv);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (convertible &amp;&amp; originalValue <span class="hljs-keyword">instanceof</span> TypedStringValue &amp;&amp;
                    !((TypedStringValue) originalValue).isDynamic() &amp;&amp;
                    !(convertedValue <span class="hljs-keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) {
                pv.setConvertedValue(convertedValue);
                deepCopy.add(pv);
            }
            <span class="hljs-keyword">else</span> {
                resolveNecessary = <span class="hljs-keyword">true</span>;
                deepCopy.add(<span class="hljs-keyword">new</span> PropertyValue(pv, convertedValue));
            }
        }
    }
    <span class="hljs-comment">// 标记已经转换完毕</span>
    <span class="hljs-keyword">if</span> (mpvs != <span class="hljs-keyword">null</span> &amp;&amp; !resolveNecessary) {
        mpvs.setConverted();
    }

    <span class="hljs-comment">// Set our (possibly massaged) deep copy.</span>
    <span class="hljs-keyword">try</span> {
        bw.setPropertyValues(<span class="hljs-keyword">new</span> MutablePropertyValues(deepCopy));
    }
    <span class="hljs-keyword">catch</span> (BeansException ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                mbd.getResourceDescription(), beanName, <span class="hljs-string">"Error setting property values"</span>, ex);
    }
}
</code></pre><p>这里面的核心方法：<strong><code>valueResolver.resolveValueIfNecessary</code></strong></p>
<h5 class="heading">11.6.2.6 [setter] resolveValueIfNecessary</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveValueIfNecessary</span><span class="hljs-params">(Object argName, @Nullable Object value)</span> </span>{
    <span class="hljs-comment">// We must check each value to see whether it requires a runtime reference</span>
    <span class="hljs-comment">// to another bean to be resolved.</span>
    <span class="hljs-comment">// 11.6.2.7 如果依赖了另外一个Bean时，进入下面的分支</span>
    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> RuntimeBeanReference) {
        RuntimeBeanReference ref = (RuntimeBeanReference) value;
        <span class="hljs-keyword">return</span> resolveReference(argName, ref);
    }
    <span class="hljs-comment">// 如果根据另一个Bean的name进行依赖，进入下面的分支</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> RuntimeBeanNameReference) {
        String refName = ((RuntimeBeanNameReference) value).getBeanName();
        refName = String.valueOf(doEvaluate(refName));
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.beanFactory.containsBean(refName)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(
                    <span class="hljs-string">"Invalid bean name '"</span> + refName + <span class="hljs-string">"' in bean reference for "</span> + argName);
        }
        <span class="hljs-keyword">return</span> refName;
    }
    <span class="hljs-comment">// 解析BeanDefinitionHolder</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> BeanDefinitionHolder) {
        <span class="hljs-comment">// Resolve BeanDefinitionHolder: contains BeanDefinition with name and aliases.</span>
        BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;
        <span class="hljs-keyword">return</span> resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());
    }
    <span class="hljs-comment">// 解析纯BeanDefinition</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> BeanDefinition) {
        <span class="hljs-comment">// Resolve plain BeanDefinition, without contained name: use dummy name.</span>
        BeanDefinition bd = (BeanDefinition) value;
        String innerBeanName = <span class="hljs-string">"(inner bean)"</span> + BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR +
                ObjectUtils.getIdentityHexString(bd);
        <span class="hljs-keyword">return</span> resolveInnerBean(argName, innerBeanName, bd);
    }
    <span class="hljs-comment">// 解析数组</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> ManagedArray) {
        <span class="hljs-comment">// May need to resolve contained runtime references.</span>
        ManagedArray array = (ManagedArray) value;
        Class&lt;?&gt; elementType = array.resolvedElementType;
        <span class="hljs-keyword">if</span> (elementType == <span class="hljs-keyword">null</span>) {
            String elementTypeName = array.getElementTypeName();
            <span class="hljs-keyword">if</span> (StringUtils.hasText(elementTypeName)) {
                <span class="hljs-keyword">try</span> {
                    elementType = ClassUtils.forName(elementTypeName, <span class="hljs-keyword">this</span>.beanFactory.getBeanClassLoader());
                    array.resolvedElementType = elementType;
                }
                <span class="hljs-keyword">catch</span> (Throwable ex) {
                    <span class="hljs-comment">// Improve the message by showing the context.</span>
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                            <span class="hljs-keyword">this</span>.beanDefinition.getResourceDescription(), <span class="hljs-keyword">this</span>.beanName,
                            <span class="hljs-string">"Error resolving array type for "</span> + argName, ex);
                }
            }
            <span class="hljs-keyword">else</span> {
                elementType = Object.class;
            }
        }
        <span class="hljs-keyword">return</span> resolveManagedArray(argName, (List&lt;?&gt;) value, elementType);
    }
    <span class="hljs-comment">// 11.6.2.8 解析List</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> ManagedList) {
        <span class="hljs-comment">// May need to resolve contained runtime references.</span>
        <span class="hljs-keyword">return</span> resolveManagedList(argName, (List&lt;?&gt;) value);
    }
    <span class="hljs-comment">// 解析Set</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> ManagedSet) {
        <span class="hljs-comment">// May need to resolve contained runtime references.</span>
        <span class="hljs-keyword">return</span> resolveManagedSet(argName, (Set&lt;?&gt;) value);
    }
    <span class="hljs-comment">// 解析Map</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> ManagedMap) {
        <span class="hljs-comment">// May need to resolve contained runtime references.</span>
        <span class="hljs-keyword">return</span> resolveManagedMap(argName, (Map&lt;?, ?&gt;) value);
    }
    <span class="hljs-comment">// 解析Properties</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> ManagedProperties) {
        Properties original = (Properties) value;
        Properties copy = <span class="hljs-keyword">new</span> Properties();
        original.forEach((propKey, propValue) -&gt; {
            <span class="hljs-keyword">if</span> (propKey <span class="hljs-keyword">instanceof</span> TypedStringValue) {
                propKey = evaluate((TypedStringValue) propKey);
            }
            <span class="hljs-keyword">if</span> (propValue <span class="hljs-keyword">instanceof</span> TypedStringValue) {
                propValue = evaluate((TypedStringValue) propValue);
            }
            <span class="hljs-keyword">if</span> (propKey == <span class="hljs-keyword">null</span> || propValue == <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                        <span class="hljs-keyword">this</span>.beanDefinition.getResourceDescription(), <span class="hljs-keyword">this</span>.beanName,
                        <span class="hljs-string">"Error converting Properties key/value pair for "</span> + argName + <span class="hljs-string">": resolved to null"</span>);
            }
            copy.put(propKey, propValue);
        });
        <span class="hljs-keyword">return</span> copy;
    }
    <span class="hljs-comment">// 解析String</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> TypedStringValue) {
        <span class="hljs-comment">// Convert value to target type here.</span>
        TypedStringValue typedStringValue = (TypedStringValue) value;
        Object valueObject = evaluate(typedStringValue);
        <span class="hljs-keyword">try</span> {
            Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue);
            <span class="hljs-keyword">if</span> (resolvedTargetType != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> valueObject;
            }
        }
        <span class="hljs-keyword">catch</span> (Throwable ex) {
            <span class="hljs-comment">// Improve the message by showing the context.</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                    <span class="hljs-keyword">this</span>.beanDefinition.getResourceDescription(), <span class="hljs-keyword">this</span>.beanName,
                    <span class="hljs-string">"Error converting typed String value for "</span> + argName, ex);
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> NullBean) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> evaluate(value);
    }
}
</code></pre><p>解析上面几个标号的分支，了解属性赋值和自动注入的核心</p>
<h5 class="heading">11.6.2.7 [setter] RuntimeBeanReference</h5>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> RuntimeBeanReference) {
        RuntimeBeanReference ref = (RuntimeBeanReference) value;
        <span class="hljs-keyword">return</span> resolveReference(argName, ref);
    }
</code></pre><p>这部分跳转到了 <code>resolveReference</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">resolveReference</span><span class="hljs-params">(Object argName, RuntimeBeanReference ref)</span> </span>{
    <span class="hljs-keyword">try</span> {
        Object bean;
        <span class="hljs-comment">// 获取BeanName</span>
        String refName = ref.getBeanName();
        refName = String.valueOf(doEvaluate(refName));
        <span class="hljs-comment">// 如果Bean在父容器，则去父容器取</span>
        <span class="hljs-keyword">if</span> (ref.isToParent()) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.getParentBeanFactory() == <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                        <span class="hljs-keyword">this</span>.beanDefinition.getResourceDescription(), <span class="hljs-keyword">this</span>.beanName,
                        <span class="hljs-string">"Can't resolve reference to bean '"</span> + refName +
                                <span class="hljs-string">"' in parent factory: no parent factory available"</span>);
            }
            bean = <span class="hljs-keyword">this</span>.beanFactory.getParentBeanFactory().getBean(refName);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 在本容器，调用getBean</span>
            bean = <span class="hljs-keyword">this</span>.beanFactory.getBean(refName);
            <span class="hljs-keyword">this</span>.beanFactory.registerDependentBean(refName, <span class="hljs-keyword">this</span>.beanName);
        }
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> NullBean) {
            bean = <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-keyword">return</span> bean;
    }
    <span class="hljs-keyword">catch</span> (BeansException ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                <span class="hljs-keyword">this</span>.beanDefinition.getResourceDescription(), <span class="hljs-keyword">this</span>.beanName,
                <span class="hljs-string">"Cannot resolve reference to bean '"</span> + ref.getBeanName() + <span class="hljs-string">"' while setting "</span> + argName, ex);
    }
}
</code></pre><p>发现这里面的核心还是<strong>getBean</strong>方法！开始触发关联创建Bean。</p>
<h5 class="heading">11.6.2.8 [setter] 解析List</h5>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> ManagedList) {
        <span class="hljs-comment">// May need to resolve contained runtime references.</span>
        <span class="hljs-keyword">return</span> resolveManagedList(argName, (List&lt;?&gt;) value);
    }
</code></pre><p>跳转到 <code>resolveManagedList</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> List&lt;?&gt; resolveManagedList(Object argName, List&lt;?&gt; ml) {
    List&lt;Object&gt; resolved = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(ml.size());
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ml.size(); i++) {
        resolved.add(resolveValueIfNecessary(<span class="hljs-keyword">new</span> KeyedArgName(argName, i), ml.get(i)));
    }
    <span class="hljs-keyword">return</span> resolved;
}
</code></pre><p>这里面直接把 <code>List</code> 集合塞入属性中即可。</p>
<p>至此，属性赋值和自动注入得以体现，至于这里面如何解决循环依赖，下一篇详细描述。</p>
<h4 class="heading">11.6.3 initializeBean：初始化Bean</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>{
    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) {
        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
            invokeAwareMethods(beanName, bean);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }, getAccessControlContext());
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 11.6.3.1 将那些实现xxxAware接口的类，注入一些属性（beanName、ClassLoader、BeanFactory）</span>
        invokeAwareMethods(beanName, bean);
    }

    Object wrappedBean = bean;
    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) {
        <span class="hljs-comment">// 11.6.3.2 后置处理器在做初始化之前的处理</span>
        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
    }

    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 11.6.3.3 初始化Bean，执行@PostConstruct，InitializingBean接口的方法</span>
        invokeInitMethods(beanName, wrappedBean, mbd);
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(
                (mbd != <span class="hljs-keyword">null</span> ? mbd.getResourceDescription() : <span class="hljs-keyword">null</span>),
                beanName, <span class="hljs-string">"Invocation of init method failed"</span>, ex);
    }
    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) {
        <span class="hljs-comment">// 后置处理器在做初始化之后的处理</span>
        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    }

    <span class="hljs-keyword">return</span> wrappedBean;
}
</code></pre><h5 class="heading">11.6.3.1 invokeAwareMethods：执行注入的功能</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAwareMethods</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean)</span> </span>{
    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) {
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanNameAware) {
            ((BeanNameAware) bean).setBeanName(beanName);
        }
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanClassLoaderAware) {
            ClassLoader bcl = getBeanClassLoader();
            <span class="hljs-keyword">if</span> (bcl != <span class="hljs-keyword">null</span>) {
                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
            }
        }
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanFactoryAware) {
            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="hljs-keyword">this</span>);
        }
    }
}
</code></pre><p>可以发现这里面是对 BeanName 的注入，<code>BeanClassLoader</code> 的注入，以及 <code>BeanFactory</code> 的注入，实现很简单，不再展开。</p>
<h5 class="heading">11.6.3.2 applyBeanPostProcessorsBeforeInitialization：执行后置处理器</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span>
        <span class="hljs-keyword">throws</span> BeansException </span>{

    Object result = existingBean;
    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) {
        Object current = processor.postProcessBeforeInitialization(result, beanName);
        <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> result;
        }
        result = current;
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre><p>发现这里是真正的执行 <code>BeanPostProcessor</code> 的方法了，调用逻辑也很简单，不再展开。</p>
<h5 class="heading">11.6.3.3 invokeInitMethods：执行初始化Bean的操作</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeInitMethods</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span>
        <span class="hljs-keyword">throws</span> Throwable </span>{

    <span class="hljs-comment">// 不是InitializiingBean，而且也没声明afterPropertiesSet方法，则不执行下面的逻辑</span>
    <span class="hljs-keyword">boolean</span> isInitializingBean = (bean <span class="hljs-keyword">instanceof</span> InitializingBean);
    <span class="hljs-keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="hljs-keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="hljs-string">"afterPropertiesSet"</span>))) {
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="hljs-string">"'"</span>);
        }
        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">try</span> {
                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; {
                    ((InitializingBean) bean).afterPropertiesSet();
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                }, getAccessControlContext());
            }
            <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) {
                <span class="hljs-keyword">throw</span> pae.getException();
            }
        }
        <span class="hljs-keyword">else</span> {
            ((InitializingBean) bean).afterPropertiesSet();
        }
    }

    <span class="hljs-keyword">if</span> (mbd != <span class="hljs-keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) {
        String initMethodName = mbd.getInitMethodName();
        <span class="hljs-keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;
                !(isInitializingBean &amp;&amp; <span class="hljs-string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;
                !mbd.isExternallyManagedInitMethod(initMethodName)) {
            invokeCustomInitMethod(beanName, bean, mbd);
        }
    }
}
</code></pre><p>可以发现这里只有执行了 <code>InitializiingBean</code> 接口的 <code>afterPropertiesSet</code> 方法，没有找到 <code>@PostConstruct</code> 标注的方法。根据之前的分析，知道 <code>@PostConstruct</code> 标注的方法会先执行。那上面的源码中，执行 <code>InitializingBean</code> 的方法之前只有执行 <code>BeanPostProcessor</code> 了，那可以大概猜测是一个 <code>BeanPostProcessor</code> 执行了 <code>@PostConstruct</code> 方法。</p>
<p>通过给一个自定义的组件声明测试方法，并标注 <code>PostConstruct</code> ，发现它的调用栈里有一个 <code>InitDestroyAnnotationBeanPostProcessor</code> ，它的执行方法 <code>postProcessBeforeInitilization</code> 方法如下：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());
    <span class="hljs-keyword">try</span> {
        metadata.invokeInitMethods(bean, beanName);
    }
    <span class="hljs-keyword">catch</span> (InvocationTargetException ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"Invocation of init method failed"</span>, ex.getTargetException());
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"Failed to invoke init method"</span>, ex);
    }
    <span class="hljs-keyword">return</span> bean;
}
</code></pre><p>可以发现调用了 <code>metadata.invokeInitMethods</code> 方法执行了 <code>@PostConstruct</code> 标注的方法。</p>
<p>至此，可以发现初始化Bean的逻辑也调用完成，整个 <code>doCreateBean</code> 方法执行完毕。</p>
<hr>
<p>回到 <code>getBean</code> 方法中：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">if</span> (mbd.isSingleton()) {
        <span class="hljs-comment">// 11.7 匿名内部类执行完成后的getSingleton调用</span>
        sharedInstance = getSingleton(beanName, () -&gt; {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 11.3 createBean</span>
                <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);
            }
            <span class="hljs-keyword">catch</span> (BeansException ex) {
                <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span>
                <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span>
                <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span>
                destroySingleton(beanName);
                <span class="hljs-keyword">throw</span> ex;
            }
        });
        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
    }
</code></pre><p>在 <code>createBean</code> 执行完后，回到了匿名内部类的 <code>getSingleton</code> 方法：</p>
<h3 class="heading">11.7 匿名内部类执行完成后的getSingleton调用</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>{
    Assert.notNull(beanName, <span class="hljs-string">"Bean name must not be null"</span>);
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) {
        Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);
        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// ......</span>
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// createBean方法在getObject中</span>
                singletonObject = singletonFactory.getObject();
                newSingleton = <span class="hljs-keyword">true</span>;
            } <span class="hljs-comment">// catch ......</span>
            <span class="hljs-keyword">finally</span> {
                <span class="hljs-keyword">if</span> (recordSuppressedExceptions) {
                    <span class="hljs-keyword">this</span>.suppressedExceptions = <span class="hljs-keyword">null</span>;
                }
                afterSingletonCreation(beanName);
            }
            <span class="hljs-keyword">if</span> (newSingleton) {
                <span class="hljs-comment">// 将这个创建好的Bean放到IOC容器的单实例Bean缓存区中</span>
                addSingleton(beanName, singletonObject);
            }
        }
        <span class="hljs-keyword">return</span> singletonObject;
    }
}
</code></pre><p>调用完成后，finally 块中还有一步操作：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterSingletonCreation</span><span class="hljs-params">(String beanName)</span> </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-keyword">this</span>.singletonsCurrentlyInCreation.remove(beanName)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Singleton '"</span> + beanName + <span class="hljs-string">"' isn't currently in creation"</span>);
    }
}
</code></pre><p>在if条件中，它要把当前Bean的name从 <code>singletonsCurrentlyInCreation</code> （正在被创建的Bean）中清除。</p>
<p>最终，将这个Bean添加到 <code>singletonObjects</code> （一级缓存）中，<code>createBean</code> 方法彻底完成。</p>
<h3 class="heading">11.8 最后的工作</h3>
<p>回到 <code>preInstantiateSingletons</code> 中。</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Trigger post-initialization callback for all applicable beans...</span>
    <span class="hljs-keyword">for</span> (String beanName : beanNames) {
        Object singletonInstance = getSingleton(beanName);
        <span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) {
            <span class="hljs-keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
            <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) {
                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
                    smartSingleton.afterSingletonsInstantiated();
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                }, getAccessControlContext());
            }
            <span class="hljs-keyword">else</span> {
                smartSingleton.afterSingletonsInstantiated();
            }
        }
    }
</code></pre><p>它又回调了一组类型为 <code>SmartInitializingSingleton</code> 的组件，来回调它们的 <code>afterSingletonsInstantiated</code> 方法。</p>
<h4 class="heading">11.8.1 SmartInitializingSingleton</h4>
<p>它的文档注释原文翻译：</p>
<blockquote>
<p>Callback interface triggered at the end of the singleton pre-instantiation phase during BeanFactory bootstrap. This interface can be implemented by singleton beans in order to perform some initialization after the regular singleton instantiation algorithm, avoiding side effects with accidental early initialization (e.g. from ListableBeanFactory.getBeansOfType calls). In that sense, it is an alternative to InitializingBean which gets triggered right at the end of a bean's local construction phase.
This callback variant is somewhat similar to org.springframework.context.event.ContextRefreshedEvent but doesn't require an implementation of org.springframework.context.ApplicationListener, with no need to filter context references across a context hierarchy etc. It also implies a more minimal dependency on just the beans package and is being honored by standalone ListableBeanFactory implementations, not just in an org.springframework.context.ApplicationContext environment.
NOTE: If you intend to start/manage asynchronous tasks, preferably implement org.springframework.context.Lifecycle instead which offers a richer model for runtime management and allows for phased startup/shutdown.</p>
<p>在 <code>BeanFactory</code> 引导期间的单实例bean的初始化阶段结束时触发的回调接口。该接口可以由单例bean实现，以便在常规的单例实例化算法之后执行一些初始化，避免意外的早期初始化带来的副作用（例如，来自 <code>ListableBeanFactory.getBeansOfType</code> 调用）。从这个意义上讲，它是 <code>InitializingBean</code> 的替代方法，后者在bean的本地构造阶段结束时立即触发。
这个回调变体有点类似于 <code>org.springframework.context.event.ContextRefreshedEvent</code>，但是不需要 <code>org.springframework.context.ApplicationListener</code> 的实现，不需要在整个上下文层次结构中过滤上下文引用。这也意味着更多对bean包的依赖性最小，并且由独立的ListableBeanFactory实现兑现，而不仅仅是在 <code>ApplicationContext</code> 环境中。
注意：如果要启动/管理异步任务，则最好实现 <code>org.springframework.context.Lifecycle</code>，它为运行时管理提供了更丰富的模型，并允许分阶段启动/关闭。</p>
</blockquote>
<p>从文档注释来看，它是 <code>InitializingBean</code> 的替代方案，但通过上面的代码也了解，它的执行时机是：<strong>所有单实例Bean都创建完毕</strong>。小伙伴们大概对这个地方有个印象即可，后续的源码分析中可能会遇到，我会再往回提的。</p>
<h2 class="heading">小结</h2>
<ol>
<li>IOC容器初始化单实例Bean使用 <code>getBean</code> 方法。</li>
<li>真正创建Bean的步骤是 <code>doCreateBean</code> 。</li>
<li>创建Bean的过程：
<ol>
<li>实例化Bean</li>
<li>属性赋值&amp;自动注入</li>
<li>执行初始化方法</li>
</ol>
</li>
<li><code>BeanPostProcessor</code> 中before方法真正的执行时机是在注入之后，初始化方法调用之前。</li>
</ol>
<p>【至此，初始化单实例Bean的全过程完毕，咱中间留了一个循环依赖的问题，下一篇将通过原理和实例来分析IOC容器是如何解决循环依赖的】</p>
</div>
</body></html>