<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>WebMvc：自动装配回顾与DispatcherServlet组件</h1>
<h1 class="heading">25. WebMvc：自动装配回顾与DispatcherServlet组件</h1>
<p>我们把应用重置回刚初始化的状态，也或者新创建一个干净的工程，还是只导入 <code>spring-boot-starter-web</code> 依赖，接下来咱开始分析WebMvc的一些原理。</p>
<p>之前分析自动装配时，咱们拿WebMvc来解析实例了。咱简单回顾一下WebMvc的自动装配都干了什么。</p>
<h2 class="heading">1. WebMvc自动配置装配的核心组件</h2>
<h3 class="heading">1.1 WebMvcAutoConfiguration</h3>
<p>配置 <code>Converter</code>：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>{
        <span class="hljs-keyword">this</span>.messageConvertersProvider
              .ifAvailable((customConverters) -&gt; converters.addAll(customConverters.getConverters()));
    }
</code></pre><p><code>ViewResolver</code>：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// 最常用的视图解析器</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> InternalResourceViewResolver <span class="hljs-title">defaultViewResolver</span><span class="hljs-params">()</span> </span>{}
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> BeanNameViewResolver <span class="hljs-title">beanNameViewResolver</span><span class="hljs-params">()</span> </span>{}
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ContentNegotiatingViewResolver <span class="hljs-title">viewResolver</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>{}
<span class="hljs-comment">// 国际化组件</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>{}
</code></pre><p>静态资源映射，<code>webjars</code> 映射：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>{
    <span class="hljs-comment">// ......</span>
    <span class="hljs-comment">// 映射webjars</span>
    <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(<span class="hljs-string">"/webjars/**"</span>)) {
        customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="hljs-string">"/webjars/**"</span>)
                .addResourceLocations(<span class="hljs-string">"classpath:/META-INF/resources/webjars/"</span>)
                .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
    <span class="hljs-comment">// 映射静态资源路径</span>
    String staticPathPattern = <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern();
    <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) {
        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)
                .addResourceLocations(getResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations()))
                .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
}
</code></pre><p>设置 <code>index.html</code>：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> Resource <span class="hljs-title">getIndexHtml</span><span class="hljs-params">(String location)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resourceLoader.getResource(location + <span class="hljs-string">"index.html"</span>);
}
</code></pre><p>应用图标：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> SimpleUrlHandlerMapping <span class="hljs-title">faviconHandlerMapping</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// ......</span>
    mapping.setUrlMap(Collections.singletonMap(<span class="hljs-string">"**/favicon.ico"</span>, faviconRequestHandler()));
    <span class="hljs-keyword">return</span> mapping;
}
</code></pre><h3 class="heading">1.2 DispatcherServletAutoConfiguration</h3>
<p>DispatcherServlet：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
<span class="hljs-function"><span class="hljs-keyword">public</span> DispatcherServlet <span class="hljs-title">dispatcherServlet</span><span class="hljs-params">()</span> </span>{
    DispatcherServlet dispatcherServlet = <span class="hljs-keyword">new</span> DispatcherServlet();
    <span class="hljs-comment">// ......</span>
    <span class="hljs-keyword">return</span> dispatcherServlet;
}
</code></pre><h3 class="heading">1.3 ServletWebServerFactoryAutoConfiguration</h3>
<p>TomcatServletWebServerFactory：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> TomcatServletWebServerFactory <span class="hljs-title">tomcatServletWebServerFactory</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TomcatServletWebServerFactory();
}
</code></pre><p>WebServerFactoryCustomizerBeanPostProcessor + ErrorPageRegistrarBeanPostProcessor：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata,
        BeanDefinitionRegistry registry)</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 编程式注入组件</span>
    registerSyntheticBeanIfMissing(registry, <span class="hljs-string">"webServerFactoryCustomizerBeanPostProcessor"</span>,
            WebServerFactoryCustomizerBeanPostProcessor.class);
    registerSyntheticBeanIfMissing(registry, <span class="hljs-string">"errorPageRegistrarBeanPostProcessor"</span>,
            ErrorPageRegistrarBeanPostProcessor.class);
}
</code></pre><h3 class="heading">1.4 官方文档的说明</h3>
<p><a target="_blank" href="https://docs.spring.io/spring-boot/docs/2.1.9.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration">https://docs.spring.io/spring-boot/docs/2.1.9.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</a></p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df74752f0ea8e0~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>官方文档列举的组件如下：</p>
<ul>
<li>视图解析器</li>
<li>webjars的资源映射</li>
<li>自动配置的转换器、格式化器（Converter、Formatter）</li>
<li>Http请求转换器（HttpMessageConverter）</li>
<li>响应代码解析器</li>
<li>静态主页映射</li>
<li>网站图标映射</li>
<li>可配置的Web初始化绑定器</li>
</ul>
<p>基本上面列举的部分都在官方文档中有描述了。</p>
<p>咱们都知道，SpringWebMvc的核心是 <code>DispatcherServlet</code> ，那对于WebMvc部分咱就着重来看启动、配置，以及与 <code>DispatcherServlet</code> 相关的部分。</p>
<h2 class="heading">2. 启动应用相关原理</h2>
<p>在了解启动原理之前，先来了解一下Servlet3.0的一些规范，这对后续了解 <strong>SpringWebMvc</strong> 和 <strong>SpringBootWebMvc</strong> 有很大帮助。</p>
<h3 class="heading">2.1 Servlet3.0规范中引导应用启动的说明</h3>
<p>在Servlet3.0的规范文档（小伙伴可点击链接下载：<a target="_blank" href="https://download.oracle.com/otn-pub/jcp/servlet-3.0-fr-eval-oth-JSpec/servlet-3_0-final-spec.pdf?AuthParam=1571470730_c5c9dee74deeafbfdeb7cb7f87ea17f4%EF%BC%89%EF%BC%8C8.2.4%E7%AB%A0%E8%8A%82%EF%BC%8C%E6%9C%89%E5%AF%B9%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8F%92%E4%BB%B6%E7%9A%84%E6%8F%8F%E8%BF%B0%E3%80%82%E5%B0%8F%E5%86%8C%E6%8A%8A%E5%85%B3%E9%94%AE%E9%83%A8%E5%88%86%E7%9A%84%E5%8E%9F%E6%96%87%E5%BC%95%E5%85%A5%E8%BF%9B%E6%9D%A5%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%B0%8F%E4%BC%99%E4%BC%B4%E4%BB%AC%E9%98%85%E8%AF%BB%E3%80%82">https://download.oracle.com/otn-pub/jcp/servlet-3.0-fr-eval-oth-JSpec/servlet-3_0-final-spec.pdf?AuthParam=1571470730_c5c9dee74deeafbfdeb7cb7f87ea17f4），8.2.4章节，有对运行时插件的描述。小册把关键部分的原文引入进来，方便小伙伴们阅读。</a></p>
<blockquote>
<p>An instance of the ServletContainerInitializer is looked up via the jar services API by the container at container / application startup time. The framework providing an implementation of the ServletContainerInitializer MUST bundle in the META-INF/services directory of the jar file a file called javax.servlet.ServletContainerInitializer, as per the jar services API, that points to the implementation class of the ServletContainerInitializer.</p>
</blockquote>
<p>咱也不贴正儿八经的翻译了，咱用自己的语言描述一下。</p>
<p>在Servlet容器（Tomcat、Jetty等）启动应用时，会扫描应用jar包中 <code>ServletContainerInitializer</code> 的实现类。框架必须在jar包的 <code>META-INF/services</code> 的文件夹中提供一个名为 <code>javax.servlet.ServletContainerInitializer</code> 的文件，文件内容要写明 <code>ServletContainerInitializer</code> 的实现类的全限定名。</p>
<p>而这个 <code>ServletContainerInitializer</code> 是一个接口，实现它的类必须实现一个方法：<code>onStartUp</code> 。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServletContainerInitializer</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="hljs-keyword">throws</span> ServletException</span>;
}
</code></pre><p>那不难猜出，要这个接口肯定是为了要执行这个 <code>onStartUp</code> 方法。</p>
<p>另外，还可以在这个 <code>ServletContainerInitializer</code> 的实现类上标注 <code>@HandlesTypes</code> 注解，在应用启动的时候自行加载一些附加的类，这些类会以字节码的集合形式传入 <code>onStartup</code> 方法的第一个参数中。</p>
<p>了解了这部分Servlet3.0规范后，咱来回顾之前遇到的一个陌生的类：<code>SpringBootServletInitializer</code> 。</p>
<h3 class="heading">2.2 SpringBootServletInitializer的作用和原理</h3>
<p>回顾 <code>SpringBoot</code> 应用打包启动的两种方式：</p>
<ul>
<li>打jar包启动时，先创建IOC容器，在创建过程中创建了嵌入式Web容器。（详细的jar包启动会在 <code>JarLauncher</code> 篇解析）</li>
<li>打war包启动时，要先启动外部的Web服务器，Web服务器再去启动 <code>SpringBoot</code> 应用，然后才是创建IOC容器。</li>
</ul>
<p>那么在打war包启动时，里面最核心的步骤：<strong>Web服务器启动SpringBoot应用</strong> 。</p>
<p>而这个步骤，就需要依靠 <code>SpringBootServletInitializer</code> 。下面咱来看看外置Web容器是如何成功引导 <code>SpringBoot</code> 应用启动的：</p>
<ol>
<li>
<p>外部Web容器（Tomcat、Jetty、Undertow等）启动，开始加载 SpringBoot 的war 包并解压。</p>
</li>
<li>
<p>去 <code>SpringBoot</code> 应用中的每一个被依赖的jar中寻找 <code>META-INF/services/javax.servlet.SpringBootServletInitializer</code> 的文件。</p>
</li>
<li>
<p>根据文件中标注的全限定类名，去找这个类（就是 <code>SpringServletContainerInitializer</code>）。</p>
</li>
<li>
<p>这个类的 onStartup 方法中会将 <code>@HandlesTypes</code> 中标注的类型的所有普通实现类（也就是非抽象子类）都实例化出来，之后分别调他们自己的 <code>onStartup</code> 方法。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@HandlesTypes</span>(WebApplicationInitializer.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringServletContainerInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContainerInitializer</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span>
            <span class="hljs-keyword">throws</span> ServletException </span>{
        <span class="hljs-comment">// SpringServletContainerInitializer会加载所有的WebApplicationInitializer类型的普通实现类</span>
        
        List&lt;WebApplicationInitializer&gt; initializers = <span class="hljs-keyword">new</span> LinkedList&lt;WebApplicationInitializer&gt;();

        <span class="hljs-keyword">if</span> (webAppInitializerClasses != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) {
                <span class="hljs-comment">// 如果不是接口，不是抽象类</span>
                <span class="hljs-keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;
                        WebApplicationInitializer.class.isAssignableFrom(waiClass)) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">// 创建该类的实例</span>
                        initializers.add((WebApplicationInitializer) waiClass.newInstance());
                    }
                    <span class="hljs-keyword">catch</span> (Throwable ex) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Failed to instantiate WebApplicationInitializer class"</span>, ex);
                    }
                }
            }
        }

        <span class="hljs-keyword">if</span> (initializers.isEmpty()) {
            servletContext.log(<span class="hljs-string">"No Spring WebApplicationInitializer types detected on classpath"</span>);
            <span class="hljs-keyword">return</span>;
        }

        servletContext.log(initializers.size() + <span class="hljs-string">" Spring WebApplicationInitializers detected on classpath"</span>);
        AnnotationAwareOrderComparator.sort(initializers);
        <span class="hljs-comment">// 调用各自的onStartup方法</span>
        <span class="hljs-keyword">for</span> (WebApplicationInitializer initializer : initializers) {
            initializer.onStartup(servletContext);
        }
    }
}
</code></pre><p>这个 <code>onStartup</code> 方法的文档注释原文翻译：</p>
<blockquote>
<p>Delegate the ServletContext to any WebApplicationInitializer implementations present on the application classpath.
Because this class declares @HandlesTypes(WebApplicationInitializer.class), Servlet 3.0+ containers will automatically scan the classpath for implementations of Spring's WebApplicationInitializer interface and provide the set of all such types to the webAppInitializerClasses parameter of this method.
If no WebApplicationInitializer implementations are found on the classpath, this method is effectively a no-op. An INFO-level log message will be issued notifying the user that the ServletContainerInitializer has indeed been invoked but that no WebApplicationInitializer implementations were found.
Assuming that one or more WebApplicationInitializer types are detected, they will be instantiated (and sorted if the @@Order annotation is present or the Ordered interface has been implemented). Then the WebApplicationInitializer.onStartup(ServletContext) method will be invoked on each instance, delegating the ServletContext such that each instance may register and configure servlets such as Spring's DispatcherServlet, listeners such as Spring's ContextLoaderListener, or any other Servlet API componentry such as filters.</p>
<p>将 <code>ServletContext</code> 委托给应用程序类路径上存在的任何 <code>WebApplicationInitializer</code> 实现。
因为此类声明了 <code>@HandlesTypes(WebApplicationInitializer.class)</code>，所以 Servlet 3.0+ 容器将自动扫描类路径以查找 Spring 的 <code>WebApplicationInitializer</code> 接口的实现，并将所有此类的类型的集合提供给此方法的 <code>webAppInitializerClasses</code> 参数。
如果在类路径上没有找到 <code>WebApplicationInitializer</code> 实现，则此方法实际上是无操作的。将发出info级别的日志消息，通知用户确实已调用 <code>ServletContainerInitializer</code>，但是未找到 <code>WebApplicationInitializer</code> 实现。
假设检测到一个或多个 <code>WebApplicationInitializer</code> 类型，将对其进行实例化（如果存在 <code>@Order</code> 注解或已实现 <code>Ordered</code> 接口，则将对其进行排序）。然后将在每个实例上调用 <code>WebApplicationInitializer.onStartup(ServletContext)</code> 方法，委派 ServletContext，以便每个实例可以注册和配置 Servlet（例如 Spring 的 <code>DispatcherServlet</code>），监听器（例如 Spring 的 <code>ContextLoaderListener</code>）或任何其他 Servlet API组件（例如Filter）。</p>
</blockquote>
</li>
<li>
<p>因为打war包的 <code>SpringBoot</code> 工程会在启动类的同包下创建 <code>ServletInitializer</code> ，并且必须继承 <code>SpringBootServletInitializer</code>，所以会被服务器创建对象。</p>
</li>
<li>
<p><code>SpringBootServletInitializer</code> 没有重写 <code>onStartup</code> 方法，去父类 <code>SpringServletContainerInitializer</code> 中寻找</p>
<ul>
<li>父类 <code>SpringServletContainerInitializer</code> 中的 <code>onStartup</code> 方法中有一句核心源码：</li>
<li><code>WebApplicationContextrootAppContext rootAppContext = createRootApplicationContext(servletContext);</code></li>
</ul>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>{
    <span class="hljs-comment">// Logger initialization is deferred in case an ordered</span>
    <span class="hljs-comment">// LogServletContextInitializer is being used</span>
    <span class="hljs-keyword">this</span>.logger = LogFactory.getLog(getClass());
    <span class="hljs-comment">// 创建 父IOC容器</span>
    WebApplicationContext rootAppContext = createRootApplicationContext(servletContext);
    <span class="hljs-keyword">if</span> (rootAppContext != <span class="hljs-keyword">null</span>) {
        servletContext.addListener(<span class="hljs-keyword">new</span> ContextLoaderListener(rootAppContext) {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent event)</span> </span>{
                <span class="hljs-comment">// no-op because the application context is already initialized</span>
            }
        });
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"No ContextLoaderListener registered, as "</span> + <span class="hljs-string">"createRootApplicationContext() did not "</span>
                      + <span class="hljs-string">"return an application context"</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">createRootApplicationContext</span><span class="hljs-params">(ServletContext servletContext)</span> </span>{
    <span class="hljs-comment">// 使用Builder机制，前面也介绍过</span>
    SpringApplicationBuilder builder = createSpringApplicationBuilder();
    builder.main(getClass());
    ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);
    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">this</span>.logger.info(<span class="hljs-string">"Root context already created (using as parent)."</span>);
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="hljs-keyword">null</span>);
        builder.initializers(<span class="hljs-keyword">new</span> ParentContextApplicationContextInitializer(parent));
    }
    <span class="hljs-comment">// 设置Initializer</span>
    builder.initializers(<span class="hljs-keyword">new</span> ServletContextApplicationContextInitializer(servletContext));
    <span class="hljs-comment">// 在这里设置了容器启动类：AnnotationConfigServletWebServerApplicationContext</span>
    builder.contextClass(AnnotationConfigServletWebServerApplicationContext.class);
    <span class="hljs-comment">// 【引导】多态进入子类（自己定义）的方法中</span>
    builder = configure(builder);
    builder.listeners(<span class="hljs-keyword">new</span> WebEnvironmentPropertySourceInitializer(servletContext));
    <span class="hljs-comment">// builder.build()，创建SpringApplication</span>
    SpringApplication application = builder.build();
    <span class="hljs-keyword">if</span> (application.getAllSources().isEmpty()
          &amp;&amp; AnnotationUtils.findAnnotation(getClass(), Configuration.class) != <span class="hljs-keyword">null</span>) {
        application.addPrimarySources(Collections.singleton(getClass()));
    }
    Assert.state(!application.getAllSources().isEmpty(),
               <span class="hljs-string">"No SpringApplication sources have been defined. Either override the "</span>
               + <span class="hljs-string">"configure method or add an @Configuration annotation"</span>);
    <span class="hljs-comment">// Ensure error pages are registered</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.registerErrorPageFilter) {
        application.addPrimarySources(Collections.singleton(ErrorPageFilterConfiguration.class));
    }
    <span class="hljs-comment">// 启动SpringBoot应用</span>
    <span class="hljs-keyword">return</span> run(application);
}
</code></pre></li>
<li>
<p>在这个方法中：</p>
<ol>
<li>
<p>先创建 <code>SpringApplicationBuilder</code> 应用构建器；</p>
</li>
<li>
<p>再创建一些环境配置；</p>
</li>
<li>
<p>下面中间部分有一句： <code>builder = configure(builder);</code></p>
</li>
<li>
<p>这句源码由于多态，执行了子类（SpringBoot 工程中必须写的那个启动类的同包下的 <code>ServletInitializer</code>）重写的方法；</p>
</li>
<li>
<p>又因为重写的格式固定，是传入了 SpringBoot 的目标运行主程序；</p>
<p><code>return builder.sources(DemoApplication.class);</code></p>
</li>
<li>
<p>所以下一步才能启动 SpringBoot 工程。</p>
</li>
</ol>
</li>
<li>
<p>之后就跟启动运行主程序 <code>SpringBootApplication</code> 没什么区别了。</p>
</li>
</ol>
<p>以上就是 <code>SpringBootServletInitializer</code> 的作用和原理。</p>
<h2 class="heading">3. @Controller标注的Bean装配MVC原理</h2>
<p>做过Controller开发的小伙伴都知道，自己写的Controller类只需要打上 <code>@Controller</code> 或 <code>@RestController</code> 注解，即可加载到WebMvc中，被 <code>DispatcherServlet</code> 找到，这一章节咱来看WebMvc是如何将这些Bean注册到WebMvc中的。</p>
<h3 class="heading">3.0 回顾IOC和AOP原理</h3>
<p>先回想一下IOC和AOP的几个原理：</p>
<ul>
<li><code>@Autowired</code> 是什么时机被解析的：<code>AutowiredAnnotationBeanPostProcessor</code> 在 <code>postProcessMergedBeanDefinition</code> 中触发。</li>
<li>代理对象是什么时机创建的：<strong>Bean的初始化之后，<code>AnnotationAwareAspectJAutoProxyCreator</code> 负责创建代理对象</strong> 。</li>
</ul>
<p>那由此可以猜测，解析 <code>@Controller</code> 中 <code>@RequestMapping</code> 的时机可能也在这两种情况之内，暂且保存这个猜想。</p>
<p>下面根据IOC容器的启动过程，来实际探究 <code>@RequestMapping</code> 的解析时机。</p>
<h3 class="heading">3.1 初始化 RequestMapping 的入口</h3>
<p>这个入口讲真一开始我找的时候找了好久，抓后置处理器死活抓不到关键的解析部分，后来我换了一个思路（小伙伴们可以一起来跟我体会一下这个寻找的思路）：解析 <code>@Controller</code> 中的所有映射的方法，就是解析被 <code>@RequestMapping</code> 标注的方法。之前看 <code>WebMvcAutoConfiguration</code> 时又知道注册了一个 <code>RequestMappingHandlerMapping</code> 的组件，那估计可以从这个组价中找到一些端倪。</p>
<h3 class="heading">3.2 来到RequestMappingHandlerMapping</h3>
<p>打开这个类，借助IDEA列举所有方法时，第一个方法吸引了我：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/23/16df7476fdb2a3ad~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>它实现了 <code>InitializingBean</code> ，可是它为什么要这么干呢？咱来进到实现中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>.config = <span class="hljs-keyword">new</span> RequestMappingInfo.BuilderConfiguration();
    <span class="hljs-keyword">this</span>.config.setUrlPathHelper(getUrlPathHelper());
    <span class="hljs-keyword">this</span>.config.setPathMatcher(getPathMatcher());
    <span class="hljs-keyword">this</span>.config.setSuffixPatternMatch(<span class="hljs-keyword">this</span>.useSuffixPatternMatch);
    <span class="hljs-keyword">this</span>.config.setTrailingSlashMatch(<span class="hljs-keyword">this</span>.useTrailingSlashMatch);
    <span class="hljs-keyword">this</span>.config.setRegisteredSuffixPatternMatch(<span class="hljs-keyword">this</span>.useRegisteredSuffixPatternMatch);
    <span class="hljs-keyword">this</span>.config.setContentNegotiationManager(getContentNegotiationManager());

    <span class="hljs-keyword">super</span>.afterPropertiesSet();
}
</code></pre><p>这里面都是一些设置，不稀奇啊，继续进到父类的 <code>afterPropertiesSet</code> 中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>{
    initHandlerMethods();
}
</code></pre><p>它只是调了 <code>initHandlerMethods</code> 方法，但这个方法的字面意思貌似就有些问题：初始化 <code>HandlerMethod</code> ？难不成这个方法有关键的含义吗？</p>
<h3 class="heading">3.2 initHandlerMethods</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SCOPED_TARGET_NAME_PREFIX = <span class="hljs-string">"scopedTarget."</span>;

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initHandlerMethods</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (String beanName : getCandidateBeanNames()) {
        <span class="hljs-keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {
            processCandidateBean(beanName);
        }
    }
    handlerMethodsInitialized(getHandlerMethods());
}
</code></pre><p>可以发现它把IOC容器中所有Bean的名称前缀不是 <code>"scopedTarget."</code> 的都拿出来，执行一个 <code>processCandidateBean</code> 方法。</p>
<h3 class="heading">3.3 processCandidateBean</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCandidateBean</span><span class="hljs-params">(String beanName)</span> </span>{
    Class&lt;?&gt; beanType = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> {
        beanType = obtainApplicationContext().getType(beanName);
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-comment">// An unresolvable bean type, probably from a lazy bean - let's ignore it.</span>
        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
            logger.trace(<span class="hljs-string">"Could not resolve type for bean '"</span> + beanName + <span class="hljs-string">"'"</span>, ex);
        }
    }
    <span class="hljs-keyword">if</span> (beanType != <span class="hljs-keyword">null</span> &amp;&amp; isHandler(beanType)) {
        detectHandlerMethods(beanName);
    }
}
</code></pre><p>上面的步骤是根据Bean的名称来获取Bean的类型，下面有一个判断：<code>isHandler</code></p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHandler</span><span class="hljs-params">(Class&lt;?&gt; beanType)</span> </span>{
    <span class="hljs-keyword">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||
            AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));
}
</code></pre><p>很明显它要看当前Bean是否有 <code>@Controller</code> 或 <code>@RequestMapping</code> 标注。</p>
<p>至此发现了重大关键点：<strong>它真的在解析 <code>@Controller</code> 和 <code>@RequestMapping</code> 了</strong>！证明咱的寻找思路是正确的。</p>
<p>那判断成功后，if中的结构体就一定是解析类中标注了 <code>@RequestMapping</code> 的方法了。</p>
<h3 class="heading">3.4 detectHandlerMethods</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detectHandlerMethods</span><span class="hljs-params">(Object handler)</span> </span>{
    Class&lt;?&gt; handlerType = (handler <span class="hljs-keyword">instanceof</span> String ?
            obtainApplicationContext().getType((String) handler) : handler.getClass());

    <span class="hljs-keyword">if</span> (handlerType != <span class="hljs-keyword">null</span>) {
        Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);
        <span class="hljs-comment">// 3.5 解析筛选方法</span>
        Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,
                (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-keyword">return</span> getMappingForMethod(method, userType);
                    }
                    <span class="hljs-keyword">catch</span> (Throwable ex) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Invalid mapping on handler class ["</span> +
                                userType.getName() + <span class="hljs-string">"]: "</span> + method, ex);
                    }
                });
        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
            logger.trace(formatMappings(userType, methods));
        }
        <span class="hljs-comment">// 3.6 注册方法映射</span>
        methods.forEach((method, mapping) -&gt; {
            Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);
            registerHandlerMethod(handler, invocableMethod, mapping);
        });
    }
}
</code></pre><p>上面的一开始还是拿到这个Bean的类型，下面会使用一个 <code>MethodInterceptor</code> 来筛选一些方法。</p>
<h4 class="heading">3.4.0 MethodIntrospector.selectMethods</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Map&lt;Method, T&gt; <span class="hljs-title">selectMethods</span><span class="hljs-params">(Class&lt;?&gt; targetType, <span class="hljs-keyword">final</span> MetadataLookup&lt;T&gt; metadataLookup)</span> </span>{
    <span class="hljs-keyword">final</span> Map&lt;Method, T&gt; methodMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();
    Set&lt;Class&lt;?&gt;&gt; handlerTypes = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
    Class&lt;?&gt; specificHandlerType = <span class="hljs-keyword">null</span>;

    <span class="hljs-keyword">if</span> (!Proxy.isProxyClass(targetType)) {
        specificHandlerType = ClassUtils.getUserClass(targetType);
        handlerTypes.add(specificHandlerType);
    }
    handlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType));

    <span class="hljs-keyword">for</span> (Class&lt;?&gt; currentHandlerType : handlerTypes) {
        <span class="hljs-keyword">final</span> Class&lt;?&gt; targetClass = (specificHandlerType != <span class="hljs-keyword">null</span> ? specificHandlerType : currentHandlerType);

        ReflectionUtils.doWithMethods(currentHandlerType, method -&gt; {
            Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);
            T result = metadataLookup.inspect(specificMethod);
            <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) {
                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);
                <span class="hljs-keyword">if</span> (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == <span class="hljs-keyword">null</span>) {
                    methodMap.put(specificMethod, result);
                }
            }
        }, ReflectionUtils.USER_DECLARED_METHODS);
    }

    <span class="hljs-keyword">return</span> methodMap;
}
</code></pre><p>核心是中间的 for 循环：它会循环类中所有的方法，并且根据一个 <code>MetadataLookup</code> 类型来确定是否可以符合匹配条件。</p>
<p>注意 <code>MetadataLookup</code> 是一个函数式接口：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MetadataLookup</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-function">T <span class="hljs-title">inspect</span><span class="hljs-params">(Method method)</span></span>;
}
</code></pre><hr>
<p>回到上面的方法中，筛选方法中传入的 Lambda 表达式如下：</p>
<pre><code class="hljs java" lang="java">    Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,
            (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 3.5</span>
                    <span class="hljs-keyword">return</span> getMappingForMethod(method, userType);
                }
                <span class="hljs-keyword">catch</span> (Throwable ex) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Invalid mapping on handler class ["</span> +
                            userType.getName() + <span class="hljs-string">"]: "</span> + method, ex);
                }
            });
</code></pre><p>它最终是调 <code>getMappingForMethod</code> 方法：</p>
<h3 class="heading">3.5 getMappingForMethod</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> RequestMappingInfo <span class="hljs-title">getMappingForMethod</span><span class="hljs-params">(Method method, Class&lt;?&gt; handlerType)</span> </span>{
    <span class="hljs-comment">// 创建方法级别的RequestMappingInfo</span>
    RequestMappingInfo info = createRequestMappingInfo(method);
    <span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 创建类级别的RequestMappingInfo</span>
        RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);
        <span class="hljs-keyword">if</span> (typeInfo != <span class="hljs-keyword">null</span>) {
            info = typeInfo.combine(info);
        }
        <span class="hljs-comment">// 拼接路径前缀</span>
        String prefix = getPathPrefix(handlerType);
        <span class="hljs-keyword">if</span> (prefix != <span class="hljs-keyword">null</span>) {
            info = RequestMappingInfo.paths(prefix).build().combine(info);
        }
    }
    <span class="hljs-keyword">return</span> info;
}
</code></pre><p>这里面分为几个步骤：创建方法级别的 <code>RequestMappingInfo</code> ，创建类级别的 <code>RequestMappingInfo</code> ，拼接路径前缀。一步一步来看：</p>
<h4 class="heading">3.5.1 createRequestMappingInfo(method)</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> RequestMappingInfo <span class="hljs-title">createRequestMappingInfo</span><span class="hljs-params">(AnnotatedElement element)</span> </span>{
    RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);
    RequestCondition&lt;?&gt; condition = (element <span class="hljs-keyword">instanceof</span> Class ?
            getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element));
    <span class="hljs-keyword">return</span> (requestMapping != <span class="hljs-keyword">null</span> ? createRequestMappingInfo(requestMapping, condition) : <span class="hljs-keyword">null</span>);
}
</code></pre><p>这部分很明显就是在解析 <code>@RequestMapping</code> 注解了！最终会把 <code>@RequestMapping</code> 及相关的属性封装到一个 <code>RequestMappingInfo</code> 对象中，逻辑比较简单。</p>
<h4 class="heading">3.5.2 createRequestMappingInfo(handlerType)</h4>
<p>这部分也是一样的道理，不过这里面有个关键的部分：如果类上声明了 <code>@RequestMapping</code> 注解，会把这段注解跟方法上的 <code>@RequestMapping</code> 做一个拼接。</p>
<pre><code class="hljs java" lang="java">RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);
<span class="hljs-keyword">if</span> (typeInfo != <span class="hljs-keyword">null</span>) {
    info = typeInfo.combine(info); <span class="hljs-comment">// 拼接</span>
}
</code></pre><h4 class="heading">3.5.3 getPathPrefix(handlerType)</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> Map&lt;String, Predicate&lt;Class&lt;?&gt;&gt;&gt; pathPrefixes = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();

<span class="hljs-function">String <span class="hljs-title">getPathPrefix</span><span class="hljs-params">(Class&lt;?&gt; handlerType)</span> </span>{
    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Predicate&lt;Class&lt;?&gt;&gt;&gt; entry : <span class="hljs-keyword">this</span>.pathPrefixes.entrySet()) {
        <span class="hljs-keyword">if</span> (entry.getValue().test(handlerType)) {
            String prefix = entry.getKey();
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.embeddedValueResolver != <span class="hljs-keyword">null</span>) {
                prefix = <span class="hljs-keyword">this</span>.embeddedValueResolver.resolveStringValue(prefix);
            }
            <span class="hljs-keyword">return</span> prefix;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>这里面提到了一个陌生的属性：<code>pathPrefixes</code> 。</p>
<p>这个属性，借助IDEA发现有对应的set方法，而set方法只有一个位置有调用它：<code>WebMvcAutoConfiguration</code> ，初始化时调用过（不过它直接回调了父类 <code>WebMvcConfigurationSupport</code> 的方法）。</p>
<h5 class="heading">3.5.3.1 WebMvcConfigurationSupport#requestMappingHandlerMapping</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> RequestMappingHandlerMapping <span class="hljs-title">requestMappingHandlerMapping</span><span class="hljs-params">()</span> </span>{
    RequestMappingHandlerMapping mapping = createRequestMappingHandlerMapping();
    <span class="hljs-comment">// ......</span>
    PathMatchConfigurer configurer = getPathMatchConfigurer();
    <span class="hljs-comment">// ......</span>
    Map&lt;String, Predicate&lt;Class&lt;?&gt;&gt;&gt; pathPrefixes = configurer.getPathPrefixes();
    <span class="hljs-keyword">if</span> (pathPrefixes != <span class="hljs-keyword">null</span>) {
        mapping.setPathPrefixes(pathPrefixes);
    }

    <span class="hljs-keyword">return</span> mapping;
}
</code></pre><p>可以发现调用的set方法来自于上面的 <code>configurer.getPathPrefixes</code> ，而 <code>configurer</code> 又来源于 <code>getPathMatchConfigurer</code> 。</p>
<h5 class="heading">3.5.3.2 getPathMatchConfigurer</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> PathMatchConfigurer <span class="hljs-title">getPathMatchConfigurer</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pathMatchConfigurer == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">this</span>.pathMatchConfigurer = <span class="hljs-keyword">new</span> PathMatchConfigurer();
        configurePathMatch(<span class="hljs-keyword">this</span>.pathMatchConfigurer);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pathMatchConfigurer;
}
</code></pre><p>这里面它专门有一个 <code>configurePathMatch</code> 方法用来配置 <code>PathMatch</code> 。</p>
<h5 class="heading">3.5.2.3 configurePathMatch</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>{
    <span class="hljs-keyword">this</span>.configurers.configurePathMatch(configurer);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>{
    <span class="hljs-keyword">for</span> (WebMvcConfigurer delegate : <span class="hljs-keyword">this</span>.delegates) {
        delegate.configurePathMatch(configurer);
    }
}
</code></pre><p>可以发现这一部分是将所有IOC容器中的 <code>WebMvcConfigurer</code> 都拿出来回调 <code>configurePathMatch</code> 方法。（这也启发我们可以自定义一些配置类，实现 <code>WebMvcConfigurer</code> 接口来重写 <code>configurePathMatch</code> 方法，添加自定义规则）</p>
<hr>
<p>到这里位置，方法的前缀路径就拼好了，下面到了最后一步：注册方法映射</p>
<h3 class="heading">3.6 registerHandlerMethod：注册方法映射</h3>
<pre><code class="hljs java" lang="java">    methods.forEach((method, mapping) -&gt; {
        Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);
        registerHandlerMethod(handler, invocableMethod, mapping);
    });
</code></pre><p>这部分会根据已经筛选好的方法，来注册 <code>HandlerMethod</code> 。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MappingRegistry mappingRegistry = <span class="hljs-keyword">new</span> MappingRegistry();

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerHandlerMethod</span><span class="hljs-params">(Object handler, Method method, T mapping)</span> </span>{
    <span class="hljs-keyword">this</span>.mappingRegistry.register(mapping, handler, method);
}
</code></pre><p>进到 <code>register</code> 中：（关键部分注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(T mapping, Object handler, Method method)</span> </span>{
    <span class="hljs-comment">// 读写锁加锁</span>
    <span class="hljs-keyword">this</span>.readWriteLock.writeLock().lock();
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 将Controller的类型和Controller中的方法包装为一个HandlerMethod对象</span>
        HandlerMethod handlerMethod = createHandlerMethod(handler, method);
        assertUniqueMethodMapping(handlerMethod, mapping);
        <span class="hljs-comment">// 将RequestMappingInfo和Controller的目标方法存入Map中</span>
        <span class="hljs-keyword">this</span>.mappingLookup.put(mapping, handlerMethod);

        <span class="hljs-comment">// 将注解中的映射url和RequestMappingInfo存入Map</span>
        List&lt;String&gt; directUrls = getDirectUrls(mapping);
        <span class="hljs-keyword">for</span> (String url : directUrls) {
            <span class="hljs-keyword">this</span>.urlLookup.add(url, mapping);
        }

        String name = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">if</span> (getNamingStrategy() != <span class="hljs-keyword">null</span>) {
            name = getNamingStrategy().getName(handlerMethod, mapping);
            addMappingName(name, handlerMethod);
        }

        <span class="hljs-comment">// 将Controller目标方法和跨域配置存入Map</span>
        CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);
        <span class="hljs-keyword">if</span> (corsConfig != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);
        }

        <span class="hljs-comment">// uri 映射 HandlerMethod封装的MappingRegistration对象，存入Map中</span>
        <span class="hljs-keyword">this</span>.registry.put(mapping, <span class="hljs-keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));
    }
    <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">this</span>.readWriteLock.writeLock().unlock();
    }
}
</code></pre><p>上面的源码逻辑也算比较清晰的了，外层它会保证线程安全，中间的try块会封装 <code>Controller</code> 和它的方法，变成一个 <code>HandlerMethod</code> 对象，之后分别保存三组Map映射（源码中已标注注释），完成注册。</p>
<p>至此，<code>@Controller</code> 中的 <code>@RequestMapping</code> 信息已经被装载进 <code>RequestMappingHandlerMapping</code> 中。</p>
<h2 class="heading">小结</h2>
<ol>
<li>Servlet3.0规范中取消了 <code>web.xml</code>，改用 <code>ServletContainerInitializer</code> 来接管应用启动。</li>
<li><code>SpringBootServletInitializer</code> 实现了 <code>WebApplicationInitializer</code> ，用于被 <code>ServletContainerInitializer</code> 引导 SpringBoot 应用启动。</li>
<li>Controller 中的 <code>@RequestMapping</code> 标注的方法装载时机是 <code>RequestMappingHandlerMapping</code> 的初始化阶段。</li>
</ol>
<p>【本篇我们主要了解了 SpringBoot 打war包运行的原理，以及 Controller 中的映射方法的加载原理，下一篇咱来真正走一遍 <code>DispatcherServlet</code> 的工作原理，体会 WebMvc 中的设计】</p>
</div>
</body></html>