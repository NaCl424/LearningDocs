<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>IOC：刷新容器-BeanFactory的预处理</h1>
<h1 class="heading">11. IOC：刷新容器-BeanFactory的预处理</h1>
<p>（接下来的几篇将会有非常多的干货，小伙伴们一定要好好理解好好消化）</p>
<p>（因为IOC容器的刷新部分实在太多而且复杂，这部分将不延续之前文章的标号，单独成编号体系）</p>
<p>【接前章】</p>
<pre><code class="hljs java" lang="java">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);
        refreshContext(context);
        afterRefresh(context, applicationArguments);
</code></pre><p>上一篇IOC容器已经准备好了，下面到了IOC容器最核心的部分：<strong>refresh</strong>。</p>
<h2 class="heading">0. refreshContext</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshContext</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>{
    refresh(context);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.registerShutdownHook) {
        <span class="hljs-keyword">try</span> {
            context.registerShutdownHook();
        }
        <span class="hljs-keyword">catch</span> (AccessControlException ex) {
            <span class="hljs-comment">// Not allowed in some environments.</span>
        }
    }
}
</code></pre><p>它直接调了refresh方法（注意此时还是 SpringApplication，没有进到真正的IOC容器），后面又注册了一个关闭的钩子。这个 <code>registerShutdownHook</code> 方法的文档注释：</p>
<blockquote>
<p>Register a shutdown hook with the JVM runtime, closing this context on JVM shutdown unless it has already been closed at that time.</p>
<p>向JVM运行时注册一个shutdown的钩子，除非JVM当时已经关闭，否则在JVM关闭时关闭上下文。</p>
</blockquote>
<p>可以大概看出来，这个钩子的作用是监听JVM关闭时销毁IOC容器和里面的Bean。这里面有一个很经典的应用：应用停止时释放数据库连接池里面的连接。</p>
<p>下面咱来看这个refresh方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">(ApplicationContext applicationContext)</span> </span>{
    Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);
    ((AbstractApplicationContext) applicationContext).refresh();
}
</code></pre><p>没有什么复杂的逻辑，它会直接强转成 <code>AbstractApplicationContext</code>，调它的refresh方法。之前我们有了解过，<code>AbstractApplicationContext</code> 中的 <strong>refresh</strong> 是IOC容器启动时的最核心方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">//最终调到AbstractApplicationContext的refresh方法</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>{
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) {
        <span class="hljs-comment">// Prepare this context for refreshing.</span>
        <span class="hljs-comment">// 1. 初始化前的预处理</span>
        prepareRefresh();

        <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span>
        <span class="hljs-comment">// 2. 获取BeanFactory，加载所有bean的定义信息（未实例化）</span>
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        <span class="hljs-comment">// Prepare the bean factory for use in this context.</span>
        <span class="hljs-comment">// 3. BeanFactory的预处理配置</span>
        prepareBeanFactory(beanFactory);

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span>
            <span class="hljs-comment">// 4. 准备BeanFactory完成后进行的后置处理</span>
            postProcessBeanFactory(beanFactory);

            <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span>
            <span class="hljs-comment">// 5. 执行BeanFactory创建后的后置处理器</span>
            invokeBeanFactoryPostProcessors(beanFactory);

            <span class="hljs-comment">// Register bean processors that intercept bean creation.</span>
            <span class="hljs-comment">// 6. 注册Bean的后置处理器</span>
            registerBeanPostProcessors(beanFactory);

            <span class="hljs-comment">// Initialize message source for this context.</span>
            <span class="hljs-comment">// 7. 初始化MessageSource</span>
            initMessageSource();

            <span class="hljs-comment">// Initialize event multicaster for this context.</span>
            <span class="hljs-comment">// 8. 初始化事件派发器</span>
            initApplicationEventMulticaster();

            <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span>
            <span class="hljs-comment">// 9. 子类的多态onRefresh</span>
            onRefresh();

            <span class="hljs-comment">// Check for listener beans and register them.</span>
            <span class="hljs-comment">// 10. 注册监听器</span>
            registerListeners();
          
            <span class="hljs-comment">//到此为止，BeanFactory已创建完成</span>

            <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span>
            <span class="hljs-comment">// 11. 初始化所有剩下的单例Bean</span>
            finishBeanFactoryInitialization(beanFactory);

            <span class="hljs-comment">// Last step: publish corresponding event.</span>
            <span class="hljs-comment">// 12. 完成容器的创建工作</span>
            finishRefresh();
        }

        <span class="hljs-keyword">catch</span> (BeansException ex) {
            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) {
                logger.warn(<span class="hljs-string">"Exception encountered during context initialization - "</span> +
                        <span class="hljs-string">"cancelling refresh attempt: "</span> + ex);
            }

            <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span>
            destroyBeans();

            <span class="hljs-comment">// Reset 'active' flag.</span>
            cancelRefresh(ex);

            <span class="hljs-comment">// Propagate exception to caller.</span>
            <span class="hljs-keyword">throw</span> ex;
        }

        <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// Reset common introspection caches in Spring's core, since we</span>
            <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span>
            <span class="hljs-comment">// 13. 清除缓存</span>
            resetCommonCaches();
        }
    }
}
</code></pre><p>这个方法非常长，一共有13个步骤，本篇我们来看前3个步骤：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>{
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) {
        <span class="hljs-comment">// Prepare this context for refreshing.</span>
        <span class="hljs-comment">// 1. 初始化前的预处理</span>
        prepareRefresh();

        <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span>
        <span class="hljs-comment">// 2. 获取BeanFactory，加载所有bean的定义信息（未实例化）</span>
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        <span class="hljs-comment">// Prepare the bean factory for use in this context.</span>
        <span class="hljs-comment">// 3. BeanFactory的预处理配置</span>
        prepareBeanFactory(beanFactory);
</code></pre><h2 class="heading">1. prepareRefresh：初始化前的预处理</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareRefresh</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>.startupDate = System.currentTimeMillis(); <span class="hljs-comment">// 记录启动时间</span>
    <span class="hljs-keyword">this</span>.closed.set(<span class="hljs-keyword">false</span>); <span class="hljs-comment">// 标记IOC容器的关闭状态为false</span>
    <span class="hljs-keyword">this</span>.active.set(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 标记IOC容器已激活</span>

    <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) {
        logger.info(<span class="hljs-string">"Refreshing "</span> + <span class="hljs-keyword">this</span>);
    }

    <span class="hljs-comment">// Initialize any placeholder property sources in the context environment</span>
    <span class="hljs-comment">// 1.1 初始化属性配置</span>
    initPropertySources();

    <span class="hljs-comment">// Validate that all properties marked as required are resolvable</span>
    <span class="hljs-comment">// see ConfigurablePropertyResolver#setRequiredProperties</span>
    <span class="hljs-comment">// 1.2 属性校验</span>
    getEnvironment().validateRequiredProperties();

    <span class="hljs-comment">// Allow for the collection of early ApplicationEvents,</span>
    <span class="hljs-comment">// to be published once the multicaster is available...</span>
    <span class="hljs-comment">// 这个集合的作用，是保存容器中的一些事件，以便在合适的时候利用事件广播器来广播这些事件</span>
    <span class="hljs-comment">// 【配合registerListeners方法中的第三部分使用】</span>
    <span class="hljs-keyword">this</span>.earlyApplicationEvents = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
}
</code></pre><p>最前面先记录启动时间，标记IOC容器状态，之后要开始初始化属性配置：</p>
<h3 class="heading">1.1 initPropertySources：初始化属性配置</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initPropertySources</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// For subclasses: do nothing by default.</span>
}
</code></pre><p>这个方法是一个模板方法，留给子类重写，默认不做任何事情。</p>
<p>借助IDEA，发现这个方法在 <code>GenericWebApplicationContext</code> 中有重写，而 <code>AnnotationConfigServletWebServerApplicationContext</code> 恰好继承了它。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initPropertySources</span><span class="hljs-params">()</span> </span>{
    ConfigurableEnvironment env = getEnvironment();
    <span class="hljs-keyword">if</span> (env <span class="hljs-keyword">instanceof</span> ConfigurableWebEnvironment) {
        ((ConfigurableWebEnvironment) env).initPropertySources(<span class="hljs-keyword">this</span>.servletContext, <span class="hljs-keyword">null</span>);
    }
}
</code></pre><p>它最终又调到 <code>Environment</code> 的 <code>initPropertySources</code> 中。<code>StandardServletEnvironment</code> 是唯一重写这个方法的：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initPropertySources</span><span class="hljs-params">(@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)</span> </span>{
    WebApplicationContextUtils.initServletPropertySources(getPropertySources(), servletContext, servletConfig);
}
</code></pre><p>继续追踪 <code>WebApplicationContextUtils.initServletPropertySources</code>：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVLET_CONTEXT_PROPERTY_SOURCE_NAME = <span class="hljs-string">"servletContextInitParams"</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVLET_CONFIG_PROPERTY_SOURCE_NAME = <span class="hljs-string">"servletConfigInitParams"</span>;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initServletPropertySources</span><span class="hljs-params">(MutablePropertySources sources,
        @Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)</span> </span>{

    Assert.notNull(sources, <span class="hljs-string">"'propertySources' must not be null"</span>);
    String name = StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME;
    <span class="hljs-keyword">if</span> (servletContext != <span class="hljs-keyword">null</span> &amp;&amp; sources.contains(name) &amp;&amp; sources.get(name) <span class="hljs-keyword">instanceof</span> StubPropertySource) {
        sources.replace(name, <span class="hljs-keyword">new</span> ServletContextPropertySource(name, servletContext));
    }
    name = StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME;
    <span class="hljs-keyword">if</span> (servletConfig != <span class="hljs-keyword">null</span> &amp;&amp; sources.contains(name) &amp;&amp; sources.get(name) <span class="hljs-keyword">instanceof</span> StubPropertySource) {
        sources.replace(name, <span class="hljs-keyword">new</span> ServletConfigPropertySource(name, servletConfig));
    }
}
</code></pre><p>这个方法的文档注释：</p>
<blockquote>
<p>Replace Servlet-based stub property sources with actual instances populated with the given servletContext and servletConfig objects.
This method is idempotent with respect to the fact it may be called any number of times but will perform replacement of stub property sources with their corresponding actual property sources once and only once.</p>
<p>将基于Servlet的存根属性源替换为使用给定 <code>ServletContext</code> 和 <code>ServletConfig</code> 对象填充的实际实例。</p>
<p>关于此方法可以调用任意次的事实，它是幂等的，但是将用其相应的实际属性源执行一次且仅一次的存根属性源替换。</p>
</blockquote>
<p>通过大概的阅读文档注释和内部的两个if，可以大概确定它是把 Servlet 的一些初始化参数放入IOC容器中（类似于 web.xml 中的参数放入IOC容器）。</p>
<hr>
<p>回到prepareRefresh方法：</p>
<pre><code class="hljs java" lang="java">    initPropertySources();

    <span class="hljs-comment">// Validate that all properties marked as required are resolvable</span>
    <span class="hljs-comment">// see ConfigurablePropertyResolver#setRequiredProperties</span>
    <span class="hljs-comment">// 1.2 属性校验</span>
    getEnvironment().validateRequiredProperties();
</code></pre><h3 class="heading">1.2 validateRequiredProperties：属性校验</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// AbstractEnvironment</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validateRequiredProperties</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MissingRequiredPropertiesException </span>{
    <span class="hljs-keyword">this</span>.propertyResolver.validateRequiredProperties();
}

<span class="hljs-comment">// AbstractPropertyResolver</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validateRequiredProperties</span><span class="hljs-params">()</span> </span>{
    MissingRequiredPropertiesException ex = <span class="hljs-keyword">new</span> MissingRequiredPropertiesException();
    <span class="hljs-keyword">for</span> (String key : <span class="hljs-keyword">this</span>.requiredProperties) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getProperty(key) == <span class="hljs-keyword">null</span>) {
            ex.addMissingRequiredProperty(key);
        }
    }
    <span class="hljs-keyword">if</span> (!ex.getMissingRequiredProperties().isEmpty()) {
        <span class="hljs-keyword">throw</span> ex;
    }
}
</code></pre><p>从调用的两步来看，它是要检验一些必需的属性是否为空，如果有null的属性会抛出异常。从源码的英文单行注释中可以看到，它与 <code>ConfigurablePropertyResolver</code> 的 <code>setRequiredProperties</code> 方法有关。翻看这个方法的文档注释：</p>
<blockquote>
<p>Specify which properties must be present, to be verified by validateRequiredProperties().</p>
<p>指定必须存在哪些属性，以通过 <code>validateRequiredProperties</code> 方法进行验证。</p>
</blockquote>
<p>它是说指定了属性，就可以通过 <code>validateRequiredProperties</code> 方法校验。那到底有没有字段校验呢？咱通过Debug来看一眼：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/16/16dd225d23f70b03~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>。。。。。。根本就没有要校验的。。。那这一步就跳过去吧。。。。。。</p>
<hr>
<p>回到 <code>prepareRefresh</code> 方法：</p>
<pre><code class="hljs java" lang="java">    getEnvironment().validateRequiredProperties();

    <span class="hljs-comment">// Allow for the collection of early ApplicationEvents,</span>
    <span class="hljs-comment">// to be published once the multicaster is available...</span>
    <span class="hljs-comment">// 这个集合的作用，是保存容器中的一些事件，以便在合适的时候利用事件广播器来广播这些事件</span>
    <span class="hljs-comment">// 【配合registerListeners方法中的第三部分使用】</span>
    <span class="hljs-keyword">this</span>.earlyApplicationEvents = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
</code></pre><p>这个早期事件，目前还不好解释，得联系后面的一个组件来解释。</p>
<h2 class="heading">2. obtainFreshBeanFactory：获取BeanFactory，加载所有bean的定义信息</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableListableBeanFactory <span class="hljs-title">obtainFreshBeanFactory</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 2.1 刷新BeanFactory</span>
    refreshBeanFactory();
    <span class="hljs-keyword">return</span> getBeanFactory();
}
</code></pre><p>源码非常简单，先刷新后获取。</p>
<h3 class="heading">2.1 refreshBeanFactory</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException</span>;
</code></pre><p>发现它是一个抽象方法，留给子类重写。对于XML配置的IOC容器，和注解配置的IOC容器，分别有一种实现。借助IDEA，发现 <code>GenericApplicationContext</code> 和 <code>AbstractRefreshableApplicationContext</code> 重写了它。根据前面的分析，<code>AnnotationConfigServletWebServerApplicationContext</code> 继承了 <code>GenericApplicationContext</code>，故咱来看它的 <code>refreshBeanFactory</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.refreshed.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(
                <span class="hljs-string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);
    }
    <span class="hljs-keyword">this</span>.beanFactory.setSerializationId(getId());
}
</code></pre><p>逻辑很简单，只是设置了 <code>BeanFactory</code> 的序列化ID而已。</p>
<h4 class="heading">2.1.1 【扩展】基于XML的refreshBeanFactory</h4>
<p>上面看到有两个子类重写了这个方法（XML和注解的），基于XML配置的IOC容器，在这一步要做的事情要更复杂，简单扫一眼：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>{
    <span class="hljs-keyword">if</span> (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 创建BeanFactory</span>
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        beanFactory.setSerializationId(getId());
        <span class="hljs-comment">// 自定义配置BeanFactory</span>
        customizeBeanFactory(beanFactory);
        <span class="hljs-comment">// 解析、加载XML中定义的BeanDefinition</span>
        loadBeanDefinitions(beanFactory);
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanFactoryMonitor) {
            <span class="hljs-keyword">this</span>.beanFactory = beanFactory;
        }
    }
    <span class="hljs-keyword">catch</span> (IOException ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);
    }
}

<span class="hljs-function"><span class="hljs-keyword">protected</span> DefaultListableBeanFactory <span class="hljs-title">createBeanFactory</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());
}

<span class="hljs-comment">// 使用XmlBeanDefinitionReader做bean的装配（即解析xml）</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException, IOException </span>{
    <span class="hljs-comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span>
    XmlBeanDefinitionReader beanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(beanFactory);

    <span class="hljs-comment">// Configure the bean definition reader with this context's</span>
    <span class="hljs-comment">// resource loading environment.</span>
    beanDefinitionReader.setEnvironment(<span class="hljs-keyword">this</span>.getEnvironment());
    beanDefinitionReader.setResourceLoader(<span class="hljs-keyword">this</span>);
    beanDefinitionReader.setEntityResolver(<span class="hljs-keyword">new</span> ResourceEntityResolver(<span class="hljs-keyword">this</span>));

    <span class="hljs-comment">// Allow a subclass to provide custom initialization of the reader,</span>
    <span class="hljs-comment">// then proceed with actually loading the bean definitions.</span>
    initBeanDefinitionReader(beanDefinitionReader);
    loadBeanDefinitions(beanDefinitionReader);
}
</code></pre><p>可以发现逻辑更复杂。简单来看一下吧：</p>
<p>如果已经有 BeanFactory 了，销毁Bean和 BeanFactory 。之后创建一个 BeanFactory，设置序列化ID，执行自定义 BeanFactory 的逻辑，之后加载Bean定义，最后设置到IOC容器中。</p>
<p>这其中有xml的加载和读取，由于 SpringBoot 已经几乎放弃xml配置，全部通过注解和 JavaConfig 来配置应用，故不再深入研究。</p>
<h3 class="heading">2.2 getBeanFactory</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ConfigurableListableBeanFactory <span class="hljs-title">getBeanFactory</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.beanFactory;
}
</code></pre><p>更简单了，不必多言。</p>
<h2 class="heading">3. prepareBeanFactory：BeanFactory的预处理配置</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{
    <span class="hljs-comment">// Tell the internal bean factory to use the context's class loader etc.</span>
    <span class="hljs-comment">// 设置BeanFactory的类加载器、表达式解析器等</span>
    beanFactory.setBeanClassLoader(getClassLoader());
    beanFactory.setBeanExpressionResolver(<span class="hljs-keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
    beanFactory.addPropertyEditorRegistrar(<span class="hljs-keyword">new</span> ResourceEditorRegistrar(<span class="hljs-keyword">this</span>, getEnvironment()));

    <span class="hljs-comment">// Configure the bean factory with context callbacks.</span>
    <span class="hljs-comment">// 3.1 配置一个可回调注入ApplicationContext的BeanPostProcessor</span>
    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationContextAwareProcessor(<span class="hljs-keyword">this</span>));
    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

    <span class="hljs-comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span>
    <span class="hljs-comment">// MessageSource registered (and found for autowiring) as a bean.</span>
    <span class="hljs-comment">// 3.2 自动注入的支持</span>
    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="hljs-keyword">this</span>);
    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="hljs-keyword">this</span>);
    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span>
    <span class="hljs-comment">// 3.3 配置一个可加载所有监听器的组件</span>
    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationListenerDetector(<span class="hljs-keyword">this</span>));

    <span class="hljs-comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span>
    <span class="hljs-keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));
        <span class="hljs-comment">// Set a temporary ClassLoader for type matching.</span>
        beanFactory.setTempClassLoader(<span class="hljs-keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }

    <span class="hljs-comment">// Register default environment beans.</span>
    <span class="hljs-comment">// 注册了默认的运行时环境、系统配置属性、系统环境的信息</span>
    <span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
    }
    <span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
    }
    <span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
    }
}
</code></pre><p>在源码中发现了一个组件概念：<strong><code>BeanPostProcessor</code></strong>。这个概念非常非常重要，我们先来了解一下它。</p>
<p>【如果小伙伴不是很了解或不了解 <strong><code>BeanPostProcessor</code></strong>，请继续往下看；对 <code>BeanPostProcessor</code> 很熟悉的小伙伴可以跳过第3.0节】</p>
<h3 class="heading">3.0 【重要】BeanPostProcessor</h3>
<p>它的文档注释原文翻译：</p>
<blockquote>
<p>Factory hook that allows for custom modification of new bean instances, e.g. checking for marker interfaces or wrapping them with proxies.
ApplicationContexts can autodetect BeanPostProcessor beans in their bean definitions and apply them to any beans subsequently created. Plain bean factories allow for programmatic registration of post-processors, applying to all beans created through this factory.
Typically, post-processors that populate beans via marker interfaces or the like will implement postProcessBeforeInitialization, while post-processors that wrap beans with proxies will normally implement postProcessAfterInitialization.</p>
<p>这个接口允许自定义修改新的Bean的实例，例如检查它们的接口或者将他们包装成代理对象等，</p>
<p>ApplicationContexts能自动察觉到我们在 <code>BeanPostProcessor</code> 里对对象作出的改变，并在后来创建该对象时应用其对应的改变。普通的bean工厂允许对后置处理器进行程序化注册，它适用于通过该工厂创建的所有bean。</p>
<p>通常，通过标记接口等填充bean的后处理器将实现 <code>postProcessBeforeInitialization</code>，而使用代理包装bean的后处理器将实现 <code>postProcessAfterInitialization</code>。</p>
</blockquote>
<p>它通常被称为 <strong>“Bean的后置处理器”</strong>，它的作用在文档注释中也描述的差不多，<strong>它可以在对象实例化但初始化之前，以及初始化之后进行一些后置处理</strong>。</p>
<p>可以这样简单理解 Bean 的初始化步骤，以及 BeanPostProcessor 的切入时机：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/5/16e3bb3c836be8e1~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>下面用一个实例快速感受 <code>BeanPostProcessor</code> 的作用。</p>
<h4 class="heading">3.0.1 BeanPostProcessor的使用</h4>
<p>声明一个 Cat 类：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>{
    String name;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
}
</code></pre><p>再声明一个 CatBeanPostProcessor：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CatBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>{
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
        <span class="hljs-keyword">return</span> bean;
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Cat) {
            Cat cat = (Cat) bean;
            cat.name = <span class="hljs-string">"dog"</span>;
        }
        <span class="hljs-keyword">return</span> bean;
    }
    
}
</code></pre><p><code>BeanPostProcessor</code> 可以在前后做一些额外的处理。</p>
<p>接下来，编写一个配置类，并创建这个Cat对象：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"com.example.demo.postprocessor"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigurationDemo</span> </span>{
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Cat <span class="hljs-title">cat</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">"cat"</span>);
    }
    
}
</code></pre><p>启动IOC容器，并获取这个Cat，打印它的name，发现打印输出是dog，证明后置处理器已经起作用了。</p>
<h4 class="heading">3.0.2 【执行时机】Bean初始化的顺序及BeanPostProcessor的执行时机</h4>
<p>我们在学过 SpringFramework 的时候，知道Bean的几种额外的初始化方法的指定（<code>init-method</code>，<code>@PostConstruct</code>，<code>InitializingBean接口</code>）。那么它们以及构造方法的执行顺序，以及 <code>BeanPostProcessor</code> 的执行时机分别是什么呢？我们修改上面的代码来测试一下：</p>
<p>修改 Cat：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>{
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name)</span> </span>{
        System.out.println(<span class="hljs-string">"Cat constructor run..."</span>);
    }
    
    <span class="hljs-meta">@PostConstruct</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterInit</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Cat PostConstruct run..."</span>);
    }
    
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Cat afterPropertiesSet run..."</span>);
    }
}
</code></pre><p>修改 CatBeanPostProcessor：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CatBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>{
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Cat) {
            System.out.println(<span class="hljs-string">"Cat postProcessBeforeInitialization run..."</span>);
        }
        <span class="hljs-keyword">return</span> bean;
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Cat) {
            System.out.println(<span class="hljs-string">"Cat postProcessAfterInitialization run..."</span>);
        }
        <span class="hljs-keyword">return</span> bean;
    }
    
}
</code></pre><p>重新启动IOC容器，打印结果如下：</p>
<pre><code class="hljs bash" lang="bash">Cat constructor run...
Cat postProcessBeforeInitialization run...
Cat PostConstruct run...
Cat afterPropertiesSet run...
Cat postProcessAfterInitialization run...
</code></pre><p>由此可得结论：</p>
<ul>
<li>初始化执行顺序：
<ul>
<li>构造方法</li>
<li><code>@PostConstruct</code> / <code>init-method</code></li>
<li><code>InitializingBean</code> 的 <code>afterPropertiesSet</code> 方法</li>
</ul>
</li>
<li>BeanPostProcessor的执行时机
<ul>
<li>before：构造方法之后，<code>@PostConstruct</code> 之前</li>
<li>after：<code>afterPropertiesSet</code> 之后</li>
</ul>
</li>
</ul>
<p>出现这种情况的原理，我们可以先翻看文档注释，等到后面初始化单实例Bean时会有源码解析。</p>
<ul>
<li>
<p>@PostConstruct</p>
<ul>
<li>
<blockquote>
<p>The PostConstruct annotation is used on a method that needs to be executed after dependency injection is done to perform any initialization. This method MUST be invoked before the class is put into service. This annotation MUST be supported on all classes that support dependency injection.</p>
<p>PostConstruct注解，用于标注在需要依赖注入完成，以执行任何初始化之后需要执行的方法上。在Bean投入使用之前必须调用此方法。所有支持依赖注入的类都必须支持该注解。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>InitializingBean：</p>
<ul>
<li>
<blockquote>
<p>Interface to be implemented by beans that need to react once all their properties have been set by a BeanFactory: e.g. to perform custom initialization, or merely to check that all mandatory properties have been set.
An alternative to implementing InitializingBean is specifying a custom init method, for example in an XML bean definition.</p>
<p>由 BeanFactory 设置完所有属性后需要作出反应的bean所实现的接口：执行自定义初始化，或仅检查是否已设置所有必填属性。</p>
<p>实现InitializingBean的替代方法是指定自定义 init-method，例如在XML bean定义中。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>BeanPostProcessor：</p>
<ul>
<li>
<p>before：</p>
<ul>
<li>
<blockquote>
<p>Apply this BeanPostProcessor to the given new bean instance before any bean initialization callbacks (like InitializingBean's afterPropertiesSet or a custom init-method). The bean will already be populated with property values. The returned bean instance may be a wrapper around the original.</p>
<p>在任何bean初始化回调（例如 <code>InitializingBean的afterPropertiesSet</code> 或 <code>自定义init-method</code>）之前，将此 BeanPostProcessor 应用于给定的新bean实例。该bean将已经用属性值填充。返回的bean实例可能是原始实例的包装。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>after：</p>
<ul>
<li>
<blockquote>
<p>Apply this BeanPostProcessor to the given new bean instance after any bean initialization callbacks (like InitializingBean's afterPropertiesSet or a custom init-method). The bean will already be populated with property values. The returned bean instance may be a wrapper around the original.</p>
<p>在任何bean初始化回调（例如<code>InitializingBean的afterPropertiesSet</code> 或 <code>自定义init-method</code>）之后，将此 BeanPostProcessor 应用于给定的新bean实例。该bean将已经用属性值填充。返回的bean实例可能是原始实例的包装。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<p>了解 <code>BeanPostProcessor</code> 后，来看下面几个片段：</p>
<h3 class="heading">3.1 addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</h3>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Configure the bean factory with context callbacks.</span>
    <span class="hljs-comment">// 3.1 配置一个可回调注入ApplicationContext的BeanPostProcessor</span>
    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationContextAwareProcessor(<span class="hljs-keyword">this</span>));
    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
</code></pre><p>它先配置了一个 <code>ApplicationContextAwareProcessor</code>，之后又忽略了下面几个接口。它这么做的原因是什么呢？咱不妨先来看看 <code>ApplicationContextAwareProcessor</code> 是什么。</p>
<h4 class="heading">3.1.1 ApplicationContextAwareProcessor</h4>
<p>它的文档注释原文翻译：</p>
<blockquote>
<p>BeanPostProcessor implementation that passes the ApplicationContext to beans that implement the EnvironmentAware, EmbeddedValueResolverAware, ResourceLoaderAware, ApplicationEventPublisherAware, MessageSourceAware and/or ApplicationContextAware interfaces.
Implemented interfaces are satisfied in order of their mention above.
Application contexts will automatically register this with their underlying bean factory. Applications do not use this directly.</p>
<p>BeanPostProcessor 实现，它将 ApplicationContext 传递给实现 <code>EnvironmentAware</code>，<code>EmbeddedValueResolverAware</code>，<code>ResourceLoaderAware</code>，<code>ApplicationEventPublisherAware</code>，<code>MessageSourceAware</code> 和/或 <code>ApplicationContextAware</code> 接口的bean。</p>
<p>按照上面提到的顺序满足已实现的接口。</p>
<p>IOC容器将自动在其基础bean工厂中注册它。应用程序不直接使用它。</p>
</blockquote>
<p>看到这段文档注释，就已经能明白上面的几个ignore的意义了。我们再看一眼源码，便更能理解它的设计了：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
    AccessControlContext acc = <span class="hljs-keyword">null</span>;

    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> &amp;&amp;
            (bean <span class="hljs-keyword">instanceof</span> EnvironmentAware || bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware ||
                    bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware || bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware ||
                    bean <span class="hljs-keyword">instanceof</span> MessageSourceAware || bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware)) {
        acc = <span class="hljs-keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();
    }

    <span class="hljs-keyword">if</span> (acc != <span class="hljs-keyword">null</span>) {
        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
            invokeAwareInterfaces(bean);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }, acc);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 往下调用</span>
        invokeAwareInterfaces(bean);
    }

    <span class="hljs-keyword">return</span> bean;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAwareInterfaces</span><span class="hljs-params">(Object bean)</span> </span>{
    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) {
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EnvironmentAware) {
            ((EnvironmentAware) bean).setEnvironment(<span class="hljs-keyword">this</span>.applicationContext.getEnvironment());
        }
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware) {
            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="hljs-keyword">this</span>.embeddedValueResolver);
        }
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware) {
            ((ResourceLoaderAware) bean).setResourceLoader(<span class="hljs-keyword">this</span>.applicationContext);
        }
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware) {
            ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="hljs-keyword">this</span>.applicationContext);
        }
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> MessageSourceAware) {
            ((MessageSourceAware) bean).setMessageSource(<span class="hljs-keyword">this</span>.applicationContext);
        }
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware) {
            ((ApplicationContextAware) bean).setApplicationContext(<span class="hljs-keyword">this</span>.applicationContext);
        }
    }
}
</code></pre><p>它果然在挨个判断，然后注入。</p>
<h3 class="heading">3.2 registerResolvableDependency：自动注入的支持</h3>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span>
    <span class="hljs-comment">// MessageSource registered (and found for autowiring) as a bean.</span>
    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="hljs-keyword">this</span>);
    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="hljs-keyword">this</span>);
    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="hljs-keyword">this</span>);
</code></pre><p>上面的单行注释翻译：</p>
<blockquote>
<p>BeanFactory 接口未在普通工厂中注册为可解析类型。</p>
<p>MessageSource 注册为Bean（并发现用于自动装配）。</p>
</blockquote>
<p>上面一句还能看懂，下面是干什么？讲真我也不是很清楚，咱还是看看这个方法的文档注释吧。</p>
<blockquote>
<p>Register a special dependency type with corresponding autowired value.
This is intended for factory/context references that are supposed to be autowirable but are not defined as beans in the factory: e.g. a dependency of type ApplicationContext resolved to the ApplicationContext instance that the bean is living in.
Note: There are no such default types registered in a plain BeanFactory, not even for the BeanFactory interface itself.</p>
<p>用相应的自动装配值注册一个特殊的依赖类型。</p>
<p>这适用于应该是可自动执行但未在工厂中定义为bean的工厂/上下文引用：类型为 ApplicationContext 的依赖关系已解析为Bean所在的 ApplicationContext 实例。</p>
<p>注意：在普通 BeanFactory 中没有注册这样的默认类型，甚至 BeanFactory 接口本身也没有。</p>
</blockquote>
<p>它大概的意思是如果遇到一个特殊的依赖类型，就使用一个特殊的预先准备好的对象装配进去。</p>
<p>它的方法实现（仅在 <code>DefaultListableBeanFactory</code> 中有实现）：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">/** Map from dependency type to corresponding autowired value. */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">16</span>);

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerResolvableDependency</span><span class="hljs-params">(Class&lt;?&gt; dependencyType, @Nullable Object autowiredValue)</span> </span>{
    Assert.notNull(dependencyType, <span class="hljs-string">"Dependency type must not be null"</span>);
    <span class="hljs-keyword">if</span> (autowiredValue != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (!(autowiredValue <span class="hljs-keyword">instanceof</span> ObjectFactory || dependencyType.isInstance(autowiredValue))) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Value ["</span> + autowiredValue +
                    <span class="hljs-string">"] does not implement specified dependency type ["</span> + dependencyType.getName() + <span class="hljs-string">"]"</span>);
        }
        <span class="hljs-keyword">this</span>.resolvableDependencies.put(dependencyType, autowiredValue);
    }
}
</code></pre><p>前面的判断都不看，底下有一个put操作，key和value分别是<strong>依赖的类型</strong>和<strong>自动注入的值</strong>。</p>
<p>这个 <code>resolvableDependencies</code> 是个Map，它的注释：</p>
<blockquote>
<p>从依赖项类型映射到相应的自动装配值。</p>
</blockquote>
<p>至此，它的功能已经明确了：它可以支持一些特殊依赖关系的类型，并放到 <code>resolvableDependencies</code> 集合中保存，使得能在任意位置注入上述源码中的组件。</p>
<h3 class="heading">3.3 addBeanPostProcessor(new ApplicationListenerDetector(this))</h3>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span>
    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationListenerDetector(<span class="hljs-keyword">this</span>));
</code></pre><p>又注册了一个后置处理器，来看 <code>ApplicationListenerDetector</code> 的文档注释：</p>
<blockquote>
<p>BeanPostProcessor that detects beans which implement the ApplicationListener interface. This catches beans that can't reliably be detected by getBeanNamesForType and related operations which only work against top-level beans.</p>
<p><code>BeanPostProcessor</code>，用于检测实现 <code>ApplicationListener</code> 接口的bean。这将捕获 getBeanNamesForType 和仅对顶级bean有效的相关操作无法可靠检测到的bean。</p>
</blockquote>
<p>文档注释还是比较容易理解的，它是来收集 <code>ApplicationListener</code> 的。再来看看它的源码核心部分：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> </span>{
    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationListener) {
        <span class="hljs-comment">// potentially not detected as a listener by getBeanNamesForType retrieval</span>
        Boolean flag = <span class="hljs-keyword">this</span>.singletonNames.get(beanName);
        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(flag)) {
            <span class="hljs-comment">// singleton bean (top-level or inner): register on the fly</span>
            <span class="hljs-keyword">this</span>.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(flag)) {
            <span class="hljs-keyword">if</span> (logger.isWarnEnabled() &amp;&amp; !<span class="hljs-keyword">this</span>.applicationContext.containsBean(beanName)) {
                <span class="hljs-comment">// inner bean with other scope - can't reliably process events</span>
                logger.warn(<span class="hljs-string">"Inner bean '"</span> + beanName + <span class="hljs-string">"' implements ApplicationListener interface "</span> +
                        <span class="hljs-string">"but is not reachable for event multicasting by its containing ApplicationContext "</span> +
                        <span class="hljs-string">"because it does not have singleton scope. Only top-level listener beans are allowed "</span> +
                        <span class="hljs-string">"to be of non-singleton scope."</span>);
            }
            <span class="hljs-keyword">this</span>.singletonNames.remove(beanName);
        }
    }
    <span class="hljs-keyword">return</span> bean;
}
</code></pre><p>逻辑还是比较简单的，如果Bean是 <code>ApplicationListener</code> 的实现类，并且是单实例Bean，则会注册到IOC容器中。</p>
<h2 class="heading">小结</h2>
<ol>
<li>IOC容器在开始刷新之前有加载 <code>BeanDefinition</code> 的过程。</li>
<li><code>BeanFactory</code> 的初始化中会注册后置处理器，和自动注入的支持。</li>
<li><code>BeanPostProcessor</code> 的执行时机是在Bean初始化前后执行。</li>
</ol>
<p>【至此，BeanFactory 已经准备好，下一篇会进行后处理和组件扫描】</p>
</div>
</body></html>