<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>IOC：刷新容器-后置处理器、监听器的注册</h1>
<h1 class="heading">13. IOC：刷新容器-后置处理器、监听器的注册</h1>
<p>【接前章】</p>
<p>本篇解析6-10步骤：</p>
<pre><code class="hljs java" lang="java">        <span class="hljs-comment">// Register bean processors that intercept bean creation.</span>
        <span class="hljs-comment">//4.7.6 注册Bean的后置处理器</span>
        registerBeanPostProcessors(beanFactory);

        <span class="hljs-comment">// Initialize message source for this context.</span>
        <span class="hljs-comment">//4.7.7 初始化MessageSource（SpringMVC）</span>
        initMessageSource();

        <span class="hljs-comment">// Initialize event multicaster for this context.</span>
        <span class="hljs-comment">//4.7.8 初始化事件派发器</span>
        initApplicationEventMulticaster();

        <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span>
        <span class="hljs-comment">//4.7.9、4.8 子类的多态onRefresh</span>
        onRefresh();

        <span class="hljs-comment">// Check for listener beans and register them.</span>
        <span class="hljs-comment">//4.7.10 注册监听器</span>
        registerListeners();
</code></pre><h2 class="heading">6. registerBeanPostProcessors：注册 BeanPostProcessor</h2>
<p>（源码较长，关键注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{
    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="hljs-keyword">this</span>);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(
        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>{

    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);

    <span class="hljs-comment">// Register BeanPostProcessorChecker that logs an info message when</span>
    <span class="hljs-comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span>
    <span class="hljs-comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span>
    <span class="hljs-keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="hljs-number">1</span> + postProcessorNames.length;
    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

    <span class="hljs-comment">// 这次拿的接口类型是BeanPostProcessor，并且创建了更多的List，分别存放不同的PostProcessor</span>
    <span class="hljs-comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span>
    <span class="hljs-comment">// Ordered, and the rest.</span>
    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-comment">// 根据PriorityOrdered、Ordered接口，对这些BeanPostProcessor进行归类</span>
    <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) {
        <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            priorityOrderedPostProcessors.add(pp);
            <span class="hljs-comment">// MergedBeanDefinitionPostProcessor类型的后置处理器被单独放在一个集合中，说明该接口比较特殊</span>
            <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) {
                internalPostProcessors.add(pp);
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) {
            orderedPostProcessorNames.add(ppName);
        }
        <span class="hljs-keyword">else</span> {
            nonOrderedPostProcessorNames.add(ppName);
        }
    }

    <span class="hljs-comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span>
    <span class="hljs-comment">// 注册实现了PriorityOrdered的BeanPostProcessor</span>
    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

    <span class="hljs-comment">// Next, register the BeanPostProcessors that implement Ordered.</span>
    <span class="hljs-comment">// 注册实现了Ordered接口的BeanPostProcessor</span>
    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (String ppName : orderedPostProcessorNames) {
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        orderedPostProcessors.add(pp);
        <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    sortPostProcessors(orderedPostProcessors, beanFactory);
    registerBeanPostProcessors(beanFactory, orderedPostProcessors);

    <span class="hljs-comment">// Now, register all regular BeanPostProcessors.</span>
    <span class="hljs-comment">// 注册普通的BeanPostProcessor</span>
    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (String ppName : nonOrderedPostProcessorNames) {
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        nonOrderedPostProcessors.add(pp);
        <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

    <span class="hljs-comment">// Finally, re-register all internal BeanPostProcessors.</span>
    <span class="hljs-comment">// 最最后，才注册那些MergedBeanDefinitionPostProcessor</span>
    sortPostProcessors(internalPostProcessors, beanFactory);
    registerBeanPostProcessors(beanFactory, internalPostProcessors);

    <span class="hljs-comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span>
    <span class="hljs-comment">// moving it to the end of the processor chain (for picking up proxies etc).</span>
    <span class="hljs-comment">// 手动加了一个ApplicationListenerDetector，它是一个ApplicationListener的检测器</span>
    <span class="hljs-comment">// 这个检测器用于在最后检测IOC容器中的Bean是否为ApplicationListener接口的实现类，如果是，还会有额外的作用</span>
    <span class="hljs-comment">// 实际上它并不是手动加，而是重新注册它，让他位于所有后置处理器的最末尾位置</span>
    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationListenerDetector(applicationContext));
}
</code></pre><p>发现这段套路与前面看到的注册 <code>BeanFactoryPostProcessor</code> 极其类似！</p>
<p>这里面有几个特殊的组件，着重看一眼：</p>
<h3 class="heading">6.1 MergedBeanDefinitionPostProcessor</h3>
<p>它是一个接口，它的文档注释原文翻译：</p>
<blockquote>
<p>Post-processor callback interface for merged bean definitions at runtime. BeanPostProcessor implementations may implement this sub-interface in order to post-process the merged bean definition (a processed copy of the original bean definition) that the Spring BeanFactory uses to create a bean instance.
The postProcessMergedBeanDefinition method may for example introspect the bean definition in order to prepare some cached metadata before post-processing actual instances of a bean. It is also allowed to modify the bean definition but only for definition properties which are actually intended for concurrent modification. Essentially, this only applies to operations defined on the RootBeanDefinition itself but not to the properties of its base classes.</p>
<p>在运行时用于合并bean定义的后处理器回调接口。 <code>BeanPostProcessor</code> 实现可以实现此子接口，以便对Spring <code>BeanFactory</code> 用于创建bean实例的合并bean定义（原始bean定义的已处理副本）进行后处理。</p>
<p><code>postProcessMergedBeanDefinition</code> 方法可以例如内省bean定义，以便在对bean的实际实例进行后处理之前准备一些缓存的元数据。还允许修改bean定义，但只允许修改实际上用于并行修改的定义属性。本质上，这仅适用于 <code>RootBeanDefinition</code> 本身定义的操作，不适用于其基类的属性。</p>
</blockquote>
<p>文档注释似乎并没有说明太多意思，它是说给 <code>BeanDefinition</code> 做合并。借助IDEA，看一眼它的实现类：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/16/16dd227ab546da5c~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>这里面有一个我们一看就很兴奋： <code>AutowiredAnnotationBeanPostProcessor</code> 。</p>
<h4 class="heading">6.1.1 【重要】AutowiredAnnotationBeanPostProcessor</h4>
<p>它的文档注释非常长，这里我们截取重要的部分：</p>
<blockquote>
<p>BeanPostProcessor implementation that autowires annotated fields, setter methods and arbitrary config methods. Such members to be injected are detected through a Java 5 annotation: by default, Spring's @Autowired and @Value annotations.
Also supports JSR-330's @Inject annotation, if available, as a direct alternative to Spring's own @Autowired.
Only one constructor (at max) of any given bean class may declare this annotation with the 'required' parameter set to true, indicating the constructor to autowire when used as a Spring bean. If multiple non-required constructors declare the annotation, they will be considered as candidates for autowiring. The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primary/default constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. An annotated constructor does not have to be public.
Fields are injected right after construction of a bean, before any config methods are invoked. Such a config field does not have to be public.</p>
<p><code>BeanPostProcessor</code> 的实现，可自动连接带注解的字段，setter方法和任意config方法。通过Java 5注释检测要注入的此类成员：默认情况下，Spring的 <code>@Autowired</code> 和 <code>@Value</code> 注解。
还支持JSR-330的 <code>@Inject</code> 注解（如果可用），以替代Spring自己的 <code>@Autowired</code> 。
任何给定bean类的构造器（最大）只能使用 "required" 参数设置为true来声明此批注，指示在用作Spring bean时要自动装配的构造器。如果多个不需要的构造函数声明了注释，则它们将被视为自动装配的候选对象。将选择通过匹配Spring容器中的bean可以满足的依赖关系数量最多的构造函数。如果没有一个候选者满意，则将使用主/默认构造函数（如果存在）。如果一个类仅声明一个单一的构造函数开始，即使没有注释，也将始终使用它。带注解的构造函数不必是public的。
在构造任何bean之后，调用任何配置方法之前，立即注入字段。这样的配置字段不必是public的。
Config方法可以具有任意名称和任意数量的参数。这些参数中的每个参数都将与Spring容器中的匹配bean自动连接。 Bean属性设置器方法实际上只是这种常规config方法的特例。 Config方法不必是public的。</p>
</blockquote>
<p>很明确，它就是完成自动注入的Bean后置处理器。它实现了 <code>MergedBeanDefinitionPostProcessor</code> ，那自然要实现接口中的方法：<code>postProcessMergedBeanDefinition</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>{
    InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="hljs-keyword">null</span>);
    metadata.checkConfigMembers(beanDefinition);
}
</code></pre><p>这里面分两步，先获取注入的依赖，再进行对象检查。分步骤来看：</p>
<h5 class="heading">6.1.1.1 findAutowiringMetadata</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> InjectionMetadata <span class="hljs-title">findAutowiringMetadata</span><span class="hljs-params">(String beanName, Class&lt;?&gt; clazz, @Nullable PropertyValues pvs)</span> </span>{
    <span class="hljs-comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span>
    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
    <span class="hljs-comment">// Quick check on the concurrent map first, with minimal locking.</span>
    <span class="hljs-comment">// 首先从缓存中取，如果没有才创建</span>
    InjectionMetadata metadata = <span class="hljs-keyword">this</span>.injectionMetadataCache.get(cacheKey);
    <span class="hljs-keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) {
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.injectionMetadataCache) {
            metadata = <span class="hljs-keyword">this</span>.injectionMetadataCache.get(cacheKey);
            <span class="hljs-keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) {
                <span class="hljs-keyword">if</span> (metadata != <span class="hljs-keyword">null</span>) {
                    metadata.clear(pvs);
                }
                <span class="hljs-comment">// 构建自动装配的信息</span>
                metadata = buildAutowiringMetadata(clazz);
                <span class="hljs-comment">// 放入缓存</span>
                <span class="hljs-keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);
            }
        }
    }
    <span class="hljs-keyword">return</span> metadata;
}
</code></pre><p>这部分实现中使用了双检锁来保证线程安全，之后会构建自动装配的 metadata：</p>
<h5 class="heading">6.1.1.2 buildAutowiringMetadata</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> InjectionMetadata <span class="hljs-title">buildAutowiringMetadata</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; clazz)</span> </span>{
    List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    Class&lt;?&gt; targetClass = clazz;
    
    <span class="hljs-comment">// 循环获取父类信息</span>
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        <span class="hljs-comment">// 循环获取类上的属性，并判断是否有@Autowired等注入类注解</span>
        ReflectionUtils.doWithLocalFields(targetClass, field -&gt; {
            AnnotationAttributes ann = findAutowiredAnnotation(field);
            <span class="hljs-keyword">if</span> (ann != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">if</span> (Modifier.isStatic(field.getModifiers())) {
                    <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) {
                        logger.info(<span class="hljs-string">"Autowired annotation is not supported on static fields: "</span> + field);
                    }
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">boolean</span> required = determineRequiredStatus(ann);
                currElements.add(<span class="hljs-keyword">new</span> AutowiredFieldElement(field, required));
            }
        });

        <span class="hljs-comment">// 循环获取类上的方法，并判断是否有需要依赖的项</span>
        ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; {
            Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
            <span class="hljs-keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {
                <span class="hljs-keyword">return</span>;
            }
            AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);
            <span class="hljs-keyword">if</span> (ann != <span class="hljs-keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {
                <span class="hljs-keyword">if</span> (Modifier.isStatic(method.getModifiers())) {
                    <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) {
                        logger.info(<span class="hljs-string">"Autowired annotation is not supported on static methods: "</span> + method);
                    }
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">if</span> (method.getParameterCount() == <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) {
                        logger.info(<span class="hljs-string">"Autowired annotation should only be used on methods with parameters: "</span> +
                                method);
                    }
                }
                <span class="hljs-keyword">boolean</span> required = determineRequiredStatus(ann);
                PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);
                currElements.add(<span class="hljs-keyword">new</span> AutowiredMethodElement(method, required, pd));
            }
        });

        elements.addAll(<span class="hljs-number">0</span>, currElements);
        targetClass = targetClass.getSuperclass();
    }
    <span class="hljs-keyword">while</span> (targetClass != <span class="hljs-keyword">null</span> &amp;&amp; targetClass != Object.class);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InjectionMetadata(clazz, elements);
}
</code></pre><p>先看一眼这个 do-while 循环，这个 do-while 循环是用来一步一步往父类上爬的（可以看到这个循环体的最后一行是获取父类，判断条件是判断是否爬到了 <code>Object</code>）。</p>
<p>循环体中，先是反射遍历当前类的属性，并判断上面是否有 <code>@Autowired</code> 等类型的注解。这部分注解的加载在这个方法中可以追溯到：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; autowiredAnnotationTypes = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">4</span>);

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AutowiredAnnotationBeanPostProcessor</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);
    <span class="hljs-keyword">this</span>.autowiredAnnotationTypes.add(Value.class);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">this</span>.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)
                ClassUtils.forName(<span class="hljs-string">"javax.inject.Inject"</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));
    }
    <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) {
        <span class="hljs-comment">// JSR-330 API not available - simply skip.</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">private</span> AnnotationAttributes <span class="hljs-title">findAutowiredAnnotation</span><span class="hljs-params">(AccessibleObject ao)</span> </span>{
    <span class="hljs-keyword">if</span> (ao.getAnnotations().length &gt; <span class="hljs-number">0</span>) {  <span class="hljs-comment">// autowiring annotations have to be local</span>
        <span class="hljs-keyword">for</span> (Class&lt;? extends Annotation&gt; type : <span class="hljs-keyword">this</span>.autowiredAnnotationTypes) {
            AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ao, type);
            <span class="hljs-keyword">if</span> (attributes != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">return</span> attributes;
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>可以发现这部分判断的几种注解： <code>@Autowired</code> 、<code>@Value</code> 、<code>@Inject</code> 。</p>
<p>之后又获取方法上的注解，也保存进去。最后获取父类，一层一层往上爬，直到循环跳出，方法结束。</p>
<hr>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>{
    InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="hljs-keyword">null</span>);
    metadata.checkConfigMembers(beanDefinition);
}
</code></pre><p>下面要到 <code>checkConfigMembers</code> 方法了：</p>
<h5 class="heading">6.1.1.3 checkConfigMembers</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkConfigMembers</span><span class="hljs-params">(RootBeanDefinition beanDefinition)</span> </span>{
    Set&lt;InjectedElement&gt; checkedElements = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-keyword">this</span>.injectedElements.size());
    <span class="hljs-keyword">for</span> (InjectedElement element : <span class="hljs-keyword">this</span>.injectedElements) {
        Member member = element.getMember();
        <span class="hljs-keyword">if</span> (!beanDefinition.isExternallyManagedConfigMember(member)) {
            beanDefinition.registerExternallyManagedConfigMember(member);
            checkedElements.add(element);
            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
                logger.trace(<span class="hljs-string">"Registered injected element on class ["</span> + <span class="hljs-keyword">this</span>.targetClass.getName() + <span class="hljs-string">"]: "</span> + element);
            }
        }
    }
    <span class="hljs-keyword">this</span>.checkedElements = checkedElements;
}
</code></pre><p>这里面涉及到一个叫 <code>Member</code> 的概念：</p>
<blockquote>
<p>Member is an interface that reflects identifying information about a single member (a field or a method) or a constructor.</p>
<p>反映有关单个成员（字段或方法）或构造函数的标识信息的接口。</p>
</blockquote>
<p>看文档注释的意思，大概可以看出来它是表示类中的一个成员。</p>
<p>源码中的for循环，里面有两个很迷的方法。这两个方法都操作了 <code>RootBeanDefinition</code> 的一个属性：<code>externallyManagedConfigMember</code> ，而这部分除了这两个方法有调过，也没别的地方用了。这两个方法除了这个方法中使用过，别的地方也没用过。那看来这部分不会影响到大局，大可忽略。</p>
<p>至此，咱先对 <code>AutowiredAnnotationBeanPostProcessor</code>  这个后置处理器作一个了解，自动注入的原理会在后续慢慢看到。</p>
<hr>
<p>再来看一个后置处理器，它是在注册BeanPostProcessor中的最后一步，显式声明的。</p>
<h3 class="heading">6.2 ApplicationListenerDetector</h3>
<p>注意上面的截图，会发现 <code>ApplicationListenerDetector</code> 也实现了 <code>MergedBeanDefinitionPostProcessor</code> 。而且这个类在之前第11篇的3.3章节介绍过它，它的作用是收集监听器。它是 <code>BeanPostProcessor</code> ，但同时它也是 <code>MergedBeanDefinitionPostProcessor</code> 。那咱来看看它实现 <code>MergedBeanDefinitionPostProcessor</code> 后实现的方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>{
    <span class="hljs-keyword">this</span>.singletonNames.put(beanName, beanDefinition.isSingleton());
}
</code></pre><p>可以发现非常简单，只是保存Bean是否为单实例Bean的信息。这个单实例Bean的机制在前面也提到过，只有单实例Bean才能注册到监听器列表中。</p>
<p>至此，<code>registerBeanPostProcessors</code> 方法执行完毕。</p>
<h2 class="heading">7. initMessageSource：初始化MessageSource</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MESSAGE_SOURCE_BEAN_NAME = <span class="hljs-string">"messageSource"</span>;

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMessageSource</span><span class="hljs-params">()</span> </span>{
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    <span class="hljs-comment">// 检查是否已经存在了MessageSource组件，如果有，直接赋值</span>
    <span class="hljs-keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
        <span class="hljs-keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
        <span class="hljs-comment">// Make MessageSource aware of parent MessageSource.</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.messageSource <span class="hljs-keyword">instanceof</span> HierarchicalMessageSource) {
            HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="hljs-keyword">this</span>.messageSource;
            <span class="hljs-keyword">if</span> (hms.getParentMessageSource() == <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// Only set parent context as parent MessageSource if no parent MessageSource</span>
                <span class="hljs-comment">// registered already.</span>
                hms.setParentMessageSource(getInternalParentMessageSource());
            }
        }
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Using MessageSource ["</span> + <span class="hljs-keyword">this</span>.messageSource + <span class="hljs-string">"]"</span>);
        }
    }
    <span class="hljs-comment">// 如果没有，创建一个，并注册到BeanFactory中</span>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Use empty MessageSource to be able to accept getMessage calls.</span>
        DelegatingMessageSource dms = <span class="hljs-keyword">new</span> DelegatingMessageSource();
        dms.setParentMessageSource(getInternalParentMessageSource());
        <span class="hljs-keyword">this</span>.messageSource = dms;
        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="hljs-keyword">this</span>.messageSource);
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Unable to locate MessageSource with name '"</span> + MESSAGE_SOURCE_BEAN_NAME +
                    <span class="hljs-string">"': using default ["</span> + <span class="hljs-keyword">this</span>.messageSource + <span class="hljs-string">"]"</span>);
        }
    }
}
</code></pre><p>这个组件我们在之前第7篇的IOC容器介绍（1.3.2章节）中说过，它是实现国际化的接口。</p>
<p>它默认创建的实现类是 <code>DelegatingMessageSource</code> ，它的文档注释：</p>
<blockquote>
<p>Empty <code>MessageSource</code> that delegates all calls to the parent MessageSource. If no parent is available, it simply won't resolve any message.</p>
<p>Used as placeholder by AbstractApplicationContext, if the context doesn't define its own MessageSource. Not intended for direct use in applications.</p>
<p>空的MessageSource，将所有调用委派给父MessageSource。如果没有父母可用，它将根本无法解决任何消息。</p>
<p>如果上下文未定义其自己的MessageSource，则AbstractApplicationContext用作占位符。不适用于直接在应用程序中使用。</p>
</blockquote>
<p>其实，<code>DelegatingMessageSource</code> 扮演的角色更像是一种 “消息源解析的委派”（用户未指定时，IOC容器会默认使用 <code>DelegatingMessageSource</code> ）。它的功能比较简单：将字符串和参数数组格式化为一个国际化后的消息。</p>
<h2 class="heading">8. initApplicationEventMulticaster：初始化事件派发器</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> ApplicationEventMulticaster applicationEventMulticaster;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String APPLICATION_EVENT_MULTICASTER_BEAN_NAME = <span class="hljs-string">"applicationEventMulticaster"</span>;

<span class="hljs-comment">// 初始化当前ApplicationContext的事件广播器</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initApplicationEventMulticaster</span><span class="hljs-params">()</span> </span>{
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    <span class="hljs-keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
        <span class="hljs-comment">// 8.1 ApplicationEventMulticaster</span>
        <span class="hljs-keyword">this</span>.applicationEventMulticaster =
                beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Using ApplicationEventMulticaster ["</span> + <span class="hljs-keyword">this</span>.applicationEventMulticaster + <span class="hljs-string">"]"</span>);
        }
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.applicationEventMulticaster = <span class="hljs-keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);
        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="hljs-keyword">this</span>.applicationEventMulticaster);
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Unable to locate ApplicationEventMulticaster with name '"</span> +
                    APPLICATION_EVENT_MULTICASTER_BEAN_NAME +
                    <span class="hljs-string">"': using default ["</span> + <span class="hljs-keyword">this</span>.applicationEventMulticaster + <span class="hljs-string">"]"</span>);
        }
    }
}
</code></pre><p>源码中先判断IOC容器中是否有名称为 <code>applicationEventMulticaster</code> 的Bean，没有就默认注册一个 <code>ApplicationEventMulticaster</code> 。</p>
<h3 class="heading">8.1 ApplicationEventMulticaster</h3>
<p>它的文档注释原文翻译：</p>
<blockquote>
<p>Interface to be implemented by objects that can manage a number of ApplicationListener objects, and publish events to them.</p>
<p>由可以管理多个 <code>ApplicationListener</code> 对象并向其发布事件的对象实现的接口。</p>
</blockquote>
<p>可以发现它就是一个事件发布器而已。它的核心方法-事件发布的源码如下：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multicastEvent</span><span class="hljs-params">(ApplicationEvent event)</span> </span>{
    <span class="hljs-comment">// 往下面的方法跳转</span>
    multicastEvent(event, resolveDefaultEventType(event));
}

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>{
    ResolvableType type = (eventType != <span class="hljs-keyword">null</span> ? eventType : resolveDefaultEventType(event));
    Executor executor = getTaskExecutor();
    <span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {
        <span class="hljs-keyword">if</span> (executor != <span class="hljs-keyword">null</span>) {
            executor.execute(() -&gt; invokeListener(listener, event));
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 执行监听器，继续往下跳转</span>
            invokeListener(listener, event);
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeListener</span><span class="hljs-params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>{
    ErrorHandler errorHandler = getErrorHandler();
    <span class="hljs-keyword">if</span> (errorHandler != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 真正执行监听器的方法</span>
            doInvokeListener(listener, event);
        }
        <span class="hljs-keyword">catch</span> (Throwable err) {
            errorHandler.handleError(err);
        }
    }
    <span class="hljs-keyword">else</span> {
        doInvokeListener(listener, event);
    }
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInvokeListener</span><span class="hljs-params">(ApplicationListener listener, ApplicationEvent event)</span> </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// ApplicationListener的方法</span>
        listener.onApplicationEvent(event);
    }
    <span class="hljs-keyword">catch</span> (ClassCastException ex) {
        String msg = ex.getMessage();
        <span class="hljs-keyword">if</span> (msg == <span class="hljs-keyword">null</span> || matchesClassCastMessage(msg, event.getClass())) {
            <span class="hljs-comment">// Possibly a lambda-defined listener which we could not resolve the generic event type for</span>
            <span class="hljs-comment">// -&gt; let's suppress the exception and just log a debug message.</span>
            Log logger = LogFactory.getLog(getClass());
            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
                logger.trace(<span class="hljs-string">"Non-matching event type for listener: "</span> + listener, ex);
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> ex;
        }
    }
}
</code></pre><p>可以发现它最终会执行到 <code>ApplicationListener</code> 的 <code>onApplicationEvent</code> 方法，思路比较简单。</p>
<h2 class="heading">9. onRefresh：子类扩展刷新</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>{
    <span class="hljs-comment">// For subclasses: do nothing by default.</span>
}
</code></pre><p>发现又是模板方法。这部分我们单独留到第16篇再展开描述，SpringBoot 在这里做了额外的操作。</p>
<h2 class="heading">10. registerListeners：注册监听器</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerListeners</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Register statically specified listeners first.</span>
    <span class="hljs-comment">// 把所有的IOC容器中以前缓存好的一组ApplicationListener取出来，添加到事件派发器中</span>
    <span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {
        getApplicationEventMulticaster().addApplicationListener(listener);
    }

    <span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span>
    <span class="hljs-comment">// uninitialized to let post-processors apply to them!</span>
    <span class="hljs-comment">// 拿到BeanFactory中定义的所有的ApplicationListener类型的组件全部取出，添加到事件派发器中</span>
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">for</span> (String listenerBeanName : listenerBeanNames) {
        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    }

    <span class="hljs-comment">// Publish early application events now that we finally have a multicaster...</span>
    <span class="hljs-comment">// 10.1 广播早期事件</span>
    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="hljs-keyword">this</span>.earlyApplicationEvents;
    <span class="hljs-keyword">this</span>.earlyApplicationEvents = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">if</span> (earlyEventsToProcess != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) {
            getApplicationEventMulticaster().multicastEvent(earlyEvent);
        }
    }
}

<span class="hljs-keyword">public</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.applicationListeners;
}
</code></pre><p>监听器在IOC容器中早就注册好了，取出来后要放入事件广播器，以方便事件广播器广播事件。</p>
<p>在上面方法的最后一段，它广播了早期事件。</p>
<p>之前在最开始我们遇见过早期事件（refresh的第一步），下面咱要真正的说说这个早期事件了。</p>
<h3 class="heading">10.1 earlyEvent：早期事件</h3>
<p>在 <code>refresh</code> 方法的 <code>prepareRefresh</code> 中，最后一步有这么一句：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Allow for the collection of early ApplicationEvents,</span>
    <span class="hljs-comment">// to be published once the multicaster is available...</span>
    <span class="hljs-comment">// 这个集合的作用，是保存容器中的一些事件，以便在合适的时候利用事件广播器来广播这些事件</span>
    <span class="hljs-comment">// 【配合registerListeners方法中的第三部分使用】</span>
    <span class="hljs-keyword">this</span>.earlyApplicationEvents = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
</code></pre><p>这里存储的事件会在这一步被触发。由此也知早期事件的发布时机：<strong>监听器被注册，但其余的单实例Bean还没有创建时</strong>。</p>
<p>实际上，通过Debug，发现默认情况下这里根本就没有早期事件：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/16/16dd22778b6117cd~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>由此也大概猜到这个早期事件的设计由来：<strong>留给开发者，在后置处理器和监听器都被创建好，其余的单实例Bean还没有创建时，提供一个预留的时机来处理一些额外的事情</strong>。</p>
<h3 class="heading">10.2 【扩展】SpringFramework中的观察者模式</h3>
<p>实际上 <code>ApplicationListener</code> 与 <code>ApplicationEvent</code> 这样的事件派发机制就是观察者模式的体现。</p>
<p>事件派发器（广播器）、事件监听器（被通知者）、事件（<code>ApplicationEvent</code>），其实这就是构成观察者模式的三大组件</p>
<ul>
<li>广播器（<code>ApplicationEventMulticaster</code>）：观察事件发生</li>
<li>被通知者（<code>ApplicationListener</code>）：接收广播器发送的广播，并做出相应的行为</li>
</ul>
<h2 class="heading">小结</h2>
<ol>
<li>注册 <code>BeanPostProcessor</code> 的时机是 <code>BeanFactory</code> 已经初始化完毕，监听器还没有注册之前。</li>
<li>注册 <code>ApplicationListener</code> 的时机是 <code>BeanPostProcessor</code> 注册完，但还没有初始化单实例Bean。</li>
<li>IOC容器使用 <code>ApplicationEventMulticaster</code> 广播事件。</li>
</ol>
<p>【至此，后置处理器、监听器都已经注册完毕，下面到了最复杂的部分之一：<strong>初始化剩余单实例Bean</strong>】</p>
</div>
</body></html>