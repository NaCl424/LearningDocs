<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>嵌入式容器：创建过程回顾和深入配置</h1>
<h1 class="heading">27. 嵌入式容器：创建过程回顾和嵌入式Tomcat的核心启动</h1>
<p>前几篇咱解析了WebMvc中的一些原理，以及 <code>DispatcherServlet</code> 的完整工作原理，接下来的两篇咱来深入 SpringBoot 中的嵌入式容器。</p>
<p>我们都知道，默认情况下 SpringBoot 应用可以打jar包运行，在启动IOC容器时引导启动嵌入式Web容器（Tomcat），而且根据之前的IOC原理，我们知道在 <code>ServletWebServerApplicationContext</code> 的 <code>onRefresh</code> 方法中创建了嵌入式 Tomcat，这一篇咱来展开研究嵌入式 Tomcat 创建的过程。</p>
<p>（为统一概念，本篇和下一篇中出现的嵌入式Web容器统一为 <strong>Tomcat</strong>）</p>
<h2 class="heading">0. 前置知识</h2>
<p>Tomcat 的内部核心结构包含如下组件：</p>
<ul>
<li>Service：一个 Tomcat-Server 可以有多个 Service ， Service 中包含下面的所有组件</li>
<li>Connector：用于与客户端交互，接收客户端的请求，并将结果响应给客户端</li>
<li>Engine：负责处理来自 Service 中的 Connector 的所有请求</li>
<li>Host：可理解为主机，一个主机绑定一个端口号</li>
<li>Context：可理解为应用，一个主机下有多个应用，一个应用中有多个 Servlet （可以简单理解为 webapps 中一个文件夹代表一个 Context ）</li>
</ul>
<h2 class="heading">1. ServletWebServerApplicationContext#onRefresh</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.onRefresh();
    <span class="hljs-keyword">try</span> {
        createWebServer();
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">"Unable to start web server"</span>, ex);
    }
}
</code></pre><p>在 <code>ServletWebServerApplicationContext</code> 的 <code>onRefresh</code> 方法会调用 <code>createWebServer</code> 方法创建嵌入式 Tomcat。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createWebServer</span><span class="hljs-params">()</span> </span>{
    WebServer webServer = <span class="hljs-keyword">this</span>.webServer;
    ServletContext servletContext = getServletContext();
    <span class="hljs-comment">// 如果WebServer和ServletContext都为null时，证明需要创建嵌入式Tomcat</span>
    <span class="hljs-keyword">if</span> (webServer == <span class="hljs-keyword">null</span> &amp;&amp; servletContext == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 创建了嵌入式Tomcat的工厂</span>
        ServletWebServerFactory factory = getWebServerFactory();
        <span class="hljs-comment">// 创建嵌入式Tomcat</span>
        <span class="hljs-keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (servletContext != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">try</span> {
            getSelfInitializer().onStartup(servletContext);
        }
        <span class="hljs-keyword">catch</span> (ServletException ex) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">"Cannot initialize servlet context"</span>, ex);
        }
    }
    initPropertySources();
}
</code></pre><p>这部分源码我们之前也都看过，重点来看 <code>getWebServer</code> 中的创建嵌入式 Tomcat 的部分：</p>
<h2 class="heading">2. TomcatServletWebServerFactory#getWebServer</h2>
<p>（不需要展开的步骤均已在源码中标好注释）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PROTOCOL = <span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span>;
<span class="hljs-keyword">private</span> String protocol = DEFAULT_PROTOCOL;

<span class="hljs-function"><span class="hljs-keyword">public</span> WebServer <span class="hljs-title">getWebServer</span><span class="hljs-params">(ServletContextInitializer... initializers)</span> </span>{
    Tomcat tomcat = <span class="hljs-keyword">new</span> Tomcat();
    <span class="hljs-comment">// 给嵌入式Tomcat创建一个临时文件夹，用于存放Tomcat运行中需要的文件</span>
    File baseDir = (<span class="hljs-keyword">this</span>.baseDirectory != <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">this</span>.baseDirectory : createTempDir(<span class="hljs-string">"tomcat"</span>);
    tomcat.setBaseDir(baseDir.getAbsolutePath());
    <span class="hljs-comment">// Tomcat核心概念：Connector，默认放入的protocol为NIO模式</span>
    Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-keyword">this</span>.protocol);
    <span class="hljs-comment">// 给Service添加Connector</span>
    tomcat.getService().addConnector(connector);
    <span class="hljs-comment">// 执行定制器，修改即将设置到Tomcat中的Connector</span>
    customizeConnector(connector);
    tomcat.setConnector(connector);
    <span class="hljs-comment">// 关闭热部署（嵌入式Tomcat不存在修改web.xml、war包等情况）</span>
    tomcat.getHost().setAutoDeploy(<span class="hljs-keyword">false</span>);
    <span class="hljs-comment">// 设置backgroundProcessorDelay机制</span>
    configureEngine(tomcat.getEngine());
    <span class="hljs-keyword">for</span> (Connector additionalConnector : <span class="hljs-keyword">this</span>.additionalTomcatConnectors) {
        tomcat.getService().addConnector(additionalConnector);
    }
    <span class="hljs-comment">// 2.1 生成TomcatEmbeddedContext</span>
    prepareContext(tomcat.getHost(), initializers);
    <span class="hljs-comment">// 3. 创建TomcatWebServer</span>
    <span class="hljs-keyword">return</span> getTomcatWebServer(tomcat);
}
</code></pre><p>咱来看这个方法，首先它new了一个 <code>Tomcat</code> 对象（它还不是真正的嵌入式 Tomcat），之后下面的一大堆都是对 Tomcat 的配置，这里面着重看一眼这个最复杂的 <code>prepareContext</code> 方法：</p>
<h3 class="heading">2.1 prepareContext</h3>
<p>（注释均已在源码中标注好，小伙伴们对哪一步感兴趣可以借助IDE自己动手Debug体会一下实现）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(Host host, ServletContextInitializer[] initializers)</span> </span>{
    File documentRoot = getValidDocumentRoot();
    <span class="hljs-comment">// 创建TomcatEmbeddedContext</span>
    TomcatEmbeddedContext context = <span class="hljs-keyword">new</span> TomcatEmbeddedContext();
    <span class="hljs-keyword">if</span> (documentRoot != <span class="hljs-keyword">null</span>) {
        context.setResources(<span class="hljs-keyword">new</span> LoaderHidingResourceRoot(context));
    }
    context.setName(getContextPath());
    context.setDisplayName(getDisplayName());
    <span class="hljs-comment">// 设置contextPath，很熟悉了</span>
    context.setPath(getContextPath());
    <span class="hljs-comment">// 给嵌入式Tomcat创建docbase的临时文件夹</span>
    File docBase = (documentRoot != <span class="hljs-keyword">null</span>) ? documentRoot : createTempDir(<span class="hljs-string">"tomcat-docbase"</span>);
    context.setDocBase(docBase.getAbsolutePath());
    <span class="hljs-comment">// 注册监听器</span>
    context.addLifecycleListener(<span class="hljs-keyword">new</span> FixContextListener());
    context.setParentClassLoader((<span class="hljs-keyword">this</span>.resourceLoader != <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">this</span>.resourceLoader.getClassLoader()
            : ClassUtils.getDefaultClassLoader());
    <span class="hljs-comment">// 设置默认编码映射</span>
    resetDefaultLocaleMapping(context);
    addLocaleMappings(context);
    context.setUseRelativeRedirects(<span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">try</span> {
        context.setCreateUploadTargets(<span class="hljs-keyword">true</span>);
    }
    <span class="hljs-keyword">catch</span> (NoSuchMethodError ex) {
        <span class="hljs-comment">// Tomcat is &lt; 8.5.39. Continue.</span>
    }
    configureTldSkipPatterns(context);
    <span class="hljs-comment">// 自定义的类加载器，可以加载web应用的jar包</span>
    WebappLoader loader = <span class="hljs-keyword">new</span> WebappLoader(context.getParentClassLoader());
    loader.setLoaderClass(TomcatEmbeddedWebappClassLoader.class.getName());
    <span class="hljs-comment">// 指定类加载器遵循双亲委派机制</span>
    loader.setDelegate(<span class="hljs-keyword">true</span>);
    context.setLoader(loader);
    <span class="hljs-comment">// 注册默认的Servlet</span>
    <span class="hljs-keyword">if</span> (isRegisterDefaultServlet()) {
        addDefaultServlet(context);
    }
    <span class="hljs-comment">// 如果需要jsp支持，注册jsp的Servlet和Initializer</span>
    <span class="hljs-keyword">if</span> (shouldRegisterJspServlet()) {
        addJspServlet(context);
        addJasperInitializer(context);
    }
    <span class="hljs-comment">// 注册监听器</span>
    context.addLifecycleListener(<span class="hljs-keyword">new</span> StaticResourceConfigurer(context));
    ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);
    host.addChild(context);
    configureContext(context, initializersToUse);
    postProcessContext(context);
}
</code></pre><p>回到 <code>getWebServer</code> 中，最下面执行最核心的方法： <code>getTomcatWebServer</code></p>
<h2 class="heading">3. getTomcatWebServer</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> TomcatWebServer <span class="hljs-title">getTomcatWebServer</span><span class="hljs-params">(Tomcat tomcat)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class="hljs-number">0</span>);
}
</code></pre><p>它只是new了一个 <code>TomcatWebServer</code> 而已，进入构造方法中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TomcatWebServer</span><span class="hljs-params">(Tomcat tomcat, <span class="hljs-keyword">boolean</span> autoStart)</span> </span>{
    Assert.notNull(tomcat, <span class="hljs-string">"Tomcat Server must not be null"</span>);
    <span class="hljs-keyword">this</span>.tomcat = tomcat;
    <span class="hljs-keyword">this</span>.autoStart = autoStart;
    initialize();
}
</code></pre><p>构造方法中竟然还暗藏玄机，它在属性赋值后执行了 <code>initialize</code> 方法。</p>
<h2 class="heading">4. initialize</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> WebServerException </span>{
    logger.info(<span class="hljs-string">"Tomcat initialized with port(s): "</span> + getPortsDescription(<span class="hljs-keyword">false</span>));
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.monitor) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 4.1 设置Engine的id</span>
            addInstanceIdToEngineName();

            <span class="hljs-comment">// 4.2 获取第一个Context</span>
            Context context = findContext();
            <span class="hljs-comment">// 4.3 添加监听器</span>
            context.addLifecycleListener((event) -&gt; {
                <span class="hljs-keyword">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) {
                    <span class="hljs-comment">// Remove service connectors so that protocol binding doesn't</span>
                    <span class="hljs-comment">// happen when the service is started.</span>
                    removeServiceConnectors();
                }
            });

            <span class="hljs-comment">// Start the server to trigger initialization listeners</span>
            <span class="hljs-comment">// 4.4 启动Tomcat</span>
            <span class="hljs-keyword">this</span>.tomcat.start();

            <span class="hljs-comment">// We can re-throw failure exception directly in the main thread</span>
            rethrowDeferredStartupExceptions();

            <span class="hljs-comment">// ......</span>
    }
}
</code></pre><p>把整个启动过程分为几步来看：</p>
<h3 class="heading">4.1 addInstanceIdToEngineName：设置Engine的id</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInstanceIdToEngineName</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> instanceId = containerCounter.incrementAndGet();
    <span class="hljs-keyword">if</span> (instanceId &gt; <span class="hljs-number">0</span>) {
        Engine engine = <span class="hljs-keyword">this</span>.tomcat.getEngine();
        engine.setName(engine.getName() + <span class="hljs-string">"-"</span> + instanceId);
    }
}
</code></pre><p>这部分在初始化时，<code>containerCounter</code> 的值是-1，调用 <code>incrementAndGet</code> 方法后返回0。因为是0，下面的if也就不进入了。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/27/16eab6657ca010e0~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<h3 class="heading">4.2 findContext：获取第一个Context</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> Context <span class="hljs-title">findContext</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (Container child : <span class="hljs-keyword">this</span>.tomcat.getHost().findChildren()) {
        <span class="hljs-keyword">if</span> (child <span class="hljs-keyword">instanceof</span> Context) {
            <span class="hljs-keyword">return</span> (Context) child;
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"The host does not contain a Context"</span>);
}
</code></pre><p>这一步它要拿到Tomcat中的 <code>host</code>，来获取它的 <code>children</code> 。通过Debug发现已经存在一组 <code>Container</code> 了，当然也只有一个：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/27/16eab671f93849c2~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>拿到之后，返回去。</p>
<h3 class="heading">4.3 addLifecycleListener：添加监听器</h3>
<pre><code class="hljs java" lang="java">    context.addLifecycleListener((event) -&gt; {
        <span class="hljs-keyword">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) {
            <span class="hljs-comment">// Remove service connectors so that protocol binding doesn't</span>
            <span class="hljs-comment">// happen when the service is started.</span>
            <span class="hljs-comment">// 删除ServiceConnectors，以便在启动服务时不会发生协议绑定。</span>
            removeServiceConnectors();
        }
    });
</code></pre><p>这一步的单行注释是解释不让 Connector 初始化，可为什么人家组件都初始化了，就单单不让它初始化呢？这要回归到IOC容器的启动原理中。</p>
<p>创建嵌入式 Tomcat 的时机是 <code>onRefresh</code> 方法，此时还有很多单实例Bean没有被创建，此时如果直接初始化所有组件后，Connector 也被初始化，此时客户端就可以与 Tomcat 进行交互，但这个时候单实例Bean还没有初始化完毕（尤其是 <code>DispatcherServlet</code>），就会导致传入的请求 Tomcat 无法处理，出现异常。</p>
<p>所以 SpringBoot 为了避免这个问题，会<strong>在嵌入式 Tomcat 发布事件时检测此时的 <code>Context</code> 状态是否为 <code>"START_EVENT"</code> ，如果是则将这些 <code>Connector</code> 先移除掉</strong>。</p>
<h3 class="heading">4.4 this.tomcat.start：启动Tomcat</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    getServer();
    <span class="hljs-comment">// 4.5</span>
    server.start();
}
</code></pre><p>第一步的操作跟前面是一样的，下面是 <code>server.start()</code> ，它来真正启动嵌入式 Tomcat 。</p>
<h3 class="heading">4.5 server.start</h3>
<p>来到 <code>LifecycleBase</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{

    <span class="hljs-keyword">if</span> (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||
            LifecycleState.STARTED.equals(state)) {

        <span class="hljs-keyword">if</span> (log.isDebugEnabled()) {
            Exception e = <span class="hljs-keyword">new</span> LifecycleException();
            log.debug(sm.getString(<span class="hljs-string">"lifecycleBase.alreadyStarted"</span>, toString()), e);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (log.isInfoEnabled()) {
            log.info(sm.getString(<span class="hljs-string">"lifecycleBase.alreadyStarted"</span>, toString()));
        }

        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (state.equals(LifecycleState.NEW)) {
        init();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.equals(LifecycleState.FAILED)) {
    <span class="hljs-comment">// ......</span>
}
</code></pre><p>这里启动时会根据当前的状态来走不同的分支，而刚启动的 Tomcat 状态为 <code>"NEW"</code> ，进入 init 方法：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/27/16eab667f32f520c~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<h4 class="heading">4.5.1 StandardServer#init</h4>
<p>来到父类 <code>LifecycleBase</code> 中（<code>StandardServer</code> 没有重写）：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-keyword">if</span> (!state.equals(LifecycleState.NEW)) {
        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);
    }

    <span class="hljs-keyword">try</span> {
        setStateInternal(LifecycleState.INITIALIZING, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);
        initInternal();
        setStateInternal(LifecycleState.INITIALIZED, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);
    } <span class="hljs-keyword">catch</span> (Throwable t) {
        handleSubClassException(t, <span class="hljs-string">"lifecycleBase.initFail"</span>, toString());
    }
}
</code></pre><p>上面对于不为NEW的状态，会额外执行方法，当前状态为<strong>NEW</strong>，不进入，走下面的try块。try块在 <code>initInternal</code> 的前后设置了两次生命周期的状态（初始化中、初始化完成），说明 <code>initInternal</code> 方法中一定是真正的 Tomcat 组件初始化的过程。</p>
<h4 class="heading">4.5.2 StandardServer#initInternal</h4>
<p>来到 <code>StandardServer</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{

    <span class="hljs-keyword">super</span>.initInternal();

    <span class="hljs-comment">// ......</span>
}
</code></pre><p>先来到父类 <code>LifecycleBase</code> 的 <code>initInternal</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-comment">// If oname is not null then registration has already happened via preRegister().</span>
    <span class="hljs-comment">// 如果oname不为null，则已经通过preRegister()进行了注册</span>
    <span class="hljs-keyword">if</span> (oname == <span class="hljs-keyword">null</span>) {
        mserver = Registry.getRegistry(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>).getMBeanServer();
        oname = register(<span class="hljs-keyword">this</span>, getObjectNameKeyProperties());
    }
}
</code></pre><p>默认情况下 <code>oname</code> 为null，走下面的初始化过程。初始化完成后的效果：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/27/16eab66a7edecce7~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>回到子类 <code>StandardServer</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{

    <span class="hljs-keyword">super</span>.initInternal();

    <span class="hljs-comment">// ......</span>
    <span class="hljs-comment">// Initialize our defined Services</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; services.length; i++) {
        services[i].init();
    }
}
</code></pre><p>中间的一大段我们暂且不关心，主要来看最后一步：它要初始化这些 <code>Server</code> 中的 <code>Service</code> 。</p>
<h4 class="heading">4.5.3 又回到LifecycleBase</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-keyword">if</span> (!state.equals(LifecycleState.NEW)) {
        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);
    }

    <span class="hljs-keyword">try</span> {
        setStateInternal(LifecycleState.INITIALIZING, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);
        initInternal();
        setStateInternal(LifecycleState.INITIALIZED, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);
    } <span class="hljs-keyword">catch</span> (Throwable t) {
        handleSubClassException(t, <span class="hljs-string">"lifecycleBase.initFail"</span>, toString());
    }
}
</code></pre><p>再走一遍流程，进到 <code>initInternal</code> 方法，这次初始化的是 <code>StandardService</code>：</p>
<h4 class="heading">4.5.4 StandardService#initInternal</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{

    <span class="hljs-keyword">super</span>.initInternal();

    <span class="hljs-keyword">if</span> (engine != <span class="hljs-keyword">null</span>) {
        engine.init();
    }

    <span class="hljs-comment">// Initialize any Executors</span>
    <span class="hljs-keyword">for</span> (Executor executor : findExecutors()) {
        <span class="hljs-keyword">if</span> (executor <span class="hljs-keyword">instanceof</span> JmxEnabled) {
            ((JmxEnabled) executor).setDomain(getDomain());
        }
        executor.init();
    }

    <span class="hljs-comment">// Initialize mapper listener</span>
    mapperListener.init();

    <span class="hljs-comment">// Initialize our defined Connectors</span>
    <span class="hljs-keyword">synchronized</span> (connectorsLock) {
        <span class="hljs-keyword">for</span> (Connector connector : connectors) {
            connector.init();
        }
    }
}
</code></pre><p>发现了这里面要依次初始化几个组件：<code>Engine</code>，<code>Executor</code>，<code>LifecycleMBeanBase(mapperListener)</code>，<code>Connector</code> 。</p>
<p>到这里咱应该有种意识：这几个家伙的初始化不会又回到 <code>LifecycleBase</code> 中了吧？可以很确定的回答：基本是的。。。所以接下来咱就不贴 <code>LifecycleBase</code> 的源码了，直接看这几个组件的实现吧：</p>
<h4 class="heading">4.5.5 StandardEngine#initInternal</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-comment">// Ensure that a Realm is present before any attempt is made to start</span>
    <span class="hljs-comment">// one. This will create the default NullRealm if necessary.</span>
    <span class="hljs-comment">// 在尝试启动一个Realm之前，请确保存在一个Realm。如有必要，这将创建默认的NullRealm</span>
    getRealm();
    <span class="hljs-keyword">super</span>.initInternal();
}

<span class="hljs-function"><span class="hljs-keyword">public</span> Realm <span class="hljs-title">getRealm</span><span class="hljs-params">()</span> </span>{
    Realm configured = <span class="hljs-keyword">super</span>.getRealm();
    <span class="hljs-comment">// If no set realm has been called - default to NullRealm</span>
    <span class="hljs-comment">// This can be overridden at engine, context and host level</span>
    <span class="hljs-keyword">if</span> (configured == <span class="hljs-keyword">null</span>) {
        configured = <span class="hljs-keyword">new</span> NullRealm();
        <span class="hljs-keyword">this</span>.setRealm(configured);
    }
    <span class="hljs-keyword">return</span> configured;
}
</code></pre><p>很明显这里是初始化Realm的，且实现很简单，不再展开。</p>
<h4 class="heading">4.5.6 Executor#initInternal</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-keyword">super</span>.initInternal();
}
</code></pre><p>它还是调的父类 <code>LifecycleMBeanBase</code> 的方法，不再赘述。</p>
<h4 class="heading">4.5.7 MapperListener#initInternal</h4>
<p><code>MapperListener</code> 没有重写 <code>initInternal</code> 方法，相当于也跟上面一样，不再赘述。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-comment">// If oname is not null then registration has already happened via preRegister().</span>
    <span class="hljs-comment">// 如果oname不为null，则已经通过preRegister()进行了注册</span>
    <span class="hljs-keyword">if</span> (oname == <span class="hljs-keyword">null</span>) {
        mserver = Registry.getRegistry(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>).getMBeanServer();
        oname = register(<span class="hljs-keyword">this</span>, getObjectNameKeyProperties());
    }
}
</code></pre><p>跟上面一样，不再赘述。</p>
<h4 class="heading">4.5.8 Connector#initInternal</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-keyword">super</span>.initInternal();
    <span class="hljs-comment">// ......</span>

    <span class="hljs-comment">// Initialize adapter</span>
    <span class="hljs-comment">// CoyoteAdapter负责连接Coyote和Servlet容器(web应用)</span>
    adapter = <span class="hljs-keyword">new</span> CoyoteAdapter(<span class="hljs-keyword">this</span>);
    protocolHandler.setAdapter(adapter);
    <span class="hljs-comment">// ......</span>

    <span class="hljs-keyword">try</span> {
        protocolHandler.init();
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LifecycleException(
                sm.getString(<span class="hljs-string">"coyoteConnector.protocolHandlerInitializationFailed"</span>), e);
    }
}
</code></pre><p>中间部分它初始化了一个 <code>CoyoteAdapter</code> ，它负责连接 <code>Connector</code> 和 <code>Container</code> ，也就是 <code>Coyote</code> 和 <code>Servlet容器</code>。</p>
<p>最下面的try-catch中，它又调用了 <code>protocolHandler.init</code> ：</p>
<h4 class="heading">4.5.9 protocolHandler.init</h4>
<p>来到 <code>AbstractHttp11Protocol</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// Upgrade protocols have to be configured first since the endpoint</span>
    <span class="hljs-comment">// init (triggered via super.init() below) uses this list to configure</span>
    <span class="hljs-comment">// the list of ALPN protocols to advertise</span>
    <span class="hljs-comment">// 必须先配置升级协议，因为端点初始化（通过下面的super.init()触发）使用此列表来配置要发布的ALPN协议列表</span>
    <span class="hljs-keyword">for</span> (UpgradeProtocol upgradeProtocol : upgradeProtocols) {
        configureUpgradeProtocol(upgradeProtocol);
    }

    <span class="hljs-keyword">super</span>.init();
}
</code></pre><p>Debug发现这个 <code>upgradeProtocols</code> 为空，直接走下面父类（<code>AbstractProtocol</code>）的 <code>init</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-keyword">if</span> (getLog().isInfoEnabled()) {
        getLog().info(sm.getString(<span class="hljs-string">"abstractProtocolHandler.init"</span>, getName()));
        logPortOffset();
    }

    <span class="hljs-keyword">if</span> (oname == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// Component not pre-registered so register it</span>
        oname = createObjectName();
        <span class="hljs-keyword">if</span> (oname != <span class="hljs-keyword">null</span>) {
            Registry.getRegistry(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>).registerComponent(<span class="hljs-keyword">this</span>, oname, <span class="hljs-keyword">null</span>);
        }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.domain != <span class="hljs-keyword">null</span>) {
        rgOname = <span class="hljs-keyword">new</span> ObjectName(domain + <span class="hljs-string">":type=GlobalRequestProcessor,name="</span> + getName());
        Registry.getRegistry(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>).registerComponent(
                getHandler().getGlobal(), rgOname, <span class="hljs-keyword">null</span>);
    }

    String endpointName = getName();
    endpoint.setName(endpointName.substring(<span class="hljs-number">1</span>, endpointName.length()-<span class="hljs-number">1</span>));
    endpoint.setDomain(domain);

    endpoint.init();
}
</code></pre><p>上面又是一堆初始化，这个咱暂且不关注，注意最底下有一个 <code>endpoint.init</code> ：</p>
<h4 class="heading">4.5.10 endpoint.init</h4>
<p>来到 <code>AbstractEndPoint</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// Debug为false</span>
    <span class="hljs-keyword">if</span> (bindOnInit) {
        bindWithCleanup();
        bindState = BindState.BOUND_ON_INIT;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.domain != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// Register endpoint (as ThreadPool - historical name)</span>
        oname = <span class="hljs-keyword">new</span> ObjectName(domain + <span class="hljs-string">":type=ThreadPool,name=\""</span> + getName() + <span class="hljs-string">"\""</span>);
        Registry.getRegistry(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>).registerComponent(<span class="hljs-keyword">this</span>, oname, <span class="hljs-keyword">null</span>);

        ObjectName socketPropertiesOname = <span class="hljs-keyword">new</span> ObjectName(domain +
                <span class="hljs-string">":type=ThreadPool,name=\""</span> + getName() + <span class="hljs-string">"\",subType=SocketProperties"</span>);
        socketProperties.setObjectName(socketPropertiesOname);
        Registry.getRegistry(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>).registerComponent(socketProperties, socketPropertiesOname, <span class="hljs-keyword">null</span>);

        <span class="hljs-keyword">for</span> (SSLHostConfig sslHostConfig : findSslHostConfigs()) {
            registerJmx(sslHostConfig);
        }
    }
}
</code></pre><p>这里面又是初始化 <code>oname</code> ，又是配置 <code>socketProperties</code> 的，但这里面再也没见到 <code>init</code> 方法，证明这部分初始化过程已经结束了。</p>
<p>值得注意的是，Debug发现 <code>bindOnInit</code> 变量为false，说明<strong>嵌入式 Tomcat 不在初始化期间绑定端口号</strong>。</p>
<h4 class="heading">4.5.11 初始化小结</h4>
<p>嵌入式 Tomcat 的组件初始化步骤顺序如下：</p>
<ol>
<li>Server</li>
<li>Service</li>
<li>Engine</li>
<li>Executor</li>
<li>MapperListener</li>
<li>Connector</li>
<li>Protocol</li>
<li>EndPoint</li>
</ol>
<hr>
<p>至此，初始化过程完毕，回到 <code>start</code> 方法中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-comment">// ......</span>
    <span class="hljs-keyword">if</span> (state.equals(LifecycleState.NEW)) {
        init();
    } <span class="hljs-comment">// else if ......</span>

    <span class="hljs-keyword">try</span> {
        setStateInternal(LifecycleState.STARTING_PREP, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);
        startInternal();
        <span class="hljs-comment">// ......</span>
}
</code></pre><p>接下来到了真正启动的部分了：<code>startInternal</code></p>
<h3 class="heading">4.6 StandardServer#startInternal</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-comment">// 发布启动事件</span>
    fireLifecycleEvent(CONFIGURE_START_EVENT, <span class="hljs-keyword">null</span>);
    setState(LifecycleState.STARTING);

    <span class="hljs-comment">// 4.6.1 NamingResources启动</span>
    globalNamingResources.start();

    <span class="hljs-comment">// Start our defined Services</span>
    <span class="hljs-keyword">synchronized</span> (servicesLock) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; services.length; i++) {
            <span class="hljs-comment">// 4.6.2 Service启动</span>
            services[i].start();
        }
    }

    <span class="hljs-keyword">if</span> (periodicEventDelay &gt; <span class="hljs-number">0</span>) {
        monitorFuture = getUtilityExecutor().scheduleWithFixedDelay(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        startPeriodicLifecycleEvent();
                    }
                }, <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS);
    }
}
</code></pre><p><code>startInternal</code> 方法中有两部分启动：<code>globalNamingResources</code> 启动，<code>services</code> 启动。分别来看：</p>
<h4 class="heading">4.6.1 globalNamingResources.start</h4>
<p>来到 <code>NamingResourcesImpl</code> ，因为它也实现了 <code>LifecycleBase</code> ，还是会来到上面的 <code>startInternal</code> 方法中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    fireLifecycleEvent(CONFIGURE_START_EVENT, <span class="hljs-keyword">null</span>);
    setState(LifecycleState.STARTING);
}
</code></pre><p>这部分只是发布事件和设置状态而已，与之前一致，不再赘述。</p>
<h4 class="heading">4.6.2 StandardService#start</h4>
<p>最终又来到 <code>startInternal</code> 方法了：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{

    <span class="hljs-keyword">if</span>(log.isInfoEnabled())
        log.info(sm.getString(<span class="hljs-string">"standardService.start.name"</span>, <span class="hljs-keyword">this</span>.name));
    setState(LifecycleState.STARTING);

    <span class="hljs-comment">// Start our defined Container first</span>
    <span class="hljs-keyword">if</span> (engine != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">synchronized</span> (engine) {
            <span class="hljs-comment">// 4.6.3</span>
            engine.start();
        }
    }

    <span class="hljs-keyword">synchronized</span> (executors) {
        <span class="hljs-keyword">for</span> (Executor executor: executors) {
            <span class="hljs-comment">// 4.6.6</span>
            executor.start();
        }
    }

    <span class="hljs-comment">// 4.6.7</span>
    mapperListener.start();

    <span class="hljs-comment">// Start our defined Connectors second</span>
    <span class="hljs-keyword">synchronized</span> (connectorsLock) {
        <span class="hljs-keyword">for</span> (Connector connector: connectors) {
            <span class="hljs-comment">// If it has already failed, don't try and start it</span>
            <span class="hljs-keyword">if</span> (connector.getState() != LifecycleState.FAILED) {
                <span class="hljs-comment">// 4.6.8</span>
                connector.start();
            }
        }
    }
}
</code></pre><p>发现这部分与之前的初始化几乎一致！也是依次启动 <code>Engine</code> 、<code>Executor</code> 、<code>MapperListener</code> 、<code>Connector</code> 。</p>
<h4 class="heading">4.6.3 Engine#start</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-comment">// Log our server identification information</span>
    <span class="hljs-keyword">if</span> (log.isInfoEnabled()) {
        log.info(sm.getString(<span class="hljs-string">"standardEngine.start"</span>, ServerInfo.getServerInfo()));
    }

    <span class="hljs-comment">// Standard container startup</span>
    <span class="hljs-keyword">super</span>.startInternal();
}
</code></pre><p>它直接调的父类 <code>ContainerBase</code> 的 <code>startInternal</code> 方法：（重要部分注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{

    <span class="hljs-comment">// Start our subordinate components, if any</span>
    logger = <span class="hljs-keyword">null</span>;
    getLogger();
    <span class="hljs-comment">// Cluster与集群相关，SpringBoot项目中使用嵌入式Tomcat，不存在集群</span>
    Cluster cluster = getClusterInternal();
    <span class="hljs-keyword">if</span> (cluster <span class="hljs-keyword">instanceof</span> Lifecycle) {
        ((Lifecycle) cluster).start();
    }
    <span class="hljs-comment">// Realm与授权相关</span>
    Realm realm = getRealmInternal();
    <span class="hljs-keyword">if</span> (realm <span class="hljs-keyword">instanceof</span> Lifecycle) {
        ((Lifecycle) realm).start();
    }

    <span class="hljs-comment">// Start our child containers, if any</span>
    <span class="hljs-comment">// Container的类型是StandardHost</span>
    Container children[] = findChildren();
    List&lt;Future&lt;Void&gt;&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
        <span class="hljs-comment">// 4.6.4 异步初始化Host</span>
        results.add(startStopExecutor.submit(<span class="hljs-keyword">new</span> StartChild(children[i])));
    }

    MultiThrowable multiThrowable = <span class="hljs-keyword">null</span>;

    <span class="hljs-keyword">for</span> (Future&lt;Void&gt; result : results) {
        <span class="hljs-keyword">try</span> {
            result.get();
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            log.error(sm.getString(<span class="hljs-string">"containerBase.threadedStartFailed"</span>), e);
            <span class="hljs-keyword">if</span> (multiThrowable == <span class="hljs-keyword">null</span>) {
                multiThrowable = <span class="hljs-keyword">new</span> MultiThrowable();
            }
            multiThrowable.add(e);
        }

    }
    <span class="hljs-keyword">if</span> (multiThrowable != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LifecycleException(sm.getString(<span class="hljs-string">"containerBase.threadedStartFailed"</span>),
                multiThrowable.getThrowable());
    }

    <span class="hljs-comment">// Start the Valves in our pipeline (including the basic), if any</span>
    <span class="hljs-keyword">if</span> (pipeline <span class="hljs-keyword">instanceof</span> Lifecycle) {
        ((Lifecycle) pipeline).start();
    }

    setState(LifecycleState.STARTING);

    <span class="hljs-comment">// Start our thread</span>
    <span class="hljs-keyword">if</span> (backgroundProcessorDelay &gt; <span class="hljs-number">0</span>) {
        monitorFuture = Container.getService(ContainerBase.<span class="hljs-keyword">this</span>).getServer()
                .getUtilityExecutor().scheduleWithFixedDelay(
                        <span class="hljs-keyword">new</span> ContainerBackgroundProcessorMonitor(), <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS);
    }
}
</code></pre><p>这里面又是嵌套的初始化了其他组件，一一来看：</p>
<h4 class="heading">4.6.4 new StartChild(children[i])</h4>
<p>这部分比较有意思，它用了异步初始化，先来看看 <code>StartChild</code> 的定义：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartChild</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Void</span>&gt;
</span></code></pre><p>它实现了带返回值的异步多线程接口 <strong><code>Callable</code></strong> ！那里面的核心方法就是 <strong><code>call</code></strong> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    child.start();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>它在这里初始化 <code>child</code>，而通过Debug得知 <code>child</code> 的类型是 <code>StandardHost</code>，故来到 <code>StandardHost</code> 的 <code>start</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-comment">// Set error report valve</span>
    String errorValve = getErrorReportValveClass();
    <span class="hljs-keyword">if</span> ((errorValve != <span class="hljs-keyword">null</span>) &amp;&amp; (!errorValve.equals(<span class="hljs-string">""</span>))) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>;
            Valve[] valves = getPipeline().getValves();
            <span class="hljs-keyword">for</span> (Valve valve : valves) {
                <span class="hljs-keyword">if</span> (errorValve.equals(valve.getClass().getName())) {
                    found = <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }
            <span class="hljs-keyword">if</span>(!found) {
                Valve valve =
                    (Valve) Class.forName(errorValve).getConstructor().newInstance();
                getPipeline().addValve(valve);
            }
        } <span class="hljs-keyword">catch</span> (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.error(sm.getString(
                    <span class="hljs-string">"standardHost.invalidErrorReportValveClass"</span>,
                    errorValve), t);
        }
    }
    <span class="hljs-keyword">super</span>.startInternal();
}
</code></pre><p>上面的一个大if结构是设置错误提示页面的，下面又调父类的 <code>startInternal</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    <span class="hljs-comment">// ......</span>
    <span class="hljs-comment">// Start our child containers, if any</span>
    Container children[] = findChildren();
    List&lt;Future&lt;Void&gt;&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
        results.add(startStopExecutor.submit(<span class="hljs-keyword">new</span> StartChild(children[i])));
    }
</code></pre><p>又回来了。。。因为一个 <code>Host</code> 包含一个 <code>Context</code> 。</p>
<p><code>Host</code> 搜索children就会搜到它下面的 <code>Context</code> ，之后又是下面的初始化过程，进入 Context 的初始化：</p>
<h4 class="heading">4.6.5 TomcatEmbeddedContext#start</h4>
<p>这个方法非常非常长（300行+），小册就不全部贴出来了，咱现在是启动阶段，那我们只关心里面的 start 相关代码。</p>
<p>借由前面的Debug过程，我们先总结一个规律：<strong>所有带生命周期性质的组件，都会在启动时走到 <code>startInternal</code> 方法</strong>。</p>
<p>那我们接下来Debug这个300行+的代码时，只需要在方法头和方法尾打上断点，中间部分只要走 <code>startInternal</code> 方法的，就是组件的初始化。通过Debug，发现有如下组件被调用了 start 方法：</p>
<ul>
<li>StandardRoot</li>
<li>DirResourceSet</li>
<li>WebappLoader</li>
<li>JarResourceSet</li>
<li>StandardWrapper</li>
<li>StandardPineline</li>
<li>StandardWrapperValve</li>
<li>NonLoginAuthenticator</li>
<li>StandardContextValve</li>
<li>StandardManager</li>
<li>LazySessionIdGenerator</li>
</ul>
<p>组件的 <code>startInternal</code> 方法就不一一列举了，小册把这些组件的核心功能列举一下，有兴趣的小伙伴可以深入研究一下，小册也只是引导小伙伴们对嵌入式 Tomcat 的底层原理有一个大概的认识和了解。</p>
<h4 class="heading">4.6.6 Executor#start</h4>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">synchronized</span> (executors) {
        <span class="hljs-keyword">for</span> (Executor executor: executors) {
            <span class="hljs-comment">// 4.6.6</span>
            executor.start();
        }
    }
</code></pre><p><code>Engine</code> 启动完成后，下一步到了 <code>Executor</code> 的启动。但由于 <code>Executor</code> 没有实现 <code>startInternal</code> 方法，故这一步不再展开。</p>
<h4 class="heading">4.6.7 MapperListener#start</h4>
<pre><code class="hljs java" lang="java">    mapperListener.start();
</code></pre><p><code>Executor</code> 启动完成后，接下来启动 <code>MapperListener</code> ：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{
    setState(LifecycleState.STARTING);

    Engine engine = service.getContainer();
    <span class="hljs-keyword">if</span> (engine == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 获取当前部署的主机名（本地调试为localhost）</span>
    findDefaultHost();

    <span class="hljs-comment">// 4.6.7.1 把当前自身注册到Engine、Host、Context、Wrapper中</span>
    addListeners(engine);

    <span class="hljs-comment">// 取出的Container的类型为Host</span>
    Container[] conHosts = engine.findChildren();
    <span class="hljs-keyword">for</span> (Container conHost : conHosts) {
        Host host = (Host) conHost;
        <span class="hljs-keyword">if</span> (!LifecycleState.NEW.equals(host.getState())) {
            <span class="hljs-comment">// Registering the host will register the context and wrappers</span>
            <span class="hljs-comment">// 4.6.7.2 将Host、Context、Wrapper注册到当前监听器中</span>
            registerHost(host);
        }
    }
}
</code></pre><p>这里面它干了三件事请：获取主机名，将监听器注册到各组件中，将各组件注册到监听器（实现双向）。咱主要看一眼两方互相注册的动作：</p>
<h5 class="heading">4.6.7.1 addListeners</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addListeners</span><span class="hljs-params">(Container container)</span> </span>{
    container.addContainerListener(<span class="hljs-keyword">this</span>);
    container.addLifecycleListener(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">for</span> (Container child : container.findChildren()) {
        addListeners(child);
    }
}
</code></pre><p>很明显这是递归调用，而且从 <code>Engine</code> 开始一层一层往下执行，都把当前监听器注册进去。</p>
<h5 class="heading">4.6.7.2 registerHost</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerHost</span><span class="hljs-params">(Host host)</span> </span>{
    String[] aliases = host.findAliases();
    mapper.addHost(host.getName(), aliases, host);

    <span class="hljs-keyword">for</span> (Container container : host.findChildren()) {
        <span class="hljs-keyword">if</span> (container.getState().isAvailable()) {
            registerContext((Context) container);
        }
    }

    <span class="hljs-comment">// Default host may have changed</span>
    findDefaultHost();

    <span class="hljs-comment">// log ......</span>
}
</code></pre><p>注意这里面的for循环，又调了 <code>registerContext</code> ，可见这个思路也跟上面差不多，类似于递归，不过这是手动一步一步往里设置（毕竟类型不一样）。</p>
<h4 class="heading">4.6.8 Connector#start</h4>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Start our defined Connectors second</span>
    <span class="hljs-keyword">synchronized</span> (connectorsLock) {
        <span class="hljs-keyword">for</span> (Connector connector: connectors) {
            <span class="hljs-comment">// If it has already failed, don't try and start it</span>
            <span class="hljs-keyword">if</span> (connector.getState() != LifecycleState.FAILED) {
                connector.start();
            }
        }
    }
</code></pre><p>最后一步是启动 <code>Connector</code> 。但通过Debug发现根本没有 <code>Connector</code> ！</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/27/16eab66cd1855776~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>为什么之前还看到一个 <code>Connector</code> ，现在就没了呢？还记得在 <code>this.tomcat.start();</code> 之前有一个监听器吗？</p>
<pre><code class="hljs java" lang="java">    context.addLifecycleListener((event) -&gt; {
        <span class="hljs-keyword">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) {
            <span class="hljs-comment">// Remove service connectors so that protocol binding doesn't</span>
            <span class="hljs-comment">// happen when the service is started.</span>
            removeServiceConnectors();
        }
    });
</code></pre><p>很明显就是这一步把 <code>Connector</code> 删了嘛！</p>
<blockquote>
<p>Remove service connectors so that protocol binding doesn't happen when the service is started.</p>
<p>删除 <code>Service</code> 的 <code>Connector</code> ，以便在启动服务时不会发生协议绑定。</p>
</blockquote>
<p>那大概率就是这一步让这个家伙给删了。注意这个监听器是在 <code>context</code> 中注册的，那我们猜想，应该是 <code>Context</code> 启动时触发的这个监听效果。</p>
<p>回过头来重新Debug一次，发现在 <code>Engine</code> 启动之后，<code>Connector</code> 就已经没了。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/27/16eab66e5274869a~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>将断点打在上面 <code>context</code> 的监听器上，放行，发现果然 <strong>在 <code>TomcatEmbeddedContext</code> 的启动期间触发了这个监听器</strong>。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/27/16eab670224d3ae1~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>至于为什么要删除的原因，上面4.3章节也描述了，是为了<strong>防止 SpringBoot 应用还没有初始化完成时就已经可以接收客户端的请求</strong>。</p>
<hr>
<p>至此，<code>tomcat.start();</code> 方法彻底执行完成。</p>
<h4 class="heading">4.6.9 启动小结</h4>
<p>启动过程依次启动了如下组件：</p>
<ol>
<li>NamingResources</li>
<li>Service</li>
<li>Engine</li>
<li>Host</li>
<li>Context</li>
<li>Wrapper</li>
<li>MapperListener</li>
</ol>
<h3 class="heading">4.7 回到initialize</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> WebServerException </span>{
        <span class="hljs-comment">// ......</span>
            <span class="hljs-keyword">this</span>.tomcat.start();

            <span class="hljs-comment">// We can re-throw failure exception directly in the main thread</span>
            <span class="hljs-comment">// 如果上面的启动出现问题，则抛出异常</span>
            rethrowDeferredStartupExceptions();

            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 将当前Context与当前ClassLoader绑定</span>
                ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());
            }
            <span class="hljs-keyword">catch</span> (NamingException ex) {
                <span class="hljs-comment">// Naming is not enabled. Continue</span>
            }

            <span class="hljs-comment">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span>
            <span class="hljs-comment">// blocking non-daemon to stop immediate shutdown</span>
            <span class="hljs-comment">// 4.8 阻止Tomcat结束</span>
            startDaemonAwaitThread();
        }
        <span class="hljs-keyword">catch</span> (Exception ex) {
            stopSilently();
            destroySilently();
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> WebServerException(<span class="hljs-string">"Unable to start embedded Tomcat"</span>, ex);
        }
    }
}
</code></pre><p>嵌入式 Tomcat 启动完成后，在try块的最底下会起一个新的线程，阻止 Tomcat 结束。</p>
<h3 class="heading">4.8 startDaemonAwaitThread</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startDaemonAwaitThread</span><span class="hljs-params">()</span> </span>{
    Thread awaitThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"container-"</span> + (containerCounter.get())) {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
            TomcatWebServer.<span class="hljs-keyword">this</span>.tomcat.getServer().await();
        }
    };
    awaitThread.setContextClassLoader(getClass().getClassLoader());
    awaitThread.setDaemon(<span class="hljs-keyword">false</span>);
    awaitThread.start();
}
</code></pre><p>这里面它会起一个新的 <code>awaitThread</code> 线程，并回调 Tomcat 中 <code>Server</code> 的 <code>await</code> 方法，并且它还设置 <code>Daemon</code> 为false。</p>
<p>先解释一下为什么设置 <code>Daemon</code> ：Tomcat 中所有的进程都是 Daemon 线程，在Java应用中，<strong>只要有一个非 Daemon 线程还在运行，则 Daemon 线程就不会停止，整个应用也不会终止</strong>。既然要让 Tomcat 一直运行以监听客户端请求，就必须需要让 Tomcat 内部的 Daemon 线程都存活，根据前面的描述，就必须制造一个能卡住停止的非 Daemon 线程。于是上面新起的 <code>awaitThread</code> 线程就被设置为非 Daemon 线程。</p>
<p>下面看看线程中执行的 <code>await</code> 方法：（源码很长，只截取出跟 SpringBoot 嵌入式 Tomcat 有关的部分）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Negative values - don't wait on port - tomcat is embedded or we just don't like ports</span>
    <span class="hljs-comment">// 如果关闭Tomcat的端口是-2，则直接返回，不卡线程</span>
    <span class="hljs-keyword">if</span> (getPortWithOffset() == -<span class="hljs-number">2</span>) {
        <span class="hljs-comment">// undocumented yet - for embedding apps that are around, alive.</span>
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 如果关闭Tomcat的端口是-1，代表是嵌入式Tomcat</span>
    <span class="hljs-keyword">if</span> (getPortWithOffset() == -<span class="hljs-number">1</span>) {
        <span class="hljs-keyword">try</span> {
            awaitThread = Thread.currentThread();
            <span class="hljs-keyword">while</span>(!stopAwait) {
                <span class="hljs-keyword">try</span> {
                    Thread.sleep( <span class="hljs-number">10000</span> );
                } <span class="hljs-keyword">catch</span>( InterruptedException ex ) {
                    <span class="hljs-comment">// continue and check the flag</span>
                }
            }
        } <span class="hljs-keyword">finally</span> {
            awaitThread = <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Set up a server socket to wait on</span>
    <span class="hljs-comment">// 退出端口正常的处理（属于外部Tomcat逻辑）......</span>
}
</code></pre><p>可以发现，如果设置的 Tomcat 的退出端口是 -1，则代表是嵌入式 Tomcat，它会<strong>每10秒会检查一次stopAwait的值</strong>，如果为true则停止卡线程，让 Tomcat 停止。</p>
<p>默认请款下 Tomcat 的退出端口是8005，为什么这里会变成 -1 呢？追踪源码，发现在 <code>Tomcat</code> 的 <code>getServer</code> 方法中有设置：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">getServer</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> server;
    }

    System.setProperty(<span class="hljs-string">"catalina.useNaming"</span>, <span class="hljs-string">"false"</span>);

    server = <span class="hljs-keyword">new</span> StandardServer();

    initBaseDir();

    <span class="hljs-comment">// Set configuration source</span>
    ConfigFileLoader.setSource(<span class="hljs-keyword">new</span> CatalinaBaseConfigurationSource(<span class="hljs-keyword">new</span> File(basedir), <span class="hljs-keyword">null</span>));

    <span class="hljs-comment">// 设置端口号为 -1，代表嵌入式</span>
    server.setPort( -<span class="hljs-number">1</span> );

    Service service = <span class="hljs-keyword">new</span> StandardService();
    service.setName(<span class="hljs-string">"Tomcat"</span>);
    server.addService(service);
    <span class="hljs-keyword">return</span> server;
}
</code></pre><p>至此，嵌入式 Tomcat 已经成功创建好，但 <code>Connector</code> 还没有归还，还在被删除中。</p>
<h2 class="heading">5. ServletWebServerApplicationContext#startWebServer</h2>
<p>当IOC容器的 onRefresh 方法执行完，单实例Bean初始化完成后，来到 <code>finishRefresh</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishRefresh</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.finishRefresh();
    WebServer webServer = startWebServer();
    <span class="hljs-keyword">if</span> (webServer != <span class="hljs-keyword">null</span>) {
        publishEvent(<span class="hljs-keyword">new</span> ServletWebServerInitializedEvent(webServer, <span class="hljs-keyword">this</span>));
    }
}
</code></pre><p>在这里它会真正启动嵌入式 Tomcat 容器：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> WebServer <span class="hljs-title">startWebServer</span><span class="hljs-params">()</span> </span>{
    WebServer webServer = <span class="hljs-keyword">this</span>.webServer;
    <span class="hljs-keyword">if</span> (webServer != <span class="hljs-keyword">null</span>) {
        webServer.start();
    }
    <span class="hljs-keyword">return</span> webServer;
}
</code></pre><p>可以看到它在这里调用了 <code>TomcatWebServer</code> 的 <code>start</code> 方法。</p>
<h2 class="heading">6. TomcatWebServer#start</h2>
<p>（关键步骤注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> WebServerException </span>{
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.monitor) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.started) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 6.1 还原、启动Connector</span>
            addPreviouslyRemovedConnectors();
            <span class="hljs-comment">// 只拿一个Connector</span>
            Connector connector = <span class="hljs-keyword">this</span>.tomcat.getConnector();
            <span class="hljs-keyword">if</span> (connector != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.autoStart) {
                <span class="hljs-comment">// 6.2 延迟启动</span>
                performDeferredLoadOnStartup();
            }
            <span class="hljs-comment">// 检查Connector是否正常启动</span>
            checkThatConnectorsHaveStarted();
            <span class="hljs-keyword">this</span>.started = <span class="hljs-keyword">true</span>;
            logger.info(<span class="hljs-string">"Tomcat started on port(s): "</span> + getPortsDescription(<span class="hljs-keyword">true</span>) + <span class="hljs-string">" with context path '"</span>
                    + getContextPath() + <span class="hljs-string">"'"</span>);
        }
        <span class="hljs-comment">// catch ......</span>
        <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// 解除ClassLoader与TomcatEmbeddedContext的绑定关系</span>
            Context context = findContext();
            ContextBindings.unbindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());
        }
    }
}
</code></pre><p>源码中的注释已解释的比较清楚，下面分述源码中两个重要的环节：还原 <code>Connector</code> 和启动 <code>Connector</code> ：</p>
<h3 class="heading">6.1 addPreviouslyRemovedConnectors：还原Connector</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPreviouslyRemovedConnectors</span><span class="hljs-params">()</span> </span>{
    Service[] services = <span class="hljs-keyword">this</span>.tomcat.getServer().findServices();
    <span class="hljs-keyword">for</span> (Service service : services) {
        Connector[] connectors = <span class="hljs-keyword">this</span>.serviceConnectors.get(service);
        <span class="hljs-keyword">if</span> (connectors != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">for</span> (Connector connector : connectors) {
                <span class="hljs-comment">// 6.1.1 添加并启动</span>
                service.addConnector(connector);
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.autoStart) {
                    stopProtocolHandler(connector);
                }
            }
            <span class="hljs-keyword">this</span>.serviceConnectors.remove(service);
        }
    }
}
</code></pre><p>可以发现它将一个缓存区的 <code>Connector</code> 一个一个取出放入 <code>Service</code> 中。注意在 <code>service.addConnector</code> 中有顺便启动的部分：</p>
<h4 class="heading">6.1.1 service.addConnector</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addConnector</span><span class="hljs-params">(Connector connector)</span> </span>{
    <span class="hljs-keyword">synchronized</span> (connectorsLock) {
        connector.setService(<span class="hljs-keyword">this</span>);
        Connector results[] = <span class="hljs-keyword">new</span> Connector[connectors.length + <span class="hljs-number">1</span>];
        System.arraycopy(connectors, <span class="hljs-number">0</span>, results, <span class="hljs-number">0</span>, connectors.length);
        results[connectors.length] = connector;
        connectors = results;
    }

    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (getState().isAvailable()) {
            <span class="hljs-comment">// 6.1.2 启动Connector</span>
            connector.start();
        }
    } <span class="hljs-keyword">catch</span> (LifecycleException e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(
                sm.getString(<span class="hljs-string">"standardService.connector.startFailed"</span>, connector), e);
    }

    <span class="hljs-comment">// Report this property change to interested listeners</span>
    support.firePropertyChange(<span class="hljs-string">"connector"</span>, <span class="hljs-keyword">null</span>, connector);
}
</code></pre><p>前面的部分是取出 <code>Connector</code> ，并与 <code>Service</code> 绑定，之后中间部分的try块，会启动 <code>Connector</code> ：</p>
<h4 class="heading">6.1.2 connector.start</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>{

    <span class="hljs-comment">// Validate settings before starting</span>
    <span class="hljs-keyword">if</span> (getPortWithOffset() &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LifecycleException(sm.getString(
                <span class="hljs-string">"coyoteConnector.invalidPort"</span>, Integer.valueOf(getPortWithOffset())));
    }

    setState(LifecycleState.STARTING);

    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 启动ProtocolHandler</span>
        protocolHandler.start();
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LifecycleException(
                sm.getString(<span class="hljs-string">"coyoteConnector.protocolHandlerStartFailed"</span>), e);
    }
}
</code></pre><p><code>Connector</code> 的启动会引发 <code>ProtocolHandler</code> 的启动：</p>
<h4 class="heading">6.1.3 protocolHandler.start</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-keyword">if</span> (getLog().isInfoEnabled()) {
        getLog().info(sm.getString(<span class="hljs-string">"abstractProtocolHandler.start"</span>, getName()));
        logPortOffset();
    }

    <span class="hljs-comment">// 启动EndPoint</span>
    endpoint.start();
    monitorFuture = getUtilityExecutor().scheduleWithFixedDelay(
            <span class="hljs-keyword">new</span> Runnable() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">if</span> (!isPaused()) {
                        startAsyncTimeout();
                    }
                }
            }, <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS);
}
</code></pre><p><code>ProtocolHandler</code> 的启动会引发 EndPoint 的启动，至此所有组件均已启动完毕。</p>
<h3 class="heading">6.2 performDeferredLoadOnStartup：延迟启动</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performDeferredLoadOnStartup</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">for</span> (Container child : <span class="hljs-keyword">this</span>.tomcat.getHost().findChildren()) {
            <span class="hljs-keyword">if</span> (child <span class="hljs-keyword">instanceof</span> TomcatEmbeddedContext) {
                <span class="hljs-comment">// 延迟启动Context</span>
                ((TomcatEmbeddedContext) child).deferredLoadOnStartup();
            }
        }
    }
    <span class="hljs-keyword">catch</span> (Exception ex) {
        <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> WebServerException) {
            <span class="hljs-keyword">throw</span> (WebServerException) ex;
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> WebServerException(<span class="hljs-string">"Unable to start embedded Tomcat connectors"</span>, ex);
    }
}
</code></pre><p>发现这里面会延迟启动 <code>TomcatEmbeddedContext</code> ，此处它对比较老的表现层框架（如Struts）做了一些兼容支持，主要是替换类加载器，由于 SpringBoot 默认使用WebMvc或WebFlux，已不采用过老的表现层框架，故此处不再展开讨论。</p>
<p>至此，嵌入式 Tomcat 完整启动。</p>
<h2 class="heading">小结</h2>
<ol>
<li>嵌入式 Tomcat 与外置的 Tomcat 在核心组件上都是一样的，主要包括 <code>Service</code> 、<code>Connector</code> 、<code>Engine</code> 、<code>Host</code> 、<code>Context</code> 。</li>
<li>Tomcat 的启动过程分为初始化和启动两个步骤，分别按照核心组件的顺序启动。</li>
<li>嵌入式 Tomcat 在启动时要先移除掉 <code>Connector</code> ，防止IOC容器还没有全部启动完成后就能接收客户端的请求。</li>
</ol>
<p>【至此，嵌入式 Tomcat 成功启动，核心启动步骤解析完毕。下一篇咱看看嵌入式 Tomcat 有哪些调整的接口，好给我们做性能调优】</p>
</div>
</body></html>