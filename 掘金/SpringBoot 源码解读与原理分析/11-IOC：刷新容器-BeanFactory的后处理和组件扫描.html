<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>IOC：刷新容器-BeanFactory的后处理和组件扫描</h1>
<h1 class="heading">12. IOC：刷新容器-BeanFactory的后处理和组件扫描</h1>
<p>【接前章】</p>
<p>本篇解析4、5步骤：</p>
<pre><code class="hljs java" lang="java">        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span>
            <span class="hljs-comment">// 4. BeanFactory的后置处理</span>
            postProcessBeanFactory(beanFactory);

            <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span>
            <span class="hljs-comment">// 5. 执行BeanFactory创建后的后置处理器</span>
            invokeBeanFactoryPostProcessors(beanFactory);
</code></pre><h2 class="heading">4. postProcessBeanFactory：BeanFactory的后置处理</h2>
<p>在 <code>AbstractApplicationContext</code> 中，这个方法又被设置成模板方法了：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{
}
</code></pre><p>借助IDEA，发现 <code>AnnotationConfigServletWebServerApplicationContext</code> 重写了这个方法。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// AnnotationConfigServletWebServerApplicationContext</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{
    <span class="hljs-keyword">super</span>.postProcessBeanFactory(beanFactory);
    <span class="hljs-comment">// 包扫描</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.basePackages != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.basePackages.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>.scanner.scan(<span class="hljs-keyword">this</span>.basePackages);
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.annotatedClasses.isEmpty()) {
        <span class="hljs-keyword">this</span>.reader.register(ClassUtils.toClassArray(<span class="hljs-keyword">this</span>.annotatedClasses));
    }
}
</code></pre><p>它首先调了父类 <code>ServletWebServerApplicationContext</code> 的 <code>postProcessBeanFactory</code> 方法。</p>
<h3 class="heading">4.1 ServletWebServerApplicationContext.postProcessBeanFactory</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// ServletWebServerApplicationContext</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{
    <span class="hljs-comment">// 注册ServletContext注入器</span>
    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> WebApplicationContextServletContextAwareProcessor(<span class="hljs-keyword">this</span>));
    beanFactory.ignoreDependencyInterface(ServletContextAware.class);
    registerWebApplicationScopes();
}
</code></pre><h4 class="heading">4.1.1 注册WebApplicationContextServletContextAwareProcessor</h4>
<p>它的文档注释原文翻译：</p>
<blockquote>
<p>Variant of ServletContextAwareProcessor for use with a ConfigurableWebApplicationContext. Can be used when registering the processor can occur before the ServletContext or ServletConfig have been initialized.</p>
<p><code>ServletContextAwareProcessor</code> 的扩展，用于 <code>ConfigurableWebApplicationContext</code> 。可以在初始化 ServletContext 或 ServletConfig 之前进行处理器注册时使用。</p>
</blockquote>
<p>似乎看不出什么很明显的思路，但它说是 <code>ServletContextAwareProcessor</code> 的扩展，那追到 <code>ServletContextAwareProcessor</code> 的文档注释：</p>
<blockquote>
<p>BeanPostProcessor implementation that passes the ServletContext to beans that implement the ServletContextAware interface.
Web application contexts will automatically register this with their underlying bean factory. Applications do not use this directly.</p>
<p>将 <code>ServletContext</code> 传递给实现 <code>ServletContextAware</code> 接口的Bean的 <code>BeanPostProcessor</code> 实现。</p>
<p>Web应用程序上下文将自动将其注册到其底层bean工厂，应用程序不直接使用它。</p>
</blockquote>
<p>发现很明白，它是把 <code>ServletContext</code>、<code>ServletConfig</code> 注入到组件中。它的核心源码：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
    <span class="hljs-keyword">if</span> (getServletContext() != <span class="hljs-keyword">null</span> &amp;&amp; bean <span class="hljs-keyword">instanceof</span> ServletContextAware) {
        ((ServletContextAware) bean).setServletContext(getServletContext());
    }
    <span class="hljs-keyword">if</span> (getServletConfig() != <span class="hljs-keyword">null</span> &amp;&amp; bean <span class="hljs-keyword">instanceof</span> ServletConfigAware) {
        ((ServletConfigAware) bean).setServletConfig(getServletConfig());
    }
    <span class="hljs-keyword">return</span> bean;
}
</code></pre><p>跟上一篇中的注册几乎是一个套路，不再赘述。</p>
<h4 class="heading">4.1.2 registerWebApplicationScopes</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerWebApplicationScopes</span><span class="hljs-params">()</span> </span>{
    ExistingWebApplicationScopes existingScopes = <span class="hljs-keyword">new</span> ExistingWebApplicationScopes(getBeanFactory());
    WebApplicationContextUtils.registerWebApplicationScopes(getBeanFactory());
    existingScopes.restore();
}
</code></pre><p>这个方法没有任何注释，只能靠里面的源码来试着推测。</p>
<h5 class="heading">4.1.2.1 ExistingWebApplicationScopes</h5>
<p>从字面意思上看，它是表示在Web应用上已经存在的作用域。它的部分源码：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExistingWebApplicationScopes</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; SCOPES;

    <span class="hljs-keyword">static</span> {
        Set&lt;String&gt; scopes = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
        scopes.add(WebApplicationContext.SCOPE_REQUEST);
        scopes.add(WebApplicationContext.SCOPE_SESSION);
        SCOPES = Collections.unmodifiableSet(scopes);
    }
  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restore</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.scopes.forEach((key, value) -&gt; {
            <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) {
                logger.info(<span class="hljs-string">"Restoring user defined scope "</span> + key);
            }
            <span class="hljs-keyword">this</span>.beanFactory.registerScope(key, value);
        });
    }
</code></pre><p>发现它确实是缓存了两种scope，分别是 request 域和 session 域。</p>
<p>下面的 <code>restore</code> 方法，是把现在缓存的所有作用域，注册到 BeanFactory 中。</p>
<p>大概猜测这是<strong>将Web的request域和session域注册到IOC容器，让IOC容器知道这两种作用域</strong>（学过 SpringFramework 都知道Bean的作用域有request 和 session）。</p>
<h5 class="heading">4.1.2.2 WebApplicationContextUtils.registerWebApplicationScopes</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerWebApplicationScopes</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{
    registerWebApplicationScopes(beanFactory, <span class="hljs-keyword">null</span>);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerWebApplicationScopes</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory,
        @Nullable ServletContext sc)</span> </span>{

    <span class="hljs-comment">// 注册作用域类型</span>
    beanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, <span class="hljs-keyword">new</span> RequestScope());
    beanFactory.registerScope(WebApplicationContext.SCOPE_SESSION, <span class="hljs-keyword">new</span> SessionScope());
    <span class="hljs-keyword">if</span> (sc != <span class="hljs-keyword">null</span>) {
        ServletContextScope appScope = <span class="hljs-keyword">new</span> ServletContextScope(sc);
        beanFactory.registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);
        <span class="hljs-comment">// Register as ServletContext attribute, for ContextCleanupListener to detect it.</span>
        sc.setAttribute(ServletContextScope.class.getName(), appScope);
    }

    <span class="hljs-comment">// 自动注入的支持</span>
    beanFactory.registerResolvableDependency(ServletRequest.class, <span class="hljs-keyword">new</span> RequestObjectFactory());
    beanFactory.registerResolvableDependency(ServletResponse.class, <span class="hljs-keyword">new</span> ResponseObjectFactory());
    beanFactory.registerResolvableDependency(HttpSession.class, <span class="hljs-keyword">new</span> SessionObjectFactory());
    beanFactory.registerResolvableDependency(WebRequest.class, <span class="hljs-keyword">new</span> WebRequestObjectFactory());
    <span class="hljs-keyword">if</span> (jsfPresent) {
        FacesDependencyRegistrar.registerFacesDependencies(beanFactory);
    }
}
</code></pre><p>它的文档注释原文翻译：</p>
<blockquote>
<p>Register web-specific scopes ("request", "session", "globalSession", "application") with the given BeanFactory, as used by the WebApplicationContext.</p>
<p>使用WebApplicationContext使用的给定BeanFactory注册特定于Web的作用域（“request”，“session”，“globalSession”，“application”）。</p>
</blockquote>
<p>注释很清晰，将Web的几种作用域注册到 BeanFactory 中。</p>
<p>源码中注册了 request 、session 、application 域，还注册了几种特定的依赖注入的关系。</p>
<hr>
<p>回到 <code>AnnotationConfigServletWebServerApplicationContext</code> 中：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.basePackages != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.basePackages.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>.scanner.scan(<span class="hljs-keyword">this</span>.basePackages);
    }
</code></pre><p>下一步是进行组件的包扫描。不过注意一点，在这个位置上打断点，Debug运行时发现 basePackages 为null，故此处不进，小伙伴不要觉得之前已经知道了 primarySource 就觉得这个地方 basePackages 就肯定有值了。</p>
<p>咱先了解下这个包扫描，方便后续咱们看到时理解。</p>
<h3 class="heading">4.2 【重要】包扫描</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotatedBeanDefinitionReader reader;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassPathBeanDefinitionScanner scanner;
</code></pre><p>在 <code>AnnotationConfigServletWebServerApplicationContext</code> 中有声明 <code>注解Bean定义解析器</code> 和 <code>类路径Bean定义扫描器</code> 的类型，可以依此类型来查看原理。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// ClassPathBeanDefinitionScanner</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">scan</span><span class="hljs-params">(String... basePackages)</span> </span>{
    <span class="hljs-keyword">int</span> beanCountAtScanStart = <span class="hljs-keyword">this</span>.registry.getBeanDefinitionCount();

    doScan(basePackages);

    <span class="hljs-comment">// Register annotation config processors, if necessary.</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.includeAnnotationConfig) {
        AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="hljs-keyword">this</span>.registry);
    }

    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);
}
</code></pre><p>又出现 <strong>scan</strong> 和 <strong>doScan</strong> 了。doScan 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">doScan</span><span class="hljs-params">(String... basePackages)</span> </span>{
    Assert.notEmpty(basePackages, <span class="hljs-string">"At least one base package must be specified"</span>);
    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
    <span class="hljs-comment">// 只有主启动类所在包</span>
    <span class="hljs-keyword">for</span> (String basePackage : basePackages) {
        <span class="hljs-comment">// 4.2.1 - 4.2.5 扫描包及子包下的组件</span>
        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
        <span class="hljs-comment">// 4.3 ......</span>
    }
    <span class="hljs-keyword">return</span> beanDefinitions;
}
</code></pre><h4 class="heading">4.2.1 findCandidateComponents</h4>
<p>来到父类 <code>ClassPathScanningCandidateComponentProvider</code> 的 <code>findCandidateComponents</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> CandidateComponentsIndex componentsIndex;

<span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;BeanDefinition&gt; <span class="hljs-title">findCandidateComponents</span><span class="hljs-params">(String basePackage)</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.componentsIndex != <span class="hljs-keyword">null</span> &amp;&amp; indexSupportsIncludeFilters()) {
        <span class="hljs-keyword">return</span> addCandidateComponentsFromIndex(<span class="hljs-keyword">this</span>.componentsIndex, basePackage);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> scanCandidateComponents(basePackage);
    }
}
</code></pre><p>很明显，包扫描进入的是下面的 <code>scanCandidateComponents</code> ：</p>
<h4 class="heading">4.2.2 scanCandidateComponents</h4>
<p>这个方法中有大量log，精简篇幅如下：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// ResourcePatternResolver</span>
String CLASSPATH_ALL_URL_PREFIX = <span class="hljs-string">"classpath*:"</span>;

<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_RESOURCE_PATTERN = <span class="hljs-string">"**/*.class"</span>;
<span class="hljs-keyword">private</span> String resourcePattern = DEFAULT_RESOURCE_PATTERN;

<span class="hljs-function"><span class="hljs-keyword">private</span> Set&lt;BeanDefinition&gt; <span class="hljs-title">scanCandidateComponents</span><span class="hljs-params">(String basePackage)</span> </span>{
    Set&lt;BeanDefinition&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 拼接包扫描路径</span>
        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
                resolveBasePackage(basePackage) + <span class="hljs-string">'/'</span> + <span class="hljs-keyword">this</span>.resourcePattern;
        <span class="hljs-comment">// 4.2.3,4 包扫描</span>
        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
        <span class="hljs-keyword">for</span> (Resource resource : resources) {
            <span class="hljs-keyword">if</span> (resource.isReadable()) {
                <span class="hljs-keyword">try</span> {
                    MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
                    <span class="hljs-keyword">if</span> (isCandidateComponent(metadataReader)) {
                        ScannedGenericBeanDefinition sbd = <span class="hljs-keyword">new</span> ScannedGenericBeanDefinition(metadataReader);
                        sbd.setResource(resource);
                        sbd.setSource(resource);
                        <span class="hljs-keyword">if</span> (isCandidateComponent(sbd)) {
                            candidates.add(sbd);
                        }
                <span class="hljs-comment">// log和catch部分省略</span>
    <span class="hljs-keyword">return</span> candidates;
}
</code></pre><p>首先它将要扫描的包和一些前缀进行拼接：前缀是 <code>classpath*:</code> ，后缀默认扫 <code>**/*.class</code> ，中间部分调了一个 <code>resolveBasePackage</code> 方法，这个方法其实不看也能猜出来是把这个<strong>包名转换成文件路径</strong>（不然怎么拼接到扫描路径呢）。看一眼源码：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// ClassPathScanningCandidateComponentProvider</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">resolveBasePackage</span><span class="hljs-params">(String basePackage)</span> </span>{
    <span class="hljs-keyword">return</span> ClassUtils.convertClassNameToResourcePath(getEnvironment().resolveRequiredPlaceholders(basePackage));
}

<span class="hljs-comment">// ClassUtils</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> PACKAGE_SEPARATOR = <span class="hljs-string">'.'</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> PATH_SEPARATOR = <span class="hljs-string">'/'</span>;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">convertClassNameToResourcePath</span><span class="hljs-params">(String className)</span> </span>{
    Assert.notNull(className, <span class="hljs-string">"Class name must not be null"</span>);
    <span class="hljs-keyword">return</span> className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);
}
</code></pre><p>果然是包名转换，把 <code>.</code> 转换成 <code>/</code> 。</p>
<p>由此可算得，入门启动程序中的拼接包路径应该是： <code>classpath*:com/example/demo/**/*.class</code> 。</p>
<p>回到方法中：</p>
<pre><code class="hljs java" lang="java">        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
                resolveBasePackage(basePackage) + <span class="hljs-string">'/'</span> + <span class="hljs-keyword">this</span>.resourcePattern;
        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
</code></pre><p>下面的 <code>getResources</code> 方法最终会拿 <code>ResourcePatternResolver</code> 来获取一组 <code>Resource</code> ，分开来看：</p>
<h4 class="heading">4.2.3 getResourcePatternResolver</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> ResourcePatternResolver <span class="hljs-title">getResourcePatternResolver</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resourcePatternResolver == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">this</span>.resourcePatternResolver = <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resourcePatternResolver;
}
</code></pre><p>可以发现它用的是 <code>PathMatchingResourcePatternResolver</code> 。那下面的 <code>getResources</code> 方法就是它里面的了：</p>
<h4 class="heading">4.2.4 getResources：包扫描</h4>
<pre><code class="hljs java" lang="java">String CLASSPATH_ALL_URL_PREFIX = <span class="hljs-string">"classpath*:"</span>;

<span class="hljs-keyword">public</span> Resource[] getResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException {
    Assert.notNull(locationPattern, <span class="hljs-string">"Location pattern must not be null"</span>);
    <span class="hljs-keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {
        <span class="hljs-comment">// a class path resource (multiple resources for same name possible)</span>
        <span class="hljs-keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
            <span class="hljs-comment">// a class path resource pattern</span>
            <span class="hljs-keyword">return</span> findPathMatchingResources(locationPattern);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// all class path resources with the given name</span>
            <span class="hljs-keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));
        }
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Generally only look for a pattern after a prefix here,</span>
        <span class="hljs-comment">// and on Tomcat only after the "*/" separator for its "war:" protocol.</span>
        <span class="hljs-keyword">int</span> prefixEnd = (locationPattern.startsWith(<span class="hljs-string">"war:"</span>) ? locationPattern.indexOf(<span class="hljs-string">"*/"</span>) + <span class="hljs-number">1</span> :
                locationPattern.indexOf(<span class="hljs-string">':'</span>) + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {
            <span class="hljs-comment">// a file pattern</span>
            <span class="hljs-keyword">return</span> findPathMatchingResources(locationPattern);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// a single resource with the given name</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Resource[] {getResourceLoader().getResource(locationPattern)};
        }
    }
}
</code></pre><p>整个方法的大if结构中，先判断要扫描的包路径是否有 <code>classpath*:</code> ，有则截掉，之后判断路径是否能匹配扫描规则。而这个规则的匹配器，通过IDEA发现 <code>PathMatcher</code> 只有一个实现类： <code>AntPathMatcher</code> ，由此也解释了 <code>SpringFramework</code> 支持的是ant规则声明包。</p>
<p>如果规则匹配，则会进入下面的 <code>findPathMatchingResources</code> 方法：</p>
<h5 class="heading">4.2.4.1 findPathMatchingResources：根据Ant路径进行包扫描</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">// 4.2.4.1.1 截取扫描根路径</span>
    String rootDirPath = determineRootDir(locationPattern);
    <span class="hljs-comment">// 截取剩下扫描路径（**/*.class）</span>
    String subPattern = locationPattern.substring(rootDirPath.length());
    <span class="hljs-comment">// 4.2.4.2,3 获取扫描包路径下的所有包</span>
    Resource[] rootDirResources = getResources(rootDirPath);
    Set&lt;Resource&gt; result = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">16</span>);
    <span class="hljs-keyword">for</span> (Resource rootDirResource : rootDirResources) {
        rootDirResource = resolveRootDirResource(rootDirResource);
        URL rootDirUrl = rootDirResource.getURL();
        <span class="hljs-keyword">if</span> (equinoxResolveMethod != <span class="hljs-keyword">null</span> &amp;&amp; rootDirUrl.getProtocol().startsWith(<span class="hljs-string">"bundle"</span>)) {
            URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, <span class="hljs-keyword">null</span>, rootDirUrl);
            <span class="hljs-keyword">if</span> (resolvedUrl != <span class="hljs-keyword">null</span>) {
                rootDirUrl = resolvedUrl;
            }
            rootDirResource = <span class="hljs-keyword">new</span> UrlResource(rootDirUrl);
        }
        <span class="hljs-keyword">if</span> (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {
            result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) {
            result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));
        }
        <span class="hljs-keyword">else</span> {
            result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));
        }
    }
    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
        logger.trace(<span class="hljs-string">"Resolved location pattern ["</span> + locationPattern + <span class="hljs-string">"] to resources "</span> + result);
    }
    <span class="hljs-keyword">return</span> result.toArray(<span class="hljs-keyword">new</span> Resource[<span class="hljs-number">0</span>]);
}
</code></pre><p>首先它要截取扫描根路径，这个截取是一个简单算法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">determineRootDir</span><span class="hljs-params">(String location)</span> </span>{
    <span class="hljs-keyword">int</span> prefixEnd = location.indexOf(<span class="hljs-string">':'</span>) + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> rootDirEnd = location.length();
    <span class="hljs-keyword">while</span> (rootDirEnd &gt; prefixEnd &amp;&amp; getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) {
        rootDirEnd = location.lastIndexOf(<span class="hljs-string">'/'</span>, rootDirEnd - <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">if</span> (rootDirEnd == <span class="hljs-number">0</span>) {
        rootDirEnd = prefixEnd;
    }
    <span class="hljs-keyword">return</span> location.substring(<span class="hljs-number">0</span>, rootDirEnd);
}
</code></pre><p>通过上面的算法，可以计算得路径是 <code>classpath*:com/example/demo/</code> 。</p>
<hr>
<p>回到上面的方法：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// 4.2.4.1.1 截取扫描根路径</span>
    String rootDirPath = determineRootDir(locationPattern);
    <span class="hljs-comment">// 截取剩下扫描路径（**/*.class）</span>
    String subPattern = locationPattern.substring(rootDirPath.length());
    Resource[] rootDirResources = getResources(rootDirPath);
</code></pre><p>在截取完成后，又把根路径传入了那个 <code>getResources</code> 方法。由于这一次没有后缀了，只有根路径，故进入的分支方法会不一样：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> Resource[] getResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException {
    Assert.notNull(locationPattern, <span class="hljs-string">"Location pattern must not be null"</span>);
    <span class="hljs-keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {
        <span class="hljs-comment">// a class path resource (multiple resources for same name possible)</span>
        <span class="hljs-keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
            <span class="hljs-comment">// a class path resource pattern</span>
            <span class="hljs-keyword">return</span> findPathMatchingResources(locationPattern);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓</span>
            <span class="hljs-comment">// all class path resources with the given name</span>
            <span class="hljs-keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));
        }
    }
    <span class="hljs-comment">// ...</span>
</code></pre><p>这次路径是 <code>classpath*:com/example/demo/</code> ，不能匹配了，进入下面的else部分，<code>findAllClassPathResources</code> 方法：</p>
<h5 class="heading">4.2.4.2 findAllClassPathResources</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">protected</span> Resource[] findAllClassPathResources(String location) <span class="hljs-keyword">throws</span> IOException {
    String path = location;
    <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">"/"</span>)) {
        path = path.substring(<span class="hljs-number">1</span>);
    }
    <span class="hljs-comment">//                     ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓</span>
    Set&lt;Resource&gt; result = doFindAllClassPathResources(path);
    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
        logger.trace(<span class="hljs-string">"Resolved classpath location ["</span> + location + <span class="hljs-string">"] to resources "</span> + result);
    }
    <span class="hljs-keyword">return</span> result.toArray(<span class="hljs-keyword">new</span> Resource[<span class="hljs-number">0</span>]);
}
</code></pre><p>这里进行真正的扫描获取包的工作：<code>doFindAllClassPathResources</code></p>
<h5 class="heading">4.2.4.3 doFindAllClassPathResources</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;Resource&gt; <span class="hljs-title">doFindAllClassPathResources</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    Set&lt;Resource&gt; result = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">16</span>);
    ClassLoader cl = getClassLoader();
    Enumeration&lt;URL&gt; resourceUrls = (cl != <span class="hljs-keyword">null</span> ? cl.getResources(path) : ClassLoader.getSystemResources(path));
    <span class="hljs-keyword">while</span> (resourceUrls.hasMoreElements()) {
        URL url = resourceUrls.nextElement();
        result.add(convertClassLoaderURL(url));
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(path)) {
        <span class="hljs-comment">// The above result is likely to be incomplete, i.e. only containing file system references.</span>
        <span class="hljs-comment">// We need to have pointers to each of the jar files on the classpath as well...</span>
        addAllClassLoaderJarRoots(cl, result);
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre><p>可以发现它在做的工作是<strong>使用类加载器，把传入的根包以Resource的形式加载出来，以便后续的文件读取</strong>。</p>
<hr>
<p>之后方法返回，回到4.2.4.1的方法中：</p>
<h5 class="heading">4.2.4.4 扫描包</h5>
<pre><code class="hljs java" lang="java">    Resource[] rootDirResources = getResources(rootDirPath);
    Set&lt;Resource&gt; result = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">16</span>);
    <span class="hljs-keyword">for</span> (Resource rootDirResource : rootDirResources) {
        rootDirResource = resolveRootDirResource(rootDirResource);
        URL rootDirUrl = rootDirResource.getURL();
        <span class="hljs-keyword">if</span> (equinoxResolveMethod != <span class="hljs-keyword">null</span> &amp;&amp; rootDirUrl.getProtocol().startsWith(<span class="hljs-string">"bundle"</span>)) {
            URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, <span class="hljs-keyword">null</span>, rootDirUrl);
            <span class="hljs-keyword">if</span> (resolvedUrl != <span class="hljs-keyword">null</span>) {
                rootDirUrl = resolvedUrl;
            }
            rootDirResource = <span class="hljs-keyword">new</span> UrlResource(rootDirUrl);
        }
        <span class="hljs-keyword">if</span> (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {
            result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) {
            result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓</span>
            result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));
        }
    }
</code></pre><p>它要拿到所有要扫描的包的文件路径，来进行真正的包扫描工作。</p>
<p>首先 <code>resolveRootDirResource</code> 方法在实现中直接把 <code>rootDirResource</code> 返回了（不知道这什么鬼才操作），之后要判断扫描包路径前缀是否为vfs或jar，都不是则进入最底下的方法（默认情况下我们只配置扫描本项目的组件，则扫描最终的扫描包路径前缀为 <code>file:/</code>）。</p>
<h5 class="heading">4.2.4.5 doFindPathMatchingFileResources</h5>
<p>这个方法默认在 <code>PathMatchingResourcePatternResolver</code> 中有实现，但通过IDEA发现它被 <code>ServletContextResourcePatternResolver</code> 重写了。通过Debug，走到这一步也发现先进的 <code>ServletContextResourcePatternResolver</code> 中的 <code>doFindPathMatchingFileResources</code> 方法。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;Resource&gt; <span class="hljs-title">doFindPathMatchingFileResources</span><span class="hljs-params">(Resource rootDirResource, String subPattern)</span>
        <span class="hljs-keyword">throws</span> IOException </span>{

    <span class="hljs-keyword">if</span> (rootDirResource <span class="hljs-keyword">instanceof</span> ServletContextResource) {
        ServletContextResource scResource = (ServletContextResource) rootDirResource;
        ServletContext sc = scResource.getServletContext();
        String fullPattern = scResource.getPath() + subPattern;
        Set&lt;Resource&gt; result = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">8</span>);
        doRetrieveMatchingServletContextResources(sc, fullPattern, scResource.getPath(), result);
        <span class="hljs-keyword">return</span> result;
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.doFindPathMatchingFileResources(rootDirResource, subPattern);
    }
}
</code></pre><p>然而在默认的项目内部包扫描中，与 <code>ServletContextResource</code> 没有关系，故还是要回到 <code>PathMatchingResourcePatternResolver</code> 中。</p>
<h5 class="heading">4.2.4.6 PathMatchingResourcePatternResolver.doFindPathMatchingFileResources</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;Resource&gt; <span class="hljs-title">doFindPathMatchingFileResources</span><span class="hljs-params">(Resource rootDirResource, String subPattern)</span>
        <span class="hljs-keyword">throws</span> IOException </span>{

    File rootDir;
    <span class="hljs-keyword">try</span> {
        rootDir = rootDirResource.getFile().getAbsoluteFile();
    }
    <span class="hljs-keyword">catch</span> (FileNotFoundException ex) {
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Cannot search for matching files underneath "</span> + rootDirResource +
                    <span class="hljs-string">" in the file system: "</span> + ex.getMessage());
        }
        <span class="hljs-keyword">return</span> Collections.emptySet();
    }
    <span class="hljs-keyword">catch</span> (Exception ex) {
        <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) {
            logger.info(<span class="hljs-string">"Failed to resolve "</span> + rootDirResource + <span class="hljs-string">" in the file system: "</span> + ex);
        }
        <span class="hljs-keyword">return</span> Collections.emptySet();
    }
    <span class="hljs-keyword">return</span> doFindMatchingFileSystemResources(rootDir, subPattern);
}
</code></pre><p>try中先把文件加载出来，之后调了下面的 <code>doFindMatchingFileSystemResources</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;Resource&gt; <span class="hljs-title">doFindMatchingFileSystemResources</span><span class="hljs-params">(File rootDir, String subPattern)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
        logger.trace(<span class="hljs-string">"Looking for matching resources in directory tree ["</span> + rootDir.getPath() + <span class="hljs-string">"]"</span>);
    }
    <span class="hljs-comment">//                        ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓</span>
    Set&lt;File&gt; matchingFiles = retrieveMatchingFiles(rootDir, subPattern);
    Set&lt;Resource&gt; result = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(matchingFiles.size());
    <span class="hljs-keyword">for</span> (File file : matchingFiles) {
        result.add(<span class="hljs-keyword">new</span> FileSystemResource(file));
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre><p>源码中很明显只有一句是核心： <code>retrieveMatchingFiles</code> ：</p>
<h5 class="heading">4.2.4.7 retrieveMatchingFiles</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;File&gt; <span class="hljs-title">retrieveMatchingFiles</span><span class="hljs-params">(File rootDir, String pattern)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-comment">// 不存在的检查</span>
    <span class="hljs-keyword">if</span> (!rootDir.exists()) {
        <span class="hljs-comment">// log</span>
        <span class="hljs-keyword">return</span> Collections.emptySet();
    }
    <span class="hljs-comment">// 非文件夹检查</span>
    <span class="hljs-keyword">if</span> (!rootDir.isDirectory()) {
        <span class="hljs-comment">// log</span>
        <span class="hljs-keyword">return</span> Collections.emptySet();
    }
    <span class="hljs-comment">// 不可读检查</span>
    <span class="hljs-keyword">if</span> (!rootDir.canRead()) {
        <span class="hljs-comment">// log</span>
        <span class="hljs-keyword">return</span> Collections.emptySet();
    }
    String fullPattern = StringUtils.replace(rootDir.getAbsolutePath(), File.separator, <span class="hljs-string">"/"</span>);
    <span class="hljs-keyword">if</span> (!pattern.startsWith(<span class="hljs-string">"/"</span>)) {
        fullPattern += <span class="hljs-string">"/"</span>;
    }
    fullPattern = fullPattern + StringUtils.replace(pattern, File.separator, <span class="hljs-string">"/"</span>);
    Set&lt;File&gt; result = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">8</span>);
    doRetrieveMatchingFiles(fullPattern, rootDir, result);
    <span class="hljs-keyword">return</span> result;
}
</code></pre><p>上面的一些必要的检查之后，它将路径进行整理，最终调用 <code>doRetrieveMatchingFiles</code> 方法：</p>
<h5 class="heading">4.2.4.8 doRetrieveMatchingFiles：递归扫描</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRetrieveMatchingFiles</span><span class="hljs-params">(String fullPattern, File dir, Set&lt;File&gt; result)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
        logger.trace(<span class="hljs-string">"Searching directory ["</span> + dir.getAbsolutePath() +
                <span class="hljs-string">"] for files matching pattern ["</span> + fullPattern + <span class="hljs-string">"]"</span>);
    }
    <span class="hljs-keyword">for</span> (File content : listDirectory(dir)) {
        String currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, <span class="hljs-string">"/"</span>);
        <span class="hljs-keyword">if</span> (content.isDirectory() &amp;&amp; getPathMatcher().matchStart(fullPattern, currPath + <span class="hljs-string">"/"</span>)) {
            <span class="hljs-keyword">if</span> (!content.canRead()) {
                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
                    logger.debug(<span class="hljs-string">"Skipping subdirectory ["</span> + dir.getAbsolutePath() +
                            <span class="hljs-string">"] because the application is not allowed to read the directory"</span>);
                }
            }
            <span class="hljs-keyword">else</span> {
                doRetrieveMatchingFiles(fullPattern, content, result);
            }
        }
        <span class="hljs-keyword">if</span> (getPathMatcher().match(fullPattern, currPath)) {
            result.add(content);
        }
    }
}
</code></pre><p>这个方法是最终进行包扫描的底层，可以发现在16行使用了递归扫描。</p>
<hr>
<p>扫描完成后， <code>getResources</code> 方法算是彻底执行完成，回到4.2.2 scanCandidateComponents 方法中：</p>
<h4 class="heading">4.2.5 解析Component</h4>
<pre><code class="hljs java" lang="java">    Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
    <span class="hljs-keyword">for</span> (Resource resource : resources) {
        <span class="hljs-keyword">if</span> (traceEnabled) {
            logger.trace(<span class="hljs-string">"Scanning "</span> + resource);
        }
        <span class="hljs-keyword">if</span> (resource.isReadable()) {
            <span class="hljs-keyword">try</span> {
                MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
                <span class="hljs-keyword">if</span> (isCandidateComponent(metadataReader)) {
                    ScannedGenericBeanDefinition sbd = <span class="hljs-keyword">new</span> ScannedGenericBeanDefinition(metadataReader);
                    sbd.setResource(resource);
                    sbd.setSource(resource);
                    <span class="hljs-keyword">if</span> (isCandidateComponent(sbd)) {
                        <span class="hljs-keyword">if</span> (debugEnabled) {
                            logger.debug(<span class="hljs-string">"Identified candidate component class: "</span> + resource);
                        }
                        candidates.add(sbd);
                    }
                    <span class="hljs-comment">// else ......</span>
</code></pre><p>下面要遍历每个扫描出来的.class文件（此时还没有进行过滤），来下面的try部分。</p>
<p>它使用了一个 <code>MetadataReader</code> 来解析.class文件，它就可以读取这个class的类定义信息、注解标注信息。之后要用 <code>MetadataReader</code> 来判断这个class是否为一个 <strong>Component</strong>：</p>
<h5 class="heading">4.2.5.1 isCandidateComponent</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCandidateComponent</span><span class="hljs-params">(MetadataReader metadataReader)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-keyword">for</span> (TypeFilter tf : <span class="hljs-keyword">this</span>.excludeFilters) {
        <span class="hljs-keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
    }
    <span class="hljs-keyword">for</span> (TypeFilter tf : <span class="hljs-keyword">this</span>.includeFilters) {
        <span class="hljs-keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) {
            <span class="hljs-keyword">return</span> isConditionMatch(metadataReader);
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
</code></pre><p>它拿了一组 excludeFilters 和 includeFilters，而这两组过滤器通过Debug可以发现：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/16/16dd226f9e11b2f0~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>它会判断class是否被 <code>@Component</code> / <code>@ManagedBean</code> 标注。至此发现了真正扫描 <code>@Component</code> 的原理。</p>
<p>判定为 Component 后，会将这个class封装为 <code>BeanDefinition</code>，最后返回。</p>
<p>这部分的逻辑非常复杂，咱用一个图来理解这部分过程：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/6/16e3fe470fb738c0~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<hr>
<p>返回到4.2中的doScan中：</p>
<h3 class="heading">4.3 扫描完BeanDefinition后</h3>
<pre><code class="hljs java" lang="java">    Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
    <span class="hljs-keyword">for</span> (BeanDefinition candidate : candidates) {
        ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);
        candidate.setScope(scopeMetadata.getScopeName());
        String beanName = <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="hljs-keyword">this</span>.registry);
        <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) {
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
        }
        <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) {
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
        }
        <span class="hljs-keyword">if</span> (checkCandidate(beanName, candidate)) {
            BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(candidate, beanName);
            definitionHolder =
                    AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);
            beanDefinitions.add(definitionHolder);
            registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);
        }
    }
</code></pre><p>它要遍历每个 <code>BeanDefinition</code>，进行一些后置处理。</p>
<h4 class="heading">4.3.1 beanNameGenerator.generateBeanName</h4>
<p>之前我们见过它，它的作用到后面加载它的时候咱再看。</p>
<h4 class="heading">4.3.2 postProcessBeanDefinition</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinition</span><span class="hljs-params">(AbstractBeanDefinition beanDefinition, String beanName)</span> </span>{
    beanDefinition.applyDefaults(<span class="hljs-keyword">this</span>.beanDefinitionDefaults);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.autowireCandidatePatterns != <span class="hljs-keyword">null</span>) {
        beanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(<span class="hljs-keyword">this</span>.autowireCandidatePatterns, beanName));
    }
}
</code></pre><p>发现是设置 <code>BeanDefinition</code> 的一些默认值。</p>
<h4 class="heading">4.3.3 checkCandidate</h4>
<p>字面意思是检查候选者，不是很好理解，来看这个方法的文档注释：</p>
<blockquote>
<p>Check the given candidate's bean name, determining whether the corresponding bean definition needs to be registered or conflicts with an existing definition.</p>
<p>检查给定候选者的Bean名称，以确定是否需要注册相应的Bean定义或与现有定义冲突。</p>
</blockquote>
<p>原来它是检查BeanName是否冲突的。</p>
<h4 class="heading">4.3.4 registerBeanDefinition</h4>
<p>既然上面的检查不冲突，就可以进入到if结构体中，最后就可以注册 <code>BeanDefinition</code> 。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> </span>{
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
}
</code></pre><p>遇见了熟悉的方法，这个方法之前已经看过了，不再详细解析。（第10篇4.9.4.6章节）</p>
<hr>
<p>至此，<code>BeanFactory</code> 的后置处理就结束了，但下面还有一组后置处理器，也是对 <code>BeanFactory</code> 进行处理。</p>
<h2 class="heading">5. invokeBeanFactoryPostProcessors：执行BeanFactory创建后的后置处理器</h2>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{
    <span class="hljs-comment">// 5.1 执行BeanFactory后置处理器</span>
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

    <span class="hljs-comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span>
    <span class="hljs-comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span>
    <span class="hljs-keyword">if</span> (beanFactory.getTempClassLoader() == <span class="hljs-keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(<span class="hljs-keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }
}
</code></pre><p>注意这里又出现了一个新的概念：<strong><code>BeanFactoryPostProcessor</code></strong>。</p>
<h3 class="heading">5.0 【重要】BeanFactoryPostProcessor</h3>
<p>BeanFactoryPostProcessor（<strong>BeanFactory后置处理器</strong>）是一个接口，它只定义了一个方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">/**
 * Modify the application context's internal bean factory after its standard
 * initialization. All bean definitions will have been loaded, but no beans
 * will have been instantiated yet. This allows for overriding or adding
 * properties even to eager-initializing beans.
 * 在应用程序上下文的标准初始化之后修改其内部bean工厂。
 * 所有bean定义都已经加载，但是还没有实例化bean。这允许覆盖或添加属性，甚至可以初始化bean。
 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException</span>;
</code></pre><p>实现了这个接口，<code>BeanFactory</code> 标准初始化完毕后，可以对这个 <code>BeanFactory</code> 进行<strong>后置处理</strong>。</p>
<p>这个时机下，<strong>所有的 <code>BeanDefinition</code> 已经被加载，但没有Bean被实例化</strong>。</p>
<p>另外，<code>BeanFactoryPostProcessor</code> 还有一个子接口：<strong><code>BeanDefinitionRegistryPostProcessor</code></strong>（<strong>Bean定义注册的后置处理器</strong>）</p>
<p>它额外定义了一个方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">/**
 * Modify the application context's internal bean definition registry after its
 * standard initialization. All regular bean definitions will have been loaded,
 * but no beans will have been instantiated yet. This allows for adding further
 * bean definitions before the next post-processing phase kicks in.
 * 在标准初始化之后修改应用程序上下文的内部bean定义注册表。
 * 所有常规bean定义都已加载，但还没有实例化bean。
 * 这允许在下一个后期处理阶段开始之前添加进一步的bean定义。
 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException</span>;
</code></pre><p>它的执行时机是<strong>所有Bean的定义信息即将被加载但未实例化时</strong>，也就是<strong>先于 <code>BeanFactoryPostProcessor</code></strong>。</p>
<p>【<strong>规律</strong>】<code>BeanPostProcessor</code> 是对Bean的后置处理，<code>BeanFactoryPostProcessor</code> 是对 <code>BeanFactory</code> 的后置处理，后续再看到这样的同理。</p>
<hr>
<p>回到源码：</p>
<h3 class="heading">5.1 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors：回调后置处理器</h3>
<p>这段源码非常长（130行+），为了浏览方便，我直接把关键注释写在源码中了。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(
        ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>{

    <span class="hljs-comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span>
    <span class="hljs-comment">// 首先调用BeanDefinitionRegistryPostProcessor</span>
    Set&lt;String&gt; processedBeans = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();

    <span class="hljs-comment">// 这里要判断BeanFactory的类型，默认SpringBoot创建的BeanFactory是DefaultListableBeanFactory</span>
    <span class="hljs-comment">// 这个类实现了BeanDefinitionRegistry接口，则此if结构必进</span>
    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry) {
        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        <span class="hljs-comment">// foreach中为了区分不同的后置处理器，并划分到不同的集合中</span>
        <span class="hljs-comment">// 注意如果是BeanDefinitionRegistryPostProcessor，根据原理描述，还会回调它的后置处理功能</span>
        <span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
            <span class="hljs-keyword">if</span> (postProcessor <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) {
                BeanDefinitionRegistryPostProcessor registryProcessor =
                        (BeanDefinitionRegistryPostProcessor) postProcessor;
                registryProcessor.postProcessBeanDefinitionRegistry(registry);
                registryProcessors.add(registryProcessor);
            }
            <span class="hljs-keyword">else</span> {
                regularPostProcessors.add(postProcessor);
            }
        }

        <span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span>
        <span class="hljs-comment">// uninitialized to let the bean factory post-processors apply to them!</span>
        <span class="hljs-comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span>
        <span class="hljs-comment">// PriorityOrdered, Ordered, and the rest.</span>
        <span class="hljs-comment">// 不要在这里初始化BeanFactory：我们需要保留所有未初始化的常规bean，以便让bean工厂后处理器应用到它们！</span>
        <span class="hljs-comment">// 独立于实现PriorityOrdered、Ordered和其他的BeanDefinitionRegistryPostProcessor之间。</span>
        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-comment">// 这部分实际上想表达的意思是，在创建Bean之前，要先执行这些</span>
        <span class="hljs-comment">// BeanDefinitionRegistryPostProcessor的后置处理方法，并且实现了</span>
        <span class="hljs-comment">// PriorityOrdered排序接口或实现了Ordered接口的Bean需要优先被加载。</span>

        <span class="hljs-comment">// 下面一段是从BeanFactory中取出所有BeanDefinitionRegistryPostProcessor类型的全限定名（String[]）, </span>
        <span class="hljs-comment">// 放到下面遍历，还要判断这些类里是否有实现PriorityOrdered接口的，</span>
        <span class="hljs-comment">// 如果有，存到集合里，之后进行排序、统一回调这些后置处理器</span>

        <span class="hljs-comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span>
        <span class="hljs-comment">// 首先，调用实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessors。</span>
        String[] postProcessorNames =
                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) {
            <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        currentRegistryProcessors.clear();

        <span class="hljs-comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span>
        <span class="hljs-comment">// 接下来，调用实现Ordered接口的BeanDefinitionRegistryPostProcessors。</span>
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) {
            <span class="hljs-keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        currentRegistryProcessors.clear();

        <span class="hljs-comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span>
        <span class="hljs-comment">// 最后，调用所有其他BeanDefinitionRegistryPostProcessor</span>
        <span class="hljs-keyword">boolean</span> reiterate = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">while</span> (reiterate) {
            reiterate = <span class="hljs-keyword">false</span>;
            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
            <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) {
                <span class="hljs-keyword">if</span> (!processedBeans.contains(ppName)) {
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                    reiterate = <span class="hljs-keyword">true</span>;
                }
            }
            sortPostProcessors(currentRegistryProcessors, beanFactory);
            registryProcessors.addAll(currentRegistryProcessors);
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            currentRegistryProcessors.clear();
        }

        <span class="hljs-comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span>
        <span class="hljs-comment">// 回调所有BeanFactoryPostProcessor的postProcessBeanFactory方法</span>
        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
        <span class="hljs-comment">// 先回调BeanDefinitionRegistryPostProcessor的postProcessBeanFactory方法</span>
        <span class="hljs-comment">// 再调用BeanFactoryPostProcessor的postProcessBeanFactory方法</span>
    }

    <span class="hljs-comment">// 如果BeanFactory没有实现BeanDefinitionRegistry接口，则进入下面的代码流程</span>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Invoke factory processors registered with the context instance.</span>
        <span class="hljs-comment">// 调用在上下文实例中注册的工厂处理器。</span>
        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
    }

    <span class="hljs-comment">// 下面的部分是回调BeanFactoryPostProcessor，思路与上面的几乎一样</span>
  
    <span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span>
    <span class="hljs-comment">// uninitialized to let the bean factory post-processors apply to them!</span>
    String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);

    <span class="hljs-comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span>
    <span class="hljs-comment">// Ordered, and the rest.</span>
    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) {
        <span class="hljs-keyword">if</span> (processedBeans.contains(ppName)) {
            <span class="hljs-comment">// skip - already processed in first phase above</span>
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) {
            orderedPostProcessorNames.add(ppName);
        }
        <span class="hljs-keyword">else</span> {
            nonOrderedPostProcessorNames.add(ppName);
        }
    }

    <span class="hljs-comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span>
    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

    <span class="hljs-comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span>
    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (String postProcessorName : orderedPostProcessorNames) {
        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    }
    sortPostProcessors(orderedPostProcessors, beanFactory);
    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

    <span class="hljs-comment">// Finally, invoke all other BeanFactoryPostProcessors.</span>
    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) {
        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    }
    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

    <span class="hljs-comment">// Clear cached merged bean definitions since the post-processors might have</span>
    <span class="hljs-comment">// modified the original metadata, e.g. replacing placeholders in values...</span>
    <span class="hljs-comment">// 清理缓存</span>
    beanFactory.clearMetadataCache();
}
</code></pre><p>这一部分非常重要。可以简单地这样理解：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/5/16e3bcb5b7551946~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>将这段源码分成几部分来看：</p>
<h4 class="heading">5.1.1 参数中的PostProcessor分类</h4>
<pre><code class="hljs java" lang="java">        <span class="hljs-comment">// foreach中为了区分不同的后置处理器，并划分到不同的集合中</span>
        <span class="hljs-comment">// 注意如果是BeanDefinitionRegistryPostProcessor，根据原理描述，还会回调它的后置处理功能</span>
        <span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
            <span class="hljs-keyword">if</span> (postProcessor <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) {
                BeanDefinitionRegistryPostProcessor registryProcessor =
                        (BeanDefinitionRegistryPostProcessor) postProcessor;
                registryProcessor.postProcessBeanDefinitionRegistry(registry);
                registryProcessors.add(registryProcessor);
            }
            <span class="hljs-keyword">else</span> {
                regularPostProcessors.add(postProcessor);
            }
        }
</code></pre><p>遍历一次后，把同时也是 <code>BeanDefinitionRegistryPostProcessor</code> 的后置处理器单独挑出来，直接回调 <code>postProcessBeanDefinitionRegistry</code> 方法。</p>
<p>通过Debug，发现传入这个方法的参数中，<code>beanFactoryPostProcessors</code> 有3个：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/16/16dd2274a22010e8~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>这里面同时属于 <code>BeanDefinitionRegistryPostProcessor</code> 有两个：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/16/16dd2271c1561f8f~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<h4 class="heading">5.1.2 BeanFactory中取+排序+回调</h4>
<pre><code class="hljs java" lang="java">        <span class="hljs-comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span>
        <span class="hljs-comment">// 首先，调用实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessors。</span>
        String[] postProcessorNames =
                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) {
            <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        currentRegistryProcessors.clear();
</code></pre><pre><code class="hljs java" lang="java">        <span class="hljs-comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span>
        <span class="hljs-comment">// 接下来，调用实现Ordered接口的BeanDefinitionRegistryPostProcessors。</span>
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) {
            <span class="hljs-keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        currentRegistryProcessors.clear();
</code></pre><p>它把 <code>BeanFactory</code> 中所有的 <code>BeanDefinitionRegistryPostProcessor</code> 分成三部分：实现 <code>PriorityOrdered</code> 接口的、实现 <code>Ordered</code> 接口的，普通的。</p>
<p>上面的两部分源码就是对前两种方式进行回调：筛选，排序，注册，回调，清除。</p>
<p>之后又用同样的逻辑，取所有的 <code>BeanFactoryPostProcessor</code> ，进行同样的操作，不再重复描述。</p>
<p>逻辑不算复杂，下面介绍几个重要的后置处理器。</p>
<h3 class="heading">5.2 【重要扩展】ConfigurationClassPostProcessor</h3>
<p>在上述源码的Debug中，第二环节获取所有 <code>BeanDefinitionRegistryPostProcessor</code> 的时候发现了一个后置处理器：<code>ConfigurationClassPostProcessor</code> 。</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/16/16dd225f65dbbf40~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>它的文档注释原文翻译：</p>
<blockquote>
<p>BeanFactoryPostProcessor used for bootstrapping processing of @Configuration classes.
Registered by default when using <code>&lt;context:annotation-config/&gt;</code> or <code>&lt;context:component-scan/&gt;</code>. Otherwise, may be declared manually as with any other BeanFactoryPostProcessor.
This post processor is priority-ordered as it is important that any Bean methods declared in @Configuration classes have their corresponding bean definitions registered before any other BeanFactoryPostProcessor executes.</p>
<p><code>BeanFactoryPostProcessor</code>，用于 <code>@Configuration</code> 类的扫描加载处理。
使用<code>&lt;context：annotation-config /&gt;</code> 或 <code>&lt;context：component-scan /&gt;</code> 时默认注册。否则，可以像其他任何 <code>BeanFactoryPostProcessor</code> 一样手动声明。
此后处理器按优先级排序，因为在 <code>@Configuration</code> 标注的类中声明的任何Bean方法在执行任何其他 <code>BeanFactoryPostProcessor</code> 之前都要注册其相应的Bean定义，这一点很重要。</p>
</blockquote>
<p>那自然我们应该去看它的 <code>postProcessBeanDefinitionRegistry</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>{
    <span class="hljs-keyword">int</span> registryId = System.identityHashCode(registry);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.registriesPostProcessed.contains(registryId)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(
                <span class="hljs-string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.factoriesPostProcessed.contains(registryId)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(
                <span class="hljs-string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);
    }
    <span class="hljs-keyword">this</span>.registriesPostProcessed.add(registryId);

    processConfigBeanDefinitions(registry);
}
</code></pre><p>它取出 <code>BeanFactory</code> 的id，并在下面的if结构中判断是否已经被调用过了。确定没有，在被调用过的集合中加上当前 <code>BeanFactory</code> 的id，之后调用 <code>processConfigBeanDefinitions</code> 方法：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigBeanDefinitions</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>{
    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    String[] candidateNames = registry.getBeanDefinitionNames();

    <span class="hljs-comment">// 5.2.1 确定配置类和组件</span>
    <span class="hljs-keyword">for</span> (String beanName : candidateNames) {
        BeanDefinition beanDef = registry.getBeanDefinition(beanName);
        <span class="hljs-keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
                ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
                logger.debug(<span class="hljs-string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-keyword">this</span>.metadataReaderFactory)) {
            configCandidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDef, beanName));
        }
    }

    <span class="hljs-comment">// Return immediately if no @Configuration classes were found</span>
    <span class="hljs-keyword">if</span> (configCandidates.isEmpty()) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Sort by previously determined @Order value, if applicable</span>
    <span class="hljs-comment">// 对配置类进行排序</span>
    configCandidates.sort((bd1, bd2) -&gt; {
        <span class="hljs-keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
        <span class="hljs-keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
        <span class="hljs-keyword">return</span> Integer.compare(i1, i2);
    });

    <span class="hljs-comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span>
    <span class="hljs-comment">// 5.2.2 加载获取BeanNameGenerator</span>
    SingletonBeanRegistry sbr = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">if</span> (registry <span class="hljs-keyword">instanceof</span> SingletonBeanRegistry) {
        sbr = (SingletonBeanRegistry) registry;
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.localBeanNameGeneratorSet) {
            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
            <span class="hljs-keyword">if</span> (generator != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">this</span>.componentScanBeanNameGenerator = generator;
                <span class="hljs-keyword">this</span>.importBeanNameGenerator = generator;
            }
        }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">this</span>.environment = <span class="hljs-keyword">new</span> StandardEnvironment();
    }

    <span class="hljs-comment">// Parse each @Configuration class</span>
    <span class="hljs-comment">// 加载所有配置类</span>
    ConfigurationClassParser parser = <span class="hljs-keyword">new</span> ConfigurationClassParser(
            <span class="hljs-keyword">this</span>.metadataReaderFactory, <span class="hljs-keyword">this</span>.problemReporter, <span class="hljs-keyword">this</span>.environment,
            <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.componentScanBeanNameGenerator, registry);

    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);
    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(configCandidates.size());
    <span class="hljs-keyword">do</span> {
        <span class="hljs-comment">// 5.2.3 解析配置类</span>
        parser.parse(candidates);
        parser.validate();

        Set&lt;ConfigurationClass&gt; configClasses = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
        configClasses.removeAll(alreadyParsed);

        <span class="hljs-comment">// Read the model and create bean definitions based on its content</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reader == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">this</span>.reader = <span class="hljs-keyword">new</span> ConfigurationClassBeanDefinitionReader(
                    registry, <span class="hljs-keyword">this</span>.sourceExtractor, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.environment,
                    <span class="hljs-keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());
        }
        <span class="hljs-comment">// 5.2.4 解析配置类中的内容</span>
        <span class="hljs-keyword">this</span>.reader.loadBeanDefinitions(configClasses);
        alreadyParsed.addAll(configClasses);

        candidates.clear();
        <span class="hljs-comment">// 5.2.5 加载配置类中的被@Bean标注的组件</span>
        <span class="hljs-keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
            String[] newCandidateNames = registry.getBeanDefinitionNames();
            Set&lt;String&gt; oldCandidateNames = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));
            Set&lt;String&gt; alreadyParsedClasses = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
            <span class="hljs-keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) {
                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
            }
            <span class="hljs-keyword">for</span> (String candidateName : newCandidateNames) {
                <span class="hljs-keyword">if</span> (!oldCandidateNames.contains(candidateName)) {
                    BeanDefinition bd = registry.getBeanDefinition(candidateName);
                    <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="hljs-keyword">this</span>.metadataReaderFactory) &amp;&amp;
                            !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                        candidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(bd, candidateName));
                    }
                }
            }
            candidateNames = newCandidateNames;
        }
    }
    <span class="hljs-keyword">while</span> (!candidates.isEmpty());

    <span class="hljs-comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span>
    <span class="hljs-comment">// 将ImportRegistry注册为Bean，以支持ImportAware @Configuration类</span>
    <span class="hljs-keyword">if</span> (sbr != <span class="hljs-keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
    }

    <span class="hljs-comment">// 清除缓存</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.metadataReaderFactory <span class="hljs-keyword">instanceof</span> CachingMetadataReaderFactory) {
        <span class="hljs-comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span>
        <span class="hljs-comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span>
        ((CachingMetadataReaderFactory) <span class="hljs-keyword">this</span>.metadataReaderFactory).clearCache();
    }
}
</code></pre><p>源码中有几部分是比较复杂且重要的环节，咱们一一来看：</p>
<h4 class="heading">5.2.1 确定配置类和组件</h4>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// 5.2.1 确定配置类和组件</span>
    <span class="hljs-keyword">for</span> (String beanName : candidateNames) {
        BeanDefinition beanDef = registry.getBeanDefinition(beanName);
        <span class="hljs-keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
                ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
                logger.debug(<span class="hljs-string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-keyword">this</span>.metadataReaderFactory)) {
            configCandidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDef, beanName));
        }
    }
</code></pre><p>这里面需要关注的几个 <code>ConfigurationClassUtils</code> 方法：</p>
<ul>
<li><code>isFullConfigurationClass</code>：判断一个配置类是否为full类型</li>
<li><code>isLiteConfigurationClass</code>：判断一个配置类是否为lite类型</li>
<li><code>checkConfigurationClassCandidate</code>：检查一个类是否为配置类</li>
</ul>
<p>上面提到了两个类型，都是可以从源码中看到的。那这个full和lite都是什么呢？</p>
<h5 class="heading">5.2.1.1 full与lite</h5>
<p>其实，了解full和lite，只需要到最后一个方法 <code>checkConfigurationClassCandidate</code> 中看一下就知道了：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkConfigurationClassCandidate</span><span class="hljs-params">(
        BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> </span>{

    <span class="hljs-comment">// ......</span>

    <span class="hljs-keyword">if</span> (isFullConfigurationCandidate(metadata)) {
        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLiteConfigurationCandidate(metadata)) {
        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-comment">// It's a full or lite configuration candidate... Let's determine the order value, if any.</span>
    Integer order = getOrder(metadata);
    <span class="hljs-keyword">if</span> (order != <span class="hljs-keyword">null</span>) {
        beanDef.setAttribute(ORDER_ATTRIBUTE, order);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
</code></pre><p>前面大段的代码都是校验和获取注解标注信息（已省略），核心的源码在底下的if-else结构中。它会调 <code>isFullConfigurationCandidate</code> 和 <code>isLiteConfigurationCandidate</code> 来校验Bean的类型，而这两个方法的声明：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFullConfigurationCandidate</span><span class="hljs-params">(AnnotationMetadata metadata)</span> </span>{
    <span class="hljs-keyword">return</span> metadata.isAnnotated(Configuration.class.getName());
}


<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; candidateIndicators = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-number">8</span>);
<span class="hljs-keyword">static</span> {
    candidateIndicators.add(Component.class.getName());
    candidateIndicators.add(ComponentScan.class.getName());
    candidateIndicators.add(Import.class.getName());
    candidateIndicators.add(ImportResource.class.getName());
}
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLiteConfigurationCandidate</span><span class="hljs-params">(AnnotationMetadata metadata)</span> </span>{
    <span class="hljs-comment">// Do not consider an interface or an annotation...</span>
    <span class="hljs-keyword">if</span> (metadata.isInterface()) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-comment">// Any of the typical annotations found?</span>
    <span class="hljs-keyword">for</span> (String indicator : candidateIndicators) {
        <span class="hljs-keyword">if</span> (metadata.isAnnotated(indicator)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
    }

    <span class="hljs-comment">// Finally, let's look for @Bean methods...</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> metadata.hasAnnotatedMethods(Bean.class.getName());
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="hljs-string">"Failed to introspect @Bean methods on class ["</span> + metadata.getClassName() + <span class="hljs-string">"]: "</span> + ex);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
}
</code></pre><p>由这段源码可以得知：</p>
<ul>
<li>full：<code>@Configuration</code> 标注的类</li>
<li>lite：有 <code>@Component</code> 、<code>@ComponentScan</code> 、<code>@Import</code> 、<code>@ImportResource</code> 标注的类，以及 <code>@Configuration</code> 中标注 <code>@Bean</code> 的类。</li>
</ul>
<h4 class="heading">5.2.2 加载获取BeanNameGenerator</h4>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span>
    <span class="hljs-comment">// 5.2.2 加载获取BeanNameGenerator</span>
    SingletonBeanRegistry sbr = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">if</span> (registry <span class="hljs-keyword">instanceof</span> SingletonBeanRegistry) {
        sbr = (SingletonBeanRegistry) registry;
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.localBeanNameGeneratorSet) {
            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
            <span class="hljs-keyword">if</span> (generator != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">this</span>.componentScanBeanNameGenerator = generator;
                <span class="hljs-keyword">this</span>.importBeanNameGenerator = generator;
            }
        }
    }
</code></pre><p>它要在这个地方获取 <code>BeanNameGenerator</code> ，然而通过Debug发现它是null，故先放一边。</p>
<h4 class="heading">5.2.3 解析配置类 与 包扫描的触发时机</h4>
<pre><code class="hljs java" lang="java">    <span class="hljs-keyword">do</span> {
        <span class="hljs-comment">// 5.2.3 解析配置类</span>
        parser.parse(candidates);
        parser.validate();

        <span class="hljs-comment">// ......</span>
</code></pre><p>这一段第一句就是核心：<code>parse</code></p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>{
    <span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : configCandidates) {
        BeanDefinition bd = holder.getBeanDefinition();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) {
                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
            }
            <span class="hljs-keyword">else</span> {
                parse(bd.getBeanClassName(), holder.getBeanName());
            }
        }
        <span class="hljs-comment">// catch ......</span>
    }

    <span class="hljs-keyword">this</span>.deferredImportSelectorHandler.process();
}
</code></pre><p>它要遍历每一个 <code>BeanDefinition</code>，并根据类型来决定如何解析。SpringBoot 通常使用注解配置，这里会进入第一个if结构：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">(AnnotationMetadata metadata, String beanName)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    processConfigurationClass(<span class="hljs-keyword">new</span> ConfigurationClass(metadata, beanName));
}

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
        <span class="hljs-keyword">return</span>;
    }

    ConfigurationClass existingClass = <span class="hljs-keyword">this</span>.configurationClasses.get(configClass);
    <span class="hljs-keyword">if</span> (existingClass != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (configClass.isImported()) {
            <span class="hljs-keyword">if</span> (existingClass.isImported()) {
                existingClass.mergeImportedBy(configClass);
            }
            <span class="hljs-comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span>
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Explicit bean definition found, probably replacing an import.</span>
            <span class="hljs-comment">// Let's remove the old one and go with the new one.</span>
            <span class="hljs-keyword">this</span>.configurationClasses.remove(configClass);
            <span class="hljs-keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);
        }
    }

    <span class="hljs-comment">// Recursively process the configuration class and its superclass hierarchy.</span>
    SourceClass sourceClass = asSourceClass(configClass);
    <span class="hljs-keyword">do</span> {
        sourceClass = doProcessConfigurationClass(configClass, sourceClass);
    }
    <span class="hljs-keyword">while</span> (sourceClass != <span class="hljs-keyword">null</span>);

    <span class="hljs-keyword">this</span>.configurationClasses.put(configClass, configClass);
}
</code></pre><p>上面的方法又调到下面，下面的方法中先进行判断。这里的 <code>existingClass</code> 容易被误解，它在这个方法的最后，把当前传入的组件存到一个Map中，每次组件进到这个方法时先校验是否有这个类型的Bean了，如果有，要进行一些处理。如果没有，往下走，进入到do-while结构中，它要执行 <code>doProcessConfigurationClass</code> 方法。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass)</span>
        <span class="hljs-keyword">throws</span> IOException </span>{

    <span class="hljs-keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) {
        <span class="hljs-comment">// Recursively process any member (nested) classes first</span>
        processMemberClasses(configClass, sourceClass);
    }

    <span class="hljs-comment">// Process any @PropertySource annotations</span>
    <span class="hljs-keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), PropertySources.class,
            org.springframework.context.annotation.PropertySource.class)) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment <span class="hljs-keyword">instanceof</span> ConfigurableEnvironment) {
            processPropertySource(propertySource);
        }
        <span class="hljs-comment">// ......</span>
    }

    <span class="hljs-comment">// Process any @ComponentScan annotations</span>
    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
    <span class="hljs-keyword">if</span> (!componentScans.isEmpty() &amp;&amp;
            !<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
        <span class="hljs-keyword">for</span> (AnnotationAttributes componentScan : componentScans) {
            <span class="hljs-comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span>
            <span class="hljs-comment">// ......</span>
        }
    }

    <span class="hljs-comment">// Process any @Import annotations</span>
    processImports(configClass, sourceClass, getImports(sourceClass), <span class="hljs-keyword">true</span>);

    <span class="hljs-comment">// Process any @ImportResource annotations</span>
    AnnotationAttributes importResource =
            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
    <span class="hljs-keyword">if</span> (importResource != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// ......</span>
    }

    <span class="hljs-comment">// Process individual @Bean methods</span>
    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
    <span class="hljs-keyword">for</span> (MethodMetadata methodMetadata : beanMethods) {
        configClass.addBeanMethod(<span class="hljs-keyword">new</span> BeanMethod(methodMetadata, configClass));
    }

    <span class="hljs-comment">// Process default methods on interfaces</span>
    processInterfaces(configClass, sourceClass);

    <span class="hljs-comment">// Process superclass, if any</span>
    <span class="hljs-keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) {
        String superclass = sourceClass.getMetadata().getSuperClassName();
        <span class="hljs-keyword">if</span> (superclass != <span class="hljs-keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="hljs-string">"java"</span>) &amp;&amp;
                !<span class="hljs-keyword">this</span>.knownSuperclasses.containsKey(superclass)) {
            <span class="hljs-keyword">this</span>.knownSuperclasses.put(superclass, configClass);
            <span class="hljs-comment">// Superclass found, return its annotation metadata and recurse</span>
            <span class="hljs-keyword">return</span> sourceClass.getSuperClass();
        }
    }

    <span class="hljs-comment">// No superclass -&gt; processing is complete</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>从源码注释中已经看出，它来解析 <code>@PropertySource</code> 、<code>@ComponentScan</code> 、<code>@Import</code> 、<code>@ImportResource</code> 、<code>@Bean</code> 等注解，并整理成一个 <code>ConfigClass</code> 。</p>
<p>由此可知，在这一步，一个配置类的所有信息就已经被解析完成了。</p>
<p>咱们以解析 <code>@ComponentScan</code> 为例：</p>
<h5 class="heading">5.2.3.1 解析 @ComponentScan</h5>
<pre><code class="hljs java" lang="java">    <span class="hljs-comment">// Process any @ComponentScan annotations</span>
    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
    <span class="hljs-keyword">if</span> (!componentScans.isEmpty() &amp;&amp;
            !<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
        <span class="hljs-keyword">for</span> (AnnotationAttributes componentScan : componentScans) {
            <span class="hljs-comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span>
            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
                    <span class="hljs-keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            <span class="hljs-comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span>
            <span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                <span class="hljs-keyword">if</span> (bdCand == <span class="hljs-keyword">null</span>) {
                    bdCand = holder.getBeanDefinition();
                }
                <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="hljs-keyword">this</span>.metadataReaderFactory)) {
                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }
</code></pre><p>这部分解析要追踪到 <code>componentScanParser</code> 的parse方法中，它用来真正的做注解解析：</p>
<h5 class="heading">5.2.3.2 ComponentScanAnnotationParser.parse</h5>
<p>（这里只记录重要的部分，中间省略的部分小伙伴们可借助IDE查看）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">parse</span><span class="hljs-params">(AnnotationAttributes componentScan, <span class="hljs-keyword">final</span> String declaringClass)</span> </span>{
    ClassPathBeanDefinitionScanner scanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(<span class="hljs-keyword">this</span>.registry,
            componentScan.getBoolean(<span class="hljs-string">"useDefaultFilters"</span>), <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader);

    <span class="hljs-comment">// ......</span>
    <span class="hljs-keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));
}
</code></pre><p>先看一眼最后的return：<code>doScan</code> 方法！原来包扫描的触发时机在这里：<strong>执行 <code>ConfigurationClassPostProcessor</code> 的 <code>postProcessBeanDefinitionRegistry</code> 方法，解析 <code>@ComponentScan</code> 时触发</strong>。</p>
<p>除了最后的 <code>doScan</code>，这里面有一个关注的点：</p>
<h5 class="heading">5.2.3.3 new ClassPathBeanDefinitionScanner</h5>
<p>这个构造方法中有点细节：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> BeanNameGenerator beanNameGenerator = <span class="hljs-keyword">new</span> AnnotationBeanNameGenerator();
<span class="hljs-keyword">private</span> ScopeMetadataResolver scopeMetadataResolver = <span class="hljs-keyword">new</span> AnnotationScopeMetadataResolver();

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathBeanDefinitionScanner</span><span class="hljs-params">(BeanDefinitionRegistry registry, <span class="hljs-keyword">boolean</span> useDefaultFilters,
        Environment environment, @Nullable ResourceLoader resourceLoader)</span> </span>{

    Assert.notNull(registry, <span class="hljs-string">"BeanDefinitionRegistry must not be null"</span>);
    <span class="hljs-keyword">this</span>.registry = registry;

    <span class="hljs-keyword">if</span> (useDefaultFilters) {
        registerDefaultFilters();
    }
    setEnvironment(environment);
    setResourceLoader(resourceLoader);
}
</code></pre><p>终于找到这个 <code>BeanNameGenerator</code> 的类型了：<code>AnnotationBeanNameGenerator</code> 。</p>
<h5 class="heading">5.2.3.4 【扩展】AnnotationBeanNameGenerator 的Bean名称生成规则</h5>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationBeanNameGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanNameGenerator</span> </span>{

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String COMPONENT_ANNOTATION_CLASSNAME = <span class="hljs-string">"org.springframework.stereotype.Component"</span>;


	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>{
		<span class="hljs-keyword">if</span> (definition <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) {
			String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);
			<span class="hljs-keyword">if</span> (StringUtils.hasText(beanName)) {
				<span class="hljs-comment">// Explicit bean name found.</span>
				<span class="hljs-keyword">return</span> beanName;
			}
		}
		<span class="hljs-comment">// Fallback: generate a unique default bean name.</span>
		<span class="hljs-keyword">return</span> buildDefaultBeanName(definition, registry);
	}

	<span class="hljs-meta">@Nullable</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">determineBeanNameFromAnnotation</span><span class="hljs-params">(AnnotatedBeanDefinition annotatedDef)</span> </span>{
		AnnotationMetadata amd = annotatedDef.getMetadata();
		Set&lt;String&gt; types = amd.getAnnotationTypes();
		String beanName = <span class="hljs-keyword">null</span>;
		<span class="hljs-keyword">for</span> (String type : types) {
			AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);
			<span class="hljs-keyword">if</span> (attributes != <span class="hljs-keyword">null</span> &amp;&amp; isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) {
				Object value = attributes.get(<span class="hljs-string">"value"</span>);
				<span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) {
					String strVal = (String) value;
					<span class="hljs-keyword">if</span> (StringUtils.hasLength(strVal)) {
						<span class="hljs-keyword">if</span> (beanName != <span class="hljs-keyword">null</span> &amp;&amp; !strVal.equals(beanName)) {
							<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Stereotype annotations suggest inconsistent "</span> +
									<span class="hljs-string">"component names: '"</span> + beanName + <span class="hljs-string">"' versus '"</span> + strVal + <span class="hljs-string">"'"</span>);
						}
						beanName = strVal;
					}
				}
			}
		}
		<span class="hljs-keyword">return</span> beanName;
	}

	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStereotypeWithNameValue</span><span class="hljs-params">(String annotationType,
			Set&lt;String&gt; metaAnnotationTypes, @Nullable Map&lt;String, Object&gt; attributes)</span> </span>{

		<span class="hljs-keyword">boolean</span> isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||
				metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME) ||
				annotationType.equals(<span class="hljs-string">"javax.annotation.ManagedBean"</span>) ||
				annotationType.equals(<span class="hljs-string">"javax.inject.Named"</span>);

		<span class="hljs-keyword">return</span> (isStereotype &amp;&amp; attributes != <span class="hljs-keyword">null</span> &amp;&amp; attributes.containsKey(<span class="hljs-string">"value"</span>));
	}

	<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>{
		<span class="hljs-keyword">return</span> buildDefaultBeanName(definition);
	}

	<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition)</span> </span>{
		String beanClassName = definition.getBeanClassName();
		Assert.state(beanClassName != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No bean class name set"</span>);
		String shortClassName = ClassUtils.getShortName(beanClassName);
		<span class="hljs-keyword">return</span> Introspector.decapitalize(shortClassName);
	}

}

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decapitalize</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span> || name.length() == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> name;
        }
        <span class="hljs-keyword">if</span> (name.length() &gt; <span class="hljs-number">1</span> &amp;&amp; Character.isUpperCase(name.charAt(<span class="hljs-number">1</span>)) &amp;&amp;
                        Character.isUpperCase(name.charAt(<span class="hljs-number">0</span>))){
            <span class="hljs-keyword">return</span> name;
        }
        <span class="hljs-keyword">char</span> chars[] = name.toCharArray();
        chars[<span class="hljs-number">0</span>] = Character.toLowerCase(chars[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(chars);
    }
</code></pre><p>从重写的方法开始：</p>
<p>先执行下面的 <code>determineBeanNameFromAnnotation</code> 方法，看这些模式注解上是否有显式的声明 value 属性，如果没有，则进入下面的 <code>buildDefaultBeanName</code> 方法，它会取类名的全称，之后调 <code>Introspector.decapitalize</code> 方法将首字母转为小写。</p>
<h4 class="heading">5.2.4 loadBeanDefinitions：解析配置类中的内容</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>{
    TrackedConditionEvaluator trackedConditionEvaluator = <span class="hljs-keyword">new</span> TrackedConditionEvaluator();
    <span class="hljs-keyword">for</span> (ConfigurationClass configClass : configurationModel) {
        loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
    }
}
</code></pre><p>这里它会循环所有的配置类，去加载配置类里面的Bean定义信息。继续往下看：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForConfigurationClass</span><span class="hljs-params">(
        ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>{

    <span class="hljs-keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) {
        String beanName = configClass.getBeanName();
        <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.registry.containsBeanDefinition(beanName)) {
            <span class="hljs-keyword">this</span>.registry.removeBeanDefinition(beanName);
        }
        <span class="hljs-keyword">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (configClass.isImported()) {
        registerBeanDefinitionForImportedConfigurationClass(configClass);
    }
    <span class="hljs-keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) {
        loadBeanDefinitionsForBeanMethod(beanMethod);
    }

    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
</code></pre><p>由于在之前已经解析过这个 <code>configClass</code> 了，所以在这里可以很容易的解析出这里面的 <code>@Import</code> 、标注了 <code>@Bean</code> 的方法、<code>@ImportResource</code> 等，并进行相应处理。</p>
<p>咱们以 读取 <code>@Bean</code> 注解标注的方法为例，看一眼它对Bean的解析和加载：（方法很长，关键注释已标注在源码中）</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForBeanMethod</span><span class="hljs-params">(BeanMethod beanMethod)</span> </span>{
    ConfigurationClass configClass = beanMethod.getConfigurationClass();
    MethodMetadata metadata = beanMethod.getMetadata();
    String methodName = metadata.getMethodName();

    <span class="hljs-comment">// Do we need to mark the bean as skipped by its condition?</span>
    <span class="hljs-comment">// 判断该Bean是否要被跳过</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {
        configClass.skippedBeanMethods.add(methodName);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (configClass.skippedBeanMethods.contains(methodName)) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 校验是否标注了@Bean注解</span>
    AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);
    Assert.state(bean != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No @Bean annotation attributes"</span>);

    <span class="hljs-comment">// Consider name and any aliases</span>
    <span class="hljs-comment">// Bean的名称处理规则：如果Bean中标注了name，取第一个；没有标注，取方法名</span>
    List&lt;String&gt; names = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(bean.getStringArray(<span class="hljs-string">"name"</span>)));
    String beanName = (!names.isEmpty() ? names.remove(<span class="hljs-number">0</span>) : methodName);

    <span class="hljs-comment">// Register aliases even when overridden</span>
    <span class="hljs-comment">// 其余声明的name被视为Bean的别名</span>
    <span class="hljs-keyword">for</span> (String alias : names) {
        <span class="hljs-keyword">this</span>.registry.registerAlias(beanName, alias);
    }

    <span class="hljs-comment">// Has this effectively been overridden before (e.g. via XML)?</span>
    <span class="hljs-comment">// 注解Bean如果覆盖了xml配置的Bean，要看BeanName是否相同，相同则抛出异常</span>
    <span class="hljs-keyword">if</span> (isOverriddenByExistingDefinition(beanMethod, beanName)) {
        <span class="hljs-keyword">if</span> (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),
                    beanName, <span class="hljs-string">"Bean name derived from @Bean method '"</span> + beanMethod.getMetadata().getMethodName() +
                    <span class="hljs-string">"' clashes with bean name for containing configuration class; please make those names unique!"</span>);
        }
        <span class="hljs-keyword">return</span>;
    }

    ConfigurationClassBeanDefinition beanDef = <span class="hljs-keyword">new</span> ConfigurationClassBeanDefinition(configClass, metadata);
    beanDef.setResource(configClass.getResource());
    beanDef.setSource(<span class="hljs-keyword">this</span>.sourceExtractor.extractSource(metadata, configClass.getResource()));

    <span class="hljs-comment">// 被@Bean标注的方法是否为一个静态方法</span>
    <span class="hljs-keyword">if</span> (metadata.isStatic()) {
        <span class="hljs-comment">// static @Bean method</span>
        beanDef.setBeanClassName(configClass.getMetadata().getClassName());
        beanDef.setFactoryMethodName(methodName);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// instance @Bean method</span>
        <span class="hljs-comment">// 实例Bean，设置它的工厂方法为该方法名。这个工厂方法在后续创建Bean时会利用到</span>
        beanDef.setFactoryBeanName(configClass.getBeanName());
        beanDef.setUniqueFactoryMethodName(methodName);
    }
    beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);
    beanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.
            SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);

    AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);

    Autowire autowire = bean.getEnum(<span class="hljs-string">"autowire"</span>);
    <span class="hljs-keyword">if</span> (autowire.isAutowire()) {
        beanDef.setAutowireMode(autowire.value());
    }

    <span class="hljs-comment">// 是否需要自动注入</span>
    <span class="hljs-keyword">boolean</span> autowireCandidate = bean.getBoolean(<span class="hljs-string">"autowireCandidate"</span>);
    <span class="hljs-keyword">if</span> (!autowireCandidate) {
        beanDef.setAutowireCandidate(<span class="hljs-keyword">false</span>);
    }

    <span class="hljs-comment">// 初始化方法</span>
    String initMethodName = bean.getString(<span class="hljs-string">"initMethod"</span>);
    <span class="hljs-keyword">if</span> (StringUtils.hasText(initMethodName)) {
        beanDef.setInitMethodName(initMethodName);
    }

    <span class="hljs-comment">// 销毁方法</span>
    String destroyMethodName = bean.getString(<span class="hljs-string">"destroyMethod"</span>);
    beanDef.setDestroyMethodName(destroyMethodName);

    <span class="hljs-comment">// Consider scoping</span>
    ScopedProxyMode proxyMode = ScopedProxyMode.NO;
    AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);
    <span class="hljs-keyword">if</span> (attributes != <span class="hljs-keyword">null</span>) {
        beanDef.setScope(attributes.getString(<span class="hljs-string">"value"</span>));
        proxyMode = attributes.getEnum(<span class="hljs-string">"proxyMode"</span>);
        <span class="hljs-keyword">if</span> (proxyMode == ScopedProxyMode.DEFAULT) {
            proxyMode = ScopedProxyMode.NO;
        }
    }

    <span class="hljs-comment">// Replace the original bean definition with the target one, if necessary</span>
    <span class="hljs-comment">// 如果有必要，将原始bean定义替换为目标bean定义</span>
    BeanDefinition beanDefToRegister = beanDef;
    <span class="hljs-keyword">if</span> (proxyMode != ScopedProxyMode.NO) {
        BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(
                <span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDef, beanName), <span class="hljs-keyword">this</span>.registry,
                proxyMode == ScopedProxyMode.TARGET_CLASS);
        beanDefToRegister = <span class="hljs-keyword">new</span> ConfigurationClassBeanDefinition(
                (RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);
    }

    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {
        logger.trace(String.format(<span class="hljs-string">"Registering bean definition for @Bean method %s.%s()"</span>,
                configClass.getMetadata().getClassName(), beanName));
    }
    <span class="hljs-comment">// 注册Bean定义信息</span>
    <span class="hljs-keyword">this</span>.registry.registerBeanDefinition(beanName, beanDefToRegister);
}
</code></pre><h4 class="heading">5.2.5 加载配置类中的未加载完成的被@Bean标注的组件</h4>
<pre><code class="hljs java" lang="java">        <span class="hljs-comment">// 5.2.4 加载配置类中的被@Bean标注的组件</span>
        <span class="hljs-keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
            String[] newCandidateNames = registry.getBeanDefinitionNames();
            Set&lt;String&gt; oldCandidateNames = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));
            Set&lt;String&gt; alreadyParsedClasses = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
            <span class="hljs-keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) {
                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
            }
            <span class="hljs-keyword">for</span> (String candidateName : newCandidateNames) {
                <span class="hljs-keyword">if</span> (!oldCandidateNames.contains(candidateName)) {
                    BeanDefinition bd = registry.getBeanDefinition(candidateName);
                    <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="hljs-keyword">this</span>.metadataReaderFactory) &amp;&amp;
                            !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                        candidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(bd, candidateName));
                    }
                }
            }
            candidateNames = newCandidateNames;
        }
</code></pre><p>这部分的判断比较有趣：在上面的配置类都加载完成后，它要比对 <code>BeanDefinition</code> 的个数，以及被处理过的数量。只要数量不对应，就会展开那些配置类继续加载。这部分的源码与上面比较类似，只是检测逻辑的不同，小册不再详细展开，有兴趣的小伙伴可以自行Debug看一下效果。</p>
<p>（这部分想演示出这个情况，小册提供一个思路：声明一个配置类，再在配置类中使用 <code>@Bean</code> 注册一个组件，这样进到这个方法中就会引发两个数量不对应进入if结构体了）</p>
<h2 class="heading">小结</h2>
<ol>
<li><code>BeanFactoryPostProcessor</code> 的执行时机是所有的 <code>BeanDefinition</code> 已经被加载，但没有Bean被实例化。</li>
<li>包扫描会加载所有 <code>BeanDefinition</code>，底层采用递归扫描。</li>
<li>IOC容器使用 <code>ConfigurationClassPostProcessor</code> 进行注解组件解析。</li>
</ol>
<p>【至此，BeanFactory的工作基本全部完成，下一篇要介绍其他组价的注册】</p>
</div>
</body></html>