<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>IOC：SpringBoot准备IOC容器</h1>
<h1 class="heading">8. IOC：SpringBoot准备IOC容器</h1>
<p>了解背景后，下面咱一步一步来研究，SpringBoot 如何启动IOC容器。</p>
<p>先对本篇内容有个整体了解：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/5/16e3b74d21e41c28~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<h2 class="heading">1. main方法进入</h2>
<p>从最简单的入门程序开始：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplication</span> </span>{
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        SpringApplication.run(DemoApplication.class, args);
    }
    
}
</code></pre><h2 class="heading">2. 进入SpringApplication.run方法</h2>
<p>进入run方法，可以发现执行的 SpringBoot 应用启动操作分为两步：</p>
<pre><code class="hljs java" lang="java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> </span>{
        <span class="hljs-comment">// 调下面重载的方法</span>
        <span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] { primarySource }, args);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplication(primarySources).run(args);
    }
</code></pre><p>run方法返回的是 <code>ApplicationContext</code> 的子接口：<code>ConfigurableApplicationContext</code> ，之前我们已经了解过了，不再赘述。</p>
<p>底下的run方法分为两步，分开来看：</p>
<h2 class="heading">3. new SpringApplication(primarySources)：创建SpringApplication</h2>
<p>最终调用的构造方法是下面的两参数方法。</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> Set&lt;Class&lt;?&gt;&gt; primarySources;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(Class&lt;?&gt;... primarySources)</span> </span>{
    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, primarySources);
}

<span class="hljs-meta">@SuppressWarnings</span>({ <span class="hljs-string">"unchecked"</span>, <span class="hljs-string">"rawtypes"</span> })
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>{
    <span class="hljs-comment">// resourceLoader为null</span>
    <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, <span class="hljs-string">"PrimarySources must not be null"</span>);
    <span class="hljs-comment">// 将传入的DemoApplication启动类放入primarySources中，这样应用就知道主启动类在哪里，叫什么了</span>
    <span class="hljs-comment">// SpringBoot一般称呼这种主启动类叫primarySource（主配置资源来源）</span>
    <span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
    <span class="hljs-comment">// 3.1 判断当前应用环境</span>
    <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();
    <span class="hljs-comment">// 3.2 设置初始化器</span>
    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
    <span class="hljs-comment">// 3.3 设置监听器</span>
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    <span class="hljs-comment">// 3.4 确定主配置类</span>
    <span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();
}
</code></pre><p>暂且不看这个方法的具体实现，先看一眼构造方法的文档注释：</p>
<blockquote>
<p>Create a new <code>SpringApplication</code> instance. The application context will load beans from the specified primary sources (see class-level documentation for details. The instance can be customized before calling <code>run(String...)</code>.</p>
<p>创建一个新的 <code>SpringApplication</code> 实例。应用程序上下文将从指定的主要源加载Bean（有关详细信息，请参见类级别的文档）。可以在调用run(String...)之前自定义实例。</p>
</blockquote>
<p>文档中描述可以在run方法之前自定义实例，换句话说，可以手动配置一些 SpringApplication 的属性。</p>
<p>【如果小伙伴没有见过自定义配置 <code>SpringApplication</code>，请继续往下看；了解的小伙伴请跳过3.0节】</p>
<h3 class="heading">3.0 自定义SpringApplication</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplication</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        SpringApplication springApplication = <span class="hljs-keyword">new</span> SpringApplication(DemoApplication.class);
        springApplication.setWebApplicationType(WebApplicationType.SERVLET); <span class="hljs-comment">//强制使用WebMvc环境</span>
        springApplication.setBannerMode(Banner.Mode.OFF); <span class="hljs-comment">//不打印Banner</span>
        springApplication.run(args);
    }

}
</code></pre><hr>
<p>下面对 SpringApplication 的构造方法实现中每一步作详细解析：</p>
<h3 class="heading">3.1 WebApplicationType.deduceFromClasspath：判断当前应用环境</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] SERVLET_INDICATOR_CLASSES = { <span class="hljs-string">"javax.servlet.Servlet"</span>,
        <span class="hljs-string">"org.springframework.web.context.ConfigurableWebApplicationContext"</span> };
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String WEBMVC_INDICATOR_CLASS = <span class="hljs-string">"org.springframework."</span> + <span class="hljs-string">"web.servlet.DispatcherServlet"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String WEBFLUX_INDICATOR_CLASS = <span class="hljs-string">"org."</span> + <span class="hljs-string">"springframework.web.reactive.DispatcherHandler"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JERSEY_INDICATOR_CLASS = <span class="hljs-string">"org.glassfish.jersey.servlet.ServletContainer"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVLET_APPLICATION_CONTEXT_CLASS = <span class="hljs-string">"org.springframework.web.context.WebApplicationContext"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REACTIVE_APPLICATION_CONTEXT_CLASS = <span class="hljs-string">"org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext"</span>;

<span class="hljs-function"><span class="hljs-keyword">static</span> WebApplicationType <span class="hljs-title">deduceFromClasspath</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="hljs-keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)
            &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)) {
        <span class="hljs-keyword">return</span> WebApplicationType.REACTIVE;
    }
    <span class="hljs-keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) {
        <span class="hljs-keyword">if</span> (!ClassUtils.isPresent(className, <span class="hljs-keyword">null</span>)) {
            <span class="hljs-keyword">return</span> WebApplicationType.NONE;
        }
    }
    <span class="hljs-keyword">return</span> WebApplicationType.SERVLET;
}
</code></pre><p>这个方法没有文档注释，但方法名和返回值类型已经可以描述方法用途：<strong>从classpath下判断当前SpringBoot应用应该使用哪种环境启动</strong>。</p>
<p>上面的代码块中我把一些这个类中定义的常量也贴了进来，方便小伙伴们阅读。它们是描述了一些 <code>Servlet</code> 的全限定名、<code>DispatcherServlet</code> 的全限定名等等，它们的用途是<strong>配合下面的方法判断应用的classpath里是否有这些类</strong>。</p>
<p>下面的方法实现中：</p>
<ul>
<li>第一个if结构先判断是否是 <strong>Reactive</strong> 环境，发现有 WebFlux 的类但没有 WebMvc 的类，则判定为 Reactive 环境（全NIO）</li>
<li>之后的for循环要检查是否有跟 Servlet 相关的类，如果有任何一个类没有，则判定为非Web环境</li>
<li>如果for循环走完了，证明所有类均在当前 classpath 下，则为 Servlet（WebMvc） 环境</li>
</ul>
<h3 class="heading">3.2 setInitializers：设置初始化器</h3>
<p>setInitializers方法会将一组类型为 <code>ApplicationContextInitializer</code> 的初始化器放入 <code>SpringApplication</code> 中。</p>
<p>而这组 <strong><code>ApplicationContextInitializer</code></strong>，是在构造方法中，通过 <code>getSpringFactoriesInstances</code> 得到的。</p>
<p>在阅读这部分源码之前，先来了解一下 <code>ApplicationContextInitializer</code> 是什么。</p>
<h4 class="heading">3.2.0 【重要】ApplicationContextInitializer</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationContextInitializer</span>&lt;<span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConfigurableApplicationContext</span>&gt;
</span></code></pre><p>文档注释原文翻译：</p>
<blockquote>
<p>Callback interface for initializing a Spring ConfigurableApplicationContext prior to being refreshed.
Typically used within web applications that require some programmatic initialization of the application context. For example, registering property sources or activating profiles against the context's environment. See ContextLoader and FrameworkServlet support for declaring a "contextInitializerClasses" context-param and init-param, respectively.
ApplicationContextInitializer processors are encouraged to detect whether Spring's Ordered interface has been implemented or if the @Order annotation is present and to sort instances accordingly if so prior to invocation.</p>
<p>用于在刷新容器之前初始化Spring <code>ConfigurableApplicationContext</code> 的回调接口。</p>
<p>通常在需要对应用程序上下文进行某些编程初始化的Web应用程序中使用。例如，根据上下文环境注册属性源或激活配置文件。请参阅 <code>ContextLoader</code> 和<code>FrameworkServlet</code> 支持，分别声明 <code>"contextInitializerClasses"</code> 的 context-param 和 init-param。</p>
<p>鼓励 <code>ApplicationContextInitializer</code> 处理器检测是否已实现Spring的 <code>Ordered</code> 接口，或者是否标注了 <code>@Order</code> 注解，并在调用之前相应地对实例进行排序。</p>
</blockquote>
<p>第一句注释已经解释的很明白了，它是在IOC容器之前的回调。它的使用方式有三种：</p>
<h5 class="heading">3.2.0.1 运行SpringApplication之前手动添加</h5>
<p>先编写一个Demo：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextInitializerDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextInitializer</span> </span>{
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> </span>{
        System.out.println(<span class="hljs-string">"ApplicationContextInitializerDemo#initialize run..."</span>);
    }
    
}
</code></pre><p>之后在主启动类上手动添加：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplication</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-comment">// SpringApplication.run(DemoApplication.class, args);</span>
        SpringApplication springApplication = <span class="hljs-keyword">new</span> SpringApplication(DemoApplication.class);
        springApplication.addInitializers(<span class="hljs-keyword">new</span> ApplicationContextInitializerDemo());
        springApplication.run(args);
    }

}
</code></pre><p>运行主启动类，控制台打印（看Banner下面的第一行）：</p>
<pre><code class="hljs bash" lang="bash">  .   ____          _            __ _ _
 /\\ / ___<span class="hljs-string">'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '</span>_ | <span class="hljs-string">'_| | '</span>_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  <span class="hljs-string">'  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.1.9.RELEASE)

ApplicationContextInitializerDemo#initialize run...
1970-01-01 00:00:00.000  INFO 7876 --- [  restartedMain] com.example.demo.DemoApplication         : Starting DemoApplication on DESKTOP with PID 7876 (D:\IDEA\spring-boot-demo\target\classes started by LinkedBear in D:\IDEA\spring-boot-demo)
................
</span></code></pre><h5 class="heading">3.2.0.2 application.properties中配置</h5>
<p>在 <code>application.properties</code> 中配置如下内容：</p>
<pre><code class="hljs properties" lang="properties">context.initializer.classes=com.example.demo.ApplicationContextInitializerDemo
</code></pre><h5 class="heading">3.2.0.3 spring.factories中配置</h5>
<p>在工程的 resources 目录下新建 <strong>“META-INF”</strong> 目录，并在下面创建一个 <code>spring.factories</code> 文件。在文件内声明：</p>
<pre><code class="hljs properties" lang="properties">org.springframework.context.ApplicationContextInitializer=com.example.demo.ApplicationContextInitializerDemo
</code></pre><p>三种方式效果都是一样的。</p>
<hr>
<p>回到上面的方法中：</p>
<pre><code class="hljs java" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInitializers</span><span class="hljs-params">(Collection&lt;? extends ApplicationContextInitializer&lt;?&gt;&gt; initializers)</span> </span>{
    <span class="hljs-keyword">this</span>.initializers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">this</span>.initializers.addAll(initializers);
}

<span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>{
    <span class="hljs-keyword">return</span> getSpringFactoriesInstances(type, <span class="hljs-keyword">new</span> Class&lt;?&gt;[] {});
}

<span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>{
    ClassLoader classLoader = getClassLoader();
    <span class="hljs-comment">// Use names and ensure unique to protect against duplicates （使用名称并确保唯一，以防止重复）</span>
    <span class="hljs-comment">// 3.2.1 SpringFactoriesLoader.loadFactoryNames：加载指定类型的所有已配置组件的全限定类名</span>
    Set&lt;String&gt; names = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
    <span class="hljs-comment">// 3.2.2 createSpringFactoriesInstances：创建这些组件的实例</span>
    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
    AnnotationAwareOrderComparator.sort(instances);
    <span class="hljs-keyword">return</span> instances;
}
</code></pre><p>方法中有两步是比较重要的，下面分别来看：</p>
<h4 class="heading">3.2.1 SpringFactoriesLoader.loadFactoryNames</h4>
<p>这个方法我们已经在之前详细解析过，这里不重复解释，不过我们可以看一眼 <code>spring-boot</code> 和  <code>spring-boot-autoconfigure</code> 包下的 <code>spring.factories</code> 里面对于 <code>ApplicationContextInitializer</code> 的配置：</p>
<pre><code class="hljs properties" lang="properties"># Application Context Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer
</code></pre><pre><code class="hljs properties" lang="properties"># Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\
org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener
</code></pre><p>它一共配置了6个 <code>ApplicationContextInitializer</code>，对这些Initializer作简单介绍：</p>
<ul>
<li>ConfigurationWarningsApplicationContextInitializer：报告IOC容器的一些常见的错误配置</li>
<li>ContextIdApplicationContextInitializer：设置Spring应用上下文的ID</li>
<li>DelegatingApplicationContextInitializer：加载 <code>application.properties</code> 中 <code>context.initializer.classes</code> 配置的类</li>
<li>ServerPortInfoApplicationContextInitializer：将内置servlet容器实际使用的监听端口写入到 <code>Environment</code> 环境属性中</li>
<li>SharedMetadataReaderFactoryContextInitializer：创建一个 SpringBoot 和 <code>ConfigurationClassPostProcessor</code> 共用的 <code>CachingMetadataReaderFactory</code> 对象</li>
<li>ConditionEvaluationReportLoggingListener：将 <code>ConditionEvaluationReport</code> 写入日志</li>
</ul>
<h4 class="heading">3.2.2 createSpringFactoriesInstances：反射创建这些组件的实例</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">createSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,
        ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> </span>{
    List&lt;T&gt; instances = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(names.size());
    <span class="hljs-keyword">for</span> (String name : names) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 反射创建这些对象</span>
            Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);
            Assert.isAssignable(type, instanceClass);
            Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);
            T instance = (T) BeanUtils.instantiateClass(constructor, args);
            instances.add(instance);
        }
        <span class="hljs-keyword">catch</span> (Throwable ex) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot instantiate "</span> + type + <span class="hljs-string">" : "</span> + name, ex);
        }
    }
    <span class="hljs-keyword">return</span> instances;
}
</code></pre><h3 class="heading">3.3 setListeners：设置监听器</h3>
<p>与上面一样，先了解下 <code>ApplicationListener</code> ：</p>
<h4 class="heading">3.3.0 【重要】ApplicationListener</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">import</span> java.util.EventListener;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">EventListener</span>
</span></code></pre><p>它的文档注释原文翻译：</p>
<blockquote>
<p>Interface to be implemented by application event listeners. Based on the standard java.util.EventListener interface for the Observer design pattern.
As of Spring 3.0, an ApplicationListener can generically declare the event type that it is interested in. When registered with a Spring ApplicationContext, events will be filtered accordingly, with the listener getting invoked for matching event objects only.</p>
<p>由应用程序事件监听器实现的接口。基于观察者模式的标准 <code>java.util.EventListener</code> 接口。</p>
<p>从Spring 3.0开始，<code>ApplicationListener</code> 可以一般性地声明监听的事件类型。向IOC容器注册后，将相应地过滤事件，并且仅针对匹配事件对象调用监听器。</p>
</blockquote>
<p>文档注释也写的很明白，它就是监听器，用于监听IOC容器中发布的各种事件。至于事件是干嘛的，要到后续看IOC容器的刷新过程时才能看到。</p>
<h4 class="heading">3.3.1 加载Listener</h4>
<pre><code class="hljs java" lang="java"><span class="hljs-comment">// 加载所有类型为ApplicationListener的已配置的组件的全限定类名</span>
setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
</code></pre><p>套路与 <code>setInitializers</code> 一致，同样的我们来看看它加载了的 Listener：</p>
<pre><code class="hljs properties" lang="properties"># Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.config.ConfigFileApplicationListener,\
org.springframework.boot.context.config.DelegatingApplicationListener,\
org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\
org.springframework.boot.context.logging.LoggingApplicationListener,\
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener
</code></pre><pre><code class="hljs properties" lang="properties"># Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.autoconfigure.BackgroundPreinitializer
</code></pre><ul>
<li>ClearCachesApplicationListener：应用上下文加载完成后对缓存做清除工作</li>
<li>ParentContextCloserApplicationListener：监听双亲应用上下文的关闭事件并往自己的子应用上下文中传播</li>
<li>FileEncodingApplicationListener：检测系统文件编码与应用环境编码是否一致，如果系统文件编码和应用环境的编码不同则终止应用启动</li>
<li>AnsiOutputApplicationListener：根据 <code>spring.output.ansi.enabled</code> 参数配置 AnsiOutput</li>
<li>ConfigFileApplicationListener：从常见的那些约定的位置读取配置文件</li>
<li>DelegatingApplicationListener：监听到事件后转发给 <code>application.properties</code> 中配置的 <code>context.listener.classes</code> 的监听器</li>
<li>ClasspathLoggingApplicationListener：对环境就绪事件 <code>ApplicationEnvironmentPreparedEvent</code> 和应用失败事件 <code>ApplicationFailedEvent</code> 做出响应</li>
<li>LoggingApplicationListener：配置 <code>LoggingSystem</code>。使用 <code>logging.config</code> 环境变量指定的配置或者缺省配置</li>
<li>LiquibaseServiceLocatorApplicationListener：使用一个可以和 SpringBoot 可执行jar包配合工作的版本替换 LiquibaseServiceLocator</li>
<li>BackgroundPreinitializer：使用一个后台线程尽早触发一些耗时的初始化任务</li>
</ul>
<h3 class="heading">3.4 deduceMainApplicationClass：确定主配置类</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() {
    <span class="hljs-keyword">try</span> {
        StackTraceElement[] stackTrace = <span class="hljs-keyword">new</span> RuntimeException().getStackTrace();
        <span class="hljs-keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) {
            <span class="hljs-comment">// 从本方法开始往上爬，哪一层调用栈上有main方法，方法对应的类就是主配置类</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-string">"main"</span>.equals(stackTraceElement.getMethodName())) {
                <span class="hljs-keyword">return</span> Class.forName(stackTraceElement.getClassName());
            }
        }
    }
    <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) {
        <span class="hljs-comment">// Swallow and continue</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre><p>源码很简单，从 <code>deduceMainApplicationClass</code> 方法开始往上爬，哪一层调用栈上有main方法，方法对应的类就是主配置类，就返回这个类。</p>
<p>实际上通过Debug可以发现，发现这部分的 stackTrace 就是调用栈：</p>
<p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/17/16dd97da684e1910~tplv-t2oaga2asx-image.image"><figcaption></figcaption></figure><p></p>
<p>那自然最下面调用的方法是main方法，由此可确定主配置类。</p>
<h3 class="heading">3.5 【补充】与SpringBoot1.x的区别</h3>
<pre><code class="hljs java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;Object&gt; sources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;Object&gt;();

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(Object[] sources)</span> </span>{
    <span class="hljs-comment">// sources为null时没有终止应用继续启动</span>
    <span class="hljs-comment">// sources为SpringBoot1.x中使用的成员，SpringBoot2.x保留了它，但启动过程中不再使用</span>
    <span class="hljs-keyword">if</span> (sources != <span class="hljs-keyword">null</span> &amp;&amp; sources.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>.sources.addAll(Arrays.asList(sources));
    }
    <span class="hljs-comment">// deduceWebEnvironment方法在SpringApplication中，没有抽取成一个工具方法</span>
    <span class="hljs-comment">// 且SpringBoot1.x使用Spring4.x版本，没有WebFlux模块，故这里面只判断是否为WebMvc环境</span>
    <span class="hljs-keyword">this</span>.webEnvironment = deduceWebEnvironment();
    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    <span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();
}
</code></pre><h2 class="heading">小结</h2>
<ol>
<li><code>SpringApplication</code> 的创建和运行是两个不同的步骤。</li>
<li>SpringBoot 会根据当前classpath下的类来决定Web应用类型。</li>
<li>SpringBoot 的应用中包含两个关键组件：<code>ApplicationContextInitializer</code> 和 <code>ApplicationListener</code> ，分别是初始化器和监听器，它们都在构建 <code>SpringApplication</code> 时注册。</li>
</ol>
<p>【至此，<code>SpringApplication</code> 的初始化完成，下面会开始真正的启动 SpringApplication 】</p>
</div>
</body></html>