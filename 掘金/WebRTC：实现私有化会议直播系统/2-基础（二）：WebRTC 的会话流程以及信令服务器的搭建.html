<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>基础（二）：WebRTC 的会话流程以及信令服务器的搭建</h1>
<p>上节我们学了如何通过浏览器的 API 去操控电脑上的摄像头、麦克风、屏幕分享桌面，这些是我们实现会议系统必备的基础知识，接下来我们就要去思考如何实现一个会议系统，以及如何将我们学到的基础 API 和<code>WebRTC</code>组合。</p>
<p>清晰的逻辑和流程对于解决任何事情，都可以事半功倍。所以同样的，我们也得首先构思下应该以什么样的方式或流程去实践这项技术，完成这个功能。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c15694539d044425a411dc87e38fb268~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>第一步，我们必须得知道<code>WebRTC</code>是如何将远端的两个浏览器关联起来的，因为只有建立关联关系，接下来才有多媒体通信的基础。</p>
<p>第二步，关联关系转换到代码层面，那意味着在双方的浏览器中必须存在共性，这个共性你可以理解为一个核心的载体，有了载体就可以维护关联关系，那么在<code>WebRTC</code>中这个载体是什么？</p>
<p>这时我们就需要了解下<code>WebRTC</code>的核心对象<code>PeerConnection</code>，因为这就是上面两个问题的答案，<strong>建立关联关系和维护关联关系的载体。</strong></p>
<h2>核心对象 PeerConnection</h2>
<p><code>PeerConnection</code>可以说是整个<code>WebRTC</code>通话的载体，如果没有这个对象，那么后面所有流程都是没法进行的。</p>
<blockquote>
<p>首先要明确的是，在不同的浏览器中，<code>WebRTC</code>兼容性不一样，虽然前面开篇词提到它的相关 API 已经成为 W3C 的基础标准，但并不是所有的浏览器都满足这些标准的。<code>WebRTC</code>最先开始是谷歌体系，那么兼容性而言，谷歌浏览器就是首选。国内很多的浏览器也是基于谷歌内核的，因此<code>WebRTC</code>在很大程度上也是兼容的，这里先说几个常用且兼容<code>WebRTC</code>的浏览器：Chrome、360、edge、火狐、Safari。</p>
</blockquote>
<p>因此为了尽可能地兼容不同浏览器，获取到有效的<code>PeerConnection</code>对象，我们可以通过如下方式获取：</p>
<pre><code class="hljs language-javascript"> <span class="hljs-keyword">var</span> <span class="hljs-title class_">PeerConnection</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">RTCPeerConnection</span> ||
        <span class="hljs-variable language_">window</span>.<span class="hljs-property">mozRTCPeerConnection</span> ||
        <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkitRTCPeerConnection</span>;
</code></pre>
<p>知道了这个核心载体，自然就要了解这个载体的核心方法，只有它自身的核心方法才能驱动它进行工作。</p>
<blockquote>
<p>这些<strong>核心方法</strong>，在这里混个眼熟，后面到整体会话过程的时候，我们会详细来看这些方法的调用顺序以及方式。留意后面红字部分，这个也是很重要的一个点，后面我们单独引申展开看看。</p>
</blockquote>
<ul>
<li><code>addIceCandidate()</code>： 保存 ICE 候选信息，即双方协商信息，持续整个建立通信过程，直到没有更多候选信息。</li>
</ul>

<ul>
<li><code>addTrack()</code> ：添加音频或者视频轨道。</li>
</ul>

<ul>
<li><code>createAnswer()</code> ：创建应答信令。</li>
</ul>

<ul>
<li><code>createDataChannel()</code>： 创建消息通道，建立<code>WebRTC</code>通信之后，就可以<code> p2p</code> 的直接发送文本消息，无需中转服务器。</li>
</ul>

<ul>
<li><code>createOffer()</code>： 创建初始信令。</li>
</ul>

<ul>
<li><code>setRemoteDescription()</code>： 保存远端发送给自己的信令。</li>
</ul>

<ul>
<li><code>setLocalDescription()</code> ：保存自己端创建的信令。</li>
</ul>
<p>以上就是<code>PeerConnection</code>这个载体核心驱动的主要方法了，除了这些核心方法之外，还有一些<strong>事件监听函数</strong>，这些监听函数用于监听远程发送过来的消息。</p>
<p>假如 A 和 B 建立连接，如果 A 作为主动方即呼叫端，则需要调用的就是上述<strong>核心方法</strong>去创建建立连接的信息，而 B 则在另一端使用上述<strong>部分核心方法</strong>创建信息再发送给 A，A 则调用<strong>事件监听函数</strong>去保存这些信息。常用的事件监听函数如下：</p>
<ul>
<li><code>ondatachannel</code>： 创建<code>datachannel</code>后监听回调以及 <code>p2p</code>消息监听。</li>
</ul>

<ul>
<li><code>ontrack</code> ：监听远程媒体轨道即远端音视频信息。</li>
</ul>

<ul>
<li><code>onicecandidate</code>： ICE 候选监听。</li>
</ul>
<h2><code>WebRTC</code>的会话流程</h2>
<p>解决完上面俩问题，我们知道了既然要达成会话，那么就需要上述的载体，然后通过载体的核心方法和事件就可以完成从 A 到 B 两个浏览器的关联，那么关联的具体过程是什么呢？那就是我们接下来要详细解释的。首先看我给大家绘制的流程图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48a9cc63f3fc4f7d8f1778b2a19baf77~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>对照这个流程图，我们再来口述一边，上图中 <strong>A</strong> 为<strong>caller（呼叫端），B为callee（被呼叫端）。</strong></p>
<ol>
<li>首先 A 呼叫 B，呼叫之前我们一般通过实时通信协议<code>WebSocket</code>即可，让对方能收到信息。</li>
</ol>

<ol start="2">
<li>B 接受应答，A 和 B 均开始初始化<code>PeerConnection </code>实例，用来关联 A 和 B 的<code>SDP</code>会话信息。</li>
</ol>

<ol start="3">
<li>A 调用<code>createOffer</code>创建信令，同时通过<code>setLocalDescription</code>方法在本地实例<code>PeerConnection</code>中储存一份（<strong>图中流程①</strong>）。</li>
</ol>

<ol start="4">
<li>然后调用信令服务器将 A 的<code>SDP</code>转发给 B（<strong>图中流程②</strong>）。</li>
</ol>

<ol start="5">
<li>B 接收到 A 的<code>SDP</code>后调用<code>setRemoteDescription</code>，将其储存在初始化好的<code>PeerConnection</code>实例中（<strong>图中流程③</strong>）。</li>
</ol>

<ol start="6">
<li>B 同时调用<code>createAnswer</code>创建应答<code>SDP</code>，并调用<code>setLocalDescription</code>储存在自己本地<code>PeerConnection</code>实例中（<strong>图中流程④</strong>）。</li>
</ol>

<ol start="7">
<li>B 继续将自己创建的应答<code>SDP</code>通过服务器转发给 A（<strong>图中流程⑤</strong>）。</li>
</ol>

<ol start="8">
<li>A 调用<code>setRemoteDescription</code>将 B 的<code>SDP</code>储存在本地<code>PeerConnection</code>实例（<strong>图中流程⑤</strong>）。</li>
</ol>

<ol start="9">
<li>在会话的同时，从图中我们可以发现有个<code>ice candidate</code>，这个信息就是 ice 候选信息，A 发给 B 的 B 储存，B 发给 A 的 A 储存，直至候选完成。</li>
</ol>
<blockquote>
<p>我们可以发现，这里又出来个新的名词 <strong><code>SDP</code></strong>，这玩意实际就是<code>WebRTC</code>会话的<code>信令</code>，完成以上过程就相当于建立了<code>WebRTC</code>的会话基础，然后你才可以借助这个<strong>桥梁</strong>去添加和监听双方的音视频流信息。</p>
</blockquote>
<h2>信令服务器的搭建</h2>
<p>从上述整个流程来看，信令服务器为 A、B 两者中转信令起了很重要的角色，直白地讲，就是串通 A、B 的媒介，假如我的手机是 A，你的手机是 B，那么我们俩联系就需要通过运营商，而运营商的服务器替我们中转呼叫、接听、挂断等操作，在这里，<strong>运营商的服务器就是信令服务器</strong>。</p>
<p>信令服务器听上去很高大上，但实际上，它在不做复杂操作的时候，就是个即时通讯服务器，转发通话双方需要交换的信息，或者会话的信息，因此我们可以直接写个<code>WebSocket</code>服务端来完成信令服务器的使命。</p>
<p>当然，要完成信令服务器，我们也需要有针对性，我们的目的是为了<code>WebRTC</code>，那么针对的肯定就是<code>WebRTC</code>会话过程中需要的转发逻辑，由此我们可以构思下服务端应该具备哪些功能，看下图。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b728a5be84794491b11757d89cb006e0~tplv-k3u1fbpfcp-zoom-1.image" alt="">
为了完成上面这个构思，我们可以尝试写出来一个最基本的信令服务器。记住我们的目的是什么？<strong>一个会议系统</strong>，是的，所以我们设计的东西一定要满足会议的基本条件，即：用户单独标识和集体标识，也就是一开始必须区分的关键信息<code>userId</code>、<code>roomId</code>，但是怎么存会议室中的用户信息呢？
这里我会用到<code>Redis</code>的一种数据结构<code>Hash</code>，存放的大体结构如下图所示。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e6a44604e56403e80f32150140db6b0~tplv-k3u1fbpfcp-zoom-1.image" alt="">
信令服务器用什么语言呢？我们以 Web 端为主体，因此直接通过大家熟悉的<code>nodejs</code>来写即可，简单、方便、成本低，会一点点<code>JavaScript</code>即可。</p>
<h3>  具体代码</h3>
<pre><code class="hljs language-javascript">        <span class="hljs-keyword">const</span> httpServer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>).<span class="hljs-title function_">createServer</span>();
        <span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">'socket.io'</span>)(httpServer);

        <span class="hljs-comment">//redis</span>
        <span class="hljs-keyword">var</span> redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">'redis'</span>)
        <span class="hljs-keyword">const</span> roomKey = <span class="hljs-string">"meeting-room::"</span>
        <span class="hljs-keyword">var</span> redisClient = redis.<span class="hljs-title function_">createClient</span>(<span class="hljs-number">6379</span>, <span class="hljs-string">'127.0.0.1'</span>)
        redisClient.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'redisClient connect Error '</span> ,err);
        });

        <span class="hljs-keyword">const</span> userMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>() <span class="hljs-comment">// user - > socket</span>
        io.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-keyword">async</span> (socket) => {
            <span class="hljs-keyword">await</span> <span class="hljs-title function_">onListener</span>(socket)
        });

        httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">18080</span>, <span class="hljs-title function_">async</span>() => {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'服务器启动成功 *:18080'</span>);
          <span class="hljs-keyword">await</span> redisClient.<span class="hljs-title function_">connect</span>();
        });

        <span class="hljs-comment">/**
         * res data
         */</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">getMsg</span>(<span class="hljs-params">type,msg,status=<span class="hljs-number">200</span>,data=<span class="hljs-literal">null</span></span>){
            <span class="hljs-keyword">return</span> {<span class="hljs-string">"type"</span>:type,<span class="hljs-string">"msg"</span>:msg,<span class="hljs-string">"status"</span>:status,<span class="hljs-string">"data"</span>:data}

        }

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">getParams</span>(<span class="hljs-params">url,queryName</span>){
            <span class="hljs-keyword">let</span> query = <span class="hljs-built_in">decodeURI</span>(url.<span class="hljs-title function_">split</span>(<span class="hljs-string">'?'</span>)[<span class="hljs-number">1</span>]);
            <span class="hljs-keyword">let</span> vars = query.<span class="hljs-title function_">split</span>(<span class="hljs-string">"&#x26;"</span>);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; vars.<span class="hljs-property">length</span>; i++) {
              <span class="hljs-keyword">var</span> pair = vars[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">"="</span>);
              <span class="hljs-keyword">if</span> (pair[<span class="hljs-number">0</span>] === queryName) {
                <span class="hljs-keyword">return</span> pair[<span class="hljs-number">1</span>];
              }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-comment">/**
         * DB data
         * <span class="hljs-doctag">@author</span> <span class="hljs-variable">suke</span>
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">userId</span>
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">roomId</span>
         */</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserDetailByUid</span>(<span class="hljs-params">userId,roomId</span>){
            <span class="hljs-keyword">let</span> res = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(({<span class="hljs-string">"userId"</span>:userId,<span class="hljs-string">"roomId"</span>:roomId}))
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)
            <span class="hljs-keyword">return</span> res
        }

        <span class="hljs-comment">/**
         * 监听
         * <span class="hljs-doctag">@author</span> <span class="hljs-variable">suke</span>
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">s</span>
         */</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">onListener</span>(<span class="hljs-params">s</span>){
            <span class="hljs-keyword">let</span> url = s.<span class="hljs-property">client</span>.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>
            <span class="hljs-keyword">let</span> userId = <span class="hljs-title function_">getParams</span>(url,<span class="hljs-string">'userId'</span>)
            <span class="hljs-keyword">let</span> roomId = <span class="hljs-title function_">getParams</span>(url,<span class="hljs-string">'roomId'</span>)
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"client uid："</span>+userId+<span class="hljs-string">" roomId: "</span>+roomId+<span class="hljs-string">" online "</span>)
            <span class="hljs-comment">//user map</span>
            userMap.<span class="hljs-title function_">set</span>(userId,s)
            <span class="hljs-comment">//room cache</span>
            <span class="hljs-keyword">if</span>(roomId){
                <span class="hljs-keyword">await</span> redisClient.<span class="hljs-title function_">hSet</span>(roomKey+roomId,userId, <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserDetailByUid</span>(userId,roomId))
                <span class="hljs-title function_">oneToRoomMany</span>(roomId,<span class="hljs-title function_">getMsg</span>(<span class="hljs-string">'join'</span>,userId+ <span class="hljs-string">' join then room'</span>))
            }

            s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'msg'</span>, <span class="hljs-keyword">async</span> (data) => {
                  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"msg"</span>,data)
                  <span class="hljs-keyword">await</span> <span class="hljs-title function_">oneToRoomMany</span>(roomId,)
            });

            s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'disconnect'</span>, <span class="hljs-function">() =></span> { 
                  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"client uid："</span>+userId+<span class="hljs-string">" roomId: "</span>+roomId+<span class="hljs-string">" offline "</span>)
                  userMap.<span class="hljs-title function_">delete</span>(userId)
                  <span class="hljs-keyword">if</span>(roomId){
                      redisClient.<span class="hljs-title function_">hDel</span>(roomKey+roomId,userId)
                      <span class="hljs-title function_">oneToRoomMany</span>(roomId,<span class="hljs-title function_">getMsg</span>(<span class="hljs-string">'leave'</span>,userId+<span class="hljs-string">' leave the room '</span>))
                  }
            });    

            s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'roomUserList'</span>, <span class="hljs-keyword">async</span> (data) => {
                <span class="hljs-comment">// console.log("roomUserList msg",data)</span>
                s.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'roomUserList'</span>,<span class="hljs-keyword">await</span> <span class="hljs-title function_">getRoomUser</span>(data[<span class="hljs-string">'roomId'</span>]))
            })
            s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'call'</span>,<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
                <span class="hljs-keyword">let</span> targetUid = data[<span class="hljs-string">'targetUid'</span>]
                <span class="hljs-keyword">if</span>(userMap.<span class="hljs-title function_">get</span>(targetUid)){
                    <span class="hljs-title function_">oneToOne</span>(targetUid,<span class="hljs-title function_">getMsg</span>(<span class="hljs-string">'call'</span>,<span class="hljs-string">"远程呼叫"</span>,<span class="hljs-number">200</span>,data))
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(targetUid+ <span class="hljs-string">"不在线"</span>)
                }
            })
            s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'candidate'</span>,<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
                <span class="hljs-keyword">let</span> targetUid = data[<span class="hljs-string">'targetUid'</span>]
                <span class="hljs-keyword">if</span>(userMap.<span class="hljs-title function_">get</span>(targetUid)){
                    <span class="hljs-title function_">oneToOne</span>(targetUid,<span class="hljs-title function_">getMsg</span>(<span class="hljs-string">'candidate'</span>,<span class="hljs-string">"ice candidate"</span>,<span class="hljs-number">200</span>,data))
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(targetUid+ <span class="hljs-string">"不在线"</span>)
                }
            })
            s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'offer'</span>,<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
                <span class="hljs-keyword">let</span> targetUid = data[<span class="hljs-string">'targetUid'</span>]
                <span class="hljs-keyword">if</span>(userMap.<span class="hljs-title function_">get</span>(targetUid)){
                    <span class="hljs-title function_">oneToOne</span>(targetUid,<span class="hljs-title function_">getMsg</span>(<span class="hljs-string">'offer'</span>,<span class="hljs-string">"rtc offer"</span>,<span class="hljs-number">200</span>,data))
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(targetUid+ <span class="hljs-string">"不在线"</span>)
                }
            })
            s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'answer'</span>,<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
                <span class="hljs-keyword">let</span> targetUid = data[<span class="hljs-string">'targetUid'</span>]
                <span class="hljs-keyword">if</span>(userMap.<span class="hljs-title function_">get</span>(targetUid)){
                    <span class="hljs-title function_">oneToOne</span>(targetUid,<span class="hljs-title function_">getMsg</span>(<span class="hljs-string">'answer'</span>,<span class="hljs-string">"rtc answer"</span>,<span class="hljs-number">200</span>,data))
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(targetUid+ <span class="hljs-string">"不在线"</span>)
                }
            })
        }

        <span class="hljs-comment">/**
         * ono to one (event msg)
         * <span class="hljs-doctag">@author</span> <span class="hljs-variable">suke</span>
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">uid</span>
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">msg</span>
         */</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">oneToOne</span>(<span class="hljs-params">uid,msg</span>){
            <span class="hljs-keyword">let</span> s = userMap.<span class="hljs-title function_">get</span>(uid)
            <span class="hljs-keyword">if</span>(s){
                s.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'msg'</span>,msg)
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uid+<span class="hljs-string">"用户不在线"</span>)
            }
        }

        <span class="hljs-comment">/**
         * 获取房间用户列表
         * <span class="hljs-doctag">@author</span> <span class="hljs-variable">suke</span>
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">roomId</span>
         */</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getRoomUser</span>(<span class="hljs-params">roomId</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> redisClient.<span class="hljs-title function_">hGetAll</span>(roomKey+roomId)
        }

        <span class="hljs-comment">/**
         * one to room many
         * <span class="hljs-doctag">@author</span> <span class="hljs-variable">suke</span>
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">roomId</span>
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">msg</span>
         */</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">oneToRoomMany</span>(<span class="hljs-params">roomId,msg</span>){
            <span class="hljs-keyword">let</span> ulist = <span class="hljs-keyword">await</span> redisClient.<span class="hljs-title function_">hGetAll</span>(roomKey+roomId)
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> uid <span class="hljs-keyword">in</span> ulist){
              <span class="hljs-title function_">oneToOne</span>(uid,msg)
            }

        }
</code></pre>
<h3>  项目演示指南</h3>
<p>下载代码后，找到目录下： socket-server 文件夹，到文件夹执行依赖安装并配置 Redis 链接。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d83f305038a34fcda6afca04c1d920e5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<pre><code class="hljs language-perl">   cd <span class="hljs-keyword">socket</span>-server
   cnpm i 
   npm run start <span class="hljs-comment">## 启动</span>
   ---------------------打印如下则代表信令服务器启动成功---------------------------------
   > <span class="hljs-keyword">socket</span>-server@1.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> start
   > node app.js

   服务器启动成功 *:<span class="hljs-number">18080</span>
   redis 连接成功
</code></pre>
<h2>扩展</h2>
<p>在看完<code>WebRTC</code>会话流程之后，你会发现，在整个核心会话中，并没有出现媒体信息交换（比如：摄像头、麦克风媒体流的发送和接受）。所以很明显，<code>WebRTC</code>不只可以用来音视频通话。</p>
<p>确实如此，在无需视频通话的时候，我们可以用<code>WebRTC</code>这个<code>桥梁</code>当作是一种新的数据双向传输方案，现阶段已经有网站用这种方式上传用户数据或其他加密消息媒介了，而且因为<code>WebRTC</code>中数据传输协议非<code>HTTP</code>或者<code>WebSocket</code>协议请求，很多探测工具也就没法察觉。</p>
<p>下一节，我们将利用搭建好的信令服务器，去具体实现最简单的 P2P 音视频通话，同时也为了给大家演示下，<code>WebRTC</code>除音视频场景之外，利用<code>WebRTC</code>已完成会话这个桥梁，去实现无需服务端的点对点 IM 通信。</p>
<h2>本节所有源代码地址</h2>
<p><a href="https://gist.github.com/wangsrGit119/7b1d280550e593987f55f34e13f4f6aa" target="_blank" rel="nofollow noopener noreferrer">信令服务器源码</a></p>
<h2>课后题</h2>
<p>利用 <code>Node JS</code> 搭建好信令服务器之后，我们就需要在前端页面完成和 <code>socket</code> 服务器的连接。前面已经明确了信令服务器的基本功能就是信令的转发，信令说白了就是一种特殊的消息，因此课后大家可以先尝试使用这个服务器实现 <code>Web</code> 端的基本文本聊天。</p></div>
</body></html>