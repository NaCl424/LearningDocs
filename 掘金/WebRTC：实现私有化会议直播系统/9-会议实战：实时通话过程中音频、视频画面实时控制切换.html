<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>会议实战：实时通话过程中音频、视频画面实时控制切换</h1>
<p>从前面的几节课过来，我们会发现无论是在 P2P 的音视频通话，还是小场景直播，或者是会议系统，都离不开视频和音频。有了音视频，那就要控制音视频，比如在很多的场合中，我们需要主动关闭自己的麦克风或者是摄像头的画面，从而保护个人隐私。</p>
<p>这节课我们就结合实战着重讲讲如何主动控制音频和视频画面，以及视频和音频的切换。实际上在<a href="https://juejin.cn/book/7168418382318927880/section/7172208546086387719" target="_blank" rel="nofollow noopener noreferrer">《07｜直播实战：WebRTC + 人工智能实现直播虚拟背景》</a>我们提到过直接切换视频画面的操作，如果你已经忘记了那也无妨，接下来我们再专项学习下。</p>
<p>开始之前我们再熟悉下 <code>RTCRtpSender</code>，这个对象代表媒体发送方的一个音频或者视频轨道控制器，通过这个控制器，你可以去检查和控制 RTP 数据的编码与传输。它是由<code>RTCPeerConnection</code>对象的<code>getSenders()</code>方法返回，官方描述如下：</p>
<blockquote>
<p>“返回一个对象数组 <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpSender" target="_blank" rel="nofollow noopener noreferrer">RTCRtpSender</a>，每个对象代表负责传输一个轨道数据的 RTP 发送方。发送器对象提供用于<strong>检查和控制轨道数据的编码和传输的方法和属性</strong>。”</p>
</blockquote>
<p>我们后面所有的对于远程流的控制，都是通过上面的这个<code>RTCRtpSender</code>对象中的方法来。</p>
<p>需要明确的是，在前端我们获取流的操作中，一般都会将此流保存到全局的变量进而给各个 RTC 关联赋于同一个流。这样做的原因，第一是在和别的客户端关联的时候无需获取新的流；第二是节约时间和内存；第三就是便于控制，也就是这节课的重点：<strong>媒体控制</strong>。</p>
<p>但是，请注意上述提到的便于控制并不是通用的，媒体控制如果仅仅对本地流做出变更，在很多情况下并不会同步给所有的客户端，比如比特率、FPS 等，换句话说，你将本地流暂停了或者激活了并不会影响到远程的画面。那么如何去控制呢？重点就是我们这节课提到的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpSender" target="_blank" rel="nofollow noopener noreferrer">RTCRtpSender</a> 。</p>
<h2>音视频暂停和恢复</h2>
<p>暂停和恢复操作，是针对的现有的流做出的激活和暂停。</p>
<p><strong>音频暂停恢复</strong></p>
<p>b 变量为<code> true/false</code>，可以动态控制发送方的音频关闭或者开启。<code>send.track.enabled</code> 为 <code>true</code> 即激活，<code>false</code> 则暂停。</p>
<pre><code class="hljs language-ini">//单个RTC关联音频
const <span class="hljs-attr">senders</span> = localRTC .getSenders()<span class="hljs-comment">;</span>
const <span class="hljs-attr">send</span> = senders.find((s) => s.track.kind === <span class="hljs-string">'audio'</span>)
<span class="hljs-attr">send.track.enabled</span> = b

//多个RTC关联音频
RtcPcMaps.forEach((v,k) => {
        const <span class="hljs-attr">senders</span> = v.getSenders()<span class="hljs-comment">;</span>
        const <span class="hljs-attr">send</span> = senders.find((s) => s.track.kind === <span class="hljs-string">'audio'</span>)
        <span class="hljs-attr">send.track.enabled</span> = b
})
</code></pre>
<p><strong>视频暂停恢复</strong></p>
<pre><code class="hljs language-ini">//单个RTC关联视频
const <span class="hljs-attr">senders</span> = localRTC .getSenders()<span class="hljs-comment">;</span>
const <span class="hljs-attr">send</span> = senders.find((s) => s.track.kind === <span class="hljs-string">'video'</span>)
<span class="hljs-attr">send.track.enabled</span> = b

//多个RTC关联视频
RtcPcMaps.forEach((v,k) => {
        const <span class="hljs-attr">senders</span> = v.getSenders()<span class="hljs-comment">;</span>
        const <span class="hljs-attr">send</span> = senders.find((s) => s.track.kind === <span class="hljs-string">'video'</span>)
        <span class="hljs-attr">send.track.enabled</span> = b
})
</code></pre>
<p>除了将自己发送给对方的画面或音频实时控制之外，你还需要控制自己端显示的画面和音频，那就是你的本地媒体流 <code>localStream</code>。</p>
<p>说一个场景：你和 B、C 在视频会议，突然你接到一个电话，此时你将画面和麦克风关闭，对面无法看到听到；等你打完电话后，本地还是正常显示画面和声音，但是你忘了已经关闭了远程的了，此时你继续讲话不就等于白讲了？</p>
<p><strong>因此控制远程画面的同时</strong> <strong>，</strong> <strong>也要同步控制本地预览流，目的是“所见即所得”</strong> <strong>。</strong></p>
<pre><code class="hljs language-ini">//音频
this.localStream.getAudioTracks()<span class="hljs-section">[0]</span>.<span class="hljs-attr">enabled</span> = b
<span class="hljs-attr">this.mediaStatus.audio</span> = b
//视频
this.localStream.getVideoTracks()<span class="hljs-section">[0]</span>.<span class="hljs-attr">enabled</span> = b
<span class="hljs-attr">this.mediaStatus.video</span> = b
</code></pre>
<h2>媒体流的变更</h2>
<p>在通话过程中，除了上述音视频的暂停和恢复之外，一些场景往往需要我们对媒体流做出变更，最基本的就是屏幕共享，如果涉及到画质要求，则可能会变更清晰度；遇到画面投屏，则可能会变更画面的分辨率（比如：竖屏投到横屏）。接下来就讲讲如何在通话的时候去变更媒体流。</p>
<p>媒体变更最简单的操作就是音频或者视频流的切换，A 画面切 B 画面，C 音频切 D 音频。而本质上都是需要新的流去替换旧的流，也就是说，在你操作前，就想要准备好要发布的新的媒体流。</p>
<p>下面的示例中， stream 为新的流，通过 <code>getAudioTracks</code>和<code>getVideoTracks</code>分别获取新的流的音频和视频媒体信息，然后通过<code>RTCRtpSender</code>去替换原有的流。</p>
<p><strong>音频切换</strong></p>
<pre><code class="hljs language-ini">const <span class="hljs-section">[audioTrack]</span> = stream.getAudioTracks()<span class="hljs-comment">;</span>
//单个RTC关联
const <span class="hljs-attr">senders</span> = localRTC.getSenders()<span class="hljs-comment">;</span>
const <span class="hljs-attr">send</span> = senders.find((s) => s.track.kind === <span class="hljs-string">'audio'</span>)
send.replaceTrack(audioTrack)
//多个RTC关联
RtcPcMaps.forEach(<span class="hljs-attr">e</span> => {
    const <span class="hljs-attr">senders</span> = e.getSenders()<span class="hljs-comment">;</span>
    const <span class="hljs-attr">send</span> = senders.find((s) => s.track.kind === <span class="hljs-string">'audio'</span>)
    send.replaceTrack(audioTrack)
})
</code></pre>
<p><strong>视频切换</strong></p>
<pre><code class="hljs language-ini">const <span class="hljs-section">[videoTrack]</span> = stream.getVideoTracks()<span class="hljs-comment">;</span>
//单个RTC关联
const <span class="hljs-attr">senders</span> = localRTC.getSenders()<span class="hljs-comment">;</span>
const <span class="hljs-attr">send</span> = senders.find((s) => s.track.kind === <span class="hljs-string">'video'</span>)
send.replaceTrack(videoTrack)
//多个RTC关联
RtcPcMaps.forEach(<span class="hljs-attr">e</span> => {
    const <span class="hljs-attr">senders</span> = e.getSenders()<span class="hljs-comment">;</span>
    const <span class="hljs-attr">send</span> = senders.find((s) => s.track.kind === <span class="hljs-string">'video'</span>)
    send.replaceTrack(videoTrack)
})
</code></pre>
<p>当然，媒体变更过程中，不一定要重新获取新的媒体流替换旧的媒体流，除了屏幕共享这类操作必须替换外，其他的操作比如：<code>前后摄像头切换</code>、<code>摄像头宽高重新设置（分辨率）</code>、<code>FPS 设置</code>、<code>Bitrate 设置</code>等是无需替换流就可以完成设置的。此外如果摄像头支持的属性较多的话，也可以对其它属性设置。</p>
<p>下面我给大家详细解释下常用到的参数，以及用实例演示这些参数的设置方式。</p>
<h2>常用媒体参数详解</h2>
<p>在前端媒体流中，涉及到的控制参数非常多，这里给大家提及一些常用的参数。</p>
<ol>
<li><code>aspectRatio</code>：视频分辨率比例。常用值包括 1.3333333333（用于经典电视 4:3“标准”宽高比，也用于平板电脑，如 Apple 的 iPad）、1.7777777778（用于 16:9 高清宽屏宽高比）。</li>
</ol>

<ol start="2">
<li><code>facingMode</code>：摄像头面向方向。"user" 面向用户的摄像头（俗称“自拍相机”），用于自拍和视频通话。"environment" 背对用户的相机（当用户正在看屏幕时）。</li>
</ol>

<ol start="3">
<li><code>frameRate</code>：俗称 FPS。通常在 20～24 之间。</li>
</ol>

<ol start="4">
<li><code>width</code>和<code>height</code>：视频帧宽带和高度。当你设置固定的宽高之后，<code>aspectRatio</code>会自动变更。相反<strong>仅</strong>设置<code>aspectRatio</code>参数后，其他 height 和 width 参数也会变动。</li>
</ol>
<p>当然还有其他的参数，这里就不再举例，因为具体参数和摄像头的支持也是离不开的，比如有些摄像头功能复杂支持亮度、色泽、焦距的调节，而有些不支持。下面就是我本地两个摄像头具体支持参数。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59d2efaf86474e63bd15c7402446a268~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/699e21efd9f344289002f9712428e3fd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>常用参数设置</h2>
<p>除了前面提到的音视频的切换和暂停控制外，上面提到的常用参数也是直接可以设置的，其设置方法也有共性。</p>
<ol>
<li>通过 sender 的 params 参数设置。</li>
</ol>
<pre><code class="hljs language-ini"> //设置分辨率以及比特率
 let <span class="hljs-attr">width</span> = <span class="hljs-number">720</span>
 let <span class="hljs-attr">height</span> = <span class="hljs-number">640</span>
 const <span class="hljs-attr">scaleRatio</span> = sender.track.getSettings().height/height<span class="hljs-comment">;</span>
 const <span class="hljs-attr">params</span> = sender.getParameters()<span class="hljs-comment">;</span>
 //这里有可能获取到空 因此设置初始参数
  if (!params) {<span class="hljs-attr">params.encodings</span> = [{ }]<span class="hljs-comment">;}</span>
  //aspectRatio 设置
  params.encodings<span class="hljs-section">[0]</span>.<span class="hljs-attr">scaleResolutionDownBy</span> = Math.max(scaleRatio, <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
  //比特率设置
  params.encodings<span class="hljs-section">[0]</span>.<span class="hljs-attr">maxBitrate</span> = bitrate<span class="hljs-comment">;</span>
  //同步参数
  await sender.setParameters(params)<span class="hljs-comment">;</span>
</code></pre>
<ol start="2">
<li>通过强制 Constraints 设置。</li>
</ol>
<pre><code class="hljs language-ini">//过滤视频
const <span class="hljs-attr">sender</span> = senders.find((s) => s.track.kind === <span class="hljs-string">'video'</span>)
let <span class="hljs-attr">height</span> = <span class="hljs-number">200</span>
let <span class="hljs-attr">frameRate</span> = <span class="hljs-number">30</span>
let <span class="hljs-attr">aspectRatio</span> =  <span class="hljs-number">2.777777778</span>
//强制约束
await sender.track.applyConstraints({ height ,frameRate,aspectRatio})<span class="hljs-comment">;</span>
</code></pre>
<p>这里我们需要注意：</p>
<ol>
<li>通过前面第一种方式设置参数，在很多浏览器会被阻止，因此建议用第二种方式，直接强制约束来设置通用参数。</li>
</ol>

<ol start="2">
<li>在设置某些参数之前，我们需要知道，摄像头是否支持这个参数，假如你的摄像头本身的分辨率只有 <code>720X640</code> ，那么你设置<code>1920X1080</code>是不会生效的哦。</li>
</ol>
<h2>项目操作指南</h2>
<ol>
<li>打开项目，找到模块：多人视频聊天。</li>
</ol>

<ol start="2">
<li>不同客户端 A、B 加入会议。</li>
</ol>

<ol start="3">
<li>设置我们想要变更的参数</li>
</ol>
<p>这里我设置的参数有三个：<code>height</code>（帧高度） 、<code>frameRate</code>（FPS） 、<code>aspectRatio</code>（分辨率宽高之比） 。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-title function_">getRtcPeerInfo</span>(<span class="hljs-params">uid</span>){
        <span class="hljs-keyword">let</span> pcKey = <span class="hljs-variable language_">this</span>.<span class="hljs-property">formInline</span>.<span class="hljs-property">userId</span>+<span class="hljs-string">'-'</span>+uid
        <span class="hljs-keyword">let</span> p = <span class="hljs-title class_">RtcPcMaps</span>.<span class="hljs-title function_">get</span>(pcKey)
        <span class="hljs-keyword">if</span>(p){
                <span class="hljs-keyword">const</span> senders = p.<span class="hljs-title function_">getSenders</span>();
                <span class="hljs-keyword">const</span> sender = senders.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">s</span>) =></span> s.<span class="hljs-property">track</span>.<span class="hljs-property">kind</span> === <span class="hljs-string">'video'</span>)
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"设置前参数"</span>,sender.<span class="hljs-property">track</span>.<span class="hljs-title function_">getSettings</span>())
                <span class="hljs-keyword">let</span> height = <span class="hljs-number">200</span>
                <span class="hljs-keyword">let</span> frameRate = <span class="hljs-number">30</span>
                <span class="hljs-keyword">let</span> aspectRatio =  <span class="hljs-number">2.777777778</span>
                <span class="hljs-keyword">await</span> sender.<span class="hljs-property">track</span>.<span class="hljs-title function_">applyConstraints</span>({ height ,frameRate,aspectRatio});
                <span class="hljs-keyword">const</span> receivers = p.<span class="hljs-title function_">getReceivers</span>();
                <span class="hljs-keyword">const</span> receive = receivers.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">s</span>) =></span> s.<span class="hljs-property">track</span>.<span class="hljs-property">kind</span> === <span class="hljs-string">'video'</span>)
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"远程流画面设置"</span>,receive.<span class="hljs-property">track</span>.<span class="hljs-title function_">getSettings</span>())
                
        }
},
</code></pre>
<ol start="4">
<li>操作①：点击对方画面框框（Video DOM 元素），然后观察控制台和右下角画面显示。</li>
</ol>

<ol start="5">
<li>操作②：点击自己的视频（右下角显示画面），观察控制台。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1450b00fd1e4c1d8e2f7bf2da506623~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<ol start="6">
<li>参数变更说明：上图红色圈圈中的就是设置前的参数，后面绿色的就是变更后的参数，大家可以发现，这个和我代码中的一致。请注意：我在代码中并没有设置分辨率的 <code>width</code>，但是它也变了，为何？答案就在本节前面参数详解第四条中：当你设置固定的宽高之后<code>aspectRatio</code>会自动变更，相反，仅设置<code>aspectRatio</code>参数后，其他 <code>height</code> 和 <code>width</code> 参数也会变动。</li>
</ol>
<h2>代码仓库</h2>
<p><a href="https://github.com/wangsrGit119/suke-webrtc-course/blob/main/webrtc-link-demo/src/views/demo03-many2many.vue" target="_blank" rel="nofollow noopener noreferrer">本节课代码位置</a></p>
<h2>课后题</h2>
<ol>
<li>请大家根据这节课学到的内容，去改造下点对点视频通话过程中媒体流的变更。</li>
<li>完成第一个问题后，可以尝试摄像头和屏幕分享流的切换，即和对方分享自己的桌面。</li>
</ol></div>
</body></html>