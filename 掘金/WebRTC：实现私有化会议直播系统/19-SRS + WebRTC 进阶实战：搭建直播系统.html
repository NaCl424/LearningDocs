<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>SRS + WebRTC 进阶实战：搭建直播系统</h1>
<p>上节课让大家去看看 B 站直播用的是哪种媒体流，大家去看了没有？没有也没关系，实际上现阶段基本上都是 <code>FLV</code>或者<code>HLS</code>的，毕竟大型直播以及搭配 CDN 等都有成熟的案例，而现阶段，<code>WebRTC</code>在直播场景中还是有局限性的。虽然大型直播没有，但是小型的直播还是蛮多的，而我们这节课就利用上节 <code>WebRTC</code>推流到 SRS 流媒体服务器后，再用 <code>WebRTC</code>去拉流完成直播。</p>
<p>当然，上节课推流后得到的两种流地址都是可以直接作为直播源的，但是在拉流速度上和<code>WebRTC</code>还有差别，接下来我们就来看看，用 <code>WebRTC</code>和 SRS 如何提高拉流的效率，大家再和 <code>FLV</code>、<code>HLS</code>拉流对比下，看下具体的差异。</p>
<h2>WebRTC 拉流</h2>
<ol>
<li>获取已知要拉取的流 ID，即推流地址中的 <code>streamId</code>。你可以把这个流 ID 当作是直播间的房间号，具有唯一性。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1392ff9f8ef04cea852268539241dc77~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<ol start="2">
<li>初始化 <code>WebRTC</code>核心关联对象 <code>PeerConnection</code>实例，同时监听远程媒体流。</li>
</ol>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span>
<span class="hljs-keyword">if</span>(that.<span class="hljs-property">pc</span>){
        that.<span class="hljs-property">pc</span>.<span class="hljs-title function_">close</span>();
}
that.<span class="hljs-property">pc</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeerConnection</span>(<span class="hljs-literal">null</span>);
<span class="hljs-comment">//注意这里和推流参数的区别</span>
that.<span class="hljs-property">pc</span>.<span class="hljs-title function_">addTransceiver</span>(<span class="hljs-string">"audio"</span>, {<span class="hljs-attr">direction</span>: <span class="hljs-string">"recvonly"</span>});
that.<span class="hljs-property">pc</span>.<span class="hljs-title function_">addTransceiver</span>(<span class="hljs-string">"video"</span>, {<span class="hljs-attr">direction</span>: <span class="hljs-string">"recvonly"</span>});
<span class="hljs-comment">//这里监听远程媒体流过来</span>
that.<span class="hljs-property">pc</span>.<span class="hljs-property">ontrack</span>  = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
        that.<span class="hljs-title function_">setDomVideoTrick</span>(e.<span class="hljs-property">track</span>)
}
<span class="hljs-comment">//创建会话信令</span>
<span class="hljs-keyword">let</span> offer = <span class="hljs-keyword">await</span> that.<span class="hljs-property">pc</span>.<span class="hljs-title function_">createOffer</span>();
<span class="hljs-comment">//本地添加一份</span>
<span class="hljs-keyword">await</span> that.<span class="hljs-property">pc</span>.<span class="hljs-title function_">setLocalDescription</span>(offer)
</code></pre>
<ol start="3">
<li>通过 SRS 开放 API 交换基础信令 SDP，与本地同步。</li>
</ol>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//组装参数 按照API格式</span>
<span class="hljs-keyword">let</span> data = {
  <span class="hljs-string">"api"</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$srsServerAPIURL</span>+<span class="hljs-string">"rtc/v1/play/"</span>,
  <span class="hljs-string">"streamurl"</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$srsServerRTCURL</span>+streamId,
  <span class="hljs-string">"sdp"</span>: offer.<span class="hljs-property">sdp</span>
}
<span class="hljs-comment">//交换</span>
axios.<span class="hljs-title function_">post</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$srsServerAPIURL</span>+<span class="hljs-string">'rtc/v1/play/'</span>,data)
.<span class="hljs-title function_">then</span>( <span class="hljs-keyword">async</span> res => {
        res = res.<span class="hljs-property">data</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)
        <span class="hljs-keyword">if</span>(res.<span class="hljs-property">code</span> === <span class="hljs-number">0</span>){
        <span class="hljs-comment">//得到流媒体服务器应答的信令，添加到本地核心关联实例化对象的种</span>
                <span class="hljs-keyword">await</span> that.<span class="hljs-property">pc</span>.<span class="hljs-title function_">setRemoteDescription</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RTCSessionDescription</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">'answer'</span>, <span class="hljs-attr">sdp</span>: res.<span class="hljs-property">sdp</span>}))
        }
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =></span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"SRS 拉流异常"</span>,err)
})
</code></pre>
<ol start="4">
<li>监听到媒体流后挂载到本地 <code>DOM</code> 元素。</li>
</ol>
<pre><code class="hljs language-ini">setDomVideoTrick(trick){
    // this.scanvideodomId 为本地页面已存在的video标签ID
      let <span class="hljs-attr">video</span> = document.getElementById(this.scanvideodomId)
      let <span class="hljs-attr">stream</span> = video.srcObject
      if(stream){
              stream.addTrack(trick)
      }else {
              <span class="hljs-attr">stream</span> = new MediaStream()
              stream.addTrack(trick)
              <span class="hljs-attr">video.srcObject</span> = stream
              <span class="hljs-attr">video.controls</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
              <span class="hljs-attr">video.autoplay</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
              <span class="hljs-attr">video.muted</span> = <span class="hljs-literal">true</span>
      }
}
</code></pre>
<p>通过以上步骤，我们就可以直接通过 <code>WebRTC</code>订阅到发布的媒体流了。而不是用之前的 <code>HLS</code>流或者 <code>FLV </code>格式流去点播视频画面，给大家对比看下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2588ab46d0e4ec59180581118692743~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>可以看到，我在直接推流后，右侧直播预览位置几乎立马显示画面，而后面我复制的 FLV 流去播放器播放则需要加载至少一秒钟，这就是<code>WebRTC</code>在流媒体直播领域的优势。</p>
<p>说完拉流，我们再说说直播过程中其他的功能，比如音视频的控制、切换，以及更高大上的连麦。</p>
<h2>直播过程中音视频控制</h2>
<h3>音视频控制</h3>
<p>看下面代码，是不是和<a href="https://juejin.cn/book/7168418382318927880/section/7172837736468971551" target="_blank" rel="nofollow noopener noreferrer">《10 | 会议实战：实时通话过程中音频、视频画面实时控制切换》</a>中媒体控制的代码很类似？是的，只要是 WebRTC 相关，不论是用 SRS 流媒体服务，还是网关 Janus 服务，其控制的核心都是核心关联对象<code>PeerConnection</code>。</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">//音频控制 pc为 peerconnection 实例化后的对象</span>
audioControl(b){
       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.pc){
               <span class="hljs-keyword">this</span>.audioStatus = !<span class="hljs-keyword">this</span>.audioStatus 
              <span class="hljs-keyword">const</span> senders = <span class="hljs-keyword">this</span>.pc.getSenders();
              <span class="hljs-keyword">const</span> send = senders.find((s) => s.track.kind === <span class="hljs-string">'audio'</span>)
              send.track.enabled = b 
       }<span class="hljs-keyword">else</span>{
               <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"请先点击推流"</span>)
       }
}
<span class="hljs-comment">//视频控制</span>
audioControl(b){
       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.pc){
               <span class="hljs-keyword">this</span>.videoStatus= !<span class="hljs-keyword">this</span>.videoStatus
              <span class="hljs-keyword">const</span> senders = <span class="hljs-keyword">this</span>.pc.getSenders();
              <span class="hljs-keyword">const</span> send = senders.find((s) => s.track.kind === <span class="hljs-string">'video'</span>)
              send.track.enabled = b 
       }<span class="hljs-keyword">else</span>{
               <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"请先点击推流"</span>)
       }
}
</code></pre>
<h3>音视频切换</h3>
<p>这里我们使用屏幕分享来实现这个功能。</p>
<ol>
<li>获取屏幕分享流。</li>
</ol>
<pre><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">getShareMedia</span>()</span>{
    <span class="hljs-keyword">const</span> constraints = {
            video:{width:<span class="hljs-number">1920</span>,height:<span class="hljs-number">1080</span>},
            audio:<span class="hljs-literal">false</span>
    };
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> navigator.mediaDevices.getDisplayMedia(constraints).<span class="hljs-keyword">catch</span>(handleError);
}
</code></pre>
<ol start="2">
<li>通过核心实例化对象切换媒体流。</li>
</ol>
<pre><code class="hljs language-kotlin">async changeVideo(){
       <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.pc){
               <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"请先点击推流"</span>)
               <span class="hljs-keyword">return</span>
       }
       <span class="hljs-comment">//这里获取上一步的屏幕分享流</span>
       <span class="hljs-keyword">this</span>.shareStream = await <span class="hljs-keyword">this</span>.getShareMedia()
       <span class="hljs-comment">//提取第一个视频Track</span>
       <span class="hljs-keyword">const</span> [videoTrack] = <span class="hljs-keyword">this</span>.shareStream.getVideoTracks();
       <span class="hljs-comment">//获取发送器</span>
       <span class="hljs-keyword">const</span> senders = <span class="hljs-keyword">this</span>.pc.getSenders();
       <span class="hljs-keyword">const</span> send = senders.find((s) => s.track.kind === <span class="hljs-string">'video'</span>)
       <span class="hljs-comment">//替换视频Track</span>
       send.replaceTrack(videoTrack)
       <span class="hljs-comment">//更改按钮状态</span>
       <span class="hljs-keyword">this</span>.shareStatus = <span class="hljs-literal">true</span>
}
</code></pre>
<h3>直播连麦</h3>
<p>从 WebRTC 推流到 SRS 流媒体服务器，再到从流媒体服务器拉流，这个过程中我们注意到，实例化<code>PeerConnection</code>后的核心对象中， <code>addTransceiver</code>方法中<code>direction</code>参数为<code>sendonly</code>和<code>recvonly</code>，这个参数是什么意思呢？看下面表格：</p>






























<table><thead><tr><th>参数</th><th>RTCRtpSender</th><th>RTCRtpReceiver</th></tr></thead><tbody><tr><td>sendrecv</td><td>提供和发送 RTP 数据包（媒体信息）</td><td>接收 RTP 包（媒体信息），也接收对等方 RTP 数据包</td></tr><tr><td>sendonly</td><td>提供和发送 RTP 数据包（媒体信息）</td><td>不接受 RTP 数据包</td></tr><tr><td>recvonly</td><td>不提供和发送 RTP 数据包，也就是说本地有流媒体，但是你无法给对面发送</td><td>接收 RTP 数据包</td></tr><tr><td>inactive</td><td>不提供和发送 RTP 数据包</td><td>不接收 RTP 数据包</td></tr></tbody></table>
<p>表头中<code>RTCRtpSender</code>和<code>RTCRtpReceiver</code>这两个东西，你可以理解为手机充电线的那个充电头，一端接收，另一端输出，永久配对且缺一不可。而对于 <code>WebRTC</code>而言，它们的作用就是描述和控制媒体输出和输入，<code>sendonly</code>代表只发送媒体数据但是不接受，<code>recvonly</code>则相反，仅接收不发送媒体数据。</p>
<p>通过上面参数我们发现，当前<code>拉流端</code>和<code>推流端</code>与 SRS 流服务器建立的 RTC 连接对于媒体接收和发送而言是单向的，不能通过已经建立的链接去反向发送媒体流，比如<code>拉流端</code>（观众）给<code>推流端</code>（主播）发送视频或音频。既然这样，那我们如何去实现 “直播连麦” 功能呢？</p>
<p>很简单，既然大家都在同一个直播间，我们可以让<code>观众端</code>在申请连麦同意后主动推流给 SRS 流媒体服务器，成功后再告诉<code>主播</code>该<code>观众</code>推流的 <code>流ID</code>，然后让主播拉流不就可以了？</p>
<h2>连麦实战</h2>
<ol>
<li>申请连麦。在申请的时候携带唯一的流 ID，确保预留且不重复的。</li>
</ol>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//服务端增加socket事件 </span>
<span class="hljs-comment">//申请连麦</span>
s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'applyMic'</span>,<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
        <span class="hljs-keyword">let</span> targetUid = data[<span class="hljs-string">'targetUid'</span>]
        <span class="hljs-title function_">oneToOne</span>(targetUid,<span class="hljs-title function_">getMsg</span>(<span class="hljs-string">'applyMic'</span>,<span class="hljs-string">"apply mic"</span>,<span class="hljs-number">200</span>,data))
})
<span class="hljs-comment">//同意</span>
s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'acceptApplyMic'</span>,<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
        <span class="hljs-keyword">let</span> targetUid = data[<span class="hljs-string">'targetUid'</span>]
        <span class="hljs-title function_">oneToOne</span>(targetUid,<span class="hljs-title function_">getMsg</span>(<span class="hljs-string">'acceptApplyMic'</span>,<span class="hljs-string">"acceptApplyMic mic"</span>,<span class="hljs-number">200</span>,data))
})
<span class="hljs-comment">//拒绝</span>
s.<span class="hljs-title function_">on</span>(<span class="hljs-string">'refuseApplyMic'</span>,<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
        <span class="hljs-keyword">let</span> targetUid = data[<span class="hljs-string">'targetUid'</span>]
        <span class="hljs-title function_">oneToOne</span>(targetUid,<span class="hljs-title function_">getMsg</span>(<span class="hljs-string">'refuseApplyMic'</span>,<span class="hljs-string">"refuseApplyMic mic"</span>,<span class="hljs-number">200</span>,data))
})


<span class="hljs-comment">//客户端（包括主播和观众端 连接同一个socket服务器）并监听对应事件</span>
<span class="hljs-title function_">applyMic</span>(<span class="hljs-params"></span>){
      <span class="hljs-keyword">let</span> tid =  <span class="hljs-title function_">getParams</span>(<span class="hljs-string">'tid'</span>)<span class="hljs-comment">//主播ID</span>
      <span class="hljs-keyword">let</span> params ={        <span class="hljs-string">"userId"</span>: <span class="hljs-title function_">getParams</span>(<span class="hljs-string">'userId'</span>),<span class="hljs-string">"targetUid"</span>:tid,<span class="hljs-attr">streamId</span>:<span class="hljs-title function_">getParams</span>(<span class="hljs-string">'userId'</span>)+<span class="hljs-string">'-'</span>+tid}
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">linkSocket</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'applyMic'</span>,params)
}
</code></pre>
<ol start="2">
<li>主播同意。同意后直接先根据观众发的流拉流即可。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45407c0a23594a67abb25e6f81a0647c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">if</span>(e[<span class="hljs-string">'type'</span>] === <span class="hljs-string">'applyMic'</span>){
    <span class="hljs-comment">//自动同意 根据自己的业务调整 这里我设置的是有连麦直接同意</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">params</span> ={ <span class="hljs-string">"userId"</span>: getParams(<span class="hljs-string">'userId'</span>),<span class="hljs-string">"targetUid"</span>:e.data.userId}
    that.linkSocket.emit(<span class="hljs-string">'acceptApplyMic'</span>,<span class="hljs-keyword">params</span>)
    <span class="hljs-keyword">let</span> remoteStreamId = e.data.streamId
    <span class="hljs-comment">//直接拉流即可 等有流推进来则自动会加载出来</span>
    that.$refs[<span class="hljs-string">'srsRtcPullApplyMic'</span>].getPullSdp(remoteStreamId)
}
</code></pre>
<ol start="3">
<li>观众端收到同意后开始推流。这一步就是普通的 WebRTC 直接推流即可。</li>
<li>主播端稍等即可加载出画面，开始双向通话。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03d9212a33654303a6031b72d1e5c702~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>至此我们的主播连麦完成了。</p>
<h2>项目演示</h2>
<ol>
<li>打开项目，主播访问下面模块：</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82cdb3b92487434d985da81ff7a8f8fd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>但是请注意启动后台，<code>socket-server</code>文件夹中的后台。</p>
<p>然后携带请求参数访问：</p>
<pre><code class="hljs language-arduino"><span class="hljs-comment">//指定房间号和用户ID  如果在自己的改造项目中可以写表单然后进行下一步 这里我为了演示 直接在URL携带参数</span>
http:<span class="hljs-comment">//localhost:8082/srs-rtc-push?userId=999&#x26;roomId=111</span>
</code></pre>
<ol start="2">
<li>点击推流，右上角则会直接用 RTC 去拉流预览，成功则自动会在直播预览那里显示画面，否则会弹出失败提示框。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bdb51a103fd441fbe53c8d016c4faea~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<ol start="3">
<li>点击麦克风或者摄像头切换，以及屏幕分享可以查看右上角预览画面变更（注意默认右上角画面是静音的，请手动开启）。</li>
<li>访问直播间模块页面，携带参数为推流页面的流 ID。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/265552927b37403982785bbb9ae60c6f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<pre><code class="hljs language-arduino"><span class="hljs-comment">//携带个人信息+直播间流ID+tid(主播ID)</span>
http:<span class="hljs-comment">//localhost:8082/srs-live-room?liveroomid=localStream-1673368291508&#x26;tid=999&#x26;userId=1010&#x26;roomId=111</span>
</code></pre>
<ol start="5">
<li>点击页面右侧“申请连麦”，观察推流模块画面以及当前页面控制台。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccfdd5221eb44fe3bf82bf09c2b4026c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>本节相关源码</h2>
<p><a href="https://github.com/wangsrGit119/suke-webrtc-course/blob/main/webrtc-link-demo/src/views/srs-rtc-push.vue" target="_blank" rel="nofollow noopener noreferrer">相关源码地址</a></p>
<h2>课后题</h2>
<p>在申请连麦那里我做了简化，直接自动同意连麦人员画面，在实际过程中肯定是不行的，请大家优化这个步骤，比如实现主播同意、拒绝的弹窗提醒等。</p></div>
</body></html>