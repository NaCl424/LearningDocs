<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>因为 DRY，所以 HOF</h1>
<blockquote>
<p>标题注解：DRY(Don't Repeat Yourself) 是一种软件设计原则，HOF(High Order Function)指高阶函数。</p>
</blockquote>
<h2>李雷的前端生涯第一课</h2>
<p>在展开 DRY 和 HOF 这两个话题之前，我们不妨先来看一个发生在实际研发过程中的案例。</p>
<p>（以下案例基于作者在现实生活中的工作经历，如有雷同，纯属缘分~）</p>
<h3>李雷很累，我很困惑</h3>
<p>两年前，我所在的团队启动了一个性能监控的技术专项。</p>
<p>其中涉及到一个和函数计算相关的监控指标，期望可以拿到业务中每个函数的执行时间，以此来估算整体的前端计算效率。</p>
<p>我把这个活交给了团队刚来的实习生小伙子李雷。</p>
<p>我说：小兄弟，这个不着急，接下来一周可以慢慢做，慢工才能出细活嘛。</p>
<p>李雷：没问题，请好吧您。</p>
<p>就这样，一周过去了。</p>
<p>这天我写完周报，转悠到李雷的工位，想看看功能实现得咋样了。</p>
<p>我问李雷：这周感觉怎么样？你这边没有啥业务需求，应该挺轻松的吧？</p>
<p>李雷：轻松个锤子，我快累死了！怪不得外面都说你们团队卷，这么繁重的工作只给我一周，我都想离职了！</p>
<p>这，一周写一个函数，繁。重。。。？</p>
<p>我大受震撼。</p>
<p>说话间，我立刻拉取了李雷的 remote dev 分支，开始帮他做 code review。</p>
<h3>李雷的代码，我很头大</h3>
<p>我随手点开了一个已经被李雷改造过的业务函数，它差不多长这样（解析在注释里）：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// monitor 指代我们团队自研的性能上报sdk（虽然它实际不叫这个名字），大家意会一下即可</span>
<span class="hljs-keyword">import</span> monitor <span class="hljs-keyword">from</span> <span class="hljs-string">'monitor'</span>  

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">computeOrderAmount</span>(<span class="hljs-params">xxx, xxx</span>) {
  <span class="hljs-comment">// 开始时间打点</span>
  <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()  
  <span class="hljs-comment">// 中间是一段超级长的业务逻辑，此处以...省略</span>
  ... 
  ...  

  <span class="hljs-comment">// 结束时间打点</span>
  <span class="hljs-keyword">const</span> endTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()  

  <span class="hljs-comment">// 调用 monitor，第一个入参标识上报类型，第二个入参是需要上报的时间信息</span>
  monitor.<span class="hljs-title function_">report</span>(
    <span class="hljs-string">'function-compute-time'</span>,
    <span class="hljs-comment">// 结束时间 - 开始时间，就得到了函数执行需要的时间</span>
    endTime - startTime  
  )
}
</code></pre>
<p>上面是一个脱敏了 N 次之后的极简版本，在实际上报过程中，我们不仅会收集函数的执行时间，还会上报函数的业务归属、函数的执行上下文、以及一些更加细致琐碎的信息。</p>
<p>也就是说，虽然这里大家只看到了 3 行有意义的上报代码，但实际情况下，每个函数里和监控上报有关的代码增量估计在 10-20 行之间。</p>
<p>李雷是怎么做的呢？</p>
<p>他给业务里的每一个函数，都增加了 10-20 的监控代码。</p>
<p>那么我们的业务里一共有多少个函数呢？</p>
<p>保守估计，应该有 1000+。</p>
<p>我问李雷：你是打算用一周的时间徒手写两万行代码吗？</p>
<p>李雷义愤填膺：啊？那不然嘞？</p>
<p>我叹了一口气：朋友，你听说过安利DRY吗？</p>
<p>李雷一脸错愕：啥？搁这儿背单词了？ Dry 我知道，形容词，adj，干燥的！</p>
<p><del>我直接好家伙</del>我直接放弃挣扎， 打开 VSCode 给他出了一道题。</p>
<h3>小试牛刀：对一个数组进行自定义迭代计算</h3>
<p>题目——使用原生 JS，实现如下三个函数：</p>
<ol>
<li>迭代做加法：函数入参为一个数字数组，对数组中每个元素做 +1 操作，并把计算结果输出到一个新数组 <code>newArr</code>。<br>
fe：输入<code> [1,2,3]</code>，输出<code> [2,3,4]</code></li>
<li>迭代做乘法：函数入参为一个数字数组，对数组中每个元素做 *3 操作，并把计算结果输出到一个新数组 <code>newArr</code>。<br>
fe：输入<code> [1,2,3]</code>，输出 <code>[3,6,9]</code></li>
<li>迭代做除法：函数入参为一个数字数组，对数组中每个元素做 /2 操作，并把计算结果输出到一个新数组 <code>newArr</code>。<br>
fe：输入 <code>[2,4,6]</code>，输出 <code>[1,2,3]</code></li>
</ol>
<p>这题不难，李雷刷刷两下就做完了，他交出的代码如下：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 迭代做加法</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">arrAdd1</span>(<span class="hljs-params">arr</span>) {
  <span class="hljs-keyword">const</span> newArr = []  
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&#x3C;arr.<span class="hljs-property">length</span>; i++) {
    newArr.<span class="hljs-title function_">push</span>(arr[i]+<span class="hljs-number">1</span>)
  }
  <span class="hljs-keyword">return</span> newArr
}  

<span class="hljs-comment">// 迭代做乘法 </span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">arrMult3</span>(<span class="hljs-params">arr</span>) {
  <span class="hljs-keyword">const</span> newArr = []  
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&#x3C;arr.<span class="hljs-property">length</span>; i++) {
    newArr.<span class="hljs-title function_">push</span>(arr[i]*<span class="hljs-number">3</span>)
  }
  <span class="hljs-keyword">return</span> newArr
} 

<span class="hljs-comment">// 迭代做除法</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">arrDivide2</span>(<span class="hljs-params">arr</span>) {
  <span class="hljs-keyword">const</span> newArr = []  
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&#x3C;arr.<span class="hljs-property">length</span>; i++) {
    newArr.<span class="hljs-title function_">push</span>(arr[i]/<span class="hljs-number">2</span>)
  }
  <span class="hljs-keyword">return</span> newArr
} 

<span class="hljs-comment">// 输出 [2, 3, 4]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">arrAdd1</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]))   
<span class="hljs-comment">// 输出 [3, 6, 9]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">arrMult3</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])) 
<span class="hljs-comment">// 输出 [1, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">arrDivide2</span>([<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]))  
</code></pre>
<p>我们可以看到，这三个函数的输出都是符合预期的，代码逻辑也没有毛病。</p>
<p>问题出在代码的设计上，李雷忘记了 DRY 原则。</p>
<h2>什么是 DRY 原则？</h2>
<p>DRY 是一个缩写，全拼是 Don't Repeat Yourself。</p>
<p>直译过来，就是“不要重复你自己”</p>
<p>这是一个重要的设计原则，也是程序员的基本行事准则。</p>
<p>具体到编码上来，就是提醒我们，不要做重复的工作，不要把同一段代码写N次。</p>
<p>当我们多次遇到同一个问题，多次用到重复的解法时，我们就应该把重复的这部分提取出来，而不是 ctrl-c + ctrl-v 四处复制粘贴。</p>
<h2>DRY 原则的 JS 实践：HOF(高阶函数）</h2>
<p>现在我们本着 DRY 的原则，对李雷的答案做一波改造。</p>
<p>实践 DRY 原则最重要的一点，就是将“变与不变”分离。这也是我在设计模式小册中反复跟大家强调的一个核心的设计原则。</p>
<p>就李雷的代码来说，“变与不变”分别对应哪些逻辑？</p>
<p>很明显，对于这三个函数来说，迭代loop、数组push动作都是一毛一样的，变化的仅仅是循环体里的数学算式而已。</p>
<p>数学算式是“变”，其余逻辑是“不变”。</p>
<p>我们把不变的逻辑提取出来，代码如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">arrCompute</span>(<span class="hljs-params">arr</span>) {
  <span class="hljs-keyword">const</span> newArr = []  
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&#x3C;arr.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-comment">// xxx 指的是变化的算式</span>
    newArr.<span class="hljs-title function_">push</span>(xxx)
  }
  <span class="hljs-keyword">return</span> newArr
}
</code></pre>
<p>不变的代码，我们应该把它提取为一个通用的函数。</p>
<p>变化的部分怎么处理呢？</p>
<p>大家可以思考一下，对于一个函数来说，它的三个要素（入参、函数体、出参）里，哪些要素是动态的？</p>
<p>这时不妨回顾一下，什么是函数？函数就是下面这个东西：</p>
<pre><code class="hljs language-ini"><span class="hljs-attr">y</span> = f(x)
</code></pre>
<p>出参 <code>y</code> 是因变量，函数体 <code>f</code> 是计算逻辑，函数入参 <code>x</code> 就是自变量。</p>
<p>函数体一旦被定义了就无法再修改，所以，我们使用函数体来承接“不变”。</p>
<p>因变量和自变量都是动态可变的，但因变量变化的前提是自变量的变化。</p>
<p>自变量确定的情况下，因变量也是不变的。</p>
<p>因此，唯一可以用来承接“变”的要素，只有自变量。也就是函数的入参。</p>
<p>我们要想办法把变化的算式，作为一个入参传递给 <code>arrCompute()</code>。</p>
<p>在一些语言中，你或许可以直接把一坨计算逻辑作为入参传递给函数。但在 JS 的世界里，这是行不通的，要想把逻辑作为入参传递，我们必须把它包装成函数。</p>
<p>于是，本着“不变”构造成通用函数体，“变”包装成函数作为入参传递的原则，我们可以把李雷的代码改写成下面这样：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// +1 函数 </span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span>  
}  

<span class="hljs-comment">// *3函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">mult3</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num * <span class="hljs-number">3</span> 
}  

<span class="hljs-comment">// /2函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">divide2</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num / <span class="hljs-number">2</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">arrCompute</span>(<span class="hljs-params">arr, compute</span>) {
  <span class="hljs-keyword">const</span> newArr = []  
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&#x3C;arr.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-comment">// 变化的算式以函数的形式传入</span>
    newArr.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">compute</span>(arr[i]))
  }
  <span class="hljs-keyword">return</span> newArr
}

<span class="hljs-comment">// 输出 [2, 3, 4]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">arrCompute</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], add1))
<span class="hljs-comment">// 输出 [3, 6, 9]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">arrCompute</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], mult3)) 
<span class="hljs-comment">// 输出 [1, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">arrCompute</span>([<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>], divide2))  
</code></pre>
<p>这样一来，我们就用一种更简洁、更优美的姿势，实现了同样的功能。</p>
<p>其中的 <code>arrCompute()</code> 函数，就是一个高阶函数。</p>
<p><strong>高阶函数，指的就是接收函数作为入参，或者将函数作为出参返回的函数。</strong></p>
<h2>WHY HOF——高阶函数改造前后对比</h2>
<p>既然实现的都是同样的功能，为什么我们程序员一定要 DRY、为什么用高阶函数来做就比复制粘贴梭哈更好呢？</p>
<p>我们从几个不同的角度来聊聊这个话题。</p>
<h3>更简洁的代码，方便读写</h3>
<p>别的不说，咱就直接先看楼上的这个例子。</p>
<p>对比数组计算这几个函数，改造后的代码，给人最直接的感受，就是比改造前的代码要简洁许多。</p>
<p>这个 case 里我们提取的公共逻辑不算很复杂，实际上越复杂的公共逻辑，提取前后的代码行数对比越明显。</p>
<p>通过抽取重复的逻辑到高阶函数里，我们可以减少大量复制粘贴带来的冗余代码。</p>
<p>更少的代码，意味着更小的编码负担，更好的可读性。</p>
<h4>更小的编码负担</h4>
<p>对于李雷的性能上报任务来说，1000个函数，每个函数里人肉增加 20-30 行重复代码，也要写上几万行。</p>
<p>若能提取一个高阶函数出来，那么他最多只需要给 1000 多个函数逐个包装一层高阶函数的调用。</p>
<p>几万行 vs 1000多行，四舍五入等于不用写代码（狂笑）。</p>
<h4>更好的可读性</h4>
<p>这里我并不是说只有高阶函数能够改善代码的可读性，而是说你提取任意逻辑到一个函数里、然后给它起一个恰当的名字，都能够改善代码的可读性。</p>
<p>仍然是性能上报这个 case，如果我们不提取代码到高阶函数里，那么同事读到李雷改造过的业务代码，他的反应估计是这样的：</p>
<p>这里看上去好像被新来的那个小伙子改过了，我来看看具体改了啥。额，1-10行，好像是打了一些时间戳、记录了一些业务上下文；额，倒数后 20 行，好像是在调用性能 sdk，上报一些参数......喔，这原来是在做性能上报啊！</p>
<p>同事不得不逐行阅读李雷写的每一行代码，才能够推测出他的意图，<strong>因为这段逻辑没有一个名字</strong>。</p>
<p>而定义函数的过程，恰恰就是给一段逻辑起名字的过程啊，家人们！</p>
<p>我给这段性能上报的逻辑起名叫 performanceReport，然后在任何一个业务函数调用时，都用 performanceReport 这样包裹它一下：</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">performanceReport</span>(anyFunction)
</code></pre>
<p>这样一来，是不是地球人都能一眼看出来，我这里要做性能上报了？</p>
<p>这，就是可读性。</p>
<h3>代码可复用，利人利己</h3>
<p>用高阶函数，最直接的目的就是为了能够复用代码，减少重复，避免复制粘贴。</p>
<p>对于李雷来说， 他自己写的代码，自己自然是熟悉的，复制粘贴顶多算是一个体力活。</p>
<p>但如果明天韩梅梅想写一个类似的功能，她就不得不自己重新实现一遍李雷写过的逻辑。</p>
<p>对于性能上报这个场景来说，这是我分配给李雷的一个技术专项，如何完成上报、如何调用app底层的性能sdk，按道理其它同事不需要去关注这其中的实现细节。</p>
<p>但由于李雷没有去做逻辑的提取，导致韩梅梅不得不深入到李雷改造的每一个函数中，去看实现的细节，然后再把这些实现的细节搬运到自己的函数里。</p>
<p>实践 DRY 原则，不仅仅是为了方便自己的工作，也是为了提升整个团队的研发效率。</p>
<h3>清晰的逻辑边界，更少的测试工作</h3>
<p>咱们说了，对于李雷来说， 他自己写的代码，自己自然是熟悉的，复制粘贴顶多算是一个体力活。</p>
<p>但，谁能保证复制粘贴的过程，不会出错呢？</p>
<p>有没有可能，李雷在某个业务函数 A 里多贴了一行，在另一个业务函数 B 里少贴了一行，甚至在业务函数 C 里不小心把性能上报代码揉进业务代码里去了，干扰了业务层面的输出。</p>
<p>这些都是很有可能的，因为李雷是人，人远没有计算机可靠。</p>
<p>因为不可靠的人类无法保证每一个函数的质量，测试就不得不对 1000 多个函数做全面的回归。</p>
<p>但实际上，业务函数本身是不变的，我们的本意仅仅是在原有的基础上做一个性能上报的增量而已。</p>
<p>也就是说，讲道理，如果我们研发能够提前把变与不变通过函数的形式划分清楚，那么测试根本不需要做那么多重复的工作，他只需要对增量部分的函数（也就是高阶函数 performanceReport）做测试就可以了。</p>
<h2>总结</h2>
<p>本节，我们从一个实习生小兄弟的乌龙事件讲起，从解法、原则、动机等几个方面，全面认识了高阶函数这个东西。</p>
<p>事实上，高阶函数带来的利好，并不完全是高阶函数所特有的。</p>
<p>确切来说，这些利好是 DRY 原则带来的，是将“变与不变”明确分离的思维习惯带来的。</p>
<p>无论是设计模式，还是函数式编程，我总在反复强调“变与不变分离”这回事。在我看来，这一点，可以说是“如何写出好代码”这个问题的终极要义。</p>
<p>在接下来的几个小节中，我们还会接触到更多的函数式编程之“术”。彼时，相信大家会对这一点有更深刻的感悟。</p>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p></div>
</body></html>