<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>“安全帽”的使用哲学——不可变数据实践指南</h1>
<p>在上一节，我们围绕“什么是不可变数据”这个话题进行了深入的探讨，并建立了不可变数据和函数纯度之间的关联关系。我们已经明确知道，<strong>要想写出好的函数式代码，就需要确保数据的不可变性。</strong></p>
<p>理解了“what”和“why”的问题，本节我们来好好聊一下“how”。</p>
<h2>“不可变”不是要消灭变化，而是要控制变化</h2>
<p>大家知道，我们现代前端应用的复杂度整体是比较高的，其中最引人注目的莫过于“状态的复杂度”。</p>
<p>“状态”其实就是数据。</p>
<p>一个看似简单的 H5 营销游戏页面，背后可能就有几十上百个状态需要维护，如果没有状态之间的相互作用、相互转化，又怎能将精彩纷呈的前端交互呈现给用户呢？</p>
<p>程序失去变化，宛如人类失去灵魂。</p>
<p>所以咱们说，消灭变化是不可能的事情，也是万万不可的事情。</p>
<p>我们真正要做的，是<strong>控制变化，确保所有的变化都在可预期的范围内发生</strong>，从而防止我们的程序被变化“偷袭”。</p>
<p>正如老话所说：不怕他来，就怕他乱来。</p>
<p>我们本节要学习的，正是“不让他有机会乱来”的技术。</p>
<h2>名不副实的 "constant"</h2>
<p>首先，你需要小心 constant。</p>
<p>我至今仍然记得，“const” 关键字首次被引入 JavaScript 的那一年，函数式编程社区的 JS 开发者几乎集体高潮——不少人都认为，const 是对 JS 语言特性的一次重大改进，它将从根本上限制开发者的reassign（重新赋值）操作，进而保障数据的不可变性。</p>
<p>然而，理想很丰满，现实很骨感。const 真的能够保证数据的不变性吗？我只能说，const 了，但没完全 const（此处应有苦笑）。</p>
<p>众所周知，const 其实是单词“constant”的缩写，而“constant”意为“不变的”。如果我说，“the price is constant”，那么我想表达的就是“价格是不变的”：我早上去买是10块钱一斤，晚上去买也应该是10块钱一斤。</p>
<p>也就是说，假如我们单纯从<strong>语义上</strong>来理解“const”这个关键字，那么它确实应该为我们保障数据的不变性。</p>
<p>但语义归语义，现实情况是，<strong>const 只能够保证值类型数据的不变性，却不能够保证引用类型数据的不变性。</strong></p>
<p>对于值类型来说，我这里用 <code>const</code> 创建一个变量 <code>price</code>，并将它赋值为一个值类型（Number）数据：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> price = <span class="hljs-number">10</span>
</code></pre>
<p>如果我想修改 <code>price</code> 的值，我只能尝试对它进行 reassign（重新赋值），比如这样：</p>
<pre><code class="hljs language-js">price = <span class="hljs-number">20</span>
</code></pre>
<p>显然，如下图所示，这是行不通的，毕竟我们的 <code>const</code> 生下来就是专门阻止你做 reassign 这个动作的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a98fab8e8c1431b82c1cf30194d7d19~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>只要禁止了 reassign， 就堵死了修改值类型变量的唯一一条路，也就确保了其数据内容的不变性。</p>
<p>因此，对于存储值类型数据的变量来说，<code>const</code> 确实能够确保其内容的不变性。</p>
<p>但对于引用类型来说，就算堵住了 reassign，也不影响我们修改数据的内容。 比如这段代码就是不会抛错的：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> me = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'xiuyan'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
}

<span class="hljs-comment">// 这一行不会报错</span>
me.<span class="hljs-property">age</span> = <span class="hljs-number">35</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(me)
</code></pre>
<p>在这个案例中，我同样是使用 <code>const</code> 关键字创建了变量 <code>me</code>，但在尝试修改 me 的内容时，我并没有将一个新的对象 reassign 给 me 变量，而是使用“.age”语法来访问并修改既有对象的其中一个属性。</p>
<p><code>const</code> 没想到啊，引用类型的数据内容改变居然根本不需要 reassign。没有了 reassign，<code>const</code> 察觉不到变化的发生，也就只能原地摆烂了。</p>
<p>因此，<strong><code>const</code> 对数据不变性的保证是有前提的，对于引用类型来说，const 并没有什么卵用</strong>。</p>
<p>事实上，由于值类型数据天然存在不可变性，当我们讨论“JS 数据不可变性”时，更多的其实就是在讨论如何保证【引用类型】数据的不可变性。</p>
<h2>不可变数据の实践原则：拷贝，而不是修改</h2>
<p>既然 constant 指望不上，那么我们有什么办法来确保引用类型数据的不可变性呢？</p>
<p>答案也很简单，大家只需要记住一个原则：<strong>不要修改，要拷贝。</strong></p>
<h3>拷贝行为实践：安全、快速、药到病除</h3>
<p>这里我们继续沿用上一节招聘平台的例子，首先我有一个编号为001的岗位，它的主要信息囊括在这样一个对象里：</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">const</span> JOB_INFO_001 = {level: <span class="hljs-number">7</span>, workTime:<span class="hljs-number">2</span> , <span class="hljs-keyword">type</span>:<span class="hljs-string">'engineer'</span>, city:<span class="hljs-string">'New York'</span>} 
</code></pre>
<p>某天，hr找到我说，想要给代码里添加这样一段动态增加新职位的逻辑：</p>
<ol>
<li>首先确认公司当前的高管职位总数是否少于一定的阈值，从而决定要增加的新职位是高管职位还是基础职位 (这里我们假定有一个现成的函数可以使用，它叫做 <code>isHighPosition()</code>）</li>
<li>如果 <code>isHighPosition()</code> 调用返回为 <code>true</code>，那么就动态地增加一个高管职位，这个职位基本所有信息都和某个现有的基础职位（此处以<code>001</code>为例）一致，只有 <code>level</code> 需要调整为 10。</li>
<li>否则，不增加高管职位，只增加一个基础职位（此处以<code>001</code>为例）。</li>
</ol>
<p>这个需求很简单，我们先来无脑实现一个粗糙版本：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 将 hr 的需求实现为函数 dynamicCreateJob()</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dynamicCreateJob</span>(<span class="hljs-params">baseJob</span>) {
  <span class="hljs-keyword">let</span> newJob = baseJob
  <span class="hljs-comment">// 判断当前是否需要增加一个高管职位</span>
  <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isHighPosition</span>()) {
      <span class="hljs-comment">// 针对高管职位，调整level信息</span>
      newJob.<span class="hljs-property">level</span> = <span class="hljs-number">10</span> 
  }
  <span class="hljs-keyword">return</span> newJob
}

<span class="hljs-comment">// 这里以 001 为例，对函数进行测试</span>
<span class="hljs-keyword">const</span> dynamicJob = <span class="hljs-title function_">dynamicCreateJob</span>(<span class="hljs-variable constant_">JOB_INFO_001</span>)
</code></pre>
<p>这个粗糙版本显然并没有遵循“不可变数据”的原则——它直接在 <code>baseJob</code> 的对象本体上进行了篡改，这将导致 <code>JOB_INFO_001</code> 的内容直接被覆盖，从而影响整个程序中所有引用到 <code>JOB_INFO_001</code> 的逻辑模块，导致这些模块集体“躺枪”。</p>
<p>人生建议：<strong>不要修改 baseJob，而是修改它的副本</strong>：</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// 将 hr 的需求实现为函数 dynamicCreateJob()</span>
function <span class="hljs-built_in">dynamicCreateJob</span>(baseJob) {
  <span class="hljs-comment">// 创建一个 baseJob 的副本</span>
  let newJob = {..<span class="hljs-selector-class">.baseJob</span>}
  <span class="hljs-comment">// 判断当前是否需要增加一个高管职位</span>
  <span class="hljs-built_in">if</span>(isHighPosition()) {
      <span class="hljs-comment">// 针对高管职位，调整level信息</span>
      newJob<span class="hljs-selector-class">.level</span> = <span class="hljs-number">10</span> 
  }
  return newJob
}

<span class="hljs-comment">// 这里以 001 为例，对函数进行测试</span>
const dynamicJob = <span class="hljs-built_in">dynamicCreateJob</span>(JOB_INFO_001)
</code></pre>
<p>这样一来，baseJob 和 newJob 就彻底变成了两个泾渭分明的对象了。我对 newJob 所做的任何修改，都不会影响到 baseJob。</p>
<p>通过拷贝，我们顺利地<strong>将变化控制在了 <code>dynamicCreateJob()</code> 函数内部</strong>，避免了对全局其它逻辑模块的影响。</p>
<h3>拷贝的目的：确保外部数据的只读性</h3>
<p>用拷贝代替修改后，<code>baseJob</code> 对于 <code>dynamicCreateJob()</code> 函数来说，成为了一个彻头彻尾的<strong>只读数据</strong>。</p>
<p>关于只读数据，如果你是一个函数式编程发烧友，你可能会在一些文章中读到过一种过度概括的观点：不可变数据的内涵就是创造并使用“只读数据”。</p>
<p>之所以说这种观点是过度概括的，是因为它少了一个“<strong>外部数据</strong>”的限定词。</p>
<p>正如我在开篇时强调的那样，如果一个程序里只有只读数据、而没有数据的变化，这个程序几乎无法做任何事情。</p>
<p>因此，无论是什么样的编程范式，<strong>只读数据都必须和可写数据共存</strong>。</p>
<p>对于函数式编程来说，<strong>函数的外部数据是只读的，函数的内部数据则是可写的</strong>。</p>
<p>对于一个函数来说，”外部数据“可以包括全局变量、文件系统数据、数据库数据、网络层数据等。有且仅有这些<strong>外部数据</strong>，存在【只读】的必要。</p>
<blockquote>
<p>注：由于纯函数只能通过参数获取数据，因此如果需要使用外部数据，就必须将其作为参数传递给函数。</p>
</blockquote>
<h2>小结</h2>
<p>本节，我们探讨了不可变数据的两种最直接的实践思路：对于值类型数据，我们可以使用 const 来确保其不变性；对于引用类型数据，我们可以使用拷贝来确保源数据的不变性。</p>
<p>这其中，引用类型数据的不可变性值得我们再三思考——拷贝是否是一个完美的解法？它背后是否隐藏着种种问题？有没有比拷贝更加高效的解法呢？</p>
<p>答案当然是有啦，下一节，我们就将讨论不可变数据的进阶解法中最有名的一个——Persistent Data Structure（持久化数据结构）。</p>
<h2>补充</h2>
<p>在本节，我们探讨了拷贝行为在函数式编程中的作用与意义，由此不难联想到另一个更加独立的命题：如何在 JS 中实现引用类型数据的拷贝？</p>
<p>这也是一道非常经典、也相对基础的面试题。</p>
<p>由于过于经典，相关的探讨在社区随处可见，有过面试经历的同学也基本都能对此信手拈来。这里我并不打算单独为其铺陈一个章节来叙述。</p>
<p>但对于不熟悉拷贝的同学，我想要给你以下的学习建议：</p>
<p>在本文的示例中，我使用了扩展运算符来拷贝一个简单的对象。</p>
<p>类似的，你也可以使用 Object.assign 接口来实现拷贝。</p>
<p>而对于数组，除了扩展运算符外，还有像 slice、concat、map 等实用的数组接口供你挑选。</p>
<p>当然啦，这还并非“拷贝”的全貌，若想学得精些，你还需要辨析深、浅拷贝的区别。</p>
<p>其中深拷贝的实现尤其耐人寻味，也经常作为大厂的笔试题出现。</p>
<p>学习深拷贝时，我建议你不仅要多吸收社区群众的智慧，更要善于向成熟的工具方法库进行学习，<a href="https://github.com/lodash/lodash" target="_blank" rel="nofollow noopener noreferrer">lodash</a> 的 deepClone 函数就是一个不错的教材。</p>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p></div>
</body></html>