<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>不可变数据：函数纯度的“安全帽”</h1>
<h2>JS 世界的“不可变数据”</h2>
<h3>值类型与引用类型</h3>
<p>“不可变”是对数据特征的描述，既然说到数据，咱们不妨再回头看一下 JS 世界里的 7 个数据类型：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>null</li>
<li>undefined</li>
<li>Symbol</li>
<li>Object</li>
</ul>
<blockquote>
<p>作者注：7种数据类型出自 《JavaScript 高级程序设计》第4版 ，截止小册发行日，ES 标准还新增了一个新的数据类型 BigInt，不过这个不影响我们后续的讨论</p>
</blockquote>
<p>JS中的数据类型，整体上来说只有两类：值类型（也称基本类型/原始值）和引用类型（也称复杂类型/引用值）。</p>
<p>其中值类型包括：String、Number、Boolean、null、undefined、Symbol。这类型的数据最明显的特征是<strong>大小固定、体积轻量、相对简单。</strong></p>
<p>而排除掉值类型，剩下的 Object 类型就是<strong>引用类型（复杂类型）</strong> 。这类数据相对<strong>复杂、占用空间较大、且大小不定。</strong></p>
<p>保存值类型的变量是按值访问的， 保存引用类型的变量是按引用访问的。这两类数据之间最大的区别，在于<strong>变量保存了数据之后，我们还能对这个数据做什么</strong>。</p>
<h3>不可变的值，可变的引用内容</h3>
<p><strong>值类型的数据无法被修改</strong>，当我们修改值类型变量的时候，本质上会创建一个新的值。</p>
<p>我们一起来看看下面这个例子：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>
<span class="hljs-keyword">let</span> b = a

<span class="hljs-comment">// true</span>
a === b

b = <span class="hljs-number">2</span>

<span class="hljs-comment">// false</span>
a === b
</code></pre>
<p>这段代码对应的控制台执行结果如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a2d0d2955944223a93f7196aca43637~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>当我把 <code>a</code> 赋值给 <code>b</code> 的时候，相当于在内存里开辟了一个新的坑位，然后将此时此刻的 a 值拷贝了一份、塞了进去。</p>
<p>从这一刻开始，<strong><code>a</code> 和 <code>b</code> 各据一坑，界限分明</strong>，谁也不会再影响谁。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfd10b5b86ff45cab8cf28e9211429a9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>当我修改 <code>b</code> 值的时候，相当于解除了 <code>b</code> 变量和旧的 <code>b</code> 值（也就是 <code>1</code>）之间的关联关系，然后建立了 <code>b</code> 变量和新的 <code>b</code> 值（也就是 <code>2</code>）之间的关联关系。此时 <code>b</code> 的值已经发生了变化，但 <code>a</code> 坑里的 <code>1</code> 纹丝不动。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01ebcd63effd49c0ad9a9aad5d8e99ad~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>在这整个过程中，出现的值有三个：<strong>a 值 = 1、b 值（初始值） = 1、b 值（修改后） = 2</strong>。</p>
<p>试想，我们能够把数字 <code>1</code> 修改为数字 <code>2</code> 吗？当然是不行的，1 就是 1，2 就是 2。我们最多只能调整数字 <code>1</code>、<code>2</code> 和变量 <code>b</code> 之间的映射关系。</p>
<p>也就是说，1、1、2 这三个数字<strong>从创建开始就不会再发生任何改变</strong>。</p>
<p>我们修改 b 值的时候，其实是在<strong>修改数字 1、2 与“b 变量”之间的关系</strong>，而并不是在修改数字本身。</p>
<p><strong>像数字类型这样，自创建起就无法再被修改的数据，我们称其为“不可变数据</strong>”。</p>
<p>对应到 JS 的数据分类上，“值类型”数据均为不可变数据。</p>
<p>但引用类型就没有那么好对付了。</p>
<p>在引用本身不变的情况下，引用所指向的内容是可以发生改变的。</p>
<p>请大家看下面这段代码：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> a = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'xiuyan'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
}

<span class="hljs-keyword">const</span> b = a


<span class="hljs-comment">// true </span>
a === b 

b.<span class="hljs-property">name</span> = <span class="hljs-string">'youhu'</span>   
 
<span class="hljs-comment">// true</span>
a === b 
</code></pre>
<p>对于引用类型来说，当我把 a 对象赋值给 b 时，并不会发生“开辟一个新的 b 对象坑位、放入一份 a 对象的副本”这种事——JS 会直接把 a 的引用赋值给 b（如下图）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35c6866721f84a1d8585b82bd5c965fb~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>引用类型的赋值过程，本质上是给同一块数据内容起一个新的名字。<br>
赋值结束后，a 和 b 都会指向内存中的同一块数据。而这个数据，是可以被修改的（如下图）：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0702eb197e44dc698d855fac378ccb3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p><code>b.name</code> 被修改后，a、b 两个引用的指向没有发生任何变化——坑还是那个坑，但是坑里存的对象的内容却不一样了。<br>
对于引用类型来说，我们总是可以像楼上这样，在数据被创建后，随时修改数据的内容。<br>
<strong>像这种创建后仍然可以被修改的数据，我们称其为“可变数据”。</strong></p>
<h2>为什么函数式编程不喜欢可变数据</h2>
<p>我们首先来看一个简单的例子。</p>
<h3>编码实例：可变数据如何“偷袭”我们的程序</h3>
<p>假如你和你的好兄弟老王共同维护公司的招聘网站。在基础层，老王负责开发一系列的工具函数；在业务层，你负责将基础层的工具函数进行组装，以实现具体的业务需求。</p>
<p>老王的写模块里有这样一个函数，它可以修改招聘需求中的“Level（层级）”信息：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeJobLevel</span>(<span class="hljs-params">jobInfo, level</span>) {
    <span class="hljs-keyword">const</span> newLevelJob = jobInfo
    newLevelJob.<span class="hljs-property">level</span> = level
    <span class="hljs-keyword">return</span> newLevelJob  
}    
</code></pre>
<p>而你的模块里有这样一个函数，它可以通过检验招聘需求中的层级信息，来检验这是否是一则面向高管群体的招聘。函数编码如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isHighLevelJob</span>(<span class="hljs-params">jobInfo</span>) {
    <span class="hljs-keyword">return</span> jobInfo.<span class="hljs-property">level</span> >= <span class="hljs-number">9</span>
}   
</code></pre>
<p>这个检验结果非常关键，它直接决定了这一条招聘需求的去向。</p>
<p>若 <code>isHighLevelJob()</code>判断某需求为高管需求，则此需求在发布时不会进入公司的招聘池，而是会直接被转发到猎头公司的招聘池。 相关的发布函数示意如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">releaseJobs</span>(<span class="hljs-params">jobList</span>) {
  jobList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">job</span>)=></span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isHighLevelJob</span>(job)){
      <span class="hljs-comment">// 转发给猎头公司</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 转发到公司内部的池子里去</span>
    }
  })
}
</code></pre>
<p>假设现存的招聘数据中已经有这样一条需求描述：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">JOB_INFO_001</span> = {<span class="hljs-attr">level</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">workTime</span>:<span class="hljs-number">2</span> , <span class="hljs-attr">type</span>:<span class="hljs-string">'engineer'</span>, <span class="hljs-attr">city</span>:<span class="hljs-string">'New York'</span>} 
</code></pre>
<p>这天你接到一个新的需求，内容是：<br>
想要创建一条各方面条件都和 <code>JOB_INFO_001</code> 一致，但是 level 为 10 的招聘需求 <code>JOB_INFO_002</code>。随后，将 <code>JOB_INFO_001</code> 和 <code>JOB_INFO_002</code> 一起发布。</p>
<p>于是你刷刷两下子，迅速组装出了这样一坨业务代码：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { changeJobLevel } <span class="hljs-keyword">from</span> <span class="hljs-string">'老王的模块'</span>
<span class="hljs-keyword">import</span> { isHighLevelJob, releaseJobs} <span class="hljs-keyword">from</span> <span class="hljs-string">'我自己的模块'</span>   

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">JOB_INFO_001</span> = {<span class="hljs-attr">level</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">workTime</span>:<span class="hljs-number">2</span> , <span class="hljs-attr">type</span>:<span class="hljs-string">'engineer'</span>, <span class="hljs-attr">city</span>:<span class="hljs-string">'New York'</span>} 

<span class="hljs-comment">// 基于 JOB_INFO_001，生成一个 level 为 10 的 JOB_INFO_002</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">JOB_INFO_002</span> = <span class="hljs-title function_">changeJobLevel</span>(<span class="hljs-variable constant_">JOB_INFO_001</span>, <span class="hljs-number">10</span>)   

<span class="hljs-comment">// 组装两条数据为一个发布数组</span>
<span class="hljs-keyword">const</span> releaseList = [<span class="hljs-variable constant_">JOB_INFO_001</span>, <span class="hljs-variable constant_">JOB_INFO_002</span>]

<span class="hljs-comment">// 发布两条数据</span>
<span class="hljs-title function_">releaseJobs</span>(releaseList, isHighLevelJob)
</code></pre>
<p>一段危险的业务代码就此完工。你兴冲冲地发布上线，结果却发现酿成大错——<code>JOB_INFO_001</code> 和 <code>JOB_INFO_002</code> 这两条需求竟然都被转发进了猎头需求池，公司的猎头预算瞬间翻了一倍。</p>
<p>经过上文对值类型和引用类型特性的回顾，相信许多同学早就看出了问题的所在——<code>changeJobLevel()</code> <strong>函数直接修改了入参</strong> <code>jobInfo</code> <strong>的内容</strong>，这导致 <code>JOB_INFO_001</code> 也发生了改变。</p>
<p>尽管 <code>changeJobLevel()</code> 在函数的第一行就象征性地把入参赋值给了一个新的变量“<code>newLevelJob</code>”，但这并没有什么卵用——正如我们在上文所分析的那样，对于 <code>Object</code> 类型来说，这样的赋值动作仅仅是把 <code>jobInfo</code> 的引用赋值给了 <code>newLevelJob</code> ，本质上相当于给同一个对象起了两个名字。</p>
<p>因此，<code>changeJobLevel()</code> 函数修改 <code>newLevelJob</code>，其实就是在修改 <code>JOB_INFO_001</code>。</p>
<p>同理，将 <code>JOB_INFO_001</code> 以传参的形式赋值给 <code>jobInfo</code> 的过程、以及将 <code>changeJobLevel()</code> 返回的对象赋值给 <code>JOB_INFO_002</code> 的过程，也都仅仅是“取新名字”的过程。</p>
<p>也就是说，在整段代码中，<code>jobInfo</code>、<code>newLevelJob</code>、<code>JOB_INFO_001</code> 和 <code>JOB_INFO_002</code> 这四个“名字”指向的对象其实是同一个。</p>
<p>因此，当 <code>changeJobLevel()</code> 执行完毕时，<code>JOB_INFO_001</code> 和 <code>JOB_INFO_002</code> 是严格等于的关系，它们共同指向一条 level 为 10 的招聘需求：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35138aa17ab0439ba6cb27ec6fd43a4c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>相应地，这两个变量都将会被校验为“高管需求”，并被转发至猎头需求池。</p>
<p>这就是一个典型的由可变数据所酿成的惨案。</p>
<h3>思考：可变数据的危险之处</h3>
<p>我们当然可以说，这个惨案是由老王一手造成的——他的函数编码不够规范，导致我们在上层的业务层进行调用时，无法达到预期的结果。</p>
<p>确实，老王跪了，他跪给了 JS 语言的灵活性，跪给了可变数据的不可捉摸。</p>
<p>他或许也曾经想过，要把外部变量和函数变量隔绝开，否则，他也没有必要在函数的第一行就重新做了一遍对象赋值。</p>
<p>只是，智者千虑也必有一失。他忘了，给对象穿个新马甲根本解决不了问题。如果可以，他一定会重新好好审视一遍<strong>可变数据的危险之处</strong>，那么他就会清醒地意识到，可变数据总是存在以下问题：</p>
<h4>可变数据使函数行为变得难以预测</h4>
<p>在上面这个案例中， <code>isHighLevelJob()</code> 方法是你写的，<code>changeJobLevel()</code> 方法是隔壁老王写的。<br>
你俩开发函数时各占用了一个分支，你本地自测如丝般顺滑，甚至老王自己的本地自测也如丝般顺滑（他很有可能只会校验 <code>changeJobLevel()</code> 本身的功能，而无法察觉到函数对外部环境的影响）。</p>
<p>当且仅当你们的代码一起进入主分支时，问题才会被暴露出来。<br>
也就是说，开发者对两个函数的行为的预测，在合入主分支后就失效了。</p>
<p>这正是可变数据带来的最根本的问题——<strong>不确定性</strong>。</p>
<p>可变数据会使数据的变化变得隐蔽，进而使函数的行为变得难以预测。</p>
<p>在函数式编程这种范式下，我们校验一个函数有效性的关键依据，永远是“<strong>针对已知的输入，能否给出符合预期的输出</strong>”，这样的校验非常清晰、且容易实现。</p>
<p>而可变数据的出现则将会使函数的作用边界变得模糊，进而导致使用者、甚至开发者自身都难以预测它的行为最终会指向什么样的结果。</p>
<p>毫无疑问，这也会大大增加测试的难度。</p>
<h4>可变数据使函数复用成本变高</h4>
<p>可变数据的存在，要求我们不得不在调用一个函数之前，先去了解它的逻辑细节、定位它对外部数据的依赖情况和影响情况，由此来确保调用动作的安全性。</p>
<p>但很多情况下，当我们使用某一个函数的时候，我们会默认它是一个黑盒——无论是我今天去 npm 上拉下来一个第三方包，还是说我去其他业务的文件夹下借隔壁老王写的函数来用，我们关注的都是这个<strong>函数的效用、函数的输入与输出，而不会去关注它的实现细节</strong>。</p>
<p>就好像我们使用酸奶机之前，最多读一下说明书，而不会拆开它的壳子研究一下它装了几根电阻丝一样。</p>
<p>因此，我们有必要确保，这个黑盒是可靠的、受控的。</p>
<p><strong>一个可靠、受控的黑盒，应该总是将变化控制在盒子的内部，而不去改变盒子外面的任何东西</strong>。<br>
这就像我们往酸奶机里倒入了酵母和牛奶，只期望它能产出酸奶，而不希望它引燃旁边的烤箱一样。</p>
<p>要想做到这一点，就必须<strong>把可变数据从我们的函数代码里铲除干净。</strong></p>
<h2>不可变数据的本质：函数纯度的“安全帽”</h2>
<p>行文至此，大家可能已经发现了一个华点—— <strong>“可变数据”带来的这些麻烦，和“副作用”带来的麻烦，长得还挺像。</strong></p>
<p>实际上，在我们编写函数的过程中，“可变数据”是最容易引发副作用的因素之一。强调“不可变数据”，实际上仍然是在强调函数的纯度—— <strong>“坚持纯函数，避免副作用</strong>”，这是函数式编程的实践<strong>宗旨</strong>。</p>
<p>“不可变数据”正如一顶牢牢扣在我们程序员脑袋上的<strong>安全帽</strong>，它从实践的角度，对我们的编码行为作出了更加具体的约束，确保我们能够最大限度地输出纯净、安全的代码。</p>
<p>在下一节，我们就将更进一步地探讨不可变数据，并掌握在 JS 世界里应用不可变数据的几种主要姿势。</p>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p></div>
</body></html>