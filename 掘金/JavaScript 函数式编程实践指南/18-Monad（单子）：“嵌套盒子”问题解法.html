<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Monad（单子）：“嵌套盒子”问题解法</h1>
<p>书接上回，我们已经知道，通过往 map 方法里“加料”，我们可以拓展 Functor 的能力，进而定制出不同类型的 Functor。</p>
<p>事实上，除了往 map 方法里“加料”以外，我们还有另一种拓展 Functor 的思路，那就是<strong>在保有 map 方法的基础上，往盒子里添加新的方法</strong>。</p>
<p>而 Monad，正是在这个思路上衍生出来的。</p>
<h2>何为 Monad？</h2>
<p>Monad 中文叫做“单子”，它是一种特殊的 Functor（函子）。</p>
<p>通过前面两节的学习，我们已经知道， Functor 是“一个实现了 map 方法的盒子”。</p>
<p>而 Monad，则是“一个实现了 flatMap 方法的 Functor”。</p>
<p>也就是说，<strong>Monad 是一个同时实现了 map 方法和 flatMap 方法的盒子</strong>。</p>
<p>这个 flatMap 又是何方神圣呢？</p>
<p>要理解 flatMap，我们首先要理解 Monad 的应用背景——“嵌套盒子”问题。</p>
<h2>“嵌套盒子”问题</h2>
<p>嵌套的盒子，这里指的是在 Functor 内部嵌套 Functor 的情况。</p>
<p>会导致嵌套 Functor 的场景有很多，这里我举两个比较典型的 case：</p>
<ul>
<li>
<p>线性计算场景下的嵌套 Functor —— Functor 作为另一个 Functor 的计算中间态出现</p>
</li>
<li>
<p>非线性计算场景下的嵌套 Functor —— 两个 Functor 共同作为计算入参出现</p>
</li>
</ul>
<h3>线性计算场景下的嵌套 Functor</h3>
<p>考虑这样一个函数：它接收一个用户 id 作为入参，用于检查该用户是否在用户列表中。如果是，则取 id 的前三位作为用户的默认昵称，并将昵称和id一起返回；否则，视为异常。</p>
<p>这个函数实现如下：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 这里省略 isExisted 的实现，大家知道它是用来检查 id 存在性的即可</span>
<span class="hljs-keyword">import</span> isExisted <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>  

<span class="hljs-keyword">const</span> <span class="hljs-title function_">getUser</span> = id => {  
  <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isExisted</span>(id)) {
    <span class="hljs-keyword">return</span> {
      id,
      <span class="hljs-attr">nickName</span>: <span class="hljs-title class_">String</span>(id).<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"User not found"</span>)
  }
}
</code></pre>
<p>借助 Maybe Functor，我们可以简单包装一下这个查找过程：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> isExisted <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>  

<span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserSafely</span> = id => {  
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> userInfo = <span class="hljs-title function_">getUser</span>(id)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Maybe</span>(userInfo)
  } <span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Maybe</span>(<span class="hljs-literal">null</span>)
  }
}
</code></pre>
<p>这里为了验证方便，我实现一个作弊版的 isExisted，这个函数将会在 id 为 3 的倍数时返回 true，在其他情况下返回 false：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isExisted</span> = id => id % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>
</code></pre>
<p>将这个 isExisted 代入楼上的示例代码，我们就可以检验 getUserSafely 的执行效果了：</p>
<pre><code class="hljs language-scss">const res = <span class="hljs-built_in">getUserSafely</span>(<span class="hljs-number">1110021</span>)  

<span class="hljs-comment">// 输出 'Maybe {[object Object]}'</span>
res<span class="hljs-selector-class">.inspect</span>()

<span class="hljs-comment">// 输出 {id: 1110021, nickName: '111'}</span>
res<span class="hljs-selector-class">.valueOf</span>()
</code></pre>
<p>经过这样一番调整后，findUser 函数在任何情况下都会返回一个 Maybe Functor。</p>
<p>这时，如果我想要在一个 Maybe Functor 的 map 方法中，调用这个 findUser 方法，比如这样：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> targetUser = {
  <span class="hljs-attr">id</span>: <span class="hljs-number">1100013</span>,  
  <span class="hljs-attr">credits</span>: <span class="hljs-number">2000</span>,  
  <span class="hljs-attr">level</span>: <span class="hljs-number">20</span>
}  

<span class="hljs-keyword">const</span> userContainer = <span class="hljs-title class_">Maybe</span>(targetUser)  

<span class="hljs-keyword">const</span> <span class="hljs-title function_">extractUserId</span> = user => user &#x26;&#x26; user.<span class="hljs-property">id</span>

<span class="hljs-keyword">const</span> userInfo = userContainer.<span class="hljs-title function_">map</span>(extractUserId)
                          .<span class="hljs-title function_">map</span>(getUserSafely)
</code></pre>
<p>这一波操作下来，最终得到的 userInfo 就会是一个嵌套的 Maybe Functor：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/486b3aa49706488298dde948dc85103f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>在这个例子中，我们看到的是一个线性的计算过程：</p>
<p>整个计算过程中，真正作为数据源存在的，有且仅有 targetUser，我们把 targetUser 放进 Maybe 盒子里，然后在这个盒子的基础上一次又一次地调用 map，对源数据 targetUser 做一次又一次的加工。</p>
<p>之所以会出现嵌套的 Functor，是因为在加工 targetUser 的过程中，出现了 getUserSafely() 这样一个返回 Functor 的函数。</p>
<p>这也就是所谓的“<strong>Functor 以计算中间态的形式出现</strong>”。</p>
<p>对于 map 接收的回调参数 f 来说，f 预期的入参往往是数据本身，而不是一个装着数据的盒子。</p>
<p>假设我在 findUser 之后还有一个 cryptoUser 的回调需要执行，也就是说要像下面这样延长原有的调用链：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">crypteUser</span> = (<span class="hljs-params">userInfo</span>) => {
  <span class="hljs-comment">// ..省略一些加密的具体逻辑</span>
}   

<span class="hljs-keyword">const</span> cryptedUserInfo = userContainer.<span class="hljs-title function_">map</span>(extractUserId)
                                   .<span class="hljs-title function_">map</span>(getUserSafely)
                                   .<span class="hljs-title function_">map</span>(crypteUser)	
</code></pre>
<p>cryptoUser 预期中的输入是一个包含了 id 和 nickName 的 user 对象，但实际上它得到的输入却是一个装有 user 对象的 Maybe Functor 盒子。</p>
<p>这显然是要出问题的。</p>
<p>那么如何在不破坏链式结构的前提下，打开这个盒子、把数据拿出来用呢？</p>
<p>大家可以先自己思考一下这个问题，这里我们对于解法先按下不表，继续来看嵌套盒子的另一种 case：非线性计算。</p>
<h3>非线性计算场景下的嵌套 Functor</h3>
<p>考虑这样一个函数：它用于计算一个学生的期末成绩，接收两个入参：学生的文化课分数（generalScore)，以及学生的体育课分数（healthScore）。将这两个分数分别乘以各自的权重（文化课对应权重High，体育课对应权重Low），最后得到一个总分。</p>
<p>函数实现如下：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 该函数将对给定 score 作权重为 high 的计算处理</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">highWeights</span> = score => score*<span class="hljs-number">0.8</span>

<span class="hljs-comment">// 该函数将对给定 score 作权重为 low 的计算处理</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">lowWeights</span> = (<span class="hljs-params">score</span>) => score*<span class="hljs-number">0.5</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">computeFinalScore</span> = (<span class="hljs-params">generalScore, healthScore</span>) => {
  <span class="hljs-keyword">const</span> finalGeneralScore = <span class="hljs-title function_">highWeights</span>(generalScore)  
  <span class="hljs-keyword">const</span> finalHealthScore = <span class="hljs-title function_">lowWeights</span>(healthScore)  
  <span class="hljs-keyword">return</span> finalGeneralScore + finalHealthScore
}
</code></pre>
<p>我们借助 Identity Functor 对这个计算流程进行改造如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">computeFinalScore</span> = (<span class="hljs-params">generalScore, healthScore</span>) => 
                        <span class="hljs-title class_">Identity</span>(<span class="hljs-title function_">highWeights</span>(generalScore))
                              .<span class="hljs-title function_">map</span>(
                                  <span class="hljs-function"><span class="hljs-params">finalGeneralScore</span> =></span> 
                                    <span class="hljs-title class_">Identity</span>(<span class="hljs-title function_">lowWeights</span>(healthScore))
                                      .<span class="hljs-title function_">map</span>(
                                        <span class="hljs-function"><span class="hljs-params">finalhealthScore</span> =></span> 
                                            finalGeneralScore + finalhealthScore
                                      )
                                )
</code></pre>
<p>在这个例子中，我们看到的是一个非线性的计算过程：</p>
<p>generalScore 和 healthScore 同时作为数据源存在，都是 computeFinalScore 函数的入参。从逻辑上来说，它们应该是平行的关系。</p>
<p>尽管盒子模式也能够支持逻辑上的平行关系，甚至能够支持异步。但盒子模式的调用总是链式的、线性的。</p>
<p>因此，当我们用盒子模式去实现非线性的计算过程的时候，就不得不像示例这样，把另一个数据源 healthScore 也包装成一个盒子，放进 generalScore 的 map 里面去。</p>
<p>这种情况下，也会导致嵌套 Functor 的产生。</p>
<h3>嵌套 Functor 的解法思考</h3>
<p>创建 Functor，是一个把数据放进盒子的过程。而消除嵌套，则是一个“打开盒子”的过程。</p>
<p>以线性计算示例中的 userInfo 为例，要打开这个盒子，我们需要执行两次 valueOf：</p>
<pre><code class="hljs language-js">userInfo.<span class="hljs-title function_">valueOf</span>().<span class="hljs-title function_">valueOf</span>()
</code></pre>
<p>这个写法，不优雅倒还是其次，关键是这多出来的 valueOf() 调用放在哪里合适呢？</p>
<p>放在下一个 map 的回调里吗？</p>
<p>假设我在 findUser() 之后还有一个 cryptoUser() 回调需要执行，是不是 cryptoUser() 就需要承担起“打开盒子”这个任务了？</p>
<p>但我的 cryptoUser 原本只是一个负责加密用户信息的函数，它没有义务去理解自己所在的执行上下文是什么样的，更没有必要为 findUser() 造成的问题买单。</p>
<p>硬要把“打开盒子”的任务交给 cryptoUser，反而会污染 cryptoUser 本身的逻辑。</p>
<p>咋办呢？</p>
<p>我们知道，在盒子模式中，盒子的【行为】大体上可以分为两类：</p>
<ul>
<li>回调函数的行为，也就是 map 方法中传入的那个 f。这个 f 是灵活可变的，我们可以通过 map 来组合各种各样不同的 f。我们把 f 记为“<strong>自定义行为</strong>”。</li>
<li>盒子本身预设的行为，比如 Functor 盒子中的 map。这个 map 的行为是确定的、不可变的，我们把这样的行为记作“<strong>基础行为</strong>”。</li>
</ul>
<p>既然“自定义行为”没法干这个“打开盒子”的活，我们就只能往“基础行为”上使使劲儿啦。</p>
<h2>flatMap：打开盒子，取出数据</h2>
<p>目前看来，我们需要的是这样一个“基础行为”：预期 map(f) 会返回一个嵌套的盒子，并且能够主动把套在里面那个盒子取出来。</p>
<p>说白了，不就是在 map 结束之后，再调一次 valueOf()么：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Monad</span> = x => ({
  <span class="hljs-attr">map</span>: <span class="hljs-function"><span class="hljs-params">f</span> =></span> <span class="hljs-title class_">Monad</span>(<span class="hljs-title function_">f</span>(x)),
  <span class="hljs-attr">valueOf</span>: <span class="hljs-function">() =></span> x,
  <span class="hljs-attr">inspect</span>: <span class="hljs-function">() =></span> <span class="hljs-string">`Monad {<span class="hljs-subst">${x}</span>}`</span>,

  <span class="hljs-comment">// 新增一个主动打开盒子的方法 flatMap </span>
  <span class="hljs-attr">flatMap</span>: <span class="hljs-function"><span class="hljs-params">f</span> =></span> <span class="hljs-title function_">map</span>(f).<span class="hljs-title function_">valueOf</span>()
})

<span class="hljs-keyword">const</span> monad = <span class="hljs-title class_">Monad</span>(<span class="hljs-number">1</span>) 
<span class="hljs-keyword">const</span> nestedMonad = <span class="hljs-title class_">Monad</span>(monad)  

<span class="hljs-comment">// 试试会发生什么？</span>
nestedMonad.<span class="hljs-title function_">flatMap</span>()
</code></pre>
<p>PS：截止目前，我们一直把“打开盒子”的函数叫做 valueOf()。其实这个函数在具体的实现中有很多名字，比如 join()、extract() 等等。大家平时读代码的时候能够意会就可以哈。</p>
<p>如果直接把这段代码丢进控制台运行，你将会得到这样一个报错：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39bd6458506a4c6b8fc6eec881e6c29f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>这是因为我们试图在 flatMap 中试图去调用另一个与它平级的对象方法 map，由于两个方法实际上并不在同一个上下文里，调用 map 的动作是注定要失败的。</p>
<p>这里就引出了盒子模式中的另一个重要的方法：of()。</p>
<h2>拓展：of 方法，OOP？FP？</h2>
<p>如何把一个盒子中的两个方法，放进同一个上下文里？</p>
<p>答案是创建一个 Class，像这样：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monad</span> { 
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = x
  }

  
  <span class="hljs-title function_">map</span>(<span class="hljs-params">f</span>) { 
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Monad</span>.<span class="hljs-title function_">of</span>(<span class="hljs-title function_">f</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span>)) 
  } 
  
  <span class="hljs-title function_">flatMap</span>(<span class="hljs-params">f</span>) { 
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">map</span>(f).<span class="hljs-title function_">valueOf</span>()
  }

  <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span>
  }
}

<span class="hljs-title class_">Monad</span>.<span class="hljs-property">of</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Monad</span>(val);
}  

<span class="hljs-keyword">const</span> monad = <span class="hljs-title class_">Monad</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>)  
<span class="hljs-keyword">const</span> nestedMonad = <span class="hljs-title class_">Monad</span>.<span class="hljs-title function_">of</span>(monad)  

<span class="hljs-comment">// 输出 Monad {val: 1}，符合“不嵌套”的预期</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nestedMonad.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =></span> x))
</code></pre>
<p>此情此景，你可能忍不住在心中默默祭出一声卧槽：</p>
<p>没想到啊，学了快 20 节函数式编程了，最后竟然又被 this 带回面向对象了？</p>
<p>其实，对于 JS 来说，FP 和 OOP 之间并没有想象中的那么泾渭分明。</p>
<p>有一些语言是天然有“人设”的，比如：当你写 Java 的时候，你就只想 OOP；当你写 Haskell 的时候，你就只想 FP。</p>
<p>相比之下，JS 就中庸得多了。</p>
<p>从语言实现的层面来说，它的 Function 就是 Object，Object 也是 Function......FP 和 OOP 之间俨然是一种“你中有我，我中有你”的暧昧关系。</p>
<p>从范式本身来看，我们写 FP 确实是要和 OOP 不一样的，这一点至少要在编码风格上体现出来。</p>
<p>也正是出于这个动机，FP 借助 Class 实现 Functor 和 Monad 这类盒子的时候，并不会把“我是一个 Class”这件事摆在明面上。</p>
<p>一个最典型的小细节，就是如上面这个示例一样，把构造函数的调用包装成一个 of 方法，以此来摆脱 <code>new XXX()</code> 这样高度不和谐的 OOP 代码。</p>
<h2>flatMap 的极简实现</h2>
<p>书归正传，其实在我们这个案例中，根本用不到 of 来创建上下文。</p>
<p>map 方法做了什么事情？map 方法执行了 f 回调，然后把执行结果 f(x) 放进了盒子里。</p>
<p>flatMap 想要做什么事情？flatMap 方法想要把这个执行结果 f(x) 从盒子里拿出来。</p>
<p>既然 flatMap 想要的是 f(x)，那它一开始直接不把 f(x) 往盒子里放不就行啦？</p>
<p>所以咱的 flatMap 也可以这样实现：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Monad</span> = x => ({
  <span class="hljs-attr">map</span>: <span class="hljs-function"><span class="hljs-params">f</span> =></span> <span class="hljs-title class_">Monad</span>(<span class="hljs-title function_">f</span>(x)),
  <span class="hljs-comment">// flatMap 直接返回 f(x) 的执行结果</span>
  <span class="hljs-attr">flatMap</span>: <span class="hljs-function"><span class="hljs-params">f</span> =></span> <span class="hljs-title function_">f</span>(x),

  <span class="hljs-attr">valueOf</span>: <span class="hljs-function">() =></span> x,
  <span class="hljs-attr">inspect</span>: <span class="hljs-function">() =></span> <span class="hljs-string">`Monad {<span class="hljs-subst">${x}</span>}`</span>,
})
</code></pre>
<p>整体的结构看上去很简单，实际上它也就是这么简单。</p>
<p>我们把非线性计算案例中 Identity Functor 替换成 Monad，map 替换成 flatMap，嵌套盒子的问题瞬间得解：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">computeFinalScore</span> = (<span class="hljs-params">generalScore, healthScore</span>) => 
                        <span class="hljs-title class_">Monad</span>(<span class="hljs-title function_">highWeights</span>(generalScore))
                          .<span class="hljs-title function_">flatMap</span>(
                            <span class="hljs-function"><span class="hljs-params">finalGeneralScore</span> =></span> 
                              <span class="hljs-title class_">Monad</span>(<span class="hljs-title function_">lowWeights</span>(healthScore))
                                .<span class="hljs-title function_">flatMap</span>(
                                  <span class="hljs-function"><span class="hljs-params">finalhealthScore</span> =></span> 
                                    finalGeneralScore + finalhealthScore
                                )
                            )

<span class="hljs-comment">// 输出计算结果： 210</span>
<span class="hljs-keyword">const</span> finalScore = <span class="hljs-title function_">computeFinalScore</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100</span>)  
</code></pre>
<p>这种感觉，就好像高中的时候做数学题。有时候苦思冥想大半天也只能憋出个“解”字，结果翻开标准答案一看，好家伙，也就两三行不等式就能做出来，不过如此嘛。</p>
<p>但我们都知道，答案本身并没有那么重要，重要的是我们如何去去解读它、吸收它，并且在下一次遇到类似题目时，还能想到它。</p>
<h2>总结：map VS flatMap</h2>
<p>写了这么多代码，我们最后来总结一下 flatMap 的特征。</p>
<p>flatMap 和 map 其实很像，区别在于他们对回调函数 <code>f(x)</code> 的预期：</p>
<p>map 预期 <code>f(x)</code> 会输出一个具体的值。这个值会作为下一个“基础行为”的回调入参传递下去。</p>
<p>而 flatMap 预期 <code>f(x)</code> 会输出一个 Functor，它会像剥洋葱一样，把 Functor 里包裹的值给“剥”出来。确保最终传递给下一个“基础行为”的回调入参，仍然是一个具体的值。</p>
<p>符合这个特征的方法不一定总是叫 flatMap，它有许多别名：chain、fold、flatten......等等等等。</p>
<p>不管这个方法叫啥，只要它在 Functor 的基础上，实现了楼上描述的这个“剥洋葱”般的逻辑，它都足以将一个 Functor 拓展为 Monad。</p>
<p>毕竟，盒子的本质，是一套“<strong>行为框架</strong>”。</p>
<p>决定一个盒子能否成为 Functor 或 Monad 的，并不是方法的命名，而是方法的<strong>行为</strong>。</p>
<blockquote>
<p>注：本节我们介绍了 Monad 最直观的作用：数据转换/解决嵌套盒子问题。其实，在软件生产实践中，Monad 还有一个更加广泛、更加实用的实践，那就是”<strong>把副作用放进盒子</strong>“。关于这点，我们在<a href="https://juejin.cn/book/7173591403639865377/section/7207809625310117927" target="_blank" rel="nofollow noopener noreferrer">第26节</a>会结合 RxJS 作详细的探讨。</p>
</blockquote>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p></div>
</body></html>