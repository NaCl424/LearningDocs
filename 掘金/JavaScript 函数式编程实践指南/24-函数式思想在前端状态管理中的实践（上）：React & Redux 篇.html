<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>函数式思想在前端状态管理中的实践（上）：React & Redux 篇</h1>
<p>时下流行的前端状态管理解决方案有很多，这里我想和大家探讨的是几个最具代表性的<strong>函数式状态管理解法</strong>，它们分别是：</p>
<ul>
<li>
<p><strong>React</strong> 状态管理中的“不可变数据”</p>
</li>
<li>
<p><strong>Redux</strong> 设计&#x26;实践中的函数式要素</p>
<ul>
<li>纯函数</li>
<li>不可变值</li>
<li>高阶函数&#x26;柯里化</li>
<li>函数组合</li>
</ul>
</li>
<li>
<p><strong>RxJS</strong> 对响应式编程与“盒子模式”的实践</p>
<ul>
<li>如何理解“响应式编程”</li>
<li>如何把副作用放进“盒子”</li>
</ul>
</li>
</ul>
<h2>React 状态管理中的“不可变数据”</h2>
<p>众所周知，“不可变值/不可变数据”是 React 强烈推荐开发者遵循的一个原则。这个原则在 React 中被应用于 React 组件的状态（state）和属性（props），这些数据一旦被创建，就不能被修改，只能通过创建新的数据来实现更新。</p>
<blockquote>
<p>“不可变数据”的内涵我们在<a href="https://juejin.cn/book/7173591403639865377/section/7175421412025303100" target="_blank" rel="nofollow noopener noreferrer">第 6 节</a>-<a href="https://juejin.cn/book/7173591403639865377/section/7175422876495904827" target="_blank" rel="nofollow noopener noreferrer">第 10 节</a>已经有过非常深入的探讨，此处不再赘述。</p>
</blockquote>
<h3>表象：“不可变数据”确保 React 视图能够正常更新</h3>
<p>在 React 中，如果不遵循不可变数据的原则，可能会导致组件无法正常更新或出现一些不可预期的问题。下面是一个使用可变数据的 React 组件示例：</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MutableComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [items, setItems] = <span class="hljs-title function_">useState</span>([<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>])

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRemove</span> = (<span class="hljs-params">index</span>) => {
    <span class="hljs-comment">// 直接修改了原数组，违背了不可变原则</span>
    items.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>) 
    <span class="hljs-title function_">setItems</span>(items)
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
      {items.map((item, index) => (
      <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>></span>
        {item}
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> handleRemove(index)}>remove<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
    ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span></span>
  )
}
</code></pre>
<p>在这段代码中，<code>handleRemove</code> 函数直接修改了原始数组 <code>items</code>，然后又针对这个原始数组进行了一次新的<code>setState</code>操作（代码中对应 <code>setItems</code>函数）。这就违背了不可变数据的原则——在不可变原则下，React 预期我们针对新的状态创建一个全新的数组，以此来确保新老数据的不可变性。</p>
<p>这段实践了“可变数据”的代码会导致组件无法正常更新——我们的初衷是通过点击 remove 按钮来实现列表项的删除，但楼上这段代码呈现出的效果则是：无论我们点击多少次 remove 按钮，整个列表都不会发生任何的改变。</p>
<p><strong>为了避免这类问题出现，我们应该始终使用不可变数据。</strong></p>
<p>实现不可变数据的思路有很多，对于这个例子来说，最直接的一个思路就是在执行 <code>Array.prototype.splice()</code>方法之前，先对原始数组做一次拷贝，如代码所示：</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ImmutableComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [items, setItems] = <span class="hljs-title function_">useState</span>([<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'cherry'</span>])

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRemove</span> = (<span class="hljs-params">index</span>) => {
    <span class="hljs-comment">// 基于原始数组，创建一个新数组</span>
    <span class="hljs-keyword">const</span> newItems = [...items]  
    newItems.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>) 
    <span class="hljs-title function_">setItems</span>(newItems)
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
      {items.map((item, index) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>></span>
          {item}
          <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> handleRemove(index)}>remove<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span></span>
  )
}
</code></pre>
<p>在上面的代码中，<code>handleRemove</code> 函数基于不可变数据的原则，创建了一个新的数组 <code>newItems</code>，确保了新老状态的不可变性。<strong>在</strong><code>setState</code><strong>前后，新老状态相互独立、各有各的引用，这就是 React 所期待的“状态不可变”</strong> 。</p>
<blockquote>
<p>注：除了会导致视图更新失败之外，不遵循不可变数据原则还可能导致一些性能问题——因为 React 的性能优化依赖于对数据的比较，如果使用可变数据，React 就需要对每个可变数据进行深度比较，这样会消耗更多的时间和内存。因此，在<a href="https://zh-hans.reactjs.org/docs/optimizing-performance.html#the-power-of-not-mutating-data" target="_blank" rel="nofollow noopener noreferrer"> React 官方的性能优化建议</a>中，也给不可变数据记下了浓墨重彩的一笔。</p>
</blockquote>
<p>表象咱们看到了，那深层的原因又是什么呢？具体来说，<strong>为什么 React 就认准了不可变数据不撒手呢</strong>？</p>
<h3>内核：“数据-视图”间高度确定的函数式映射关系</h3>
<p>通过<a href="https://juejin.cn/book/7173591403639865377/section/7175423125817917495" target="_blank" rel="nofollow noopener noreferrer">第 23 节</a>的学习，我们已经知道，<strong>React 组件是一个吃进数据、吐出 UI 的【纯函数】。</strong></p>
<p><strong>纯函数</strong>意味着<strong>确定性</strong>，意味着严格的一对一映射关系，意味着<strong>对于相同的数据输入，必须有相同的视图输出</strong>。</p>
<p>在这个映射关系的支撑下，对于同一个函数（React 组件）、同一套入参（React 状态）来说，组件所计算出的视图内容必定是一致的。也就是说，<strong>在数据没有发生变化的情况下，React 是有权不去做【重计算】的</strong>。这也是我们可以借助<code>Pure Component</code> 和 <code>React.memo()</code> 等技术缓存 React 组件的根本原因。</p>
<p>React 之所以以“不可变数据”作为状态更新的核心原则，根源就在于它的<strong>函数式内核</strong>，在于它追求的是<strong>数据（输入）和视图（输出）之间的高度确定的映射关系</strong>——如果数据可变（注意，“可变”指的是引用不变，但数据内容变了），就会导致数据和 UI 之间的映射关系不确定，从而使得 React 无法确定“有没有必要进行重计算”，最终导致渲染层面的异常。</p>
<p>也就是说，<strong>React 组件的纯函数特性和不可变数据原则是相互支持、相互依赖的</strong>，它们的本质目的都是为了确保 React 的渲染过程高度确定、高度可预测，从而提高应用的性能和可维护性。</p>
<h2>Redux</h2>
<p>和 React 一样，Redux 在前端社区中也扮演了一个推广函数式编程的重要角色。从设计、实现到实践原则，Redux 由内而外地堆满了函数式编程的各种 buff，接下来我们要探讨的就是其中最核心的 5 个 buff：<strong>纯函数、不可变数据、高阶函数、柯里化和函数组合</strong>。</p>
<h3>纯函数</h3>
<p>在 Redux 中，所有的状态变化都是由纯函数（称为 <code>reducer</code>）来处理的，这些函数接收当前的状态（<code>state</code>）和一个 <code>action</code> 对象，返回一个新的状态。</p>
<p>下面是一个简单的示例，展示了 Redux 如何使用纯函数来更新状态：</p>
<pre><code class="hljs language-jsx"><span class="hljs-comment">// 定义初始状态</span>
<span class="hljs-keyword">const</span> initialState = {
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
};

<span class="hljs-comment">// 定义 reducer 函数，接收当前状态和动作对象，返回新状态</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counterReducer</span>(<span class="hljs-params">state = initialState, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"increment"</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }
    <span class="hljs-keyword">case</span> <span class="hljs-string">"decrement"</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> }
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
}

<span class="hljs-comment">// 创建 store，将 reducer 函数传入</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title class_">Redux</span>.<span class="hljs-title function_">createStore</span>(counterReducer)


<span class="hljs-comment">// 分发动作对象，触发状态变化</span>
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">"increment"</span> })
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">"decrement"</span> })
</code></pre>
<p>在上面的示例中，<code>counterReducer</code> 函数就是一个 <code>reducer</code>，它接收当前 <code>state</code>和一个 <code>action</code>对象作为入参，返回一个新的 <code>state</code>作为计算结果——Redux 的设计原则要求整个<code>reducer</code>的函数体<strong>除了计算、啥也不干</strong>，因此 <code>reducer</code>是标准的纯函数。</p>
<p>由于纯函数要求我们保持外部数据的不可变性，这里我们在更新 <code>count</code> 属性时，使用了扩展运算符来拷贝当前状态。这就又引出了我们喜闻乐见的“不可变数据”原则。</p>
<blockquote>
<p>注：由此可见，纯函数和不可变数据真的是一对好基友，它们总是相互支持、相互成就的。</p>
</blockquote>
<h3>不可变数据</h3>
<p>Redux 的不可变数据原则体现在它的 <code>state</code> 数据结构上。</p>
<p>Redux 要求我们在修改 <code>state</code> 时使用不可变数据——也就是创建一个新的 <code>state</code> 对象，而不是在原有的 state 上进行修改。这一点在楼上的示例中已经充分体现，此处不多赘述。</p>
<h3>高阶函数&#x26;柯里化</h3>
<p>在 Redux 中，高阶函数的应用非常广泛。在这里，我想重点展开来讲的是“Redux 中间件”这个东西，它不仅应用了高阶函数和柯里化的思想，同时和函数组合也有密不可分的关系。</p>
<p>在 Redux 中，中间件是一个函数，它【<strong>嵌套地</strong>】接收三个入参：<code>store</code>、<code>next</code>和<code>action</code>。其中，<code>store</code>是 Redux 唯一的状态树，<code>next</code>是一个函数，用于将当前 <code>action</code>传递给下一个中间件或者传递给 <code>reducer</code>，而 <code>action</code>则是当前需要处理的行为信息对象。</p>
<p>下面我实现了一个简单的 Redux 中间件，用来在状态更新的前后输出两行 log：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">loggerMiddleware</span> = (<span class="hljs-params">store</span>) => <span class="hljs-function">(<span class="hljs-params">next</span>) =></span> <span class="hljs-function">(<span class="hljs-params">action</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'dispatching the action:'</span>, action)
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">next</span>(action)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'dispatched and new state is'</span>, store.<span class="hljs-title function_">getState</span>())
  <span class="hljs-keyword">return</span> result
}

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer, <span class="hljs-title function_">applyMiddleware</span>(loggerMiddleware))
</code></pre>
<p>在这个例子中，我们定义了一个名为 <code>loggerMiddleware</code> 的中间件。它接收一个<code>store</code>对象，返回一个结果函数 A，A 函数接收一个 <code>next</code>函数，返回一个新的结果函数 B。这个结果函数 B 会接收一个 action 对象，最终执行完整个中间件逻辑，并返回执行结果。</p>
<p>通过观察 <code>loggerMiddleware</code>，我们注意到，它是 3 个相互嵌套的一元函数所构成的<strong>高阶函数</strong>，是一个被<strong>柯里化</strong>过的函数。</p>
<blockquote>
<p>注：柯里化是把 <strong>1 个 n 元函数</strong>改造为 <strong>n 个相互嵌套的一元函数</strong>的过程，它是高阶函数的一种应用，详见小册<a href="https://juejin.cn/book/7173591403639865377/section/7175423003319074876" target="_blank" rel="nofollow noopener noreferrer"> 15 节</a>。</p>
</blockquote>
<p>通过柯里化，Redux 中间件可以将参数相同的多次调用转化为单次调用，提高了代码复用性和可维护性，也为“延迟执行”（即在当前上下文先传递部分参数，等到后面确实需要执行的时候再传递剩余参数）提供了可能性。</p>
<h3>函数组合</h3>
<p>当我们需要组合多个中间件的能力时，就用上函数组合了。</p>
<p>以下是 Redux 中组合不同中间件的示例代码：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { createStore, applyMiddleware, compose } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span>
<span class="hljs-keyword">import</span> logger <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-logger'</span>

<span class="hljs-keyword">const</span> middleware = [thunk, logger, errorReport]

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(
  reducer,
  <span class="hljs-title function_">compose</span>(
    <span class="hljs-title function_">applyMiddleware</span>(...middleware),
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">__REDUX_DEVTOOLS_EXTENSION__</span> &#x26;&#x26; <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">__REDUX_DEVTOOLS_EXTENSION__</span>()
  )
)
</code></pre>
<p>上述代码中，我们将<code>thunk</code>、<code>logger</code>和<code>errorReport</code>这三个中间件函数通过 <code>compose</code> 函数组合起来，并使用<code>applyMiddleware</code>函数将这些中间件函数应用到Redux的<code>store</code>中。</p>
<p>值得注意的是，这段代码中的 <code>compose</code>是从 <code>redux</code>内部引入的，也就是说，<code>redux</code>没有借助外部的函数式编程库，而是自己写了一个 <code>compose</code>函数来用。这就让人很难不好奇它自有的这个 <code>compose</code>长啥样：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">...funcs</span>) {
  <span class="hljs-comment">// 对函数个数为0的情况特判</span>
  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">arg</span> =></span> arg
  }
  <span class="hljs-comment">// 对函数个数为1的情况特判</span>
  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>]
  }

  <span class="hljs-comment">// 最后这行和我们 22 节实现的 pipe 是一样的</span>
  <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =></span> <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(...args)))
}
</code></pre>
<p>我们来看最关键的一行，也就是最后一行，这行代码和我们 <a href="https://juejin.cn/book/7173591403639865377/section/7175422922192846907" target="_blank" rel="nofollow noopener noreferrer">第 14 节</a> 实现的版本不同，但和我们<a href="https://juejin.cn/book/7173591403639865377/section/7175423078837518396" target="_blank" rel="nofollow noopener noreferrer">第 22 节</a>实现的 <code>pipe</code>函数可是亲兄弟呀：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 第 22 节实现的 pipe 函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">pipe</span>  = (<span class="hljs-params">...funcs</span>) => funcs.<span class="hljs-title function_">reduce</span>(
  <span class="hljs-comment">// 和 14 节的 pipe 一样是基于 reduce 实现，主要的区别在于对组合链入参的处理不同</span>
  <span class="hljs-function">(<span class="hljs-params">f, g</span>) =></span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =></span> <span class="hljs-title function_">g</span>(<span class="hljs-title function_">f</span>(...args))
);
</code></pre>
<p>这种写法的 <code>pipe/compose</code> 最大的特点在于对组合链入参的处理——<code>...args</code>中扩展运算符的存在，使得这类 <code>pipe/compose</code>组合出的函数能够消化多个入参，像这样：</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">pipe</span>(
  likeLessons,
  registerLessons,
  emptyUserLiked,
  isVIP,
  <span class="hljs-comment">// 这两个参数都会被传递给组合链中的第一个函数</span>
)(user, myLessons)
</code></pre>
<blockquote>
<p>注：楼上这段代码，在<a href="https://juejin.cn/book/7173591403639865377/section/7175423078837518396" target="_blank" rel="nofollow noopener noreferrer"> 22 节</a> 有完整的示例，跳读至此的同学可以狠狠<a href="https://juejin.cn/book/7173591403639865377/section/7175423078837518396" target="_blank" rel="nofollow noopener noreferrer">点这里</a>补全阅读上下文。）</p>
</blockquote>
<h2>小结</h2>
<p>本节我们通过分析大家相对熟悉的 React &#x26; Redux 技术点，对前面学过的纯函数、不可变数据、高阶函数、柯里化、函数组合等关键知识点进行了整合和串联。通过本节的学习，相信大家能够对已经学过的知识有更深刻的理解和认同。</p>
<p>其实，除了这些“典中典”的函数式编程特性在前端领域有广泛的实践以外，还有像“盒子模式”这样相对冷门的编程方法，它也是可以在生产级别的项目中大放异彩的。下一节，我们就将以 RxJS 为例，探讨盒子模式在前端状态管理中的实践。</p></div>
</body></html>