<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>“多元函数”解决方案：从编码工具视角看偏函数&柯里化</h1>
<p>偏函数和柯里化堪称面试场上的“老八股”了，结合近两年面试的“行情”来看，大部分 3-5 年经验的前端同学都能够对这两者的概念进行充分的阐释和辨析，但却常常在 code test 环节折戟。</p>
<p>截止目前，当偏函数和柯里化出现在大家视野里的时候，它更多地是作为一道“名词解释题”，而非一个“编码工具”。</p>
<p>然而，要想理解偏函数和柯里化，最简单的姿势其实恰恰是从“编码工具”这个角度切入。</p>
<p>本节，我们就将从“编码工具”的角度来认识它们。</p>
<p><strong>认识一个锤子，我们首先要知道它可以被用来对付哪些钉子。</strong></p>
<p><strong>认识一个编码工具，我们首先要知道它可以被用来解决哪些问题。</strong></p>
<p>偏函数和柯里化解决的最核心的问题有两个，分别是：</p>
<ul>
<li>
<p>函数组合链中的多元参数问题</p>
</li>
<li>
<p>函数逻辑复用的问题</p>
</li>
</ul>
<h2>函数组合链中的多元参数问题</h2>
<h3>理解函数中的“元数(Arity)”</h3>
<p>函数参数里的“元数”，指的其实就是函数参数的数量。</p>
<p>在数学里，我们管<strong>只包含一个自变量的函数方程式</strong>叫“一元函数”，比如这种：</p>
<pre><code class="hljs language-js">y = x + <span class="hljs-number">1</span>   
y = <span class="hljs-title function_">f</span>(x)
</code></pre>
<p>相应地，<strong>包含两个自变量的函数方程式</strong>就叫二元函数，比如这种：</p>
<pre><code class="hljs language-js">z = x + y  
z = <span class="hljs-title function_">f</span>(x, y)
</code></pre>
<p>类比到 JS 函数里来说，单个入参的函数就是一元函数，像这种：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> x*<span class="hljs-number">2</span>
}
</code></pre>
<p>两个入参的函数就是二元函数，像这种：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> x+y
}
</code></pre>
<p>显然，“多元函数”指的就是有多个（n个）入参的函数，像这种：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiple</span>(<span class="hljs-params">x,y........n</span>) {
  <span class="hljs-keyword">return</span> ....
}
</code></pre>
<h3>函数组合链中的参数对齐问题</h3>
<p>函数组合虽好，但各种限制少不了。现在请大家简单回顾一下上一节我们徒手撸过的 Pipe 函数：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 使用展开符来获取数组格式的 pipe 参数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pipe</span>(<span class="hljs-params">...funcs</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">input, func</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(input)
  }  

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>) {
    <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(callback,param)
  }
}
</code></pre>
<p>当时我们给出的调用示例是这样的：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> compute = <span class="hljs-title function_">pipe</span>(add4, multiply3, divide2)
</code></pre>
<p>仔细一看，调用链的三个函数齐刷刷都是一元函数：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 一元函数，一个入参</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add4</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num + <span class="hljs-number">4</span>
}  

<span class="hljs-comment">// 一元函数，一个入参</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply3</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num*<span class="hljs-number">3</span>
}  

<span class="hljs-comment">// 一元函数，一个入参</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">divide2</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num/<span class="hljs-number">2</span>
}
</code></pre>
<p>这个属于是理想情况了。有的时候，一个调用链中的函数彼此之间可能并没有这么和谐。</p>
<p>举个例子，假如说我做乘法的时候，手边并没有一个 multiply3， 只有一个乘数和被乘数都可以自定义的函数，如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> x*y
}
</code></pre>
<p>一元函数 multiply3 变成了二元函数 multiply，此时咱们若是把 multiply 直接丢回 pipe 链中去，那指定是要倒沫子的：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> compute = <span class="hljs-title function_">pipe</span>(add4, multiply, divide2)
<span class="hljs-comment">// 输出 NaN</span>
<span class="hljs-title function_">compute</span>(<span class="hljs-number">20</span>)
</code></pre>
<p>这段代码的执行结果如图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca5b5dd41f0b4f6b95e234cc3ef1c3b5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>竟然输出 NaN 了，为啥呢？当然是因为咱的 reduce callback 只能消化一个入参啦：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">input, func</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(input)
}  
</code></pre>
<p>当执行到 <code>callback(input, multiply) </code>时，multiply 函数期望可以接收 2 个 number 类型的入参，但实际调用时却只传入了一个 number 类型的入参：</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">multiply</span>(input)
</code></pre>
<p>这个调用等价于：</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">multiply</span>(input, <span class="hljs-literal">undefined</span>)
</code></pre>
<p>一个数字乘以 <code>undefined</code>，结果自然是 <code>NaN</code> 啦。</p>
<p>对于函数组合链来说，它总是预期链上的函数是一元函数：函数吃进一个入参，吐出一个出参，然后这个出参又会作为下一个一元函数的入参......参数个数的对齐，是组合链能够运转的前提。</p>
<p>一旦链上乱入了多元函数，那么多元函数的入参数量就无法和上一个函数的出参数量对齐，进而导致执行错误。</p>
<p>这也就是我们小标题中所说的“参数对齐”问题。</p>
<blockquote>
<p>tips：函数组合链上的函数总是一元函数，这是一个通用且广泛的约定，但并不是一个“死规矩”。<br>
有时候，我们可以通过适当的改造，使组合链接受多元函数。比如 ramda.js 中的 pipe 函数，就允许链上的第一个函数有任意多个参数（注意，仅仅是第一个函数有此“特权”，其余函数仍然必须是一元函数）。</p>
</blockquote>
<p>这可咋办呢？</p>
<p><strong>任何时候，只要我们想要对函数的入参数量进行改造，必须先想到偏函数&#x26;柯里化。</strong></p>
<h3>求解多元参数问题</h3>
<h4>柯里化的概念与实现</h4>
<p>为了确保知识的完整性，这里我还是不能免俗地要做一下名词解释。</p>
<p>先来说说柯里化，维基百科中对柯里化有着这样的定义：    </p>
<blockquote>
<p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
</blockquote>
<p>通俗来讲，它是这个意思： 柯里化是把 <strong>1 个 n 元函数</strong>改造为 <strong>n 个相互嵌套的一元函数</strong>的过程。</p>
<p>再具体一点，就是说柯里化是一个把 <code>fn(a, b, c)</code>转化为<code>fn(a)(b)(c)</code>的过程。</p>
<p>举个例子，我有一个函数，可以将任意三个数相加：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addThreeNum</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a+b+c
}
</code></pre>
<p>正常调用的话就是 <code>addThreeNum(1, 2, 3)</code> 这样的。</p>
<p>但是通过柯里化，我可以把调用姿势改造为 <code>addThreeNum(1)(2)(3)</code>。</p>
<p>如何做到呢？ 一个最直接的想法是在原有的函数上做改造，像这样（解析见注释）：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 将原函数改造为三个嵌套的一元函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addThreeNum</span>(<span class="hljs-params">a</span>) {
  <span class="hljs-comment">// 第一个函数用于记住参数a</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) {
    <span class="hljs-comment">// 第二个函数用于记住参数b</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) {
      <span class="hljs-comment">// 第三个函数用于执行计算</span>
      <span class="hljs-keyword">return</span> a+b+c
    }
  }
}

<span class="hljs-comment">// 输出6，输出结果符合预期</span>
<span class="hljs-title function_">addThreeNum</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)
</code></pre>
<p>但是，我们在<a href="https://juejin.cn/book/6844733790204461070" target="_blank" rel="nofollow noopener noreferrer">设计模式</a>中强调过“开放封闭”原则——<strong>对拓展开放，对修改封闭</strong>。</p>
<p>直接修改现有函数，显然违背了这一原则。</p>
<p>有没有什么姿势，可以允许我在<strong>保留原有函数的基础上，单纯通过增量代码来实现柯里化</strong>呢？</p>
<p>当然有啦！高阶函数不就是干这个的么！</p>
<p>下面我就针对加法这个场景，创建了一个名为 curry 的高阶函数（解析在注释里）：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 定义高阶函数 curry</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">addThreeNum</span>) {
  <span class="hljs-comment">// 返回一个嵌套了三层的函数</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addA</span>(<span class="hljs-params">a</span>) {
    <span class="hljs-comment">// 第一层“记住”参数a</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addB</span>(<span class="hljs-params">b</span>) {
      <span class="hljs-comment">// 第二层“记住”参数b</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addC</span>(<span class="hljs-params">c</span>) {
        <span class="hljs-comment">// 第三层直接调用现有函数 addThreeNum</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">addThreeNum</span>(a, b, c)
      }
    }
  }
}

<span class="hljs-comment">// 借助 curry 函数将 add</span>
<span class="hljs-keyword">const</span> curriedAddThreeNum = <span class="hljs-title function_">curry</span>(addThreeNum)
<span class="hljs-comment">// 输出6，输出结果符合预期</span>
<span class="hljs-title function_">curriedAddThreeNum</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)
</code></pre>
<h4>偏函数 VS 柯里化</h4>
<p>在理解了柯里化的基础上，理解偏函数就是小菜一碟了。</p>
<p>这里为了体现对专业术语的respect，我仍然是象征性地先放一段维基百科的解释：</p>
<blockquote>
<p>在计算机科学中，<strong>部分应用</strong>（或部分函数应用）指的是将一些参数固定在一个函数上，产生另一个较小元的函数的过程。</p>
</blockquote>
<blockquote>
<p>tips: 偏函数英文是 partial application， 直译过来就是“部分应用”。</p>
</blockquote>
<p>元的概念我们开篇就捋清楚了。所以这个定义其实并不难懂，通俗来说：</p>
<p>偏函数是指通过<strong>固定函数的一部分参数</strong>，生成一个<strong>参数数量更少的函数</strong>的过程。</p>
<p>咱来捋捋啊：</p>
<p>柯里化说的是一个 n 元函数变成 n 个一元函数。</p>
<p>偏函数说的是一个 n 元函数变成一个 m(m &#x3C; n） 元函数。</p>
<p>对于柯里化来说，不仅函数的元发生了变化，函数的数量也发生了变化（1个变成n个）。</p>
<p>对于偏函数来说，仅有函数的元发生了变化（减少了），函数的数量是不变的。</p>
<p>也就是说对于一个调用姿势长这样的四元函数来说：</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">func</span>(a, b, c, d)
</code></pre>
<p>我们可以固定第一个入参，使其缩减为一个三元函数：</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">func</span>(b, c, d)
</code></pre>
<p>也可以固定前两个入参，使其缩减为一个二元函数：</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">func</span>(c, d)
</code></pre>
<p>总之，只要它的元比之前小，就满足了偏函数的要求。</p>
<h4>偏函数求解组合链中的参数对齐问题</h4>
<p>对于开篇提到的组合链的“参数对齐”问题来说，偏函数就是一个不错的解法。</p>
<p>偏函数的实现思路是固定一部分函数参数，这里我仍然延续高阶函数的思路，对现有函数进行一定的“包装”来达到目的：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 定义一个包装函数，专门用来处理偏函数逻辑</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">wrapFunc</span>(<span class="hljs-params">func, fixedValue</span>) {
  <span class="hljs-comment">// 包装函数的目标输出是一个新的函数</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">wrappedFunc</span>(<span class="hljs-params">input</span>){
    <span class="hljs-comment">// 这个函数会固定 fixedValue，然后把 input 作为动态参数读取</span>
    <span class="hljs-keyword">const</span> newFunc = <span class="hljs-title function_">func</span>(input, fixedValue)
    <span class="hljs-keyword">return</span> newFunc
  }
  <span class="hljs-keyword">return</span> wrappedFunc
}
<span class="hljs-keyword">const</span> multiply3 = <span class="hljs-title function_">wrapFunc</span>(multiply, <span class="hljs-number">3</span>)

<span class="hljs-comment">// 输出6</span>
<span class="hljs-title function_">multiply3</span>(<span class="hljs-number">2</span>)
</code></pre>
<p>这样就成功固定了 <code>multiply</code> 函数的第一个入参 x，得到了一个一元函数 <code>multiply3</code>，这完全符合组合链对函数元的预期。</p>
<h2>函数逻辑复用问题</h2>
<p>当我们看到偏函数和柯里化的实现分别都借助了<strong>高阶函数</strong>后，“逻辑复用”几乎是一件不言而喻的事情了。</p>
<h3>参数固定-复用存量逻辑</h3>
<p>在 multiply3 这个例子中，偏函数除了解决了<strong>函数的元的问题</strong>，还充分地<strong>对现有逻辑进行了复用</strong>。</p>
<p>multiply 函数是一个存量函数，我们的目标函数 <strong>multiply3 其实可以看作是 multiply 函数功能的一个子集</strong>。</p>
<p>这种情况下，与其单独定义一个 <code>multiply3</code>，不如试着通过偏函数处理实现对存量逻辑 <strong><code>multiply</code></strong> 的定制。</p>
<p><code>multiply3</code>、<code>multiply</code> 两个函数的逻辑都不算复杂，复用带来的利好体现得还不算特别明显。</p>
<p>但在实际的应用中，我们的存量函数逻辑可以是非常复杂的。</p>
<p>比如我曾经在业务逻辑中，见到一个处理订单数据的函数：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateOrderData</span>(<span class="hljs-params">type, area, settlement</span>) {
  <span class="hljs-comment">// 省略数十行难以理解的业务逻辑......</span>
}
</code></pre>
<p><code>generateOrderData</code> 通过读取订单类型、订单地区、订单结算信息等参数，对订单信息进行重构，最终输出一套能够供 UI 层直接消化的渲染数据。</p>
<p>这样一个函数的改造成本是很高的。</p>
<p>如果我们遇到一个场景，期望能够针对某一个特定区域、特定类型的订单数据进行计算（也就是固定 <code>type</code>、<code>area</code> 这两个参数），对应函数名为 <code>generateSpecOrderData(settlement)</code>。</p>
<p>相比于参考 <code>generateOrderData</code> 的具体逻辑重新写一个 <code>generateSpecOrderData</code> 出来，直接在 <code>generateOrderData</code> 的基础上做偏函数处理不仅可以帮助我们避免大量的重复代码，同时也省去了读函数、理解函数的时间成本——毕竟，做偏函数处理只需要我们了解函数的入参规则就可以了。</p>
<h3>缩小函数的元数-减少重复传参</h3>
<p>偏函数不仅仅可以帮我们减少定义函数时的重复代码，还可以帮我们减少调用函数时的重复传参。</p>
<p>在 <code>generateSpecOrderData</code> 函数被定义出来之前，我在项目里见到了大量这样的代码：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 文件 a</span>
<span class="hljs-keyword">const</span> res = <span class="hljs-title function_">generateOrderData</span>(<span class="hljs-string">'food'</span>, <span class="hljs-string">'hunan'</span>, normalSettlement)

<span class="hljs-comment">// 文件 b</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">UIData</span> = <span class="hljs-title function_">generateOrderData</span>(<span class="hljs-string">'food'</span>, <span class="hljs-string">'hunan'</span>, orderSettlement)  

<span class="hljs-comment">// 文件 c  </span>
<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">generateOrderData</span>(<span class="hljs-string">'food'</span>, <span class="hljs-string">'hunan'</span>, couponSettlement)  
</code></pre>
<p>不同的调用，重复的传参，重复的 <code>food</code> + <code>hunan</code>。</p>
<p>而偏函数恰恰就可以把 <code>food</code> 和 <code>hunan</code> “记忆”下来，帮助我们避免这些重复。</p>
<p>实际上，通用函数为了确保其自身的灵活性，往往都具备“多元参数”的特征。但在一些特定的业务场景下，真正需要动态变化的只是其中的一部分的参数。这时候函数的一部分灵活性对我们来说是多余的，我们反而希望它的功能具体一点。</p>
<p>比如 <code>generateSpecOrderData</code> 函数，就对 <code>type</code> 和 <code>area</code> 并不感冒，只是想动态传入 <code>settlement</code> 而已。</p>
<p>这种场景下，偏函数出来扛大旗就再合适不过了。</p>
<p>至此，我们已经通过一些实例理解了偏函数和柯里化两者的概念和用途，并且结合函数组合链的例子，对偏函数解决问题的方式有了具体的认知。</p>
<p>开篇我们说过，偏函数和柯里化是一脉相承，它们解决的其实是同一类问题。</p>
<p>也就是说函数组合链的参数对不齐问题，用柯里化也是可以解决的，并且柯里化也能够协助我们更好地复用函数逻辑。</p>
<p>如何证明这一点呢？这里先留作思考题给大家，我在下一节会给出答案，并且带大家一起实现一个通用的柯里化函数。</p>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p></div>
</body></html>