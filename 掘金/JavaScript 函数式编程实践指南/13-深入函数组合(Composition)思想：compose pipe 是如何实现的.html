<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>深入函数组合(Composition)思想：compose/pipe 是如何实现的</h1>
<p><img class="equation" src="https://juejin.cn/equation?tex=%5Ccolor%7BLightPink%7D%7B%E4%BF%9D%E5%A7%86%E5%BC%8F%E6%95%99%E5%AD%A6%E3%81%AE%7D%5Ccolor%7BPink%7D%7B%E6%B8%A9%E6%83%85%E6%8F%90%E7%A4%BA%EF%BC%9A%7D" alt="\color{LightPink}{保姆式教学の}\color{Pink}{温情提示：}"></p>
<p>徒手编码 compose/pipe，是当下前端面试考察函数式编程的最通用、最高频 code test 题目。</p>
<p>任何涉及到“函数”、“组合”、“串联”、“管道”等字眼的面试题，多少都需要大家往这方面联想一下。</p>
<p>相关的提问姿势包括但不限于：</p>
<p>“如何 pipe 一系列的指定函数？”</p>
<p>“函数组合（compose）是一个什么样的过程？”</p>
<p>“rambda（或者任何一个函数式编程库）中的 compose/pipe 是如何实现的？”</p>
<p>“Redux 中间件是如何串联的？”</p>
<p>等等等等.......</p>
<p>不夸张地说，这是一门背也要背下来的学问。</p>
<p>它至少可以帮你向面试官证明，你真的能够实战函数式编程，而不是只会记忆几个 lodash-fp 或 React Hook 的 API。</p>
<p>如果你的时间有限，不允许你细嚼慢咽整本小册覆盖的所有知识点，请你至少把握住这一节——在面试场景下，它将助你摆脱“函数式小白”的标签。</p>
<h2>借助 reduce 推导函数组合</h2>
<p>事已至此，让我们重新审视一遍 reduce 的工作流示意：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c2577e6fee64879b03dce5b053a3ddf~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>在<a href="https://juejin.cn/book/7173591403639865377/section/7175422666629709884" target="_blank" rel="nofollow noopener noreferrer">第12节</a>的末尾，我曾经这样疯狂暗示了大家一波：</p>
<blockquote>
<p>咱就是说，有没有可能，有没有可能咱们把 pipeline 里的每一个函数也弄成不一样的呢？</p>
</blockquote>
<blockquote>
<p>更直白地说，你<code> reduce() </code>既然都能组合参数了，你能不能帮我的 pipeline 组合一下函数呢？</p>
</blockquote>
<blockquote>
<p>毕竟，JS 的函数是可以作为参数传递的嘛！</p>
</blockquote>
<p>一旦我们能做到这一点——一旦我们可以把 reduce pipeline 里的最小计算单元修改成任意不同的函数，那么这个工作流就会变成下面这样了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d0eed4a85a54046b0c8ee9e7ef679ed~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个流程，恰恰就是一个函数组合的 pipeline。</p>
<p>也就是说，只要我们能够想办法<strong>让 reduce 工作流里的计算单元从一个函数转变为 N 个函数</strong>，我们<strong>就可以达到函数组合的目的</strong>。</p>
<p>大家知道，在整个 reduce 的工作流中，callback 是锁死的，但每次调用 callback 时传入的参数是动态可变的（如下图）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad5509a0c9e04d8f8cc7a417ccb19ccc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这些动态可变的参数，来自 reduce 的宿主数组。</p>
<p>之前介绍 reduce 时，我们用了一个塞满数字的数组作为示例。</p>
<p>但其实，数组的元素可以是任何类型——包括<strong>函数</strong>类型。</p>
<p>我们把<strong>待组合的函数放进一个数组里，然后调用这个函数数组的 reduce 方法</strong>，就可以创建一个多个函数组成的工作流。</p>
<p>而这，正是市面上主流的函数式库实现 compose/pipe 函数的思路。</p>
<h2>借助 reduce 推导 pipe</h2>
<p>顺着这个思路，我们来考虑这样一个函数数组：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> funcs = [func1, func2, func3]
</code></pre>
<p>我们假设三个 func 均是用于数学计算的函数，整个工作流的任务就是吃进一个数字 0 作为入参、吐出一个计算结果作为出参。</p>
<p>我想要逐步地组合调用 funcs 数组里的函数，得到一个这样的声明式数据流：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae9a8c25da8e44fcab4ab393e40a6a49~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如果我借助了 reduce，我得到的数据流乍一看和楼上是有出入的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc6e25ab292b433389d99280058d169b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如何通过调整 reduce 的调用，使它的工作流和声明式数据流看齐呢？</p>
<p>首先是入参的对齐，这个比较简单，我们只需要把 initialValue 设定为 0 就可以了。</p>
<p>入参明确后，我的 reduce 调用长这样：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> funcs = [func1, func2, func3]  

funcs.<span class="hljs-title function_">reduce</span>(callback, <span class="hljs-number">0</span>)
</code></pre>
<p>接下来重点在于 callback 怎么实现。其实我们只需要把楼上两张图放在一起做个对比，答案就呼之欲出了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71658f7803864aa999f8e33370b5e93f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>图中我用红笔对 reduce 流程做了拆分，用蓝笔对目标数据流做了拆分。</p>
<p>想要让上下两个流程等价，我们只需要确保红蓝两个圈圈的工作内容总是等价就可以了。</p>
<p>从第一对红蓝圈圈开始看起，蓝色圈圈的工作内容是 func1(0)，红色圈圈的工作内容是 callback(0, func1)。</p>
<p>两者等价，意味着 callback(0, func1) = func1(0)。</p>
<p>同理，我们可以逐步推导出第二个、第三个红色圈圈的工作内容，分别应该满足：</p>
<p>callback(value1, func2) = func2(value1)</p>
<p>callback(value2, func3) = func3(value2)</p>
<p>以此类推，对于任意的入参 (input, func），callback 都应该满足：</p>
<p>callback(input, func) = func(input)</p>
<p>推导至此，我们就得到了 callback 的实现：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">input, func</span>) {
  <span class="hljs-title function_">func</span>(input)
}  

funcs.<span class="hljs-title function_">reduce</span>(callback,<span class="hljs-number">0</span>)
</code></pre>
<p>再稍微包装一下，给这坨逻辑起一个新名字：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pipe</span>(<span class="hljs-params">funcs</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">input, func</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(input)
  }  

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>) {
    <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(callback,param)
  }
}
</code></pre>
<p>我们就得到了一个经典的 pipe 函数。</p>
<h2>验证 pipe：串联数字计算逻辑</h2>
<p>长得帅的同学想必都还记得这三个函数：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add4</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num + <span class="hljs-number">4</span>
}  

<span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply3</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num*<span class="hljs-number">3</span>
}  

<span class="hljs-keyword">function</span> <span class="hljs-title function_">divide2</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num/<span class="hljs-number">2</span>
}
</code></pre>
<p>问：如何基于这些独立函数，构建一个多个函数串行执行的工作流？</p>
<p>现在有了 pipe，我们可以轻松达到这个目的。只需要把这些函数放进一个数组里，再把数组放进 pipe 里：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> compute = <span class="hljs-title function_">pipe</span>([add4, multiply3, divide2])
</code></pre>
<p>如此，我们便能够得到一个 compute 的函数，该函数正是 add4, multiply3, divide2 这三个函数的“合体”版本。</p>
<p>接下来直接调用 compute() 函数，就可以开动“传送带”，得到目标的计算结果了：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 输出 21</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">compute</span>(<span class="hljs-number">10</span>))
</code></pre>
<p>美中不足的是手动构造数组有点麻烦，我们可以直接使用展开符来获取数组格式的 pipe 参数：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 使用展开符来获取数组格式的 pipe 参数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pipe</span>(<span class="hljs-params">...funcs</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">input, func</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(input)
  }  

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>) {
    <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(callback,param)
  }
}
</code></pre>
<p>由此我们就可以向 pipe 传入任意多的函数，组合任意长的函数工作流了：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> funcFlow = <span class="hljs-title function_">pipe</span>(method1, method2, method3, method4,...., methodN)
</code></pre>
<p>至此，我们便实现了一个通用的 pipe 函数。</p>
<h2>compose：倒序的 pipe</h2>
<p>pipe 用于创建一个正序的函数传送带，而 compose 则用于创建一个倒序的函数传送带。</p>
<p>我们把 pipe 函数里的 reduce 替换为 reduceRight，就能够得到一个 compose：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 使用展开符来获取数组格式的 pipe 参数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">...funcs</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">input, func</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(input)
  }  

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>) {
    <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduceRight</span>(callback,param)
  }
}
</code></pre>
<p>使用 compose 创建同样的一个函数工作流，我们需要把入参倒序传递，如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> compute = <span class="hljs-title function_">compose</span>(divide2, multiply3, add4)
</code></pre>
<p>组合后的流水线顺序，和传参的顺序是相反的。也就是说执行 compute 时，函数的执行顺序是这样的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/361ab5f915a446db8db433f60996bd92~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>正序是 pipe，倒序是 compose。</strong></p>
<p>pipe 和 compose 的辨析，本身也是一个热门的考察点。在面试场景下，大家一定要听清楚面试官的要求，写代码前先确认需求是【<strong>Pipe--></strong> 】一系列函数还是【<strong>Compose&#x3C;--</strong>】一系列函数。</p>
<blockquote>
<p>作者注：为什么 pipe 是正序，compose 是倒序？关于这个问题，我们在 <a href="https://juejin.cn/book/7173591403639865377/section/7175422979646423098" target="_blank" rel="nofollow noopener noreferrer">第17节</a>还有更进一步的讨论，感兴趣的同学可以关注第17节的“复合运算：范畴论在编程中最核心的应用”这个section</p>
</blockquote>
<h2>知其所以然：Why Compose?</h2>
<p>面向对象的核心在于继承，而<strong>函数式编程的核心则在于组合</strong>。</p>
<p>我们常说函数式编程就像一个乐高游戏：那一个个独立内聚的函数就像一堆乐高积木方块儿。它们看似渺小到无足轻重，却可以在<strong>组合</strong>后变幻出千百种形态、最终呈现出复杂而强大的功能。</p>
<p>组合这个动词，赋予了函数式编程无限的想象力和可能性。</p>
<p>在函数式编程的实践中，我们正是<strong>借助 compose 来组合多个函数的功能</strong>，它<strong>是函数式编程中最有代表性的一个工具函数</strong>，所以它才会成为面试题中的常客。</p>
<p>在编码层面，如果不喜欢 reduce，你还可以借助循环、递归等姿势来实现 compose。</p>
<p>这里我选取了 reduce，一方面是因为它足够主流（市面流行的函数式编程库 ramda 也采取了基于 reduce 的实现），另一方面也是因为它足够巧妙。</p>
<p>巧妙到什么程度呢？结合个人的经验来看，在实际的编码和面试中，基于 reduce 的 compose 几乎是理解成本最高、同时也是许多同学避之不及的一个版本。</p>
<p>许多能力是可以向下兼容的，包括 compose 的实现。</p>
<p>我相信对多数同学来说，读懂一段循环代码或者递归代码都不会是特别难的事情。</p>
<p>然而，如果你之前没有刻意练习过从 reduce 到 compose 的推导过程，那么第一次见到类似代码的时候，即便能够勉强理解代码的意图，也未必能够灵机一动把眼前的 reduce 调用和函数组合联系起来。</p>
<p>但经过了近几节的学习，相信大家早已对 reduce 刮目相看了。</p>
<p>当你再次在别人写的代码中见到 reduce 时，脑海中闪现的关键字除了“数组、斐波那契”等等之外，不要忘了还有“<strong>函数组合</strong>”。</p>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p></div>
</body></html>