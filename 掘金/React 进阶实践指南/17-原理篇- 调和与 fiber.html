<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>原理篇- 调和与 fiber</h1>
<h2>一 前言</h2>
<p>在之前的很多章节中，我们都提到了 React fiber ，理解 fiber 是吃透 React 原理的基石，所以这节将重点介绍一下 React Fiber 。</p>
<p>通过本章节，你会学到 React fiber 原理，以及 React 调和的两大阶段，解决面试中遇到的 fiber 问题。</p>
<p>参考问题：</p>
<ul>
<li>什么是fiber ? Fiber 架构解决了什么问题？ </li>
<li>Fiber root 和 root fiber 有什么区别？ </li>
<li>不同fiber 之间如何建立起关联的？</li>
<li>React 调和流程？</li>
<li>两大阶段 commit 和 render 都做了哪些事情？</li>
<li>什么是双缓冲树？ 有什么作用？</li>
<li>Fiber 深度遍历流程？</li>
<li>Fiber的调和能中断吗？ 如何中断？</li>
</ul>
<p><strong>什么是fiber</strong></p>
<p>Fiber 的英文的是’纤维‘，fiber 诞生在 <code>Reactv16</code> 版本，整个 React 团队花费两年时间重构 fiber 架构，目的就是解决大型 React 应用卡顿；fiber 在 React 中是最小粒度的执行单元，无论 React 还是 Vue ，在遍历更新每一个节点的时候都不是用的真实 DOM ，都是采用虚拟 DOM ，所以可以理解成 fiber 就是 React 的虚拟 DOM 。</p>
<p><strong>为什么要用fiber</strong></p>
<p>在 <code>Reactv15</code> 以及之前的版本，React 对于虚拟 DOM 是采用递归方式遍历更新的，比如一次更新，就会从应用根部递归更新，递归一旦开始，中途无法中断，随着项目越来越复杂，层级越来越深，导致更新的时间越来越长，给前端交互上的体验就是卡顿。</p>
<p><code>Reactv16</code> 为了解决卡顿问题引入了 fiber ，为什么它能解决卡顿，更新 fiber 的过程叫做 <code>Reconciler</code>（调和器），每一个 fiber 都可以作为一个执行单元来处理，所以每一个 fiber 可以根据自身的过期时间<code>expirationTime</code>（ v17 版本叫做优先级 <code>lane</code> ）来判断是否还有空间时间执行更新，如果没有时间更新，就要把主动权交给浏览器去渲染，做一些动画，重排（ reflow ），重绘 repaints 之类的事情，这样就能给用户感觉不是很卡。然后等浏览器空余时间，在通过 <code>scheduler</code> （调度器），再次恢复执行单元上来，这样就能本质上中断了渲染，提高了用户体验。</p>
<h2>二 全面认识Fiber</h2>
<h3>1 element,fiber,dom三种什么关系？</h3>
<p>首先必须需要弄明白 React.element ，fiber 和真实 DOM 三者是什么关系。</p>
<ul>
<li>element 是 React 视图层在代码层级上的表象，也就是开发者写的 jsx 语法，写的元素结构，都会被创建成 element 对象的形式。上面保存了 props ， children 等信息。</li>
<li>DOM 是元素在浏览器上给用户直观的表象。</li>
<li>fiber 可以说是是 element 和真实 DOM 之间的交流枢纽站，一方面每一个类型 element 都会有一个与之对应的 fiber 类型，element 变化引起更新流程都是通过 fiber 层面做一次调和改变，然后对于元素，形成新的 DOM 做视图渲染。</li>
</ul>
<p>结构如下图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a90368f24f0477aaf0d446a8f6736db~tplv-k3u1fbpfcp-watermark.image" alt="2.jpg"></p>
<p>首先先来看一下 element 与 fiber 之间的对应关系。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">FunctionComponent</span> = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 对应函数组件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ClassComponent</span> = <span class="hljs-number">1</span>;          <span class="hljs-comment">// 对应的类组件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IndeterminateComponent</span> = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 初始化的时候不知道是函数组件还是类组件 </span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostRoot</span> = <span class="hljs-number">3</span>;                <span class="hljs-comment">// Root Fiber 可以理解为跟元素 ， 通过reactDom.render()产生的根元素</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostPortal</span> = <span class="hljs-number">4</span>;              <span class="hljs-comment">// 对应  ReactDOM.createPortal 产生的 Portal </span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostComponent</span> = <span class="hljs-number">5</span>;           <span class="hljs-comment">// dom 元素 比如 &#x3C;div></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostText</span> = <span class="hljs-number">6</span>;                <span class="hljs-comment">// 文本节点</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Fragment</span> = <span class="hljs-number">7</span>;                <span class="hljs-comment">// 对应 &#x3C;React.Fragment> </span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Mode</span> = <span class="hljs-number">8</span>;                    <span class="hljs-comment">// 对应 &#x3C;React.StrictMode>   </span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContextConsumer</span> = <span class="hljs-number">9</span>;         <span class="hljs-comment">// 对应 &#x3C;Context.Consumer></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContextProvider</span> = <span class="hljs-number">10</span>;        <span class="hljs-comment">// 对应 &#x3C;Context.Provider></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ForwardRef</span> = <span class="hljs-number">11</span>;             <span class="hljs-comment">// 对应 React.ForwardRef</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Profiler</span> = <span class="hljs-number">12</span>;               <span class="hljs-comment">// 对应 &#x3C;Profiler/ ></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SuspenseComponent</span> = <span class="hljs-number">13</span>;      <span class="hljs-comment">// 对应 &#x3C;Suspense></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoComponent</span> = <span class="hljs-number">14</span>;          <span class="hljs-comment">// 对应 React.memo 返回的组件</span>
</code></pre>
<h3>2 fiber保存了那些信息</h3>
<p>刚才说到 fiber 作为 element 和真实 DOM 元素的沟通枢纽，那么一个 fiber 上到底保存了那些信息呢？</p>
<blockquote>
<p>react-reconciler/src/ReactFiber.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberNode</span>(<span class="hljs-params"></span>){

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;                  <span class="hljs-comment">// fiber 标签 证明是什么类型fiber。</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;                  <span class="hljs-comment">// key调和子节点时候用到。 </span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-literal">null</span>;                <span class="hljs-comment">// dom元素是对应的元素类型，比如div，组件指向组件对应的类或者函数。  </span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateNode</span> = <span class="hljs-literal">null</span>;           <span class="hljs-comment">// 指向对应的真实dom元素，类组件指向组件实例，可以被ref获取。</span>
 
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>;              <span class="hljs-comment">// 指向父级fiber</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;               <span class="hljs-comment">// 指向子级fiber</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;             <span class="hljs-comment">// 指向兄弟fiber </span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 索引</span>

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">ref</span> = <span class="hljs-literal">null</span>;                 <span class="hljs-comment">// ref指向，ref函数，或者ref对象。</span>

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingProps</span> = pendingProps;<span class="hljs-comment">// 在一次更新中，代表element创建</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedProps</span> = <span class="hljs-literal">null</span>;       <span class="hljs-comment">// 记录上一次更新完毕后的props</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 类组件存放setState更新队列，函数组件存放</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;       <span class="hljs-comment">// 类组件保存state信息，函数组件保存hooks信息，dom元素为null</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">dependencies</span> = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// context或是时间的依赖项</span>

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">mode</span> = mode;                <span class="hljs-comment">//描述fiber树的模式，比如 ConcurrentMode 模式</span>

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">effectTag</span> = <span class="hljs-title class_">NoEffect</span>;       <span class="hljs-comment">// effect标签，用于收集effectList</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;          <span class="hljs-comment">// 指向下一个effect</span>

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstEffect</span> = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 第一个effect</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;          <span class="hljs-comment">// 最后一个effect</span>

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">expirationTime</span> = <span class="hljs-title class_">NoWork</span>;    <span class="hljs-comment">// 通过不同过期时间，判断任务是否过期， 在v17版本用lane表示。</span>

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;           <span class="hljs-comment">//双缓存树，指向缓存的fiber。更新阶段，两颗树互相交替。</span>
}
</code></pre>
<p>如上，我把 fiber 中每一个变量代表什么，都写出来了，大家可以参考一下。</p>
<h3>3 每一个fiber如何建立起关联的</h3>
<p>看过之前章节的朋友都知道对于每一个 element 都会对应一个 fiber ，每一个 fiber 是通过 return ， child ，sibling 三个属性建立起联系的。</p>
<ul>
<li>return： 指向父级 Fiber 节点。</li>
<li>child：  指向子 Fiber 节点。</li>
<li>sibling：指向兄弟 fiber 节点。</li>
</ul>
<p>比如项目中元素结构是这样的：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>{
   state={ <span class="hljs-attr">number</span>:<span class="hljs-number">666</span> } 
   handleClick=<span class="hljs-function">()=></span>{
     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
         <span class="hljs-attr">number</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> + <span class="hljs-number">1</span>
     })
   }
   <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>){
     <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
       hello，world
       <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span> ></span> 《React进阶实践指南》 { this.state.number } 👍  <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
       <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.handleClick</span> } ></span>点赞<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
     <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
   }
}
</code></pre>
<p><strong>fiber对应的关系如下</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5251e320a99f468ca3b46030febaa6b5~tplv-k3u1fbpfcp-watermark.image?" alt="WechatIMG1720.jpeg"></p>
<h2>三 Fiber更新机制</h2>
<h3>1 初始化</h3>
<p>既然上述明白了 fiber 里面有什么，以及 fiber 之间是如何建立起关联的，那么接下来就要从初始化和一次更新入手，看一下 fiber 是如何工作的。</p>
<p><strong>第一步：创建fiberRoot和rootFiber</strong></p>
<ul>
<li><code>fiberRoot</code>：首次构建应用， 创建一个 fiberRoot ，作为整个 React 应用的根基。</li>
<li><code>rootFiber</code>： 如下通过 ReactDOM.render 渲染出来的，如上 Index 可以作为一个 rootFiber。一个 React 应用可以有多 ReactDOM.render 创建的 rootFiber ，但是只能有一个 fiberRoot（应用根节点）。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Index</span>/></span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'app'</span>));
</code></pre>
<p>第一次挂载的过程中，会将 fiberRoot 和 rootFiber 建立起关联。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberRoot.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberRoot</span>(<span class="hljs-params">containerInfo,tag</span>){
    <span class="hljs-comment">/* 创建一个root */</span>
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FiberRootNode</span>(containerInfo,tag)
    <span class="hljs-keyword">const</span> rootFiber = <span class="hljs-title function_">createHostRootFiber</span>(tag);
    root.<span class="hljs-property">current</span> = rootFiber
    <span class="hljs-keyword">return</span> root
}
</code></pre>
<p>效果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb68640d39914c03bc77ea15616c7918~tplv-k3u1fbpfcp-watermark.image" alt="3.jpg"></p>
<p><strong>第二步：workInProgress和current</strong></p>
<p>经过第一步的处理，开始到正式渲染阶段，会进入 beginwork 流程，在讲渲染流程之前，要先弄明白两个概念：</p>
<ul>
<li>workInProgress是：正在内存中构建的 Fiber 树称为 workInProgress Fiber 树。在一次更新中，所有的更新都是发生在 workInProgress 树上。在一次更新之后，workInProgress 树上的状态是最新的状态，那么它将变成 current 树用于渲染视图。</li>
<li>current：正在视图层渲染的树叫做 current 树。</li>
</ul>
<p>接下来会到 rootFiber 的渲染流程，首先会复用当前 current 树（ rootFiber ）的 <code>alternate</code> 作为 workInProgress ，如果没有 alternate （初始化的 rootFiber 是没有 alternate ），那么会创建一个 fiber 作为 workInProgress 。会用 alternate 将新创建的 workInProgress 与 current 树建立起关联。这个关联过程只有初始化第一次创建 alternate 时候进行。</p>
<pre><code class="hljs language-js">currentFiber.<span class="hljs-property">alternate</span> = workInProgressFiber
workInProgressFiber.<span class="hljs-property">alternate</span> = currentFiber
</code></pre>
<p>效果：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a7f5a9b77ff45febd8e255fcba1ba3a~tplv-k3u1fbpfcp-watermark.image" alt="4.jpg"></p>
<p><strong>第三步：深度调和子节点，渲染视图</strong></p>
<p>接下来会按照上述第二步，在新创建的 alternates 上，完成整个 fiber 树的遍历，包括 fiber 的创建。</p>
<p>效果：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cda0522c0c85435494ccf3a3ea587baa~tplv-k3u1fbpfcp-watermark.image" alt="5.jpg"></p>
<p>最后会以 workInProgress 作为最新的渲染树，fiberRoot 的 current 指针指向 workInProgress 使其变为 current Fiber 树。到此完成初始化流程。</p>
<p>效果：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/907fb4f6768842438e0df7f083adc4b6~tplv-k3u1fbpfcp-watermark.image" alt="6.jpg"></p>
<h3>2 更新</h3>
<p>如果对于上述 demo ，开发者点击一次按钮发生更新，接下来会发生什么呢?
首先会走如上的逻辑，重新创建一颗 workInProgresss 树，复用当前 current 树上的 alternate ，作为新的 workInProgress ，由于初始化 rootfiber 有 alternate ，所以对于剩余的子节点，React 还需要创建一份，和 current 树上的 fiber 建立起 alternate 关联。渲染完毕后，workInProgresss 再次变成 current 树。</p>
<p>效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff00ce5f2db0430c841ea3a01754542e~tplv-k3u1fbpfcp-watermark.image" alt="7.jpg"></p>
<p><strong>｜--------问与答--------｜</strong><br>
问：如果如上又发生一次点击，会发生什么？</p>
<p>答：如果进行下一次更新，那么会将 current 的 alternate 作为基础（如图右树），复制一份作为 workInProgresss ，然后进行更新。</p>
<p><strong>｜--------end---------|</strong></p>
<h3>双缓冲树</h3>
<p>canvas 绘制动画的时候，如果上一帧计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。为了解决这个问题，canvas 在内存中绘制当前动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。这种在内存中构建并直接替换的技术叫做<strong>双缓存</strong>。</p>
<p>React 用 workInProgress 树(内存中构建的树) 和 current (渲染树) 来实现更新逻辑。双缓存一个在内存中构建，一个渲染视图，两颗树用 alternate 指针相互指向，在下一次渲染的时候，直接复用缓存树做为下一次渲染树，上一次的渲染树又作为缓存树，这样可以防止只用一颗树更新状态的丢失的情况，又加快了 DOM 节点的替换与更新。</p>
<h2>四 两大阶段：render和commit</h2>
<p>render 阶段和 commit 阶段是整个 fiber Reconciler 的核心，接下来研究一下两个阶段能做些什么？在正式讲解之前，有必要看一下整个 fiber 的遍历开始—— workLoop ，那么首先看一下 workLoop 。</p>
<h3>1 render阶段</h3>
<blockquote>
<p>react-reconciler/src/ReactFiberWorkLoop.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span> (){
    <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> ) {
      workInProgress = <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);
    }
}
</code></pre>
<p>上述已经说了，每一个 fiber 可以看作一个执行的单元，在调和过程中，每一个发生更新的 fiber 都会作为一次 workInProgress 。那么 workLoop 就是执行每一个单元的调度器，如果渲染没有被中断，那么 workLoop 会遍历一遍 fiber 树。
performUnitOfWork 包括两个阶段 beginWork 和 completeWork 。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberWorkLoop.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params"></span>){
    next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, renderExpirationTime);
    <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) {
       next = <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);
    }
}
</code></pre>
<p><code>beginWork</code>：是向下调和的过程。就是由 fiberRoot 按照 child 指针逐层向下调和，期间会执行函数组件，实例类组件，diff 调和子节点，打不同effectTag。</p>
<p><code>completeUnitOfWork</code>：是向上归并的过程，如果有兄弟节点，会返回 sibling兄弟，没有返回 return 父级，一直返回到 fiebrRoot ，期间可以形成effectList，对于初始化流程会创建 DOM ，对于 DOM 元素进行事件收集，处理style，className等。</p>
<p>这么一上一下，构成了整个 fiber 树的调和。</p>
<h4>向下调和beginWork</h4>
<p>先来看一下 beginwork 到底做了些什么？</p>
<blockquote>
<p>react-reconciler/src/ReactFiberBeginWork.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">beginWork</span>(<span class="hljs-params">current,workInProgress</span>){

    <span class="hljs-keyword">switch</span>(workInProgress.<span class="hljs-property">tag</span>){
       <span class="hljs-keyword">case</span> <span class="hljs-title class_">IndeterminateComponent</span>:{<span class="hljs-comment">// 初始化的时候不知道是函数组件还是类组件 </span>
           <span class="hljs-comment">//....</span>
       }
       <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>: {<span class="hljs-comment">//对应函数组件</span>
           <span class="hljs-comment">//....</span>
       }
       <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:{  <span class="hljs-comment">//类组件</span>
           <span class="hljs-comment">//...</span>
       }
       <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:{
           <span class="hljs-comment">//...  </span>
       }
       ...
    }
}
</code></pre>
<p>到这里把之前讲的章节串联起来，在生命周期章节，主要讲了 <code>ClassComponent</code>，在第十八章节讲了 <code>FunctionComponent</code> ，总结beginWork 作用如下：</p>
<ul>
<li>对于组件，执行部分生命周期，执行 render ，得到最新的 children 。</li>
<li>向下遍历调和 children ，复用 oldFiber ( diff 算法)，diff 流程在第十二章已经讲过了。</li>
<li>打不同的副作用标签 effectTag ，比如类组件的生命周期，或者元素的增加，删除，更新。</li>
</ul>
<p><strong>reconcileChildren</strong></p>
<p>接下来看一下 React 是如何调和子节点的：</p>
<blockquote>
<p>react-reconciler/src/ReactFiberBeginWork.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildren</span>(<span class="hljs-params">current,workInProgress</span>){
   <span class="hljs-keyword">if</span>(current === <span class="hljs-literal">null</span>){  <span class="hljs-comment">/* 初始化子代fiber  */</span>
        workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">mountChildFibers</span>(workInProgress,<span class="hljs-literal">null</span>,nextChildren,renderExpirationTime)
   }<span class="hljs-keyword">else</span>{  <span class="hljs-comment">/* 更新流程，diff children将在这里进行。 */</span>
        workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">reconcileChildFibers</span>(workInProgress,current.<span class="hljs-property">child</span>,nextChildren,renderExpirationTime)
   }
}
</code></pre>
<p><strong>EffectTag</strong>
我列举几个常用的 effectTag 。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Placement</span> = <span class="hljs-comment">/*             */</span> <span class="hljs-number">0b0000000000010</span>;  <span class="hljs-comment">// 插入节点</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Update</span> = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b0000000000100</span>;  <span class="hljs-comment">// 更新fiber</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Deletion</span> = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b0000000001000</span>;  <span class="hljs-comment">// 删除fiebr</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Snapshot</span> = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b0000100000000</span>;  <span class="hljs-comment">// 快照</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Passive</span> = <span class="hljs-comment">/*               */</span> <span class="hljs-number">0b0001000000000</span>;  <span class="hljs-comment">// useEffect的副作用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Callback</span> = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b0000000100000</span>;  <span class="hljs-comment">// setState的 callback</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Ref</span> = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b0000010000000</span>;  <span class="hljs-comment">// ref</span>
</code></pre>
<h4>向上归并 completeUnitOfWork</h4>
<p>completeUnitOfWork 的流程是自下向上的，那么 completeUnitOfWork 过程主要做写什么呢？</p>
<ul>
<li>首先 completeUnitOfWork 会将 effectTag 的 Fiber 节点会被保存在一条被称为 effectList 的单向链表中。在 commit 阶段，将不再需要遍历每一个 fiber ，只需要执行更新 effectList 就可以了。</li>
<li>completeWork 阶段对于组件处理 context ；对于元素标签初始化，会创建真实 DOM ，将子孙 DOM 节点插入刚生成的 DOM 节点中；会触发 diffProperties 处理 props ，比如事件收集，style，className 处理，在15章讲到过。</li>
</ul>
<h4>调和顺序</h4>
<p>那么上述写的demo片段，在初始化或者一次更新中调和顺序是怎样的呢？</p>
<ul>
<li>beginWork    -> rootFiber</li>
<li>beginWork    -> Index fiber</li>
<li>beginWork    -> div fiber</li>
<li>beginWork    -> hello,world fiber</li>
<li>completeWork -> hello,world fiber (completeWork返回sibling)</li>
<li>beginWork    -> p fiber</li>
<li>completeWork -> p fiber</li>
<li>beginWork    -> button fiber</li>
<li>completeWork -> button fiber (此时没有sibling，返回return)</li>
<li>completeWork -> div fiber</li>
<li>completeWork -> Index fiber</li>
<li>completeWork -> rootFiber  (完成整个workLoop)</li>
</ul>
<blockquote>
<p>没有  《React进阶实践指南》 和 点赞  的 文本fiber的beginWork/completeWork流程，是因为作为一种性能优化手段，针对只有单一文本子节点的Fiber，React会特殊处理。</p>
</blockquote>
<h3>2 commit阶段</h3>
<p>既然完成 render 阶段，接下来将进行第二阶段 commit 阶段。commit 阶段做的事情是：</p>
<ul>
<li>
<p>一方面是对一些生命周期和副作用钩子的处理，比如 componentDidMount ，函数组件的 useEffect ，useLayoutEffect ；</p>
</li>
<li>
<p>另一方面就是在一次更新中，添加节点（ <code>Placement</code> ），更新节点（ <code>Update</code> ），删除节点（ <code>Deletion</code> ），还有就是一些细节的处理，比如 ref 的处理。</p>
</li>
</ul>
<p>commit 细分可以分为：</p>
<ul>
<li><code>Before mutation</code> 阶段（执行 DOM 操作前）；</li>
<li><code>mutation</code> 阶段（执行 DOM 操作）；</li>
<li><code>layout</code> 阶段（执行 DOM 操作后）</li>
</ul>
<h4>① Before mutation</h4>
<blockquote>
<p>react-reconciler/src/ReactFiberWorkLoop.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitBeforeMutationEffects</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> effectTag = nextEffect.<span class="hljs-property">effectTag</span>;
    <span class="hljs-keyword">if</span> ((effectTag &#x26; <span class="hljs-title class_">Snapshot</span>) !== <span class="hljs-title class_">NoEffect</span>) {
      <span class="hljs-keyword">const</span> current = nextEffect.<span class="hljs-property">alternate</span>;
      <span class="hljs-comment">// 调用getSnapshotBeforeUpdates</span>
      <span class="hljs-title function_">commitBeforeMutationEffectOnFiber</span>(current, nextEffect);
    }
    <span class="hljs-keyword">if</span> ((effectTag &#x26; <span class="hljs-title class_">Passive</span>) !== <span class="hljs-title class_">NoEffect</span>) {
       <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-title class_">NormalPriority</span>, <span class="hljs-function">() =></span> {
          <span class="hljs-title function_">flushPassiveEffects</span>();
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        });
    }
    nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
  }
}
</code></pre>
<p>Before mutation 阶段做的事主要有以下内容：</p>
<ul>
<li>因为 Before mutation 还没修改真实的 DOM ，是获取 DOM 快照的最佳时期，如果是类组件有 getSnapshotBeforeUpdate ，那么会执行这个生命周期。</li>
<li>会异步调用 useEffect ，在生命周期章节讲到 useEffect 是采用异步调用的模式，其目的就是防止同步执行时阻塞浏览器做视图渲染。</li>
</ul>
<h4>② Mutation</h4>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitMutationEffects</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (effectTag &#x26; <span class="hljs-title class_">Ref</span>) { <span class="hljs-comment">/* 置空Ref */</span>
            <span class="hljs-keyword">const</span> current = nextEffect.<span class="hljs-property">alternate</span>;
            <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
                <span class="hljs-title function_">commitDetachRef</span>(current);
            }
        }
        <span class="hljs-keyword">switch</span> (primaryEffectTag) {
            <span class="hljs-keyword">case</span> <span class="hljs-title class_">Placement</span>: {} <span class="hljs-comment">//  新增元素</span>
            <span class="hljs-keyword">case</span> <span class="hljs-title class_">Update</span>:{}     <span class="hljs-comment">//  更新元素</span>
            <span class="hljs-keyword">case</span> <span class="hljs-title class_">Deletion</span>:{}   <span class="hljs-comment">//  删除元素</span>
        }
    } 
}
</code></pre>
<p>mutation 阶段做的事情有：</p>
<ul>
<li>置空 ref ，在 ref 章节讲到对于 ref 的处理。</li>
<li>对新增元素，更新元素，删除元素。进行真实的 DOM 操作。</li>
</ul>
<h4>③ Layout</h4>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitLayoutEffects</span>(<span class="hljs-params">root</span>){
     <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">const</span> effectTag = nextEffect.<span class="hljs-property">effectTag</span>;
          <span class="hljs-title function_">commitLayoutEffectOnFiber</span>(root,current,nextEffect,committedExpirationTime)
          <span class="hljs-keyword">if</span> (effectTag &#x26; <span class="hljs-title class_">Ref</span>) {
             <span class="hljs-title function_">commitAttachRef</span>(nextEffect);
          }
     }
}
</code></pre>
<p>Layout 阶段 DOM 已经更新完毕，Layout 做的事情有：</p>
<ul>
<li>commitLayoutEffectOnFiber 对于类组件，会执行生命周期，setState 的callback，对于函数组件会执行 useLayoutEffect 钩子。</li>
<li>如果有 ref ，会重新赋值 ref 。</li>
</ul>
<p>接下来对 commit 阶段做一个总结，主要做的事就是执行effectList，更新DOM，执行生命周期，获取ref等操作。</p>
<h3>3 调和 + 异步调度 流程总图</h3>
<p>把上一章节和本章节串联起来，调和调度过程，如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/429a103a732e42b69b6cd9a32f1d265a~tplv-k3u1fbpfcp-watermark.image" alt="3.jpeg"></p>
<h2>五 总结</h2>
<p>这节主要介绍了：</p>
<ul>
<li>fiber 的诞生的初衷，以及 fiber 组成，不同种类的 fiber ，fiber 如何建立起联系。</li>
<li>fiber 的更新机制，双缓冲树。</li>
<li>reconciler 调和过程，以及 render 和 commit 两大阶段。</li>
</ul>
<p>明白了 fiber 架构，下一节将深入 Hooks 原理 。</p></div>
</body></html>