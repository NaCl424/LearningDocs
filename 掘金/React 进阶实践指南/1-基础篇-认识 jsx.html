<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>基础篇-认识 jsx</h1>
<h2>一 我们写的 JSX 终将变成什么</h2>
<p>万物始于 <code>jsx</code>，想要深入学习 react ，就应该从 jsx 入手。弄清楚 jsx ，方便学习掌握以下内容：</p>
<ul>
<li>了解常用的元素会被 React 处理成什么，有利于后续理解 react fiber 类型；</li>
<li>理解 jsx 的编译过程，方便操纵 children、控制 React 渲染，有利于便捷使用 React 插槽组件。</li>
</ul>
<p>我写了一段 react JSX 代码，接下来，我们一步步看看它最后会变成什么样子。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> toLearn = [ <span class="hljs-string">'react'</span> , <span class="hljs-string">'vue'</span> , <span class="hljs-string">'webpack'</span> , <span class="hljs-string">'nodejs'</span>  ]

<span class="hljs-keyword">const</span> TextComponent = <span class="hljs-function">()=></span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> hello , i am function component <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span> 

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    status = <span class="hljs-literal">false</span> <span class="hljs-comment">/* 状态 */</span>
    renderFoot=<span class="hljs-function">()=></span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> i am foot<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">/* 以下都是常用的jsx元素节 */</span>
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">marginTop:</span>'<span class="hljs-attr">100px</span>' }}   ></span>
            { /* element 元素类型 */ }
            <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>hello,world<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
            { /* fragment 类型 */ }
            <span class="hljs-tag">&#x3C;<span class="hljs-name">React.Fragment</span>></span>
                <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> 👽👽 <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">React.Fragment</span>></span>
            { /* text 文本类型 */ }
            my name is alien 
            { /* 数组节点类型 */ }
            { toLearn.map(item=> <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item}</span> ></span>let us learn { item } <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span> ) }
            { /* 组件类型 */ }
            <span class="hljs-tag">&#x3C;<span class="hljs-name">TextComponent</span>/></span>
            { /* 三元运算 */  }
            { this.status ? <span class="hljs-tag">&#x3C;<span class="hljs-name">TextComponent</span> /></span> : <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>三元运算<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span> }
            { /* 函数执行 */ } 
            { this.renderFoot() }
            <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> console.log( this.render() ) } >打印render后的内容<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    }
}
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c830651f91244fdba008bff4824736f6~tplv-k3u1fbpfcp-watermark.image" alt="jsx_02.jpg"></p>
<h3>1 babel 处理后的样子</h3>
<p><strong>首先，看一下上述例子中的 jsx 模版会被babel编译成什么？</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63f79f34c6184f46bd628ea24351a40a~tplv-k3u1fbpfcp-watermark.image" alt="jsx_03.jpg"></p>
<p>和如上看到的一样，我写的 JSX 元素节点会被编译成 React Element 形式。那么，我们首先来看一下 React.createElement 的用法。</p>
<pre><code class="hljs language-js">React.createElement(
  type,
  [props],
  [...children]
)
</code></pre>
<p><code>createElement</code> 参数：<br></p>
<ul>
<li>
<p>第一个参数：如果是组件类型，会传入组件对应的类或函数；如果是 dom 元素类型，传入 div 或者 span 之类的字符串。</p>
</li>
<li>
<p>第二个参数：一个对象，在 dom 类型中为标签属性，在组件类型中为 props 。</p>
</li>
<li>
<p>其他参数：依次为 children，根据顺序排列。</p>
</li>
</ul>
<p>举个例子：</p>
<pre><code class="hljs language-js">&#x3C;div>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">TextComponent</span> /></span></span>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>hello,world<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
   <span class="hljs-keyword">let</span> us learn React!
&#x3C;/div>
</code></pre>
<p>上面的代码会被 babel 先编译成：</p>
<pre><code class="hljs language-js"> React.createElement(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>,
        React.createElement(TextComponent, <span class="hljs-literal">null</span>),
        React.createElement(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"hello,world"</span>),
        <span class="hljs-string">"let us learn React!"</span>
    )
</code></pre>
<p><strong>｜--------问与答--------｜</strong><br></p>
<p>问：老版本的 React 中，为什么写 jsx 的文件要默认引入 React?<br>
如下</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>hello,world<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>答：因为 jsx 在被 babel 编译后，写的 jsx 会变成上述 React.createElement 形式，所以需要引入 React，防止找不到 React 引起报错。<br></p>
<p><strong>｜---------end---------｜</strong></p>
<h3>2 createElement 处理后的样子</h3>
<p>然后点击按钮，看一下写的 demo 会被 React.createElement 变成什么:</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b03ba798b2c2471eb00e5ecab6fe91fe~tplv-k3u1fbpfcp-watermark.image" alt="jsx_01.jpg"></p>
<p>从上面写的 jsx 结构来看，外层的 div 被 react.createElement 转换成 react element 对象，div 里面的 8 个元素分别转换成 children 子元素列表。下面就是 jsx 的转换规则，请一定要记住，以便后续能更流畅地使用 jsx 语法。</p>













































<table><thead><tr><th><code>jsx</code>元素类型</th><th><code>react.createElement</code> 转换后</th><th><code>type</code> 属性</th></tr></thead><tbody><tr><td><code>element</code>元素类型</td><td><code>react element</code>类型</td><td>标签字符串，例如 <code>div</code></td></tr><tr><td><code>fragment</code>类型</td><td><code>react element</code>类型</td><td><code>symbol</code>  <code>react.fragment</code>类型</td></tr><tr><td>文本类型</td><td>直接字符串</td><td>无</td></tr><tr><td>数组类型</td><td>返回数组结构，里面元素被<code>react.createElement</code>转换</td><td>无</td></tr><tr><td>组件类型</td><td><code>react element</code>类型</td><td>组件类或者组件函数本身</td></tr><tr><td>三元运算 / 表达式</td><td>先执行三元运算，然后按照上述规则处理</td><td>看三元运算返回结果</td></tr><tr><td>函数执行</td><td>先执行函数，然后按照上述规则处理</td><td>看函数执行返回结果</td></tr></tbody></table>
<h3>3 React 底层调和处理后，终将变成什么？</h3>
<p>最终，在调和阶段，上述 React element 对象的每一个子节点都会形成一个与之对应的 fiber 对象，然后通过 sibling、return、child 将每一个 fiber 对象联系起来。</p>
<p>所以，我们有必要先来看一下 React 常用的 fiber 类型，以及 element 对象和 fiber 类型的对应关系。</p>
<h4>不同种类的 fiber Tag</h4>
<p>React 针对不同 React element 对象会产生不同 tag (种类) 的fiber 对象。首先，来看一下 tag 与 element 的对应关系：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> FunctionComponent = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 函数组件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ClassComponent = <span class="hljs-number">1</span>;          <span class="hljs-comment">// 类组件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IndeterminateComponent = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 初始化的时候不知道是函数组件还是类组件 </span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HostRoot = <span class="hljs-number">3</span>;                <span class="hljs-comment">// Root Fiber 可以理解为根元素 ， 通过reactDom.render()产生的根元素</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HostPortal = <span class="hljs-number">4</span>;              <span class="hljs-comment">// 对应  ReactDOM.createPortal 产生的 Portal </span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HostComponent = <span class="hljs-number">5</span>;           <span class="hljs-comment">// dom 元素 比如 &#x3C;div></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HostText = <span class="hljs-number">6</span>;                <span class="hljs-comment">// 文本节点</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Fragment = <span class="hljs-number">7</span>;                <span class="hljs-comment">// 对应 &#x3C;React.Fragment> </span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Mode = <span class="hljs-number">8</span>;                    <span class="hljs-comment">// 对应 &#x3C;React.StrictMode>   </span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ContextConsumer = <span class="hljs-number">9</span>;         <span class="hljs-comment">// 对应 &#x3C;Context.Consumer></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ContextProvider = <span class="hljs-number">10</span>;        <span class="hljs-comment">// 对应 &#x3C;Context.Provider></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ForwardRef = <span class="hljs-number">11</span>;             <span class="hljs-comment">// 对应 React.ForwardRef</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Profiler = <span class="hljs-number">12</span>;               <span class="hljs-comment">// 对应 &#x3C;Profiler/ ></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SuspenseComponent = <span class="hljs-number">13</span>;      <span class="hljs-comment">// 对应 &#x3C;Suspense></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MemoComponent = <span class="hljs-number">14</span>;          <span class="hljs-comment">// 对应 React.memo 返回的组件</span>
</code></pre>
<h4>jsx 最终形成的 fiber 结构图</h4>
<p>最终写的 jsx 会变成如下格式：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/873f00b1255d4f5f8dac4954cf37dc9f~tplv-k3u1fbpfcp-watermark.image" alt="jsx7.jpg"></p>
<p>fiber 对应关系</p>
<ul>
<li>child： 一个由父级 fiber 指向子级 fiber 的指针。</li>
<li>return：一个子级 fiber 指向父级 fiber 的指针。</li>
<li>sibling: 一个 fiber 指向下一个兄弟 fiber 的指针。</li>
</ul>
<p>温馨提示：</p>
<ul>
<li>对于上述在 jsx 中写的 map 数组结构的子节点，外层会被加上 fragment ；</li>
<li>map 返回数组结构，作为 fragment 的子节点。</li>
</ul>
<h2>二 进阶实践-可控性 render</h2>
<p>上面的 demo 暴露出了如下问题：</p>
<ol>
<li>返回的 <code>children</code> 虽然是一个数组，但是数组里面的数据类型却是不确定的，有对象类型( 如<code>ReactElement</code> ) ，有数组类型(如 <code>map</code> 遍历返回的子节点)，还有字符串类型(如文本)；</li>
<li>无法对 render 后的 React element 元素进行可控性操作。</li>
</ol>
<p>针对上述问题，我们需要对demo项目进行改造处理，具体过程可以分为4步：</p>
<ol>
<li>将上述children扁平化处理，将数组类型的子节点打开 ；</li>
<li>干掉children中文本类型节点；</li>
<li>向children最后插入<div class="last"> say goodbye</div>元素；</li>
<li>克隆新的元素节点并渲染。</li>
</ol>
<p>希望通过这个实践 demo ，大家可以<strong>加深对 jsx 编译后结构的认识，学会对 jsx 编译后的 React.element 进行一系列操作，达到理想化的目的，以及熟悉 React API 的使用。</strong></p>
<p>由于，我们想要把 render 过程变成可控的，因此需要把上述代码进行改造。</p>
<pre><code class="hljs language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    status = <span class="hljs-literal">false</span> <span class="hljs-comment">/* 状态 */</span>
    renderFoot=<span class="hljs-function">()=></span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> i am foot<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    <span class="hljs-comment">/* 控制渲染 */</span>
    controlRender=<span class="hljs-function">()=></span>{
        <span class="hljs-keyword">const</span> reactElement = (
            <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">marginTop:</span>'<span class="hljs-attr">100px</span>' }} <span class="hljs-attr">className</span>=<span class="hljs-string">"container"</span>  ></span>   
                 { /* element 元素类型 */ }
                <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>hello,world<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>  
                { /* fragment 类型 */ }
                <span class="hljs-tag">&#x3C;<span class="hljs-name">React.Fragment</span>></span>      
                    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> 👽👽 <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
                <span class="hljs-tag">&#x3C;/<span class="hljs-name">React.Fragment</span>></span>
                { /* text 文本类型 */ }
                my name is alien       
                { /* 数组节点类型 */ }
                { toLearn.map(item=> <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item}</span> ></span>let us learn { item } <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span> ) } 
                { /* 组件类型 */ }
                <span class="hljs-tag">&#x3C;<span class="hljs-name">TextComponent</span>/></span>  
                { /* 三元运算 */  }
                { this.status ? <span class="hljs-tag">&#x3C;<span class="hljs-name">TextComponent</span> /></span> :  <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>三元运算<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span> }  
                { /* 函数执行 */ } 
                { this.renderFoot() }  
                <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> console.log( this.render() ) } >打印render后的内容<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
        )
        <span class="hljs-built_in">console</span>.log(reactElement)
        <span class="hljs-keyword">const</span> { children } = reactElement.props
        <span class="hljs-comment">/* 第1步 ： 扁平化 children  */</span>
        <span class="hljs-keyword">const</span> flatChildren = React.Children.toArray(children)
        <span class="hljs-built_in">console</span>.log(flatChildren)
        <span class="hljs-comment">/* 第2步 ： 除去文本节点 */</span>
        <span class="hljs-keyword">const</span> newChildren :any= []
        React.Children.forEach(flatChildren,<span class="hljs-function">(<span class="hljs-params">item</span>)=></span>{
            <span class="hljs-keyword">if</span>(React.isValidElement(item)) newChildren.push(item)
        })
        <span class="hljs-comment">/* 第3步，插入新的节点 */</span>
        <span class="hljs-keyword">const</span> lastChildren = React.createElement(<span class="hljs-string">`div`</span>,{ <span class="hljs-attr">className</span> :<span class="hljs-string">'last'</span> } ,<span class="hljs-string">`say goodbye`</span>)
        newChildren.push(lastChildren)
        
        <span class="hljs-comment">/* 第4步：修改容器节点 */</span>
        <span class="hljs-keyword">const</span> newReactElement =  React.cloneElement(reactElement,{} ,...newChildren )
        <span class="hljs-keyword">return</span> newReactElement
    }
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.controlRender()
    }
}
</code></pre>
<p><strong>第 1 步：<code>React.Children.toArray</code> 扁平化，规范化 children 数组。</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> flatChildren = React.Children.toArray(children)
<span class="hljs-built_in">console</span>.log(flatChildren)
</code></pre>
<p>React.Children.toArray 可以扁平化、规范化 React.element 的 children 组成的数组，只要 children 中的数组元素被打开，对遍历 children 很有帮助，而且 React.Children.toArray 还可以深层次 flat 。</p>
<p>打印结果：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/901d83b9ee574e74bf982336f48813cf~tplv-k3u1fbpfcp-watermark.image" alt="jsx5.jpg"></p>
<p><strong>第 2 步：遍历 children ，验证 React.element 元素节点，除去文本节点。</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> newChildren :any= []
React.Children.forEach(flatChildren,<span class="hljs-function">(<span class="hljs-params">item</span>)=></span>{
    <span class="hljs-keyword">if</span>(React.isValidElement(item)) newChildren.push(item)
})
</code></pre>
<p>用 React.Children.forEach 去遍历子节点，如果是 react Element 元素，就添加到新的 children 数组中，通过这种方式过滤掉非 React element 节点。React.isValidElement 这个方法可以用来检测是否为 React element 元素，接收一个参数——待验证对象，如果是返回 true ， 否则返回 false 。</p>
<p>这里可能会有一个疑问就是如下：<br></p>
<p>难道用数组本身方法 filter 过滤不行么 ？ 为什么要用 React.Children.forEach 遍历？</p>
<p>这种情况下，是完全可以用数组方法过滤的，因为 React.Children.toArray 已经处理了 children ，使它变成了正常的数组结构 也就是说 <code>React.Children.forEach</code> =  <code>React.Children.toArray</code> + <code>Array.prototype.forEach</code>。</p>
<p>React.Children.forEach 本身就可以把 children 扁平化了，也就是上述第一步操作多此一举了。为什么要有第一步，主要是更多的学习一下 React api。</p>
<p><strong>第 3 步：用 React.createElement ，插入到 children 最后</strong></p>
<pre><code class="hljs language-js"> <span class="hljs-comment">/* 第三步，插入新的节点 */</span>
<span class="hljs-keyword">const</span> lastChildren = React.createElement(<span class="hljs-string">`div`</span>,{ <span class="hljs-attr">className</span> :<span class="hljs-string">'last'</span> } ,<span class="hljs-string">`say goodbye`</span>)
newChildren.push(lastChildren)
</code></pre>
<p>上述代码实际等于用 <code>JSX</code> 这么写：</p>
<pre><code class="hljs language-js">newChildren.push(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"last"</span> ></span>say goodbye<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>)
</code></pre>
<p><strong>第 4 步: 已经修改了 children，现在做的是，通过 cloneElement 创建新的容器元素。</strong></p>
<p>为什么要用 React.cloneElement ，createElement 把上面写的 jsx，变成 element 对象;  而 cloneElement 的作用是以 element 元素为样板克隆并返回新的 React element 元素。返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。</p>
<p>这里 React.cloneElement 做的事情就是，把 reactElement 复制一份，再用新的 children 属性，从而达到改变 render 结果的目的。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 第 4 步：修改容器节点 */</span>
<span class="hljs-keyword">const</span> newReactElement =  React.cloneElement(reactElement,{} ,...newChildren )
</code></pre>
<p><strong>效果</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee3697b1d4094724b236b37a6a5c34e2~tplv-k3u1fbpfcp-watermark.image" alt="jsx6.jpg"></p>
<p>验证 ：</p>
<ul>
<li>① children 已经被扁平化。</li>
<li>② 文本节点 <code>my name is alien</code> 已经被删除。</li>
<li>③ <code>&#x3C;div className="last" > say goodbye&#x3C;/div></code> 元素成功插入。</li>
</ul>
<p><strong>达到了预期效果。</strong></p>
<p><strong>｜--------问与答--------｜</strong><br></p>
<p>问: React.createElement 和 React.cloneElement 到底有什么区别呢?</p>
<p>答: 可以完全理解为，一个是用来创建 element 。另一个是用来修改 element，并返回一个新的 React.element 对象。<br></p>
<p><strong>｜---------end---------｜</strong></p>
<h2>三、Babel 解析 JSX 流程</h2>
<h3>1 @babel/plugin-syntax-jsx 和 @babel/plugin-transform-react-jsx</h3>
<p>JSX 语法实现来源于这两个 babel 插件：</p>
<ul>
<li>@babel/plugin-syntax-jsx ： 使用这个插件，能够让 Babel 有效的解析 JSX 语法。</li>
<li>@babel/plugin-transform-react-jsx ：这个插件内部调用了 @babel/plugin-syntax-jsx，可以把 React JSX 转化成 JS 能够识别的 createElement 格式。</li>
</ul>
<p><strong>Automatic Runtime</strong></p>
<p>新版本 React 已经不需要引入 createElement ，这种模式来源于 <code> Automatic Runtime</code>，看一下是如何编译的。</p>
<p>业务代码中写的 JSX 文件：</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>hello,world<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">span</span>></span>let us learn React<span class="hljs-tag">&#x3C;/<span class="hljs-name">span</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>被编译后的文件：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { jsx <span class="hljs-keyword">as</span> _jsx } <span class="hljs-keyword">from</span> <span class="hljs-string">"react/jsx-runtime"</span>;
<span class="hljs-keyword">import</span> { jsxs <span class="hljs-keyword">as</span> _jsxs } <span class="hljs-keyword">from</span> <span class="hljs-string">"react/jsx-runtime"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span>  _jsxs(<span class="hljs-string">"div"</span>, {
            <span class="hljs-attr">children</span>: [
                _jsx(<span class="hljs-string">"h1"</span>, {
                   <span class="hljs-attr">children</span>: <span class="hljs-string">"hello,world"</span>
                }),
                _jsx(<span class="hljs-string">"span"</span>, {
                    <span class="hljs-attr">children</span>:<span class="hljs-string">"let us learn React"</span> ,
                }),
            ],
        });
}
</code></pre>
<p>plugin-syntax-jsx 已经向文件中提前注入了 _jsxRuntime api。不过这种模式下需要我们在 .babelrc 设置 runtime: automatic 。</p>
<pre><code class="hljs language-json"><span class="hljs-string">"presets"</span>: [    
    [<span class="hljs-string">"@babel/preset-react"</span>,{
    <span class="hljs-attr">"runtime"</span>: <span class="hljs-string">"automatic"</span>
    }]     
],
</code></pre>
<p><strong>Classic Runtime</strong></p>
<p>还有一个就是经典模式，在经典模式下，使用 JSX 的文件需要引入 React ，不然就会报错。</p>
<p>业务代码中写的 JSX 文件：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>hello,world<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">span</span>></span>let us learn React<span class="hljs-tag">&#x3C;/<span class="hljs-name">span</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>被编译后的文件：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span>  React.createElement(
        <span class="hljs-string">"div"</span>,
        <span class="hljs-literal">null</span>,
        React.createElement(<span class="hljs-string">"h1"</span>, <span class="hljs-literal">null</span>,<span class="hljs-string">"hello,world"</span>),
        React.createElement(<span class="hljs-string">"span"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"let us learn React"</span>)
    );
}
</code></pre>
<h3>2 api层面模拟实现</h3>
<p>接下来我们通过 api 的方式来模拟一下 Babel 处理 JSX 的流程。</p>
<p>第一步：创建 element.js，写下将测试的 JSX 代码。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TestComponent</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span> hello,React <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">span</span>></span>模拟 babel 处理 jsx 流程。<span class="hljs-tag">&#x3C;/<span class="hljs-name">span</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">TestComponent</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Index
</code></pre>
<p>第二步：因为 babel 运行在 node 环境，所以同级目录下创建 jsx.js 文件。来模拟一下编译的效果。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/core"</span>)

<span class="hljs-comment">/* 第一步：模拟读取文件内容。 */</span>
fs.readFile(<span class="hljs-string">'./element.js'</span>,<span class="hljs-function">(<span class="hljs-params">e,data</span>)=></span>{ 
    <span class="hljs-keyword">const</span> code = data.toString(<span class="hljs-string">'utf-8'</span>)
    <span class="hljs-comment">/* 第二步：转换 jsx 文件 */</span>
    <span class="hljs-keyword">const</span> result = babel.transformSync(code, {
        <span class="hljs-attr">plugins</span>: [<span class="hljs-string">"@babel/plugin-transform-react-jsx"</span>],
    });
    <span class="hljs-comment">/* 第三步：模拟重新写入内容。 */</span>
    fs.writeFile(<span class="hljs-string">'./element.js'</span>,result.code,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{})
})
</code></pre>
<p>如上经过三步处理之后，再来看一下 element.js 变成了什么样子。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TestComponent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-comment">/*#__PURE__*/</span>React.createElement(<span class="hljs-string">"p"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">" hello,React "</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-comment">/*#__PURE__*/</span>React.createElement(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-comment">/*#__PURE__*/</span>React.createElement(<span class="hljs-string">"span"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"\u6A21\u62DF babel \u5904\u7406 jsx \u6D41\u7A0B\u3002"</span>), <span class="hljs-comment">/*#__PURE__*/</span>React.createElement(TestComponent, <span class="hljs-literal">null</span>));
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Index;
</code></pre>
<p>如上可以看到已经成功转成 React.createElement 形式，从根本上弄清楚了 Babel 解析 JSX 的大致流程。</p>
<h2>四、总结</h2>
<p>本章节主要讲到了两方面的知识。</p>
<p>一方面，我们写的 JSX 会先转换成 React.element，再转化成 React.fiber 的过程。这里要牢牢记住 jsx 转化成 element 的处理逻辑，还有就是 element 类型与转化成 fiber 的 tag 类型的对应关系。这对后续的学习会很有帮助。</p>
<p>另一方面，通过学习第一个实践 demo，我们掌握了如何控制经过 render 之后的 React element 对象。</p>
<p>同时也搞清楚了 Babel 解析 JSX 的大致流程。</p>
<p>下一章节，我们将从React组件角度出发，全方面认识React组件。</p>
<h3><a href="https://github.com/GoodLuckAlien/React-Advanced-Guide-Pro" target="_blank" rel="nofollow noopener noreferrer"><code>案例代码的github地址</code></a>(点击即可跳转)</h3></div>
</body></html>