<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>[WIP]实践篇-自定义 Hooks 设计</h1>
<h2>一 前言</h2>
<p>本章节将围绕自定义 hooks 展开，本章节含的知识点如下：</p>
<ul>
<li>自定义 hooks 的设计和编写。</li>
<li>几个自定义 hooks 实战。</li>
</ul>
<h2>二 全面理解自定义 hooks</h2>
<p>在 hooks 原理章节，详细介绍了 <code>React Hooks</code> 原理，在其他的章节，也陆续讲解了所有常用的 hooks 用法。接下来针对 hooks 进行功能性拓展，来研究一下在 React 中一种逻辑复用，组件强化方式——自定义 hooks 。</p>
<h3>1 概念</h3>
<p>自定义 hooks 是在 React Hooks 基础上的一个拓展，可以根据业务需求制定满足业务需要的组合 hooks ，更注重的是逻辑单元。通过业务场景不同，到底需要React Hooks 做什么，怎么样把一段逻辑封装起来，做到复用，这是自定义 hooks 产生的初衷。</p>
<p>自定义 hooks 也可以说是 React Hooks 聚合产物，其内部有一个或者多个 React Hooks 组成，用于解决一些复杂逻辑。</p>
<p>一个传统自定义 hooks 长如下的样子：</p>
<p>编写：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useXXX</span>(<span class="hljs-params">参数A,参数B</span>){
    <span class="hljs-comment">/*  
     ...自定义 hooks 逻辑
     内部应用了其他 React Hooks —— useState | useEffect | useRef ...
    */</span>
    <span class="hljs-keyword">return</span> [xxx,...]
}

</code></pre>
<p>使用：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [ xxx , ... ] = <span class="hljs-title function_">useXXX</span>(参数A,参数B...)
</code></pre>
<p>实际上自定义 hooks 的编写很简单，开发者只需要关心，传入什么参数（也可以没有参数），和返回什么内容就可以了，当然有一些监听和执行副作用的自定义 hooks ，根本无需返回值。</p>
<p>自定义 hooks 参数可能是以下内容：</p>
<ul>
<li>hooks 初始化值。</li>
<li>一些副作用或事件的回调函数。</li>
<li>可以是 useRef 获取的 DOM 元素或者组件实例。</li>
<li>不需要参数</li>
</ul>
<p>自定义 hooks 返回值可能是以下内容：</p>
<ul>
<li>负责渲染视图获取的状态。</li>
<li>更新函数组件方法，本质上是 useState 或者 useReducer。</li>
<li>一些传递给子孙组件的状态。</li>
<li>没有返回值。</li>
</ul>
<h3>2 特性</h3>
<p>上述讲到了自定义 hooks 基本概念，接下来分析一下它的特性。</p>
<h4>① 驱动条件</h4>
<p>首先要明白一点，开发者写的自定义 hooks 本质上就是一个函数，而且函数在函数组件中被执行。那么<strong>自定义 hooks 驱动本质上就是函数组件的执行</strong>。</p>
<p>自定义 hooks 驱动条件：</p>
<ul>
<li>props 改变带来的函数组件执行。</li>
<li>useState | useReducer 改变 state 引起函数组件的更新。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fca8bd0234c43fda413c71b2023d8a2~tplv-k3u1fbpfcp-watermark.image" alt="1.jpg"></p>
<h4>② 顺序原则</h4>
<p>自定义 hooks 内部至少有一个 React Hooks ，那么自定义 hooks 也要遵循 hooks 的规则，<strong>不能放在条件语句中，而且要保持执行顺序的一致性。</strong> 至于为什么？ 在 hooks 原理章节已经讲过了。</p>
<h4>③ 条件限定</h4>
<p>在自定义 hooks 中，条件限定<strong>特别重要</strong>。为什么这么说呢，因为考虑 hooks 的限定条件，是一个出色的自定义 hooks 重要因素。举个例子：</p>
<p>一些同学容易滥用自定义 hooks 导致一些问题的发生 ，比如在一个自定义这里写：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useXXX</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(defaultContext)
    <span class="hljs-comment">/* .....用上下文中 value 一段初始化逻辑  */</span>
    <span class="hljs-keyword">const</span> newValue = <span class="hljs-title function_">initValueFunction</span>(value) <span class="hljs-comment">/* 初始化 value 得到新的 newValue  */</span>
    <span class="hljs-comment">/* ...... */</span>
    <span class="hljs-keyword">return</span> newValue
}
</code></pre>
<p>比如上述一个非常简单自定义 hooks ，从 <code>context</code> 取出状态 value ，通过 <code>initValueFunction</code> 加工 value ，得到并返回最新的 newValue 。如果直接按照上述这么写，会导致什么发生呢？</p>
<p>首先每一次函数组件更新，就会执行此自定义 hooks ，那么就会重复执行初始化逻辑，重复执行<code>initValueFunction</code> ，每一次都会得到一个最新的 newValue 。 如果 newValue 作为 <code>useMemo</code> 和 <code>useEffect</code> 的 deps ，或者作为子组件的 props ，那么子组件的浅比较 props 将失去作用，那么会带来一串麻烦。</p>
<p>那么如何解决这个问题呢？答案很简单，可以通过 useRef 对 newValue 缓存，然后每次执行自定义 hooks 判断有无缓存值。如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useXXX</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> newValue =  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)  <span class="hljs-comment">/* 创建一个 value 保存状态。  */</span>
    <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(defaultContext)
    <span class="hljs-keyword">if</span>(!newValue.<span class="hljs-property">current</span>){  <span class="hljs-comment">/* 如果 newValue 不存在 */</span>
          newValue.<span class="hljs-property">current</span> = <span class="hljs-title function_">initValueFunction</span>(value)
    }
    <span class="hljs-keyword">return</span> newValue.<span class="hljs-property">current</span>
}
</code></pre>
<ul>
<li>用一个 useRef 保存初始化过程中产生的 value 值 。</li>
<li>判断如果 value 不存在，那么通过 initValueFunction 创建，如果存在直接返回 newValue.current 。</li>
</ul>
<p>如上加了条件判断之后，会让自定义 hooks 内部按照期望的方向发展。条件限定是编写出色的 hooks 重要的因素。</p>
<h4>④ 考虑可变性</h4>
<p>在编写自定义 hooks 的时候，可变性也是一个非常重要的 hooks 特性。什么叫做可变性，<strong>就是考虑一些状态值发生变化，是否有依赖于当前值变化的执行逻辑或执行副作用。</strong></p>
<p>比如上面的例子🌰中，如果 defaultContext 中的 value 是可变的，那么如果还像上述用 useRef 这么写，就会造成 context 变化，得不到最新的 value 值的情况发生。</p>
<p>所以为了解决上述可变性的问题：</p>
<ul>
<li>对于依赖于可变性状态的执行逻辑，可以用 <code>useMemo</code> 来处理。</li>
<li>对于可变性状态的执行副作用，可以用 <code>useEffect</code> 来处理。</li>
<li>对于依赖可变性状态的函数或者属性，可以用<code>useCallback</code>来处理。
于是需要把上述自定义 hooks 改版。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useXXX</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(defaultContext)
    <span class="hljs-keyword">const</span> newValue = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useMemo</span>(<span class="hljs-function">()=></span> <span class="hljs-title function_">initValueFunction</span>(value) ,[  value  ] )  
    <span class="hljs-keyword">return</span>  newValue
}
</code></pre>
<ul>
<li>用 React.useMemo 来对 initValueFunction 初始化逻辑做缓存，当上下文 value 改变的时候，重新生成新的 newValue 。</li>
</ul>
<p>这只是一个简单例子，在实际开发中，要比这种情况复杂。开发者应该注意在自定义 hooks 中，哪些状态是可变的，状态改变，又会紧跟着哪些影响。</p>
<h4>⑤ 闭包效应</h4>
<p>闭包也是自定义 hooks 应该注意的问题。这个问题和 ④ 本质一样。首先函数组件更新就是函数本身执行，一次更新所有含有状态的 hooks （ <code>useState</code> 和 <code>useReducer</code> ）产生的状态 state 是重新声明的。但是如果像 <code>useEffect</code> ， <code>useMemo</code> ，<code>useCallback</code> 等，它们内部如果引用了 state 或 props 的值，而且这些状态最后保存在了函数组件对应的 fiber 上，那么此次函数组件执行完毕后，这些状态就不会被垃圾回收机制回收释放。这样造成的影响是，上述 hooks 如果没有把内部使用的 state 或 props 作为依赖项，那么内部就一直无法使用最新的 props 或者 state 。</p>
<p>比如我举个简单的例子。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useTest</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> [ number ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useMemo</span>(<span class="hljs-function">()=></span>{
         <span class="hljs-comment">// 内部引用了 number 进行计算</span>
    },[])
}
</code></pre>
<ul>
<li>如上 useMemo 内部使用了 state 中的 number 进行计算，当 number 改变但是无法得到最新的 value 。这就是上面我说到的闭包问题。解决方法就是 useMemo 的 deps 中加入 number。</li>
</ul>
<p>但是有的时候这种依赖关系往往是更复杂的。我将如上 demo 修改。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useTest</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> [ number ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useMemo</span>(<span class="hljs-function">()=></span>{
         <span class="hljs-comment">// 内部引用了 number 进行计算</span>
    },[ number ])
    <span class="hljs-keyword">const</span> callback = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useCallback</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
         <span class="hljs-comment">// 内部引用了 useEffect</span>
    },[ value ])
    
}
</code></pre>
<ul>
<li>如上，在之前的基础上，又加了 useCallback 而且内部引用了 useMemo 生成的 value。 这个时候如果 useCallback 执行，内部想要获取新的状态值 value，那么就需要把 value 放在 useCallback 的 deps 中。</li>
</ul>
<p><strong>🤔思考：如何分清楚依赖关系呢？</strong></p>
<ul>
<li><strong>第一步</strong>：找到 hooks 内部可能发生变化的状态 ， 这个状态可以是 state 或者 props。</li>
<li><strong>第二步</strong>：分析 useMemo 或者 useCallback 内部是否使用上述状态，或者是否<strong>关联使用</strong> useMemo 或者 useCallback 派生出来的状态（ 比如上述的 value ，就是 useMemo 派生的状态 ） ，如果有使用，那么加入到 deps 。</li>
<li><strong>第三步</strong>：分析 useEffect ，useLayoutEffect ，useImperativeHandle 内部是否使用上述两个步骤产生的值，而且还要这些值做一些副作用，如果有，那么加入到 deps 。</li>
</ul>
<h2>三 自定义 hooks 设计</h2>
<p>上述介绍了自定义 hooks 的概念和特性，接下来重点分析一下，如何去设计一个自定义 hooks 。</p>
<p>首先明确的一点是，自定义 hooks 解决逻辑复用的问题，那么在正常的业务开发过程中，要明白哪些逻辑是重复性强的逻辑，这段逻辑主要功能是什么。</p>
<p>下面我把自定义 hooks 能实现的功能化整为零，在实际开发中，可能是下面一种或者几种的结合。</p>
<h3>1 接收状态</h3>
<p>自定义 hooks ，可以通过函数参数来直接接收组件传递过来的状态，也可以通过 useContext ，来隐式获取上下文中的状态。比如 React Router 中最简单的一个自定义 hooks —— useHistory ，用于获取 history 对象。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useHistory</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">RouterContext</span>).<span class="hljs-property">history</span>
}
</code></pre>
<p>注意⚠️：<strong>如果使用了内部含有 useContext 的自定义 hooks ，那么当 context 上下文改变，会让使用自定义 hooks 的组件自动渲染。</strong></p>
<h3>2 存储｜管理状态</h3>
<p><strong>储存状态</strong></p>
<p>自定义 hooks 也可以用来储存和管理状态。本质上应用 useRef 保存原始对象的特性。</p>
<p>比如 <code>rc-form</code> 中的 <code>useForm</code> 里面就是用 useRef 来保存表单状态管理 Store 的。简化流程如下</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useForm</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> formCurrent = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)
    <span class="hljs-keyword">if</span>(!formCurrent.<span class="hljs-property">current</span>){
        formCurrent.<span class="hljs-property">current</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormStore</span>()
    }
    <span class="hljs-keyword">return</span> formCurrent.<span class="hljs-property">current</span>
}
</code></pre>
<p><strong>记录状态</strong></p>
<p>当然 useRef 和 useEffect 可以配合记录函数组件的内部的状态。举个例子，我编写一个自定义 hooks 用于记录函数组件执行次数，和是否第一次渲染。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useRenderCount</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> isFirstRender = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">/* 记录是否是第一次渲染 */</span>
    <span class="hljs-keyword">const</span> renderCount = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(<span class="hljs-number">1</span>)      <span class="hljs-comment">/* 记录渲染次数 */</span>
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
        isFirstRender.<span class="hljs-property">current</span> = <span class="hljs-literal">false</span>        <span class="hljs-comment">/* 第一次渲染完成，改变状态 */</span>
    },[])
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
        <span class="hljs-keyword">if</span>(!isFirstRender.<span class="hljs-property">current</span>) renderCount.<span class="hljs-property">current</span>++ <span class="hljs-comment">/* 如果不是第一次渲染，那么添加渲染次数  */</span>
    })  
    <span class="hljs-keyword">return</span> [ renderCount.<span class="hljs-property">current</span> , isFirstRender.<span class="hljs-property">current</span> ]
} 
</code></pre>
<ul>
<li>如上用 isFirstRender  记录是否是第一次渲染 ，用 renderCount 记录渲染次数，第一个 useEffect 依赖项为空，只执行一次，第二个 useEffect 没有依赖项，每一次函数组件执行，都会执行，统计渲染次数。</li>
</ul>
<p>上述只是举了一个例子，当然在具体开发中，可以用自定义 hooks 去记录一些其他的东西。比如元素的信息，因为可以在 useEffect 中获取到最新的 DOM 元素信息的。</p>
<h3>3 更新状态</h3>
<p><strong>改变状态</strong></p>
<p>自定义 hooks 内部可以保存状态，可以把更新状态的方法暴露出去，来改变 hooks 内部状态。而更新状态的方法可以是组合多态的。</p>
<p>比如实现一个防抖节流的自定义 hooks ：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, time</span>) {
    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...arg</span>) {
      <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);
      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, arg);
      }, time);
    };
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">useDebounceState</span>(<span class="hljs-params">defauleValue,time</span>){
    <span class="hljs-keyword">const</span> [ value , changeValue ] = <span class="hljs-title function_">useState</span>(defauleValue)
    <span class="hljs-comment">/* 对 changeValue 做防抖处理   */</span>
    <span class="hljs-keyword">const</span> newChange = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useMemo</span>(<span class="hljs-function">()=></span> <span class="hljs-title function_">debounce</span>(changeValue,time) ,[ time ])
    <span class="hljs-keyword">return</span> [ value , newChange ]
}
</code></pre>
<p>使用：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> [ value , setValue ] = <span class="hljs-title function_">useDebounceState</span>(<span class="hljs-string">''</span>,<span class="hljs-number">300</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">marginTop:</span>'<span class="hljs-attr">50px</span>' }} ></span>
        《React 进阶实践指南》
        <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">""</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span>=></span>setValue(e.target.value)}  />
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5aa90ff8fe8f401e8ba669af510c35d3~tplv-k3u1fbpfcp-watermark.image" alt="3.gif"></p>
<p><strong>组合state</strong></p>
<p>自定义 hooks 可以维护多个 state ，然后可以组合更新函数。我这么说可能很多同学不理解，下面我来举一个例子，比如控制数据加载和loading效果，</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useControlData</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> [ isLoading , setLoading ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)
    <span class="hljs-keyword">const</span> [ data,  setData ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>([])
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getData</span> = (<span class="hljs-params">data</span>)=> { <span class="hljs-comment">/* 获取到数据，清空 loading 效果  */</span>
        <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>)
        <span class="hljs-title function_">setData</span>(data)
    }  
    <span class="hljs-comment">// ... 其他逻辑</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resetData</span> = (<span class="hljs-params"></span>) =>{  <span class="hljs-comment">/* 请求数据之前，添加 loading 效果 */</span>
        <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>)
        <span class="hljs-title function_">setData</span>([])
    }
    <span class="hljs-keyword">return</span> [ getData , resetData , ...  ] 
}
</code></pre>
<p><strong>合理state</strong></p>
<p>useState 和 useRef 都可以保存状态：</p>
<ul>
<li>useRef 只要组件不销毁，一直存在，而且可以随时访问最新状态值。</li>
<li>useState 可以让组件更新，但是 state 需要在下一次函数组件执行的时候才更新，而且如果想让 useEffect 或者 useMemo 访问最新的 state 值，需要将 state 添加到 deps 依赖项中。</li>
</ul>
<p>自定义 hooks 可以通过 useState + useRef 的特性，取其精华，更合理的管理 state。比如如下实现一个<strong>同步的state</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useSyncState</span>(<span class="hljs-params">defaultValue</span>){
   <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(defaultValue)        <span class="hljs-comment">/* useRef 用于保存状态 */</span>
   <span class="hljs-keyword">const</span> [ ,forceUpdate ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>)   <span class="hljs-comment">/* useState 用于更新组件 */</span>
   <span class="hljs-keyword">const</span> <span class="hljs-title function_">dispatch</span> = (<span class="hljs-params">fn</span>) => {                      <span class="hljs-comment">/* 模拟一个更新函数 */</span>
       <span class="hljs-keyword">let</span> newValue
       <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">'function'</span> ){
            newValue = <span class="hljs-title function_">fn</span>(value.<span class="hljs-property">current</span>)           <span class="hljs-comment">/* 当参数为函数的情况 */</span>
       }<span class="hljs-keyword">else</span>{
           newValue = fn                           <span class="hljs-comment">/* 当参数为其他的情况 */</span>
       }
       value.<span class="hljs-property">current</span> = newValue
       <span class="hljs-title function_">forceUpdate</span>({})                             <span class="hljs-comment">/* 强制更新 */</span>
   } 
   <span class="hljs-keyword">return</span> [  value , dispatch  ]                   <span class="hljs-comment">/* 返回和 useState 一样的格式 */</span>
}
</code></pre>
<ul>
<li>useRef 用于保存状态 ，useState 用于更新组件。</li>
<li>做一个 <code>dispatch</code> 处理参数为函数的情况。在 dispatch 内部用 forceUpdate 触发真正的更新。</li>
<li>返回的结构和 useState 结构相同。不过注意的是使用的时候要用 value.current 。</li>
</ul>
<p>使用：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> [ data , setData  ] = <span class="hljs-title function_">useSyncState</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">marginTop:</span>'<span class="hljs-attr">50px</span>' }} ></span>
        《React 进阶实践指南》 点赞 👍 { data.current }
       <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> {
           setData(num => num + 1)
           console.log(data.current) //打印到最新的值
       } } >点击<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<h3>4 操纵 DOM / 组件实例</h3>
<p>自定义 hooks 也可以设计成对原生 DOM 的操纵控制。究其原理用 useRef 获取元素， 在 useEffect 中做元素的监听。</p>
<p>比如如下场景，用一个自定义 hooks 做一些基于 DOM 的操作 。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> 操纵原生dom  */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useGetDOM</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> dom = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>()
    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
       <span class="hljs-comment">/* 做一些基于 dom 的操作 */</span>
       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dom.<span class="hljs-property">current</span>)
    },[])
    <span class="hljs-keyword">return</span> dom
}
</code></pre>
<ul>
<li>自定义 useGetDOM ，用 useRef 获取 DOM 元素，在 useEffect 中做一些基于 DOM 的操作。</li>
</ul>
<p>使用：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> dom = <span class="hljs-title function_">useGetDOM</span>()
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{</span> <span class="hljs-attr">dom</span> } ></span>
        《React进阶实践指南》
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> ></span>点赞<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<h3>5 执行副作用</h3>
<p>自定义 hooks 也可以执行一些副作用，比如说监听一些 props 或 state 变化而带来的副作用。比如如下监听，当 <code>value</code> 改变的时候，执行 <code>cb</code>。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useEffectProps</span>(<span class="hljs-params">value,cb</span>){
    <span class="hljs-keyword">const</span> isMounted = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(<span class="hljs-literal">false</span>)
    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
         <span class="hljs-comment">/* 防止第一次执行 */</span>
        isMounted.<span class="hljs-property">current</span> &#x26;&#x26; cb &#x26;&#x26; <span class="hljs-title function_">cb</span>()
    },[ value ])
    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
          <span class="hljs-comment">/* 第一次挂载 */</span>
         isMounted.<span class="hljs-property">current</span> = <span class="hljs-literal">true</span>
    },[])
}
</code></pre>
<ul>
<li>用 useRef 保存是否第一次的状态。然后在一个 useEffect 改变加载完成状态。</li>
<li>只有当不是第一次加载且 value 改变的时候，执行回调函数 cb 。</li>
<li>当使用这个自定义 hooks 就可以监听，props 或者 state 变化。接下来尝试一下。</li>
</ul>
<p>使用组件和父组件：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params">props</span>){
    <span class="hljs-title function_">useEffectProps</span>( props.<span class="hljs-property">a</span> ,<span class="hljs-function">()=></span>{<span class="hljs-comment">/* 监听 a 变化 */</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'props a 变化:'</span>, props.<span class="hljs-property">a</span>  )
    } )
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>子组件<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> [ a , setA ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> [ b , setB ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Index</span> <span class="hljs-attr">a</span>=<span class="hljs-string">{a}</span>  <span class="hljs-attr">b</span>=<span class="hljs-string">{b}</span> /></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span>=></span> setA(a+1)} >改变 props a  <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span>=></span> setB(b+1)} >改变 props b  <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abe8ac2134bf40c890a71e0b12688879~tplv-k3u1fbpfcp-watermark.image" alt="2.gif"></p>
<ul>
<li>当动态监听 props.a ，props.a 变化，监听函数执行。</li>
</ul>
<h3>6 持续维护中～</h3>
<p>本章节，第二十七章节，第十四章节为持续维护章节，会有更多精彩的自定义 hooks 设计场景。</p>
<h2>四 总结</h2>
<p>本章节学习的内容如下：</p>
<ul>
<li>自定义 hooks 的概念与特性。</li>
<li>自定义 hooks 设计方式。</li>
</ul>
<p>下一章将介绍自定义 hooks 实践。</p></div>
</body></html>