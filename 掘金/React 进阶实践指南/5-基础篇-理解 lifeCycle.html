<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>基础篇-理解 lifeCycle</h1>
<h2>一 前言</h2>
<p>在本章节中主要讲 React 的生命周期，React 类组件为开发者提供了一些生命周期钩子函数，能让开发者在 React 执行的重要阶段，在钩子函数里做一些该做的事。自从 React Hooks 问世以来，函数组件也能优雅地使用 Hooks ，弥补函数组件没有生命周期的缺陷。</p>
<p>希望通过本章节让你一次性搞定 React 生命周期的流程和能弄清楚在各个生命周期做些什么，第二点就是加深对 React Hooks 中 <code>useEffect</code> 和 <code>useLayoutEffect</code>的使用。</p>
<h2>二 类组件生命周期介绍</h2>
<p>在讲 React 生命周期之前，有必要先来简单聊聊 React 两个重要阶段，render 阶段和 commit 阶段，React 在调和( render )阶段会深度遍历 React fiber 树，目的就是发现不同( diff )，不同的地方就是接下来需要更新的地方，对于变化的组件，就会执行 render 函数。在一次调和过程完毕之后，就到了commit 阶段，commit 阶段会创建修改真实的 DOM 节点。</p>
<p>如果在一次调和的过程中，发现了一个 <code>fiber tag = 1 </code> 类组件的情况，就会按照类组件的逻辑来处理。对于类组件的处理逻辑，首先判断类组件是否已经被创建过，首先来看看源码里怎么写的。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberBeginWork.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-comment">/* workloop React 处理类组件的主要功能方法 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateClassComponent</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">let</span> shouldUpdate
    <span class="hljs-keyword">const</span> instance = workInProgress.<span class="hljs-property">stateNode</span> <span class="hljs-comment">// stateNode 是 fiber 指向 类组件实例的指针。</span>
     <span class="hljs-keyword">if</span> (instance === <span class="hljs-literal">null</span>) { <span class="hljs-comment">// instance 为组件实例,如果组件实例不存在，证明该类组件没有被挂载过，那么会走初始化流程</span>
        <span class="hljs-title function_">constructClassInstance</span>(workInProgress, <span class="hljs-title class_">Component</span>, nextProps); <span class="hljs-comment">// 组件实例将在这个方法中被new。</span>
        <span class="hljs-title function_">mountClassInstance</span>(  workInProgress,<span class="hljs-title class_">Component</span>, nextProps,renderExpirationTime ); <span class="hljs-comment">//初始化挂载组件流程</span>
        shouldUpdate = <span class="hljs-literal">true</span>; <span class="hljs-comment">// shouldUpdate 标识用来证明 组件是否需要更新。</span>
     }<span class="hljs-keyword">else</span>{  
        shouldUpdate = <span class="hljs-title function_">updateClassInstance</span>(current, workInProgress, <span class="hljs-title class_">Component</span>, nextProps, renderExpirationTime) <span class="hljs-comment">// 更新组件流程</span>
     }
     <span class="hljs-keyword">if</span>(shouldUpdate){
         nextChildren = instance.<span class="hljs-title function_">render</span>(); <span class="hljs-comment">/* 执行render函数 ，得到子节点 */</span>
        <span class="hljs-title function_">reconcileChildren</span>(current,workInProgress,nextChildren,renderExpirationTime) <span class="hljs-comment">/* 继续调和子节点 */</span>
     }
}
</code></pre>
<p>几个重要概念：</p>
<ul>
<li>① <code>instance</code> 类组件对应实例。</li>
<li>② <code>workInProgress</code> 树，当前正在调和的 fiber 树 ，一次更新中，React 会自上而下深度遍历子代 fiber ，如果遍历到一个 fiber ，会把当前 fiber 指向 workInProgress。</li>
<li>③ <code>current</code> 树，在初始化更新中，current = null ，在第一次 fiber 调和之后，会将 workInProgress 树赋值给 current 树。React 来用workInProgress 和 current 来确保一次更新中，快速构建，并且状态不丢失。</li>
<li>④ <code>Component</code> 就是项目中的 class 组件。</li>
<li>⑤ <code>nextProps</code> 作为组件在一次更新中新的 props 。</li>
<li>⑥ <code>renderExpirationTime</code> 作为下一次渲染的过期时间。</li>
</ul>
<p>上面这个函数流程我已经标的很清楚了，同学们在学习React的过程中，重要的属性一定要拿小本本记下来，比如说类组件完成渲染挂载之后， React 用什么记录组件对应的 fiber 对象和类组件实例之间的关系。只有搞清楚这些，才能慢慢深入学习 React 。</p>
<p>在组件实例上可以通过 <code>_reactInternals</code> 属性来访问组件对应的 fiber 对象。在 fiber 对象上，可以通过 <code>stateNode</code> 来访问当前 fiber 对应的组件实例。两者的关系如下图所示。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/018a9cbd20df478a955b84beba770674~tplv-k3u1fbpfcp-watermark.image" alt="lifecycle3.jpg"></p>
<h3>React 类组件生命周期执行过程探秘</h3>
<p>React 的大部分生命周期的执行，都在 <code>mountClassInstance</code> 和<code>updateClassInstance</code> 这两个方法中执行，所以为了让大家深入学习 React 生命周期的执行过程，我觉得有必要去揭秘这两个函数充当了什么角色。我把流程简化成 mount (初始化渲染) 和 update (更新)两个方向。</p>
<p>为了让大家更理解生命周期的执行流程，我这里分为<strong>组件初始化</strong>，<strong>组件更新</strong> ， <strong>组件销毁</strong> ，三大阶段分析。</p>
<h4>初始化阶段</h4>
<p><strong>① constructor 执行</strong></p>
<p>在 mount 阶段，首先执行的 constructClassInstance 函数，用来实例化 React 组件，在组件章节已经介绍了这个函数，组件中 constructor 就是在这里执行的。</p>
<p>在实例化组件之后，会调用 mountClassInstance 组件初始化。</p>
<p>接下来看一下 mountClassInstance 做了些什么？ 我只写了和生命周期息息相关的代码。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberClassComponent.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountClassInstance</span>(<span class="hljs-params">workInProgress,ctor,newProps,renderExpirationTime</span>){
    <span class="hljs-keyword">const</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;
     <span class="hljs-keyword">const</span> getDerivedStateFromProps = ctor.<span class="hljs-property">getDerivedStateFromProps</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">'function'</span>) { <span class="hljs-comment">/* ctor 就是我们写的类组件，获取类组件的静态方法 */</span>
     <span class="hljs-keyword">const</span> partialState = <span class="hljs-title function_">getDerivedStateFromProps</span>(nextProps, prevState); <span class="hljs-comment">/* 这个时候执行 getDerivedStateFromProps 生命周期 ，得到将合并的state */</span>
     <span class="hljs-keyword">const</span> memoizedState = partialState === <span class="hljs-literal">null</span> || partialState === <span class="hljs-literal">undefined</span> ? prevState : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, prevState, partialState); <span class="hljs-comment">// 合并state</span>
     workInProgress.<span class="hljs-property">memoizedState</span> = memoizedState;
     instance.<span class="hljs-property">state</span> = workInProgress.<span class="hljs-property">memoizedState</span>; <span class="hljs-comment">/* 将state 赋值给我们实例上，instance.state  就是我们在组件中 this.state获取的state*/</span>
  }
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">getDerivedStateFromProps</span> !== <span class="hljs-string">'function'</span> &#x26;&#x26;   <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getSnapshotBeforeUpdate</span> !== <span class="hljs-string">'function'</span> &#x26;&#x26; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillMount</span> === <span class="hljs-string">'function'</span> ){
      instance.<span class="hljs-title function_">componentWillMount</span>(); <span class="hljs-comment">/* 当 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 不存在的时候 ，执行 componentWillMount*/</span>
  }
}
</code></pre>
<p><strong>② getDerivedStateFromProps 执行</strong></p>
<p>在初始化阶段，<code>getDerivedStateFromProps</code> 是第二个执行的生命周期，值得注意的是它是从 ctor 类上直接绑定的静态方法，传入 props ，state 。 返回值将和之前的 state 合并，作为新的 state ，传递给组件实例使用。</p>
<p><strong>③ componentWillMount 执行</strong></p>
<p>如果存在 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 就不会执行生命周期<code>componentWillMount</code>。</p>
<p><strong>④ render 函数执行</strong></p>
<p>到此为止 <code>mountClassInstancec</code> 函数完成，但是上面 <code>updateClassComponent</code> 函数， 在执行完 <code>mountClassInstancec</code> 后，执行了 render 渲染函数，形成了 children ， 接下来 React 调用 reconcileChildren 方法深度调和 children 。</p>
<p><strong>⑤componentDidMount执行</strong></p>
<p>细心的同学可能发现，生命周期 <code>componentDidMount</code> 还没有出现，那么 <code>componentDidMount</code> 是如何执行的呢？上文中简单介绍了 render 和 commit 两个阶段，上述提及的几生命周期都是在 render 阶段执行的。一旦 React 调和完所有的 fiber 节点，就会到 commit 阶段，在组件初始化 commit 阶段，会调用 <code>componentDidMount</code> 生命周期。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberCommitWork.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitLifeCycles</span>(<span class="hljs-params">finishedRoot,current,finishedWork</span>){
     <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>){                             <span class="hljs-comment">/* fiber tag 在第一节讲了不同fiber类型 */</span>
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: {                              <span class="hljs-comment">/* 如果是 类组件 类型 */</span>
             <span class="hljs-keyword">const</span> instance = finishedWork.<span class="hljs-property">stateNode</span>        <span class="hljs-comment">/* 类实例 */</span>
             <span class="hljs-keyword">if</span>(current === <span class="hljs-literal">null</span>){                          <span class="hljs-comment">/* 类组件第一次调和渲染 */</span>
                instance.<span class="hljs-title function_">componentDidMount</span>() 
             }<span class="hljs-keyword">else</span>{                                         <span class="hljs-comment">/* 类组件更新 */</span>
                instance.<span class="hljs-title function_">componentDidUpdate</span>(prevProps,prevState，instance.<span class="hljs-property">__reactInternalSnapshotBeforeUpdate</span>); 
             }
        }
     }
}
</code></pre>
<p>从上面可以直观看到 <code>componentDidMount</code> 执行时机 和 <code>componentDidUpdate</code> 执行时机是相同的 ，只不过一个是针对初始化，一个是针对组件再更新。到此初始化阶段，生命周期执行完毕。</p>
<p>执行顺序：constructor -> getDerivedStateFromProps / componentWillMount -> render -> componentDidMount</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9838872f404c474b87612400c3a6c504~tplv-k3u1fbpfcp-watermark.image" alt="lifesycle4.jpg"></p>
<p>接下来分析一下一次组件更新中，会有哪些生命周期执行呢？</p>
<h4>更新阶段</h4>
<p>接下来一次类组件的更新阶段，到底会执行那些生命周期函数呢，回到了最开始 <code>updateClassComponent</code> 函数了，当发现 current 不为 null 的情况时，说明该类组件被挂载过，那么直接按照更新逻辑来处理。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberClassComponent.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateClassInstance</span>(<span class="hljs-params">current,workInProgress,ctor,newProps,renderExpirationTime</span>){
    <span class="hljs-keyword">const</span> instance = workInProgress.<span class="hljs-property">stateNode</span>; <span class="hljs-comment">// 类组件实例</span>
    <span class="hljs-keyword">const</span> hasNewLifecycles =  <span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">getDerivedStateFromProps</span> === <span class="hljs-string">'function'</span>  <span class="hljs-comment">// 判断是否具有 getDerivedStateFromProps 生命周期</span>
    <span class="hljs-keyword">if</span>(!hasNewLifecycles &#x26;&#x26; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillReceiveProps</span> === <span class="hljs-string">'function'</span> ){
         <span class="hljs-keyword">if</span> (oldProps !== newProps || oldContext !== nextContext) {     <span class="hljs-comment">// 浅比较 props 不相等</span>
            instance.<span class="hljs-title function_">componentWillReceiveProps</span>(newProps, nextContext);  <span class="hljs-comment">// 执行生命周期 componentWillReceiveProps </span>
         }
    }
    <span class="hljs-keyword">let</span> newState = (instance.<span class="hljs-property">state</span> = oldState);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">'function'</span>) {
        ctor.<span class="hljs-title function_">getDerivedStateFromProps</span>(nextProps,prevState)  <span class="hljs-comment">/* 执行生命周期getDerivedStateFromProps  ，逻辑和mounted类似 ，合并state  */</span>
        newState = workInProgress.<span class="hljs-property">memoizedState</span>;
    }   
    <span class="hljs-keyword">let</span> shouldUpdate = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">shouldComponentUpdate</span> === <span class="hljs-string">'function'</span> ){ <span class="hljs-comment">/* 执行生命周期 shouldComponentUpdate 返回值决定是否执行render ，调和子节点 */</span>
        shouldUpdate = instance.<span class="hljs-title function_">shouldComponentUpdate</span>(newProps,newState,nextContext,);
    }
    <span class="hljs-keyword">if</span>(shouldUpdate){
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillUpdate</span> === <span class="hljs-string">'function'</span>) {
            instance.<span class="hljs-title function_">componentWillUpdate</span>(); <span class="hljs-comment">/* 执行生命周期 componentWillUpdate  */</span>
        }
    }
    <span class="hljs-keyword">return</span> shouldUpdate
}
</code></pre>
<p><strong>①执行生命周期 componentWillReceiveProps</strong></p>
<p>首先判断 <code>getDerivedStateFromProps</code> 生命周期是否存在，如果不存在就执行<code>componentWillReceiveProps</code>生命周期。传入该生命周期两个参数，分别是 newProps 和 nextContext 。</p>
<p><strong>②执行生命周期 getDerivedStateFromProps</strong></p>
<p>接下来执行生命周期<code>getDerivedStateFromProps</code>， 返回的值用于合并state，生成新的state。</p>
<p><strong>③执行生命周期 shouldComponentUpdate</strong></p>
<p>接下来执行生命周期<code>shouldComponentUpdate</code>，传入新的 props ，新的 state ，和新的 context ，返回值决定是否继续执行 render 函数，调和子节点。这里应该注意一个问题，<code>getDerivedStateFromProps</code> 的返回值可以作为新的 state ，传递给 shouldComponentUpdate 。</p>
<p><strong>④执行生命周期 componentWillUpdate</strong></p>
<p>接下来执行生命周期 <code>componentWillUpdate</code>。updateClassInstance 方法到此执行完毕了。</p>
<p><strong>⑤执行 render 函数</strong></p>
<p>接下来会执行 render 函数，得到最新的 React element 元素。然后继续调和子节点。</p>
<p><strong>⑥执行 getSnapshotBeforeUpdate</strong></p>
<blockquote>
<p>react-reconciler/src/ReactFiberCommitWork.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitBeforeMutationLifeCycles</span>(<span class="hljs-params">current,finishedWork</span>){
     <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:{
               <span class="hljs-keyword">const</span> snapshot = instance.<span class="hljs-title function_">getSnapshotBeforeUpdate</span>(prevProps,prevState) <span class="hljs-comment">/* 执行生命周期 getSnapshotBeforeUpdate   */</span>
                instance.<span class="hljs-property">__reactInternalSnapshotBeforeUpdate</span> = snapshot; <span class="hljs-comment">/* 返回值将作为 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 生命周期  */</span>
          }
     }
}
</code></pre>
<p><code>getSnapshotBeforeUpdate</code> 的执行也是在 commit 阶段，commit 阶段细分为 <code>before Mutation</code>( DOM 修改前)，<code>Mutation</code> ( DOM 修改)，<code>Layout</code>( DOM 修改后) 三个阶段，getSnapshotBeforeUpdate 发生在<code>before Mutation</code> 阶段，生命周期的返回值，将作为第三个参数 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 。</p>
<p><strong>⑦执行 componentDidUpdate</strong></p>
<p>接下来执行生命周期 componentDidUpdate ，此时 DOM 已经修改完成。可以操作修改之后的 DOM 。到此为止更新阶段的生命周期执行完毕。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de17c24547b040b9a93b01706d9e585b~tplv-k3u1fbpfcp-watermark.image" alt="lifecycle5.jpg"></p>
<p>更新阶段对应的生命周期的执行顺序：</p>
<p>componentWillReceiveProps( props 改变) / getDerivedStateFromProp -> shouldComponentUpdate -> componentWillUpdate -> render  -> getSnapshotBeforeUpdate ->  componentDidUpdate</p>
<h4>销毁阶段</h4>
<blockquote>
<p>react-reconciler/src/ReactFiberCommitWork.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callComponentWillUnmountWithTimer</span>(<span class="hljs-params"></span>){
    instance.<span class="hljs-title function_">componentWillUnmount</span>();
}
</code></pre>
<p><strong>①执行生命周期 componentWillUnmount</strong></p>
<p>销毁阶段就比较简单了，在一次调和更新中，如果发现元素被移除，就会打对应的 Deletion 标签 ，然后在 commit 阶段就会调用 <code>componentWillUnmount</code> 生命周期，接下来统一卸载组件以及 DOM 元素。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37d76e8437764f2fb605c03332d5fb0f~tplv-k3u1fbpfcp-watermark.image" alt="lifecycle6.jpg"></p>
<p>三个阶段生命周期+无状态组件总览图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7066da719fda4a91aa2c432f60c58a48~tplv-k3u1fbpfcp-watermark.image" alt="lifesycyle8.jpg"></p>
<h3>React 各阶段生命周期能做些什么</h3>
<p>上面部分详细的介绍了 React 各生命周期的执行时机和执行顺序。接下来分别介绍一下各个 lifecycle 能做些什么？</p>
<h4>1 constructor</h4>
<p>React 在不同时期抛出不同的生命周期钩子，也就意味这这些生命周期钩子的使命。上面讲过 constructor 在类组件创建实例时调用，而且初始化的时候执行一次，所以可以在 constructor 做一些初始化的工作。</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>){
    <span class="hljs-variable language_">super</span>(props)        <span class="hljs-comment">// 执行 super ，别忘了传递props,才能在接下来的上下文中，获取到props。</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>={       <span class="hljs-comment">//① 可以用来初始化state，比如可以用来获取路由中的</span>
        <span class="hljs-attr">name</span>:<span class="hljs-string">'alien'</span>
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">/* ② 绑定 this */</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleInputChange</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleInputChange</span> , <span class="hljs-number">500</span>) <span class="hljs-comment">/* ③ 绑定防抖函数，防抖 500 毫秒 */</span>
    <span class="hljs-keyword">const</span> _render = <span class="hljs-variable language_">this</span>.<span class="hljs-property">render</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">return</span> _render.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">/* ④ 劫持修改类组件上的一些生命周期 */</span>
    }
}
<span class="hljs-comment">/* 点击事件 */</span>
<span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>){ <span class="hljs-comment">/* ... */</span> }
<span class="hljs-comment">/* 表单输入 */</span>
<span class="hljs-title function_">handleInputChange</span>(<span class="hljs-params"></span>){ <span class="hljs-comment">/* ... */</span> }
</code></pre>
<p>constructor 作用：</p>
<ul>
<li>初始化 state ，比如可以用来截取路由中的参数，赋值给 state 。</li>
<li>对类组件的事件做一些处理，比如绑定 this ， 节流，防抖等。</li>
<li>对类组件进行一些必要生命周期的劫持，渲染劫持，这个功能更适合反向继承的HOC ，在 HOC 环节，会详细讲解反向继承这种模式。</li>
</ul>
<h4>2 getDerivedStateFromProps</h4>
<pre><code class="hljs language-js"><span class="hljs-title function_">getDerivedStateFromProps</span>(nextProps,prevState)
</code></pre>
<p>两个参数：</p>
<ul>
<li>nextProps 父组件新传递的 props ;</li>
<li>prevState 传入 getDerivedStateFromProps 待合并的 state 。</li>
</ul>
<p><code>getDerivedStateFromProps</code> 方法作为类的静态属性方法执行，内部是访问不到 <code>this</code> 的，它更趋向于纯函数，从源码中就能够体会到 React 对该生命周期定义为取缔 componentWillMount 和 componentWillReceiveProps 。</p>
<p>如果把 getDerivedStateFromProps 英文分解 get ｜ Derived | State ｜ From ｜ Props  翻译  <strong>得到 派生的 state 从 props 中</strong> ，正如它的名字一样，这个生命周期用于，在初始化和更新阶段，接受父组件的 props 数据， 可以对 props 进行格式化，过滤等操作，返回值将作为新的 state 合并到 state 中，供给视图渲染层消费。</p>
<p>从源码中可以看到，只要组件更新，就会执行 <code>getDerivedStateFromProps</code>，不管是 props 改变，还是 setState ，或是 forceUpdate 。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">newProps</span>){
    <span class="hljs-keyword">const</span> { type } = newProps
    <span class="hljs-keyword">switch</span>(type){
        <span class="hljs-keyword">case</span> <span class="hljs-string">'fruit'</span> : 
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">list</span>:[<span class="hljs-string">'苹果'</span>,<span class="hljs-string">'香蕉'</span>,<span class="hljs-string">'葡萄'</span> ] } <span class="hljs-comment">/* ① 接受 props 变化 ， 返回值将作为新的 state ，用于 渲染 或 传递给s houldComponentUpdate */</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">'vegetables'</span>:
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">list</span>:[<span class="hljs-string">'菠菜'</span>,<span class="hljs-string">'西红柿'</span>,<span class="hljs-string">'土豆'</span>]}
    }
}
<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>{ this.state.list.map((item)=><span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item}</span> ></span>{ item  }<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>) }<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>getDerivedStateFromProps 作用：</p>
<ul>
<li>代替 componentWillMount 和 componentWillReceiveProps</li>
<li>组件初始化或者更新时，将 props 映射到 state。</li>
<li>返回值与 state 合并完，可以作为 shouldComponentUpdate 第二个参数  newState ，可以判断是否渲染组件。(请不要把 getDerivedStateFromProps 和 shouldComponentUpdate 强行关联到一起，两者没有必然联系)</li>
</ul>
<h4>3 componentWillMount 和 UNSAFE_componentWillMount</h4>
<p>在 React V16.3 componentWillMount ，componentWillReceiveProps ， componentWillUpdate 三个生命周期加上了不安全的标识符 <code>UNSAFE</code>，变成了如下形式，在目前最新的版本React <code>V17.0.2 </code>也没有废弃这三个生命周期。可能不久之后更高级的版本会被废除吧，首先先来看一下为什么要加<code>UNSAFE</code>，首先根据源码，大家有没有发现一个问题，就是这三个生命周期，都是在 render 之前执行的，React 对于执行 render 函数有着像 shouldUpdate 等条件制约，但是对于执行在 render 之前生命周期没有限制，存在一定隐匿风险，如果 updateClassInstance 执行多次，React 开发者滥用这几个生命周期，可能导致生命周期内的上下文多次被执行。</p>
<ul>
<li>UNSAFE_componentWillMount</li>
<li>UNSAFE_componentWillReceiveProps</li>
<li>UNSAFE_componentWillUpdate</li>
</ul>
<p>UNSAFE_componentWillMount 的作用还是做一些初始化操作，但是不建议在这个生命周期写，毕竟未来 React 可能完全取缔它。</p>
<h4>4 componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps</h4>
<p>UNSAFE_componentWillReceiveProps 函数的执行是在更新组件阶段，该生命周期执行驱动是因为父组件更新带来的 props 修改，但是只要父组件触发 render 函数，调用 React.createElement 方法，那么 props 就会被重新创建，生命周期 componentWillReceiveProps 就会执行了。这就解释了即使 props 没变，该生命周期也会执行。</p>
<p>componentWillReceiveProps 可以用来干什么？我把上面例子修改一下。</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">UNSAFE_componentWillReceiveProps</span>(<span class="hljs-params">newProps</span>){
        <span class="hljs-keyword">const</span> { type } = newProps
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'父组件render执行'</span>) <span class="hljs-comment">/*  ① 监听父组件执行render  */</span>
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=></span>{  <span class="hljs-comment">/* ② 异步控制props改变，派生出来的 state 的修改  */</span>
            <span class="hljs-keyword">switch</span>(type){
                <span class="hljs-keyword">case</span> <span class="hljs-string">'fruit'</span> : 
                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({<span class="hljs-attr">list</span>:[<span class="hljs-string">'苹果'</span>,<span class="hljs-string">'香蕉'</span>,<span class="hljs-string">'葡萄'</span> ] }) 
                <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">case</span> <span class="hljs-string">'vegetables'</span>:
                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({<span class="hljs-attr">list</span>:[<span class="hljs-string">'苹果'</span>,<span class="hljs-string">'香蕉'</span>,<span class="hljs-string">'葡萄'</span> ] }) 
                <span class="hljs-keyword">break</span>
            }
        },<span class="hljs-number">0</span>)
}
</code></pre>
<ul>
<li>componentWillReceiveProps 可以用来监听父组件是否执行 render 。</li>
<li>componentWillReceiveProps 可以用来接受 props 改变，组件可以根据props改变，来决定是否更新 state ，因为可以访问到 this ， 所以可以在异步成功回调(接口请求数据)改变 state 。这个是 getDerivedStateFromProps  不能实现的。</li>
</ul>
<p>但是笔者不建议用这种方式，props 改变，再触发 componentWillReceiveProps 异步请求数据渲染，这样首先在没做优化前提下会带来两次子组件的更新，第一次 props 改变，第二次 props 改变，异步改变state 。其次该生命周期的不安全性。再者需要在该生命周期内部，设置大量的条件判断语句，通过 this.props ， nextProps 判断 props 到底改变与否。所以完全可以换一种思路，那就是<strong>状态提升</strong>，把数据层完全托管父组件，子组件没有副作用，只负责渲染父组件传递的 props 即可。</p>
<p><strong>｜--------问与答---------｜</strong><br>
问：当 props 不变的前提下， PureComponent 组件能否阻止 componentWillReceiveProps 执行？</p>
<p>答案是否定的，componentWillReceiveProps 生命周期的执行，和纯组件没有关系，纯组件是在 componentWillReceiveProps 执行之后浅比较 props 是否发生变化。所以 PureComponent 下不会阻止该生命周期的执行。</p>
<p><strong>｜--------end---------｜</strong><br></p>
<h4>5 componentWillUpdate 和 UNSAFE_componentWillUpdate</h4>
<p>UNSAFE_componentWillUpdate 可以意味着在更新之前，此时的 DOM 还没有更新。在这里可以做一些获取 DOM 的操作。就比如说在一次更新中，保存 DOM 之前的信息(记录上一次位置)。但是 React 已经出了新的生命周期 getSnapshotBeforeUpdate 来代替 UNSAFE_componentWillUpdate。</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">UNSAFE_componentWillUpdate</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPostion</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>) <span class="hljs-comment">/* 获取元素节点 node 位置 */</span>
}
</code></pre>
<p>作用：</p>
<ul>
<li>获取组件更新之前的状态。比如 DOM 元素位置等。</li>
</ul>
<h4>6 render</h4>
<p>还记得在第一节 jsx 主要讲了 render 之后会成什么样子。所谓 render 函数，就是 jsx 的各个元素被 React.createElement 创建成 React element 对象的形式。一次 render 的过程，就是创建 React.element 元素的过程。</p>
<ul>
<li>那么可以在render里面做一些,<strong>createElement创建元素</strong> , <strong>cloneElement 克隆元素</strong> ，<strong>React.children 遍历 children</strong> 的操作。</li>
</ul>
<h4>7 getSnapshotBeforeUpdate</h4>
<pre><code class="hljs language-js"><span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps,preState</span>){}
</code></pre>
<p>两个参数：</p>
<ul>
<li>prevProps更新前的props ；</li>
<li>preState更新前的state；</li>
</ul>
<p>把 getSnapshotBeforeUpdate 用英文解释一下 ， <strong>get | snap shot | before | update</strong> ， 中文翻译为 <strong>获取更新前的快照</strong>，可以进一步理解为 获取更新前 DOM 的状态。见名知意，上面说过该生命周期是在 commit 阶段的before Mutation ( DOM 修改前)，此时 DOM 还没有更新，但是在接下来的 Mutation 阶段会被替换成真实 DOM 。此时是获取 DOM 信息的最佳时期，getSnapshotBeforeUpdate 将返回一个值作为一个<code>snapShot</code>(快照)，传递给 componentDidUpdate作为第三个参数。</p>
<p>注意：如果没有返回值会给予警告⚠️，如果没有 <code>componentDidUpdate</code>也会给予警告。</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps,preState</span>){
    <span class="hljs-keyword">const</span> style = <span class="hljs-title function_">getComputedStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>) 
    <span class="hljs-keyword">return</span> { <span class="hljs-comment">/* 传递更新前的元素位置 */</span>
        <span class="hljs-attr">cx</span>:style.<span class="hljs-property">cx</span>,
        <span class="hljs-attr">cy</span>:style.<span class="hljs-property">cy</span>
    }
}
<span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>){
    <span class="hljs-comment">/* 获取元素绘制之前的位置 */</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(snapshot)
}
</code></pre>
<p>当然这个快照 <code>snapShot</code> 不限于 DOM 的信息，也可以是根据 DOM 计算出来产物。</p>
<p>作用：</p>
<ul>
<li>getSnapshotBeforeUpdate 这个生命周期意义就是配合componentDidUpdate 一起使用，计算形成一个 snapShot 传递给 componentDidUpdate 。保存一次更新前的信息。</li>
</ul>
<h4>8 componentDidUpdate</h4>
<pre><code class="hljs language-js"><span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>){
    <span class="hljs-keyword">const</span> style = <span class="hljs-title function_">getComputedStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>)
    <span class="hljs-keyword">const</span> newPosition = { <span class="hljs-comment">/* 获取元素最新位置信息 */</span>
        <span class="hljs-attr">cx</span>:style.<span class="hljs-property">cx</span>,
        <span class="hljs-attr">cy</span>:style.<span class="hljs-property">cy</span>
    }
}
</code></pre>
<p>三个参数：</p>
<ul>
<li>prevProps 更新之前的 props ；</li>
<li>prevState 更新之前的 state ；</li>
<li>snapshot 为 getSnapshotBeforeUpdate 返回的快照，可以是更新前的 DOM 信息。</li>
</ul>
<p>作用</p>
<ul>
<li>componentDidUpdate 生命周期执行，此时 DOM 已经更新，可以直接获取 DOM 最新状态。这个函数里面如果想要使用 setState ，一定要加以限制，否则会引起无限循环。</li>
<li>接受 getSnapshotBeforeUpdate 保存的快照信息。</li>
</ul>
<h4>9 componentDidMount</h4>
<p>componentDidMount 生命周期执行时机和 componentDidUpdate 一样，一个是在<strong>初始化</strong>，一个是<strong>组件更新</strong>。此时 DOM 已经创建完，既然 DOM 已经创建挂载，就可以做一些基于 DOM 操作，DOM 事件监听器。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>,<span class="hljs-function">()=></span>{
        <span class="hljs-comment">/* 事件监听 */</span>
    }) 
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getData</span>() <span class="hljs-comment">/* 数据请求 */</span>
}
</code></pre>
<p>作用：</p>
<ul>
<li>可以做一些关于 DOM 操作，比如基于 DOM 的事件监听器。</li>
<li>对于初始化向服务器请求数据，渲染视图，这个生命周期也是蛮合适的。</li>
</ul>
<h4>10 shouldComponentUpdate</h4>
<pre><code class="hljs language-js"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">newProps,newState,nextContext</span>){}
</code></pre>
<p>shouldComponentUpdate 三个参数，第一个参数新的 props ，第二个参数新的 state ，第三个参数新的 context 。</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">newProps,newState</span>){
    <span class="hljs-keyword">if</span>(newProps.<span class="hljs-property">a</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">a</span> ){ <span class="hljs-comment">/* props中a属性发生变化 渲染组件 */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(newState.<span class="hljs-property">b</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">b</span> ){ <span class="hljs-comment">/* state 中b属性发生变化 渲染组件 */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }<span class="hljs-keyword">else</span>{ <span class="hljs-comment">/* 否则组件不渲染 */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
}
</code></pre>
<ul>
<li>这个生命周期，一般用于性能优化，shouldComponentUpdate 返回值决定是否重新渲染的类组件。需要重点关注的是第二个参数 newState ，如果有 getDerivedStateFromProps 生命周期 ，它的返回值将合并到 newState ，供 shouldComponentUpdate 使用。</li>
</ul>
<h4>11 componentWillUnmount</h4>
<p>componentWillUnmount 是组件销毁阶段唯一执行的生命周期，主要做一些收尾工作，比如清除一些可能造成内存泄漏的定时器，延时器，或者是一些事件监听器。</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>){
    <span class="hljs-built_in">clearTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>)  <span class="hljs-comment">/* 清除延时器 */</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">handerClick</span>) <span class="hljs-comment">/* 卸载事件监听器 */</span>
}
</code></pre>
<p>作用</p>
<ul>
<li>清除延时器，定时器。</li>
<li>一些基于 DOM 的操作，比如事件监听器。</li>
</ul>
<h2>3 函数组件生命周期替代方案</h2>
<p>React hooks也提供了 api ，用于弥补函数组件没有生命周期的缺陷。其原理主要是运用了 hooks 里面的 <code>useEffect</code> 和 <code>useLayoutEffect</code>。</p>
<h3>1 useEffect 和 useLayoutEffect</h3>
<p><strong>useEffect</strong></p>
<pre><code class="hljs language-js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
    <span class="hljs-keyword">return</span> destory
},dep)

</code></pre>
<p>useEffect 第一个参数 callback, 返回的 destory ， destory 作为下一次callback执行之前调用，用于清除上一次 callback 产生的副作用。</p>
<p>第二个参数作为依赖项，是一个数组，可以有多个依赖项，依赖项改变，执行上一次callback 返回的 destory ，和执行新的 effect 第一个参数 callback 。</p>
<p>对于 useEffect 执行， React 处理逻辑是采用异步调用 ，对于每一个 effect 的 callback， React 会向 <code>setTimeout</code>回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 effect 回调函数不会阻塞浏览器绘制视图。</p>
<p><strong>useLayoutEffect:</strong></p>
<p>useLayoutEffect 和 useEffect 不同的地方是采用了同步执行，那么和useEffect有什么区别呢？</p>
<ul>
<li>
<p>首先 useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前，这样可以方便修改 DOM，获取 DOM 信息，这样浏览器只会绘制一次，如果修改 DOM 布局放在 useEffect ，那 useEffect 执行是在浏览器绘制视图之后，接下来又改 DOM ，就可能会导致浏览器再次回流和重绘。而且由于两次绘制，视图上可能会造成闪现突兀的效果。</p>
</li>
<li>
<p>useLayoutEffect callback 中代码执行会阻塞浏览器绘制。</p>
</li>
</ul>
<p><strong>一句话概括如何选择 useEffect 和 useLayoutEffect ：修改 DOM ，改变布局就用 useLayoutEffect ，其他情况就用 useEffect 。</strong></p>
<p><strong>｜--------问与答---------｜</strong><br>
问：React.useEffect 回调函数 和 componentDidMount / componentDidUpdate 执行时机有什么区别 ？</p>
<p>答：useEffect 对 React 执行栈来看是异步执行的，而 componentDidMount / componentDidUpdate 是同步执行的，useEffect代码不会阻塞浏览器绘制。在时机上 ，componentDidMount / componentDidUpdate 和 useLayoutEffect 更类似。</p>
<p><strong>｜---------end----------｜</strong></p>
<h3>2 useInsertionEffect</h3>
<p>useInsertionEffect 是在 React v18 新添加的 hooks ，它的用法和 useEffect 和 useLayoutEffect 一样。那么这个 hooks 用于什么呢?</p>
<p>在介绍 useInsertionEffect 用途之前，先看一下 useInsertionEffect 的执行时机。</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'useEffect 执行'</span>)
},[])

<span class="hljs-title class_">React</span>.<span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">()=></span>{
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'useLayoutEffect 执行'</span>)
},[])

<span class="hljs-title class_">React</span>.<span class="hljs-title function_">useInsertionEffect</span>(<span class="hljs-function">()=></span>{
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'useInsertionEffect 执行'</span>)
},[])
</code></pre>
<p>打印：
useInsertionEffect 执行
useLayoutEffect 执行
useEffect 执行</p>
<p>可以看到 useInsertionEffect 的执行时机要比 useLayoutEffect 提前，useLayoutEffect 执行的时候 DOM 已经更新了，但是在 useInsertionEffect 的执行的时候，DOM 还没有更新。</p>
<p>本质上 useInsertionEffect 主要是解决 CSS-in-JS 在渲染中注入样式的性能问题。这个 hooks 主要是应用于这个场景，在其他场景下 React 不期望用这个 hooks 。</p>
<p>CSS-in-JS 的注入会引发哪些问题呢？ 首先看部分 CSS-in-JS 的实现原理，拿 Styled-components 为例子，通过styled-components，你可以使用ES6的标签模板字符串语法（Tagged Templates）为需要 styled 的 Component 定义一系列CSS属性，当该组件的JS代码被解析执行的时候，styled-components 会动态生成一个 CSS 选择器，并把对应的 CSS 样式通过 style 标签的形式插入到 head 标签里面。动态生成的 CSS 选择器会有一小段哈希值来保证全局唯一性来避免样式发生冲突。这种模式下本质上是动态生成 style 标签。</p>
<p>明白了 Styled-components 原理之后，再来看一下，如果在 useLayoutEffect 使用 CSS-in-JS 会造成哪里问题呢？</p>
<ul>
<li>首先 useLayoutEffect 执行的时机 DOM 已经更新完成，布局也已经确定了，剩下的就是交给浏览器绘制就行了。</li>
<li>如果在 useLayoutEffect 动态生成 style 标签，那么会再次影响布局，导致浏览器再次重回和重排。</li>
</ul>
<p>这个是时候 useInsertionEffect 的作用就出现了，useInsertionEffect 的执行在 DOM 更新前，所以此时使用 CSS-in-JS 避免了浏览器出现再次重回和重排的可能，解决了性能上的问题。</p>
<p>接下来我们模拟一下在 useInsertionEffect 使用 CSS-in-JS 流程：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>){

  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useInsertionEffect</span>(<span class="hljs-function">()=></span>{
     <span class="hljs-comment">/* 动态创建 style 标签插入到 head 中 */</span>
     <span class="hljs-keyword">const</span> style = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'style'</span>)
     style.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`
       .css-in-js{
         color: red;
         font-size: 20px;
       }
     `</span>
     <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(style)
  },[])

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"css-in-js"</span> ></span> hello , useInsertionEffect <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/019839eb007943cea7b6d4df422e5d81~tplv-k3u1fbpfcp-watermark.image?" alt="2.png"></p>
<p>此时 div 的字体颜色和字体大小已经更改。</p>
<p>上述详细的介绍了 useEffect，useLayoutEffect 和 useInsertionEffect，接下来拿 useEffect 做参考，详细介绍一下函数组件怎么实现生命周期的替代方案的。</p>
<h3>3 componentDidMount 替代方案</h3>
<pre><code class="hljs language-js"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
    <span class="hljs-comment">/* 请求数据 ， 事件监听 ， 操纵dom */</span>
},[])  <span class="hljs-comment">/* 切记 dep = [] */</span>
</code></pre>
<p>这里要记住 <code>dep = []</code> ，这样当前 effect 没有任何依赖项，也就只有初始化执行一次。</p>
<h3>4 componentWillUnmount 替代方案</h3>
<pre><code class="hljs language-js"> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
        <span class="hljs-comment">/* 请求数据 ， 事件监听 ， 操纵dom ， 增加定时器，延时器 */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>){
            <span class="hljs-comment">/* 解除事件监听器 ，清除定时器，延时器 */</span>
        }
},[])<span class="hljs-comment">/* 切记 dep = [] */</span>
</code></pre>
<p>在 componentDidMount 的前提下，useEffect 第一个函数的返回函数，可以作为 componentWillUnmount 使用。</p>
<h3>5 componentWillReceiveProps 代替方案</h3>
<p>说 useEffect 代替 componentWillReceiveProps 着实有点牵强。</p>
<ul>
<li>首先因为二者的执行阶段根本不同，一个是在render阶段，一个是在commit阶段。</li>
<li>其次 <strong>useEffect 会初始化执行一次</strong>，但是 componentWillReceiveProps 只有组件更新 props 变化的时候才会执行。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'props变化：componentWillReceiveProps'</span>)
},[ props ])
</code></pre>
<p>此时依赖项就是 props，props 变化，执行此时的 useEffect 钩子。</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'props中number变化：componentWillReceiveProps'</span>)
},[ props.<span class="hljs-property">number</span> ]) <span class="hljs-comment">/* 当前仅当 props中number变化，执行当前effect钩子 */</span>
</code></pre>
<p>useEffect 还可以针对 props 的某一个属性进行追踪。此时的依赖项为 props 的追踪属性。如上述代码，只有 props 中 number 变化，执行 effect 。</p>
<h3>6 componentDidUpdate 替代方案</h3>
<p>useEffect 和 componentDidUpdate 在执行时期虽然有点差别，useEffect 是异步执行，componentDidUpdate 是同步执行 ，但都是在 commit 阶段 。但是向上面所说 useEffect 会默认执行一次，而 componentDidUpdate 只有在组件更新完成后执行。</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件更新完成：componentDidUpdate '</span>)     
}) <span class="hljs-comment">/* 没有 dep 依赖项 */</span>
</code></pre>
<p>注意此时useEffect没有第二个参数。</p>
<p>没有第二个参数，那么每一次执行函数组件，都会执行该 effect。</p>
<h3>7 完整代码和效果</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FunctionLifecycle</span>(<span class="hljs-params">props</span>){
    <span class="hljs-keyword">const</span> [ num , setNum ] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
        <span class="hljs-comment">/* 请求数据 ， 事件监听 ， 操纵dom  ， 增加定时器 ， 延时器 */</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件挂载完成：componentDidMount'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>){
            <span class="hljs-comment">/* 解除事件监听器 ，清除 */</span>
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件销毁：componentWillUnmount'</span>)
        }
    },[])<span class="hljs-comment">/* 切记 dep = [] */</span>
    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'props变化：componentWillReceiveProps'</span>)
    },[ props ])
    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{ <span class="hljs-comment">/*  */</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">' 组件更新完成：componentDidUpdate '</span>)
    })
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> props : { props.number } <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> states : { num } <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> setNum(state=>state + 1) }   >改变state<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=>{
    <span class="hljs-keyword">const</span> [ number , setNumber ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> [ isRender , setRender ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        { isRender &#x26;&#x26;  <span class="hljs-tag">&#x3C;<span class="hljs-name">FunctionLifecycle</span> <span class="hljs-attr">number</span>=<span class="hljs-string">{number}</span>  /></span> }
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> setNumber(state => state + 1 ) } > 改变props  <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span> <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span>/></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span>=></span> setRender(false) } >卸载组件<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p><strong>效果</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a45e5260796b424fa1bd2d7bbce19d4b~tplv-k3u1fbpfcp-watermark.image" alt="lifecycle.gif"></p>
<h2>四 实践-实现一个ScrollView组件</h2>
<p>接下来为了让大家加深对生命周期各阶段的理解，我写了一个 demo ，编写一个类似小程序或是 webView 中的 scrollView 组件，主要用于长列表渲染，滑动底部请求渲染列表。</p>
<p>组件本身功能不重要，实现细节也不需要太纠结，本节讲的是生命周期，明白生命周期的各个阶段应该做些什么才重要。</p>
<p><strong>使用:</strong></p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* item 完全是单元项的渲染ui */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Item</span>(<span class="hljs-params">{item}</span>) {
    <span class="hljs-keyword">return</span>  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"goods_item"</span> ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{item.giftImage}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"item_image"</span> /></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"item_content"</span> ></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"goods_name"</span> ></span>
                {item.giftName}
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"hold_price"</span> /></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"new_price"</span> ></span>
                <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"new_price"</span> ></span>
                    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"one view"</span>></span>
                        ¥ {item.price}
                    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
                <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'go_share  go_text'</span> /></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}

<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { 
    <span class="hljs-keyword">const</span> [ data , setData ] = <span class="hljs-title function_">useState</span>({ <span class="hljs-attr">list</span>:[],<span class="hljs-attr">page</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">pageCount</span>:<span class="hljs-number">1</span>  }) <span class="hljs-comment">/* 记录列表数据 */</span>
    <span class="hljs-comment">/* 请求数据 */</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>)=>{
        <span class="hljs-keyword">if</span>(data.<span class="hljs-property">page</span> === data.<span class="hljs-property">pageCount</span>) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'没有数据了～'</span>)
        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(data.<span class="hljs-property">page</span> + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span>(res.<span class="hljs-property">code</span> === <span class="hljs-number">0</span>) <span class="hljs-title function_">setData</span>({
            ...res,
            <span class="hljs-attr">list</span>:res.<span class="hljs-property">page</span> === <span class="hljs-number">1</span> ?  res.<span class="hljs-property">list</span> : data.<span class="hljs-property">list</span>.<span class="hljs-title function_">concat</span>(res.<span class="hljs-property">list</span>) 
        })
    } 
    <span class="hljs-comment">/* 滚动到底部触发 */</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handerScrolltolower</span> = (<span class="hljs-params"></span>) => {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'scroll已经到底部'</span>)
        <span class="hljs-title function_">getData</span>()
    }
    <span class="hljs-comment">/* 初始化请求数据 */</span>
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=></span>{
        <span class="hljs-title function_">getData</span>()
    },[])
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ScrollView</span> 
            <span class="hljs-attr">data</span>=<span class="hljs-string">{</span> <span class="hljs-attr">data</span> }       /*  */
            <span class="hljs-attr">component</span>=<span class="hljs-string">{</span> <span class="hljs-attr">Item</span> }  /* <span class="hljs-attr">Item</span> 渲染的单元组件 */
            <span class="hljs-attr">scrolltolower</span>=<span class="hljs-string">{</span> <span class="hljs-attr">handerScrolltolower</span> } 
            <span class="hljs-attr">scroll</span>=<span class="hljs-string">{()</span>=></span>{}} 
        /></span>
}
</code></pre>
<p><strong>实现效果</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4139eb69f014d08abd8a64d6aab4d77~tplv-k3u1fbpfcp-watermark.image" alt="lifecycle2.gif"></p>
<p>编写 <strong>ScrollView</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>{
    <span class="hljs-comment">/* -----自定义事件---- */</span>
    <span class="hljs-comment">/* 控制滚动条滚动 */</span>
      handerScroll=<span class="hljs-function">(<span class="hljs-params">e</span>)=></span>{
        <span class="hljs-keyword">const</span> { scroll } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>
        scroll &#x26;&#x26; <span class="hljs-title function_">scroll</span>(e)
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handerScrolltolower</span>()
    }
    <span class="hljs-comment">/* 判断滚动条是否到底部 */</span>
    <span class="hljs-title function_">handerScrolltolower</span>(<span class="hljs-params"></span>){
       <span class="hljs-keyword">const</span> { scrolltolower } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>
       <span class="hljs-keyword">const</span> { scrollHeight , scrollTop ,  offsetHeight } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span> 
       <span class="hljs-keyword">if</span>(scrollHeight === scrollTop + offsetHeight){ <span class="hljs-comment">/* 到达容器底部位置 */</span>
           scrolltolower &#x26;&#x26; <span class="hljs-title function_">scrolltolower</span>()
       }
    }
    node = <span class="hljs-literal">null</span>

    <span class="hljs-comment">/* ---——---生命周期------- */</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
        <span class="hljs-variable language_">super</span>(props)
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>={ <span class="hljs-comment">/* 初始化 Data */</span>
            <span class="hljs-attr">list</span>:[]
        }
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">handerScrolltolower</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">handerScrolltolower</span>,<span class="hljs-number">200</span>) <span class="hljs-comment">/* 防抖处理 */</span>               
    }
    <span class="hljs-comment">/* 接收props, 合并到state */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">newProps</span>){
        <span class="hljs-keyword">const</span> { data } = newProps
        <span class="hljs-keyword">return</span> { 
            list : data.<span class="hljs-property">list</span> || [] ,
        }
    }
    <span class="hljs-comment">/* 性能优化，只有列表数据变化，渲染列表 */</span>
    <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">newProps,newState</span>){
       <span class="hljs-keyword">return</span> newState.<span class="hljs-property">list</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">list</span>
    }
    <span class="hljs-comment">/* 获取更新前容器高度 */</span>
    <span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>.<span class="hljs-property">scrollHeight</span>
    }
    <span class="hljs-comment">/* 获取更新后容器高度 */</span>
    <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'scrollView容器高度变化:'</span> , <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>.<span class="hljs-property">scrollHeight</span> - snapshot  )
    }
    <span class="hljs-comment">/* 绑定事件监听器 - 监听scorll事件 */</span>
    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'scroll'</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">handerScroll</span>)
    }
    <span class="hljs-comment">/* 解绑事件监听器 */</span>
    <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>){
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'scroll'</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">handerScroll</span>)
    }
    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> { list } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>
        <span class="hljs-keyword">const</span> { component } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"list_box"</span>  <span class="hljs-attr">ref</span>=<span class="hljs-string">{(node)</span> =></span> this.node = node }  >
            <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> ></span>     
                {
                    list.map((item) => (
                        React.createElement(component,{ item , key: item.id  }) //渲染 Item 列表内容。
                    ))
                }
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    }
}
</code></pre>
<p>scrollview组件各个生命周期功能：</p>
<ul>
<li><code>constructor</code>： 做数据初始化，将滑动处理函数，做防抖处理。</li>
<li><code>getDerivedStateFromProps</code>: 将 props 中的 list ，合并到 state 。</li>
<li><code>componentDidMount</code>: 绑定监听 scroll 事件。</li>
<li><code>shouldComponentUpdate</code>：性能优化，只有 list 改变，渲染视图。</li>
<li><code>render</code>: 渲染视图，渲染 Item 。</li>
<li><code>getSnapshotBeforeUpdate</code>：保存组件更新前的 scrollview 容器高度。</li>
<li><code>componentDidUpdate</code>：根据渲染前后容器高度，计算一次高度变化量。</li>
<li><code>componentWillUnmount</code>：解除 scroll 事件监听器。</li>
</ul>
<h2>四 收获</h2>
<p>最后总结一下本章节收获哪些知识：</p>
<ul>
<li>类组件生命周期执行过程，以及细节；</li>
<li>讲解了类组件各个生命周期，每个生命周期能做的事情；</li>
<li>函数组件生命周期代替方案；</li>
<li>实战项目，各个生命周期应用实践。</li>
</ul>
<p>下一节，将一起探讨 React ref的奥秘。</p></div>
</body></html>