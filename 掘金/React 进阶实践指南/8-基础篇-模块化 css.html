<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>基础篇-模块化 css</h1>
<h2>一 前言</h2>
<p>css 模块化一直是 React 痛点，为什么这么说呢？ 因为 React 没有像 Vue 中 <code>style scoped</code> 的模版写法，可以直接在 .vue 文件中声明 css 作用'域'。随着 React 项目日益复杂化、繁重化，React 中 css 面临很多问题，比如样式类名全局污染、命名混乱、样式覆盖等。这时， css 模块化就显得格外重要。</p>
<p>不过，在讲解如何在 React 中实现 css 模块化之前，我们首先简单介绍一下 css 模块化作用是什么？</p>
<p><strong>这里总结了 css 模块化的几个重要作用，如下</strong></p>
<ul>
<li>1 防止全局污染，样式被覆盖</li>
</ul>
<p>全局污染、样式覆盖是很容易面临的一个问题。首先假设一个场景，比如小明在参与一个项目开发，不用 css 模块化，在 React 一个组件对应的 css 文件中这么写：</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.button</span>{
    <span class="hljs-attribute">background</span>:red;
}
</code></pre>
<p>但是在浏览器中并没有生效，于是小明开始排查，结果发现，在其他组件中，其他小伙伴这么写：</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.context</span> <span class="hljs-selector-class">.button</span>{
     <span class="hljs-attribute">background</span>:blue;
} 
</code></pre>
<p>由于权重问题，样式被覆盖了。</p>
<p>上述是一个很简单的例子，但是如果不规范 css 的话，这种情况在实际开发中会变得更加棘手，有时候甚至不得不用 <code>!important</code> 或者 <code>行内样式</code> 来解决，但是只是一时痛快，如果后续有其他样式冲突，那么更难解决这个问题。 Web Components 标准中的 Shadow DOM 能彻底解决这个问题，但它的做法有点极端，样式彻底局部化，造成外部无法重写样式，损失了灵活性。</p>
<ul>
<li>2 命名混乱</li>
</ul>
<p>没有 css 模块化和统一的规范，会使得多人开发，没有一个规范，比如命名一个类名，有的人用驼峰<code>.contextBox</code>，有的人用下划线<code>.context_box</code>，还有的人用中划线<code>.context-box</code>，使得项目不堪入目。</p>
<ul>
<li>3 css 代码冗余，体积庞大。</li>
</ul>
<p>这种情况也普遍存在，因为 React 中各个组件是独立的，所以导致引入的 css 文件也是相互独立的，比如在两个 css 中，有很多相似的样式代码，如果没有用到 css 模块化，构建打包上线的时候全部打包在一起，那么无疑会增加项目的体积。</p>
<p>为了解决如上问题 css 模块化也就应运而生了，关于 React 使用 css 模块化的思路主要有两种：</p>
<ul>
<li>
<p>第一种 <code>css module</code> ，依赖于 webpack 构建和 css-loader 等 loader 处理，将 css 交给 js 来动态加载。</p>
</li>
<li>
<p>第二种就是直接放弃 css ，<code>css in js</code>用 js 对象方式写 css ，然后作为 style 方式赋予给 React 组件的 DOM 元素，这种写法将不需要 .css .less .scss 等文件，取而代之的是每一个组件都有一个写对应样式的 js 文件。</p>
</li>
</ul>
<h2>二 CSS Modules</h2>
<p>css Modules ，使得项目中可以像加载 js 模块一样加载 css ，本质上通过一定自定义的命名规则生成唯一性的 css 类名，从根本上解决 css 全局污染，样式覆盖的问题。对于 css modules 的配置，推荐使用 css-loader，因为它对 CSS Modules 的支持最好，而且很容易使用。接下来介绍一下配置的流程。</p>
<p><strong>css-loader配置</strong></p>
<pre><code class="hljs language-js">{
    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<span class="hljs-comment">/* 对于 css 文件的处理 */</span>
    use:[
       <span class="hljs-string">'css-loader?modules'</span> <span class="hljs-comment">/* 配置css-loader ,加一个 modules */</span>
    ]
}
</code></pre>
<p><strong>css文件</strong></p>
<p>然后在css文件中这么写</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.text</span>{
    <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<p><strong>js文件</strong></p>
<p>这样就可以直接在 js 文件中像引用其他 js 文件一样引用 css 文件了。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> style <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span> <span class="hljs-attr">style.text</span> } ></span>验证 css modules <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
</code></pre>
<p><strong>效果</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba20e19cfa264079978bc174f5bf0cb9~tplv-k3u1fbpfcp-watermark.image" alt="css1.jpg"></p>
<p><strong>首先来看看样式类名被编译成什么？</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/648418b349f24fcdb0060bbc1e924521~tplv-k3u1fbpfcp-watermark.image" alt="css2.jpg"></p>
<p>如上，可以看到 css-loader 将 text 变成了全局唯一的类名 <code>_1WHQzhI7PwBzQ_NMib7jy6</code>。这样有效的避免了样式冲突，全局类名污染的情况。</p>
<h3>1 自定义命名规则</h3>
<p>上述的命名有一个致命问题，就是命名中没有了 text，在调试阶段，不容易找到对应的元素。对于这个问题可以自定义命名规则。只需要在 css-loader 配置项这么写：</p>
<p><strong>自定义规则命名</strong></p>
<pre><code class="hljs language-js">{
     <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<span class="hljs-comment">/* 对于 css 文件的处理 */</span>
     use:[
        {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'css-loader'</span>,
            <span class="hljs-attr">options</span>:{
              <span class="hljs-attr">modules</span>: {
                <span class="hljs-attr">localIdentName</span>: <span class="hljs-string">"[path][name]__[local]--[hash:base64:5]"</span>, <span class="hljs-comment">/* 命名规则  [path][name]__[local] 开发环境 - 便于调试   */</span>
              },
            }
        },
     ],
}
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6bbab9c02794fa5bee0cd6750df3a4d~tplv-k3u1fbpfcp-watermark.image" alt="css3.jpg"></p>
<p>此时类名变成了， <code>src-pages-cssModule-style__text--1WHQz </code>，这个命名规则意义如下</p>
<ul>
<li>
<p><strong>[path][name]__[local]</strong> -> 开发环境，便于调试。可以直接通过 <code>src-pages-cssModule-style</code> 找到此类名对应的文件。</p>
</li>
<li>
<p><strong>[hash:base64:5]</strong> -> 生产环境，<code>1WHQz</code> 便于生产环境压缩类名。</p>
</li>
</ul>
<h3>2 全局变量</h3>
<p>一旦经过 css modules 处理的 css 文件类名 ，再引用的时候就已经无效了。因为声明的类名，比如如上的 .text 已经被处理成了哈希形式。那么怎么样快速引用声明好的全局类名呢？CSS Modules 允许使用 <code>:global(.className)</code> 的语法，声明一个全局类名。凡是这样声明的 class ，都不会被编译成哈希字符串。</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.text</span>{
    <span class="hljs-attribute">color</span>: blue;
}
:<span class="hljs-built_in">global</span>(.text_bg) {
    background-color: pink;
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> style <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=><span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span> <span class="hljs-attr">style.text</span> + ' <span class="hljs-attr">text_bg</span>'} ></span>验证 CSS Modules <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
</code></pre>
<p>效果：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/008d9a0e59a14ace8d129298f07643b2~tplv-k3u1fbpfcp-watermark.image" alt="css4.jpg"></p>
<p>这样就可以正常渲染组件样式了。</p>
<p>CSS Modules 还提供一种显式的局部作用域语法<code>:local(.text)</code>，等同于.text。</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.text</span>{
    <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-comment">/* 等价于 */</span>
:<span class="hljs-built_in">local</span>(.text_bg) {
    background-color: pink;
}
</code></pre>
<h3>3 组合样式</h3>
<p>CSS Modules 提供了一种 <code>composes</code>组合方式，实现对样式的复用。比如通过 composes 方式的实现上面的效果。</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.base</span>{ <span class="hljs-comment">/* 基础样式 */</span>
    <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-selector-class">.text</span> { <span class="hljs-comment">/* 继承基础样式 ，增加额外的样式 backgroundColor */</span>
    composes:base;
    <span class="hljs-attribute">background-color</span>: pink;
}
</code></pre>
<p>js 这么写：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> style <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=><span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span> <span class="hljs-attr">style.text</span> } ></span>验证 css modules <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
</code></pre>
<p>同样达到了上述效果。此时的 DOM 元素上的类名变成了如下的样子：</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"src-pages-cssModule-style__text--1WHQz src-pages-cssModule-style__base--2gced"</span>></span>验证 css modules <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
</code></pre>
<p>上述可以看到，用了 composes 可以将多个 class 类名添加到元素中。composes 还有一个更灵活的方法，支持动态引入别的模块下的类名。比如上述写的 <code>.base</code> 样式在另外一个文件中，完全可以如下这么写：</p>
<p><strong>style1.css 中</strong></p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.text</span>{
    <span class="hljs-attribute">color</span>: pink;
}
</code></pre>
<p><strong>style.css 中</strong></p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.text</span> { <span class="hljs-comment">/* 继承基础样式 ，增加额外的样式 backgroundColor */</span>
    composes:base from <span class="hljs-string">'./style1.css'</span>;  <span class="hljs-comment">/* base 样式在 style1.css 文件中 */</span>
    <span class="hljs-attribute">background-color</span>: pink;
}
</code></pre>
<h3>4 配置 less 和 sass</h3>
<p>配置 less 和 sass 的 CSS Modules 和配置 css 一模一样。以 less 为例子。接下来在刚才的基础上，配置一下 less 的 CSS Modules。</p>
<p><strong>less webpack配置</strong></p>
<pre><code class="hljs language-js">{
     <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,
     use:[
        {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">'css-loader'</span>,
          <span class="hljs-attr">options</span>:{
                <span class="hljs-attr">modules</span>: {
                    <span class="hljs-attr">localIdentName</span>:<span class="hljs-string">'[path][name]---[local]---[hash:base64:5]'</span>
                },
          },
        },
        {
            <span class="hljs-comment">// 可能是其他 loader, 不过不重要。</span>
        },
        <span class="hljs-string">'less-loader'</span>
     ]
}
</code></pre>
<p>然后在刚才的文件同级目录下，新建 <code>index.less</code></p>
<p><strong>index.less 这么写</strong></p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.text</span>{
    <span class="hljs-attribute">color</span>: orange;
    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;
}
</code></pre>
<p><strong>js 中这么写</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span>  React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> style <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>      <span class="hljs-comment">/* css  module*/</span> 
<span class="hljs-keyword">import</span> lessStyle <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.less'</span> <span class="hljs-comment">/*  less css module */</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=><span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span> <span class="hljs-attr">style.text</span> } ></span>验证 css modules <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span> <span class="hljs-attr">lessStyle.text</span> } ></span>验证 less + css modules <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
</code></pre>
<p><strong>效果：</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eac65e125ce54000a8de4592e7860b74~tplv-k3u1fbpfcp-watermark.image" alt="css5.jpg"></p>
<h3>5 组合方案</h3>
<p>正常情况下，React 项目可能在使用 css 处理样式之外，还会使用 scss 或者 less 预处理。那么可不可以使用一种组合方法。</p>
<ul>
<li>
<p>可以约定对于<strong>全局样式或者是公共组件样式</strong>，可以用 .css 文件 ，不需要做 CSS Modules 处理，这样就不需要写 :global 等繁琐语法。</p>
</li>
<li>
<p>对于项目中开发的<strong>页面和业务组件</strong>，统一用 scss 或者 less 等做 CSS Module，也就是 <strong>css 全局样式 + less / scss CSS Modules</strong> 方案。这样就会让 React 项目更加灵活的处理 CSS 模块化。我写一个 demo 如下：</p>
</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span>  React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">import</span> Style <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.less'</span> <span class="hljs-comment">/*  less css module */</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=><span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
     {/* 公共样式 */}
    <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"searchbtn"</span> ></span>公共按钮组件<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span> 
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span> <span class="hljs-attr">Style.text</span> } ></span>验证 less + css modules <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>

</code></pre>
<p>效果：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4de2995a9a334dfdad36ec60fa779c18~tplv-k3u1fbpfcp-watermark.image" alt="css6.jpg"></p>
<h3>6 动态添加class</h3>
<p>CSS Modules 可以配合 classNames 库 实现更灵活的动态添加类名。</p>
<p>比如在less 中这么写</p>
<pre><code class="hljs language-less"><span class="hljs-selector-class">.base</span>{ <span class="hljs-comment">/* ...基础样式 */</span> }
<span class="hljs-selector-class">.dark</span>{ <span class="hljs-comment">// 主题样式-暗色调</span>
    <span class="hljs-attribute">background</span>:<span class="hljs-number">#000</span>;
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;
}
<span class="hljs-selector-class">.light</span>{<span class="hljs-comment">// 主题样式-亮色调</span>
    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;
    <span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;
}
</code></pre>
<p>组件中引入 classNames 库：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> classNames <span class="hljs-keyword">from</span> <span class="hljs-string">'classnames'</span> 
<span class="hljs-keyword">import</span> Style <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.less'</span> <span class="hljs-comment">/*  less css module */</span>
<span class="hljs-comment">/* 动态加载 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [ theme , setTheme  ] = React.useState(<span class="hljs-string">'light'</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>  ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span>  
         <span class="hljs-attr">className</span>=<span class="hljs-string">{</span> <span class="hljs-attr">classNames</span>(<span class="hljs-attr">Style.base</span>, <span class="hljs-attr">theme</span> === <span class="hljs-string">'light'</span> ? <span class="hljs-attr">Style.light</span> <span class="hljs-attr">:</span> <span class="hljs-attr">Style.dark</span> ) }  
         <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> setTheme(theme === 'light' ? 'dark' : 'light')  }
        > 
           切换主题 
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>效果：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75d835f79b3f4ebb8b3d5548fa2c3968~tplv-k3u1fbpfcp-watermark.image" alt="css11.gif"></p>
<p>通过 CSS Modules 配合 classNames 灵活的实现了样式的动态加载。</p>
<h3>7 CSS Modules 总结</h3>
<p>下面我对 CSS Modules 的优点和注意事项做一个总结：</p>
<p>首先 CSS Modules 优点：</p>
<ul>
<li>CSS Modules 的类名都有自己的私有域的，可以避免类名重复/覆盖，全局污染问题。</li>
<li>引入 css 更加灵活，css 模块之间可以互相组合。</li>
<li>class 类名生成规则配置灵活，方便压缩 class 名。</li>
</ul>
<p>CSS Modules 的注意事项：</p>
<ul>
<li>仅用 class 类名定义 css ，不使用其他选择器。</li>
<li>不要嵌套 <code>css .a{ .b{} }</code> 或者重叠 <code>css .a .b {} </code> 。</li>
</ul>
<h2>三 CSS IN JS</h2>
<h3>1 概念和使用</h3>
<p><code>CSS IN JS</code> 相比 CSS Modules 更加简单， CSS IN JS 放弃css ，用 js 对象形式直接写 style 。先写一个例子尝尝鲜。</p>
<p>在 index.js 写 React 组件</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> Style <span class="hljs-keyword">from</span> <span class="hljs-string">'./style'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">{</span> <span class="hljs-attr">Style.boxStyle</span> }  ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{</span> <span class="hljs-attr">Style.textStyle</span> }  ></span>hi , i am CSS IN JS!<span class="hljs-tag">&#x3C;/<span class="hljs-name">span</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>在同级目录下，新建 style.js 用来写样式</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 容器的背景颜色 */</span>
<span class="hljs-keyword">const</span> boxStyle = {
    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">'blue'</span>,
}
<span class="hljs-comment">/* 字体颜色 */</span>
<span class="hljs-keyword">const</span> textStyle = {
    <span class="hljs-attr">color</span>:<span class="hljs-string">'orange'</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    boxStyle,
    textStyle
}
</code></pre>
<p>效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aab5054688f144ec9ed4f9bbb41cc08a~tplv-k3u1fbpfcp-watermark.image" alt="css7.jpg"></p>
<h3>2 灵活运用</h3>
<p>由于 CSS IN JS 本质上就是运用 js 中对象形式保存样式， 所以 js 对象的操作方法都可以灵活的用在 CSS IN JS上。</p>
<p><strong>拓展运算符实现样式继承</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> baseStyle = { <span class="hljs-comment">/* 基础样式 */</span> }

<span class="hljs-keyword">const</span> containerStyle = { 
    ...baseStyle,  <span class="hljs-comment">// 继承  baseStyle 样式</span>
    <span class="hljs-attr">color</span>:<span class="hljs-string">'#ccc'</span>   <span class="hljs-comment">// 添加的额外样式</span>
}
</code></pre>
<p><strong>动态添加样式变得更加灵活</strong></p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 暗色调  */</span>
<span class="hljs-keyword">const</span> dark = {
    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">'black'</span>,
}
<span class="hljs-comment">/* 亮色调 */</span>
<span class="hljs-keyword">const</span> light = {
    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">'white'</span>,
}
</code></pre>
<pre><code class="hljs language-js">&#x3C;span style={ theme===<span class="hljs-string">'light'</span> ? Style.light : Style.dark  }  >hi , i am CSS IN JS!&#x3C;/span>
</code></pre>
<p>更加复杂的结构：</p>
<pre><code class="hljs language-js"> &#x3C;span style={ { ...Style.textStyle , ...(theme===<span class="hljs-string">'light'</span> ? Style.light : Style.dark  ) }}  >hi , i am CSS IN JS!&#x3C;/span>
</code></pre>
<h3>3 style-components库使用</h3>
<p>CSS IN JS 也可以由一些第三方库支持，比如我即将介绍的 <code>style-components</code>。 <code>style-components</code> 可以把写好的 css 样式注入到组件中，项目中应用的已经是含有样式的组件。</p>
<p><strong>基础用法</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">'styled-components'</span>
<span class="hljs-comment">/* 给button标签添加样式，形成 Button React 组件 */</span>
<span class="hljs-keyword">const</span> Button = styled.button<span class="hljs-string">`
    background: #6a8bad;
    color: #fff;
    min-width: 96px;
    height :36px;
    border :none;
    border-radius: 18px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    margin-left: 20px !important;
`</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span>></span>按钮<span class="hljs-tag">&#x3C;/<span class="hljs-name">Button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48fe19e6059e4cfeb5ada8118b620996~tplv-k3u1fbpfcp-watermark.image" alt="css8.jpg"></p>
<p><strong>基于 props 动态添加样式</strong></p>
<p>style-components 可以通过给生成的组件添加 props 属性 ，来动态添加样式。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Button = styled.button<span class="hljs-string">`
    background: <span class="hljs-subst">${ props => props.theme ? props.theme : <span class="hljs-string">'#6a8bad'</span>  }</span>;
    color: #fff;
    min-width: 96px;
    height :36px;
    border :none;
    border-radius: 18px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    margin-left: 20px !important;
`</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">{</span>'#<span class="hljs-attr">fc4838</span>'}  ></span>props主题按钮<span class="hljs-tag">&#x3C;/<span class="hljs-name">Button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b091e38138649299c1cf4c65cfa37e8~tplv-k3u1fbpfcp-watermark.image" alt="css9.jpg"></p>
<p><strong>继承样式</strong></p>
<p>style-components 可以通过继承方式来达到样式的复用。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> NewButton = styled(Button)<span class="hljs-string">`
    background: orange;
    color: pink;
`</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
       <span class="hljs-tag">&#x3C;<span class="hljs-name">NewButton</span> ></span> 继承按钮<span class="hljs-tag">&#x3C;/<span class="hljs-name">NewButton</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>效果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48cf0accb8dd4292a39b01c10a476673~tplv-k3u1fbpfcp-watermark.image" alt="css10.jpg"></p>
<p>style-components 还有一些其他的功能，这里我就不一一介绍了，感兴趣的同学可以了解一下官网。<a href="https://styled-components.com/docs/basics#extending-styles" target="_blank" rel="nofollow noopener noreferrer">styled-components</a></p>
<h3>4 CSS IN JS 总结</h3>
<p>CSS IN JS 特点。</p>
<ul>
<li>CSS IN JS 本质上放弃了 css ，变成了 css in line 形式，所以根本上解决了全局污染，样式混乱等问题。</li>
<li>运用起来灵活，可以运用 js 特性，更灵活地实现样式继承，动态添加样式等场景。</li>
<li>由于编译器对 js 模块化支持度更高，使得可以在项目中更快地找到 style.js 样式文件，以及快捷引入文件中的样式常量。</li>
<li>无须 webpack 额外配置 css，less 等文件类型。</li>
</ul>
<p>CSS IN JS 注意事项。</p>
<ul>
<li>虽然运用灵活，但是写样式不如 css 灵活，由于样式用 js 写，所以无法像 css 写样式那样可以支持语法高亮，样式自动补全等。所以要更加注意一些样式单词拼错的问题。</li>
</ul>
<h2>四 总结</h2>
<p>本章节主要讲了：</p>
<ul>
<li>css 模块化的意义。</li>
<li>学习了 CSS Modules 方式。</li>
<li>详解了 CSS IN JS 方式。</li>
</ul>
<p>下一节，将详细讲解React HOC。</p></div>
</body></html>