<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>原理篇-v18commit全流程</h1>
<h2>一前言</h2>
<p>本章节将继续围绕 v18 commit 阶段的细节展开，将具体介绍 commit 各个阶段做些什么？还有一些细节。</p>
<p>请大家带上如下问题去思考：</p>
<ul>
<li>commit 阶段具体分为那几个部分，分别做了哪些事？</li>
<li>父子组件在 commit 阶段各个部分的执行顺序是什么样的？</li>
<li>如何执行的生命周期和 hooks 钩子的回调函数？</li>
<li>commit 阶段如何更新的 dom 节点？</li>
</ul>
<p>在正式讲解之前，我们先来两个例子：</p>
<p><strong>例子一：</strong></p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params"></span>)</span>{
    React.useEffect(<span class="hljs-function">()=></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--------Son useEffect-------'</span>)
    })
    React.useLayoutEffect(<span class="hljs-function">()=></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--------Son useLayoutEffect-------'</span>)
    })
    React.useInsertionEffect(<span class="hljs-function">()=></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--------Son useInsertionEffect-------'</span>)
    })
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>子组件<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params"></span>)</span>{
    React.useEffect(<span class="hljs-function">()=></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--------Father useEffect-------'</span>)
    })
    React.useLayoutEffect(<span class="hljs-function">()=></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--------Father useLayoutEffect-------'</span>)
    })
    React.useInsertionEffect(<span class="hljs-function">()=></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--------Father useInsertionEffect-------'</span>)
    })
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
         <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>父组件<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Son</span>/></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<ul>
<li>如上有父子组件，父子组件中分别有三个不同的 effect 。</li>
</ul>
<p>打印顺序：</p>
<p>--------Son useInsertionEffect-------
--------Father useInsertionEffect-------
--------Son useLayoutEffect-------
--------Father useLayoutEffect-------
--------Son useEffect-------
--------Father useEffect-------</p>
<p>在生命周期章节中，讲解了不同 effect 的钩子函数；在第十六章中，我们讲到过，commit 阶段具体又分别三个小阶段，分别是 <code>before mutation </code>， <code>mutation</code> 和 <code>layout</code>，而 DOM 的改变是在 mutation 阶段进行的。</p>
<p>那么对于 effect 钩子在 commit 阶段执行时机如下：</p>
<ul>
<li>useInsertionEffect 是在 mutation 阶段执行的，虽然 mutation 是更新 DOM ，但是 useInsertionEffect 是在更新 DOM 之前 。</li>
<li>useLayoutEffect 是在 layout 阶段执行，此时 DOM 已经更新了。</li>
<li>useEffect 是在浏览器绘制之后，异步执行的。</li>
</ul>
<p>明白了 effect 每个钩子的执行时机 ，从上面的例子中还可以总结出，对于不同的 effect 钩子父子组件的执行顺序是：<strong>先子后父。</strong></p>
<p>为了加深对 commit 阶段各个阶段的理解，来看一下第二个例子：</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [ color, setColor ] = React.useState(<span class="hljs-string">'#000'</span>)
    React.useEffect(<span class="hljs-function">()=></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--------useEffect-------'</span>)
    })
    React.useLayoutEffect(<span class="hljs-function">()=></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--------useLayoutEffect-------'</span>)
    })
    React.useInsertionEffect(<span class="hljs-function">()=></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--------useInsertionEffect-------'</span>)
    })
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color</span> }}></span> hello,react <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setColor('red')} >点击改变颜色<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<ul>
<li>如上点击按钮，触发 useState 那么接下来，为了让大家明白了解各个流程。我在 React 源码中获取 text 的颜色。</li>
</ul>
<p>commit 阶段主要的执行函数就是 <code>commitRootImpl</code>，我们打印 commitRootImpl 的重点阶段。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberWorkLoop.new.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitRootImpl</span>(<span class="hljs-params"></span>)</span>{

    <span class="hljs-keyword">if</span> ((finishedWork.subtreeFlags &#x26; PassiveMask) !== NoFlags || (finishedWork.flags &#x26; PassiveMask) !== NoFlags) {
         <span class="hljs-comment">/* 通过异步的方式处理 useEffect  */</span>
        scheduleCallback$<span class="hljs-number">1</span>(NormalPriority, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            flushPassiveEffects(); 
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        });
    }

    <span class="hljs-comment">/* BeforeMutation 阶段执行 */</span>
    <span class="hljs-keyword">const</span> text = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'text'</span>)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-----BeforeMutation 执行-------'</span>)
    commitBeforeMutationEffects(root, finishedWork);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-----BeforeMutation 执行完毕------'</span>)
    <span class="hljs-comment">/* Mutation 阶段执行 */</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-----Mutation 执行-----'</span>)
    <span class="hljs-keyword">if</span>(text) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'颜色获取：'</span>,<span class="hljs-built_in">window</span>.getComputedStyle(text).color)
    commitMutationEffects(root, finishedWork, lanes);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-----Mutation 执行完毕-----'</span>)
    <span class="hljs-keyword">if</span>(text) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'颜色获取：'</span>,<span class="hljs-built_in">window</span>.getComputedStyle(text).color)
    <span class="hljs-comment">/* Layout 阶段执行 */</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-----Layout 执行-----'</span>)
    commitLayoutEffects(finishedWork, root, lanes);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-----Layout 执行完毕-----'</span>)
}
</code></pre>
<p>接下来看一下打印内容：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37aef92d1d464a47955e3e6a905e9727~tplv-k3u1fbpfcp-watermark.image?" alt="1.jpeg"></p>
<p>通过上面的打印内容，可以看出，真实 DOM 改变确实在 mutation 阶段执行的，在 mutation 前后的两次打印，可以看出打印颜色的变化。</p>
<p>通过上面两个例子，直观地表现出在 commit 阶段的大致更新流程，那么本章节将围绕着流程中的细节展开，探索一下在 v18 commit 阶段有什么奥秘。</p>
<h2>二 更新标志</h2>
<p>我们都知道在 render 阶段，会遍历 fiber 树，收集需要更新的地方，打不同的标志，这些标志代表的意义不相同，有些是处理，这些标志的更新会在 commit 阶段执行。</p>
<ul>
<li>更新相关：Update-组件更新标志， Ref-处理绑定元素和组件实例，</li>
<li>元素相关：Placement-插入元素，Update-更新元素，ChildDeletion-删除元素，Snapshot-元素快照，Visibility-offscreen新特性，ContentReset-文本内容更新。</li>
<li>更新回调，执行 effect：Callback-root 回调函数，类组件回调，Passive-useEffect 的钩子函数，Layout-useLayoutEffect 的钩子函数，Insertion-useInsertionEffect的钩子函数。</li>
</ul>
<p>在老版本的 React 中会形成一个 effectList ，然后执行 effectList 就可以了。在 v17 和 v18 新版本的 React ，不再用 effectList，而是通过 rootFiber 自上而下的调和方式来处理这些标志。</p>
<p>这些标志在 commit 各种阶段被执行，看一下在具体标志的执行时机：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* Before Mutation 阶段标志 */</span>
<span class="hljs-keyword">var</span> BeforeMutationMask = Update | Snapshot 
<span class="hljs-comment">/* Mutation 阶段标志 */</span>
<span class="hljs-keyword">var</span> MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Visibility;
<span class="hljs-comment">/* Layout 阶段标志 */</span>
<span class="hljs-keyword">var</span> LayoutMask = Update | Callback | Ref | Visibility;
<span class="hljs-comment">/* useEffect 阶段标志 */</span>
<span class="hljs-keyword">var</span> PassiveMask = Passive | ChildDeletion;
</code></pre>
<p>用一幅图表示在 commit 阶段执行哪些事？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cac5ab88d0646b4ba4da0a7731fdf02~tplv-k3u1fbpfcp-watermark.image?" alt="5.jpeg"></p>
<p>这些 Mask 在整个 React 应用中充当什么角色呢？ React 又是怎么找到这些 Mask 并且处理的呢？ 接下来我们从 beforeMutation 开始寻找线索。</p>
<h2>三 beforeMutation 阶段</h2>
<p>在 beforeMutation 阶段会做哪些事情呢？接着 commitRootImpl 中的 commitBeforeMutationEffects 中来看。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberCommitWork.new.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitBeforeMutationEffects</span>(<span class="hljs-params">root, firstChild</span>) </span>{
    <span class="hljs-comment">/* root 为 fiberRoot, firstChild 为 render 阶段调和完毕的 fiber 节点。  */</span>
    nextEffect = firstChild;
    <span class="hljs-comment">/* 开始进入 Before Mutation 流程 */</span>
    commitBeforeMutationEffects_begin();
}
</code></pre>
<p>commitBeforeMutationEffects 为 Before Mutation 阶段的入口函数。</p>
<ul>
<li>nextEffect 为整个 commit 阶段的将要处理的 fiber 节点，类似于 render 阶段的 workInProgress 。</li>
<li>接下来会执行 begin 流程。</li>
</ul>
<blockquote>
<p>react-reconciler/src/ReactFiberCommitWork.new.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitBeforeMutationEffects_begin</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> fiber = nextEffect;
        <span class="hljs-keyword">var</span> child = fiber.child;
        <span class="hljs-keyword">if</span> ((fiber.subtreeFlags &#x26; BeforeMutationMask) !== NoFlags &#x26;&#x26; child !== <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">/* 这里如果子代 fiber 树有 Before Mutation 的标志，那么把 nextEffect 赋值给子代 fiber  */</span>
            nextEffect = child;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">/* 找到最底层有 Before Mutation 的标志的 fiber ，执行 complete */</span>
            commitBeforeMutationEffects_complete();
        }
    }
}
</code></pre>
<p>begin 流程解决了一个重要的问题，就是 commit 阶段执行的生命周期或者 effect 钩子为什么先子后父的。</p>
<p>首先为什么是先子后父的执行呢？</p>
<p>本质上 commit 阶段处理的事情和 dom 元素有关系，commit 阶段生命周期是可以改变真 实 dom 元素的状态的，所以如果在子组件生命周期内改变 dom 状态，并且想要在父组件的生命周期中同步状态，就需要确保父组件的生命周期执行时机要晚于子组件。</p>
<p>回到 begin 流程上来，begin 流程主要做了两件事：</p>
<ul>
<li>如果子代 fiber 树有 Before Mutation 的标志，那么把 nextEffect 赋值给子代 fiber 。这里可以理解成 begin 会向下递归，找到最底部并且有此标志的 fiber 。</li>
<li>找到最底层有 Before Mutation 的标志的 fiber ，执行 complete 。</li>
</ul>
<p>begin 流程本质上有上到下遍历，找到最底层的节点。接下来看一下 complete 流程。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberCommitWork.new.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitBeforeMutationEffects_complete</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> fiber = nextEffect;
        <span class="hljs-keyword">try</span>{
            <span class="hljs-comment">/* 真正的处理 Before Mutation 需要做的事情。 */</span>
            commitBeforeMutationEffectsOnFiber(fiber);
        }
        <span class="hljs-comment">/* 优先处理兄弟节点上的 Before Mutation  */</span>
        <span class="hljs-keyword">var</span> sibling = fiber.sibling;
        <span class="hljs-keyword">if</span> (sibling !== <span class="hljs-literal">null</span>) {
            nextEffect = sibling;
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">/* 如果没有兄弟节点，那么返回父级节点，继续进行如上流程。 */</span>
        nextEffect = fiber.return;
    }
}
</code></pre>
<p>complete 的流程是向上归并的流程，首先会执行 commitBeforeMutationEffectsOnFiber 真正的处理 Before Mutation 需要做的事情。</p>
<p>在向上归并的过程中，会先处理兄弟节点上的 Before Mutation，如果没有兄弟节点，那么返回父级节点，继续进行如上流程。</p>
<p>比如整个 fiber 树的结构如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acac4f0ba7b44a5cad2dc735078b85a1~tplv-k3u1fbpfcp-watermark.image?" alt="2.jpeg"></p>
<p>那么 begin 流程如下所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/968b7193c57148768eceaeb5161548b0~tplv-k3u1fbpfcp-watermark.image?" alt="3.jpeg"></p>
<p>complete 流程如下所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4a94e345134dd0aef1037921c4bfa7~tplv-k3u1fbpfcp-watermark.image?" alt="4.jpeg"></p>
<p>那么最重要的部分来了，就是 commitBeforeMutationEffectsOnFiber 做了什么事情：</p>
<blockquote>
<p>react-reconciler/src/ReactFiberCommitWork.new.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitBeforeMutationEffectsOnFiber</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">if</span> ((flags &#x26; Snapshot) !== NoFlags) { <span class="hljs-comment">/* 如果有 Snapshot 标志 */</span>
        <span class="hljs-keyword">switch</span> (finishedWork.tag) {
            <span class="hljs-keyword">case</span> ClassComponent:
              <span class="hljs-keyword">var</span> snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
              instance.__reactInternalSnapshotBeforeUpdate = snapshot;
        }
    }
}
</code></pre>
<p>commitBeforeMutationEffectsOnFiber 主要是用来处理 Snapshot，获取 DOM 更新前的快照信息，包括类组件执行生命周期 getSnapshotBeforeUpdate 。到此为止，Before Mutation 事情执行完毕。</p>
<h2>四 mutation 阶段</h2>
<p>接下来就到了 mutation 阶段，mutation 阶段切切实实地更新了 DOM 元素，这个阶段对于整个 commit 阶段起着举足轻重的作用，mutation 的入口函数是 commitMutationEffects ，这个函数和 Before Mutation 做的事情差不多。</p>
<p>通过 Before Mutation 一下一上的操作之后，nextEffect 又返回的起点，接下来会和 Before Mutation 的操作一样，进入向下遍历，向上归并的流程，执行所有 mutation 阶段应该做的任务。</p>
<p>那么我们这里对比 Before Mutation ，看看 Mutation 会有哪些不同点。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberCommitWork.new.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitMutationEffects_begin</span>(<span class="hljs-params">root, lanes</span>) </span>{
     <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> deletions = fiber.deletions;
        <span class="hljs-keyword">if</span> (deletions !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; deletions.length; i++) {
                <span class="hljs-keyword">var</span> childToDelete = deletions[i];
                commitDeletion(root, childToDelete, fiber);
            }
        }
     }

     <span class="hljs-comment">/* 这里做的事情和 commitBeforeMutationEffects_begin 一样，找到最底层有 Mutation 的标志的 fiber ，执行 complete*/</span>
}
</code></pre>
<p>Mutation begin 做的事，除了和 BeforeMutation 一样，找到最底层有 Mutation 的标志的 fiber ，执行 complete 外。还有一件事情就是通过调用 commitDeletion 来执行删除元素操作。</p>
<p>在这里简化 commitDeletion 流程，commitDeletion 本质上会调用方法 unmountHostComponents。</p>
<p><strong>如果是销毁，删除真实 DOM 节点</strong>
如果 fiber 类型是 HostComponent （dom元素节点）HostText 文本元素节点。会走如下逻辑：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (node.tag === HostComponent || node.tag === HostText) {
      <span class="hljs-comment">/* 省去一些逻辑，这里调用真实 DOM 操作方法，删除 DOM 元素。 */</span>
      currentParent.removeChild(node.stateNode);
}
</code></pre>
<p>如果是 DOM 元素，那么会调用 removeChild 方法，删除 DOM 元素。</p>
<p>如果其他类型的 fiber ，会调用 commitUnmount 方法。我们看一下 commitUnmount 会做些什么事情。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">switch</span> (current.tag) {
    <span class="hljs-keyword">case</span> FunctionComponent:
    <span class="hljs-keyword">case</span> ForwardRef:
    <span class="hljs-keyword">case</span> MemoComponent:
    <span class="hljs-keyword">case</span> SimpleMemoComponent:
       <span class="hljs-keyword">do</span> {
           <span class="hljs-comment">/* 函数组件执行所有 effect 的， */</span>
            <span class="hljs-keyword">if</span> (destroy !== <span class="hljs-literal">undefined</span>) {
                <span class="hljs-keyword">if</span> ((tag &#x26; Insertion) !== NoFlags$<span class="hljs-number">1</span>) {
                    <span class="hljs-comment">/* 执行 useInsertionEffect 的 destroy */</span>
                  safelyCallDestroy(current, nearestMountedAncestor, destroy);
                }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((tag &#x26; Layout) !== NoFlags$<span class="hljs-number">1</span>){
                   <span class="hljs-comment">/* 执行 useLayoutEffect 的 destroy  */</span> 
                   safelyCallDestroy(current, nearestMountedAncestor, destroy);
                }
            }
           
       }      
}
</code></pre>
<p><strong>如果是销毁，执行 destroy 函数</strong>
对于函数组件，commitUnmount 会执行所有 useInsertionEffect 和 useLayoutEffect 销毁函数 destroy。</p>
<p><strong>如果是销毁，置空 ref</strong></p>
<pre><code class="hljs language-js">  <span class="hljs-keyword">case</span> ClassComponent:
    {
        <span class="hljs-comment">/* 清空 ref  */</span>
        safelyDetachRef(current, nearestMountedAncestor);
        <span class="hljs-keyword">var</span> instance = current.stateNode;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillUnmount === <span class="hljs-string">'function'</span>) {
          <span class="hljs-comment">/* 调用类组件生命周期 componentWillUnmount  */</span>
          safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance);
        }
        <span class="hljs-keyword">return</span>;
    }
</code></pre>
<p>对于类组件，commitUnmount 会清空 ref 对象，如果有生命周期 componentWillUnmount ，会调用该生命周期。</p>
<p>在 Mutation 的 begin 里面会做这么些操作，接下来在 complete 函数里会做同样的事情，优先处理兄弟节点，最后处理父节点，然后分别调用 commitMutationEffectsOnFiber。那么这个函数又做了哪些事情呢？</p>
<p>commitMutationEffectsOnFiber 做的事情比较重要，这里重点分了几个部分：</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitMutationEffectsOnFiber</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-comment">/* 如果是文本节点，那么重置节点内容 */</span>  
  <span class="hljs-keyword">if</span> (flags &#x26; ContentReset) {
    commitResetTextContent(finishedWork);
  }
  <span class="hljs-comment">/* 如果是 ref 更新，那么重置 alternate 属性上的 ref */</span>
  <span class="hljs-keyword">if</span> (flags &#x26; Ref) {
    <span class="hljs-keyword">var</span> current = finishedWork.alternate;
    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
      commitDetachRef(current);
    }
  }
  <span class="hljs-keyword">if</span>(flags &#x26; Visibility){
      <span class="hljs-comment">/* 这一块和 v18 新属性有关，下面会介绍 */</span>
  }

  <span class="hljs-keyword">var</span> primaryFlags = flags &#x26; (Placement | Update );
  <span class="hljs-keyword">switch</span> (primaryFlags) {
    <span class="hljs-comment">/* 如果新插入节点 */</span>
    <span class="hljs-keyword">case</span> Placement:
      { 
        commitPlacement(finishedWork); 

        finishedWork.flags &#x26;= ~Placement;
        <span class="hljs-keyword">break</span>;
      }
    <span class="hljs-comment">/* ... 省去其他的相关逻辑 */</span>  
    <span class="hljs-comment">/* 对于更新会有 Update */</span>
    <span class="hljs-keyword">case</span> Update:
      {
        <span class="hljs-keyword">var</span> _current5 = finishedWork.alternate;
        commitWork(_current5, finishedWork);
        <span class="hljs-keyword">break</span>;
      }  
}
</code></pre>
<p>commitMutationEffectsOnFiber 阶段主要做的事情很多，这里列举了几个非常重要的节点，对于 ContentReset ，执行 commitResetTextContent 置空文本节点的内容。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// node 为 stateNode 属性，为 fiber 元素的真实节点。</span>
<span class="hljs-keyword">var</span> firstChild = node.firstChild;

<span class="hljs-keyword">if</span> (firstChild &#x26;&#x26; firstChild === node.lastChild &#x26;&#x26; firstChild.nodeType === TEXT_NODE) {
    firstChild.nodeValue = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">return</span>;
}
</code></pre>
<p><strong>置空文本节点和 ref 属性</strong>
对于文本节点，会先做准备工作，会置空文本节点的内容。对于 ref 属性，也会调用 commitDetachRef，做更新前的重置 ref。commitDetachRef 在 ref 章节，已经讲解了，这里就不赘述了。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
    commitDetachRef(current);
}
</code></pre>
<p>那么如果是插入新的 fiber 节点，会调用 commitPlacement 。commitPlacement 做了些什么事情呢？</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitPlacement</span>(<span class="hljs-params">finishedWork</span>)</span>{
    <span class="hljs-comment">/* 获取父级 fiber */</span>
    <span class="hljs-keyword">var</span> parentFiber = getHostParentFiber(finishedWork);
    <span class="hljs-keyword">switch</span> (parentFiber.tag) {
        <span class="hljs-comment">/* 如果节点类型是元素类型，比如 div */</span>
        <span class="hljs-keyword">case</span> HostComponent:
           <span class="hljs-comment">/* 获取下一个兄弟节点 */</span>
           <span class="hljs-keyword">var</span> before = getHostSibling(finishedWork); 
           <span class="hljs-comment">/* 执行 insertOrAppendPlacementNode，插入节点。 */</span>
           insertOrAppendPlacementNode(finishedWork, before, parent);
    }
}
</code></pre>
<p>可以看出 commitPlacement 主要找到当前元素的父级和兄弟 fiber，然后执行 insertOrAppendPlacementNode
，这个方法做了如下事情。</p>
<p><strong>插入元素节</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (before) {
    insertBefore(parent, stateNode, before);
} <span class="hljs-keyword">else</span> {
    appendChild(parent, stateNode);
}
</code></pre>
<p>如果有兄弟节点，那么在调用 insertBefore 往兄弟节点之前插入就可以了。如果没有之后的兄弟节点，说明需要插入最后一个子节点，那么调用 appendChild 插入节点就可以了。最后对于更新节点，调用 commitWork 就可以了。</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitWork</span>(<span class="hljs-params">current, finishedWork</span>) </span>{
    <span class="hljs-keyword">switch</span> (finishedWork.tag) {
        <span class="hljs-keyword">case</span> FunctionComponent:
        <span class="hljs-keyword">case</span> ForwardRef:
        <span class="hljs-keyword">case</span> MemoComponent:
        <span class="hljs-keyword">case</span> SimpleMemoComponent:
            <span class="hljs-comment">/* 先执行上一次 useInsertionEffect 的 destroy */</span>
            commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
            <span class="hljs-comment">/* 执行 useInsertionEffect 的 create  */</span>
            commitHookEffectListMount(Insertion | HasEffect, finishedWork);
        <span class="hljs-keyword">case</span> HostComponent:
            <span class="hljs-comment">/* 元素节点会执行 commitUpdate */</span>
            <span class="hljs-keyword">if</span> (updatePayload !== <span class="hljs-literal">null</span>) {
                commitUpdate(instance, updatePayload, type, oldProps, newProps);
            }    
        <span class="hljs-keyword">case</span> HostText: 
            <span class="hljs-comment">/* 文本节点更新 */</span>
            commitTextUpdate(textInstance, oldText, newText);
            <span class="hljs-keyword">return</span>
    }
}
</code></pre>
<p><strong>执行 hooks useInsertionEffect</strong>
可以看到 commitWork 对于函数组件会执行 hooks useInsertionEffect，也就证实了 useInsertionEffect 是在 Mutation 阶段执行的。</p>
<p>在 effect 的执行特点上，所有的 effect hooks，会先执行上一个次 destroy 函数，然后再调用本次的 create 函数，这就比如在 effect 里面绑定事件监听器，如果绑定新的监听器，需要先解绑老的监听器。</p>
<p><strong>更新文本节点</strong>
上面说到了文本节点已经重置，接下来会调用 commitTextUpdate 来更新文本节点的 nodeValue 属性。</p>
<p><strong>更新元素节点</strong>
对于元素的更新，本质上调用 commitUpdate ，在 commitUpdate 会更新元素的属性，比如 style 等内容。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (propKey === STYLE) {
    <span class="hljs-comment">/* 更新 style 信息。 */</span>
      setValueForStyles(domElement, propValue);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) {
    <span class="hljs-comment">/* 更新 innerHTML 。 */</span>
      setInnerHTML(domElement, propValue);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === CHILDREN) {
    <span class="hljs-comment">/* 更新 nodeValue 属性 */</span>  
      setTextContent(domElement, propValue);
    } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* 更新元素的 props  */</span>    
      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
}
</code></pre>
<p>commitUpdate 主要负责更新元素的状态，到此为止，Mutation 阶段执行完毕。</p>
<h2>五 layout 阶段</h2>
<p>接下来到了 layout 阶段，Mutation 阶段做了些真实的 DOM 操作，比如元素删除，元素更新，元素添加等操作，那么 layout 阶段，已经能够获取更新之后的 DOM 元素。</p>
<p>在执行完 commitMutationEffects 之后，会执行 commitLayoutEffects ，这个方法做的事情和 Mutation 阶段一样。接下来也会走 begin 和 complete 流程。</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitLayoutEffects_begin</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> ( fiber.tag === OffscreenComponent &#x26;&#x26; isModernRoot) {
            <span class="hljs-comment">/* 对于 OffscreenComponent 逻辑 */</span>
        }
    }
}
</code></pre>
<p>Layout 的 begin 流程和 Mutation 差不多，重点就是 Offscreen 处理逻辑，在接下来章节会讲到。Layout 阶段 complete 也没有特殊处理。</p>
<p>重点就是 Layout 阶段的 commitLayoutEffectOnFiber 函数。这个函数非常重要，主要看一下 commitLayoutEffectOnFiber 做了哪些事情？</p>
<blockquote>
<p>react-reconciler/src/ReactFiberCommitWork.new.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitLayoutEffectOnFiber</span>(<span class="hljs-params">finishedRoot, current, finishedWork, committedLanes</span>) </span>{
    <span class="hljs-keyword">if</span> ((finishedWork.flags &#x26; LayoutMask) !== NoFlags) {
        <span class="hljs-keyword">switch</span> (finishedWork.tag) {
            <span class="hljs-comment">/* 对于函数组件，执行  useLayoutEffect */</span>
            <span class="hljs-keyword">case</span> FunctionComponent:
            <span class="hljs-keyword">case</span> ForwardRef:
            <span class="hljs-keyword">case</span> SimpleMemoComponent:
                commitHookEffectListMount(Layout | HasEffect, finishedWork);
            <span class="hljs-comment">/* 对于类组件，如果初始化会执行 d，如果更新会执行 componentDidUpdate  */</span>    
            <span class="hljs-keyword">case</span> ClassComponent:
                <span class="hljs-keyword">var</span> instance = finishedWork.stateNode;
                <span class="hljs-keyword">if</span> (finishedWork.flags &#x26; Update) {
                    <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
                        <span class="hljs-comment">/* 执行 componentDidMount 生命周期 */</span>
                        instance.componentDidMount();
                    }<span class="hljs-keyword">else</span>{
                        <span class="hljs-comment">/* 执行 componentDidUpdate 生命周期 */</span>
                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                    }
                }
                <span class="hljs-keyword">var</span> updateQueue = finishedWork.updateQueue;
                <span class="hljs-comment">/* 如果有 setState 的 callback ，执行回调函数。 */</span>
                <span class="hljs-keyword">if</span> (updateQueue !== <span class="hljs-literal">null</span>) {
                    commitUpdateQueue(finishedWork, updateQueue, instance);
                }                   
    }
    <span class="hljs-keyword">if</span> (finishedWork.flags &#x26; Ref) {
        <span class="hljs-comment">/* 更新 ref 属性 */</span>
        commitAttachRef(finishedWork);
    }
}
</code></pre>
<p>commitLayoutEffectOnFiber 做了非常重要的事：</p>
<ul>
<li>首先对于函数组件，执行 useLayoutEffect。</li>
<li>对于类组件，如果初始化会执行 componentDidMount，如果更新会执行 componentDidUpdate。如果类组件触发 setState 并且有第二个参数 callback，那么这些 callback 会被放进 updateQueue 中，那么接下来会通过 commitUpdateQueue 执行每个 callback 回调函数。</li>
<li>接下来会更新 ref 属性。</li>
</ul>
<p>整个 Layout 阶段就结束了，Layout 阶段主要是执行回调函数，比如 setState 的 callback 和生命周期等，还有比如 useLayoutEffect 的钩子就是在这里执行 。</p>
<h2>六 useEffect 执行</h2>
<p>细心的同学可以看到 useEffect 的还没处理，对于 useEffect 处理，主要在 commitRootImpl 开始的时候通过 flushPassiveEffects 来执行了，但是细心的同学可以发现，flushPassiveEffects 是在 scheduleCallback 中执行的。</p>
<p>scheduleCallback 是采用异步模式下进行的，所以 useEffect 的钩子函数是在异步条件下执行的。</p>
<p>flushPassiveEffects 本质上会调用  flushPassiveEffectsImpl 。 flushPassiveEffectsImpl 内部会执行 commitPassiveMountEffects 。</p>
<p>commitPassiveMountEffects 会通过 begin ，complete 来从上到下找到最底部 fiber ，然后再从下到上执行 fiber 树上的所有的 effect，最后再执行 commitPassiveMountOnFiber。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberCommitWork.new.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitPassiveMountOnFiber</span>(<span class="hljs-params">finishedRoot, finishedWork</span>) </span>{
    <span class="hljs-keyword">switch</span> (finishedWork.tag) {
        <span class="hljs-keyword">case</span> FunctionComponent:
        <span class="hljs-keyword">case</span> ForwardRef:
        <span class="hljs-keyword">case</span> SimpleMemoComponent:
           commitHookEffectListMount(Passive$<span class="hljs-number">1</span> | HasEffect, finishedWork);
    }    
}
</code></pre>
<ul>
<li>commitPassiveMountOnFiber 如果是函数组件，会通过 commitHookEffectListMount 执行所有的 useEffect 钩子函数。</li>
</ul>
<p>那么最后看一下 commitHookEffectListMount 做了哪些事情：</p>
<blockquote>
<p>react-reconciler/src/ReactFiberCommitWork.new.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitHookEffectListMount</span>(<span class="hljs-params">flags, finishedWork</span>) </span>{
    <span class="hljs-keyword">var</span> updateQueue = finishedWork.updateQueue;
    <span class="hljs-keyword">var</span> lastEffect = updateQueue !== <span class="hljs-literal">null</span> ? updateQueue.lastEffect : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (lastEffect !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> firstEffect = lastEffect.next;
        <span class="hljs-keyword">var</span> effect = firstEffect;
        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">if</span> ((effect.tag &#x26; flags) === flags) {
                <span class="hljs-keyword">var</span> create = effect.create;
                <span class="hljs-comment">/* 执行 effect hooks 钩子函数，得到 destroy 函数 */</span>
                effect.destroy = create();
            }
        }
    }
}
</code></pre>
<p>用一幅流程图表示 commit 阶段的流程：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64730a0580d94316894849339eb2c60f~tplv-k3u1fbpfcp-watermark.image?" alt="6.jpeg"></p>
<h2>七 总结</h2>
<p>本章节主要介绍 commit 阶段的细节。还有就是 before Mutation ，Mutation ，Layout 阶段做了哪些事情。</p></div>
</body></html>