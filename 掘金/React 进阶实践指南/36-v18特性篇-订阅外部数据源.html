<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>v18特性篇-订阅外部数据源</h1>
<h2>一前言</h2>
<p>在第 31 章节中，讲到了外部数据源，还介绍了外部数据源的处理方式 —— <strong>useMutableSource</strong> 。在前不久更新的最新 React 18 中，用 useSyncExternalStore 代替了 useMutableSource 。具体内容可以参考 <a href="https://github.com/reactwg/react-18/discussions/86" target="_blank" rel="nofollow noopener noreferrer">useMutableSource → useSyncExternalStore</a> 。</p>
<p>言归正传，在之前的章节说到在 concurrent 模式下，render 可能会被执行多次，那么在读取外部数据源的会存在一个问题，比如一个 render 过程中读取了外部数据源状态 1 ，那么中途遇到更高优先级的任务，而中断了此次更新，就在此时改变了外部数据源，然后又恢复了此次更新，那么接下来又读取了数据源，由于中途发生了改变，所以这次读取的是外部数据源状态 2 ，那么一次更新中出现了这种表现不一致的情况。这个问题叫做 tearing 。</p>
<h2>二 useSyncExternalStore 介绍</h2>
<p>那么 useSyncExternalStore 的诞生并非偶然，和 v18 的更新模式下外部数据的 tearing 有着十分紧密的关联。</p>
<p>useSyncExternalStore 出现解决了这个问题，我们从 v18 发布的 tag 中，找到这样的描述：</p>
<blockquote>
<p>useSyncExternalStore is a new hook that allows external stores to support concurrent reads by forcing updates to the store to be synchronous. It removes the need for useEffect when implementing subscriptions to external data sources, and is recommended for any library that integrates with state external to React.</p>
</blockquote>
<p>useSyncExternalStore 能够让 React 组件在 concurrent  模式下安全地有效地读取外接数据源，在组件渲染过程中能够检测到变化，并且在数据源发生变化的时候，能够调度更新。当读取到外部状态发生了变化，会触发一个强制更新，来保证结果的一致性。</p>
<p>现在用 useSyncExternalStore 不在需要把订阅到更新流程交给组件处理。如下：</p>
<pre><code class="hljs language-js">)
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>{
     <span class="hljs-keyword">const</span> state = useSyncExternalStore(store.subscribe,store.getSnapshot)
     <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>如上是通过 useSyncExternalStore 实现的订阅更新，这样减少了 APP 内部组件代码，代码健壮性提升，一定程度上也降低了耦合，最重要的它解决了并发模式状态读取问题。但是这里强调的一点是， 正常的 React 开发者在开发过程中不需要使用这个 api ，这个 hooks 主要是对于 React 的一些状态管理库，比如 redux ，通过它的帮助可以合理管理外部的 store，保证数据读取的一致。</p>
<p>接下来看一下 useSyncExternalStore 使用：</p>
<pre><code class="hljs language-js">useSyncExternalStore(
    subscribe,
    getSnapshot,
    getServerSnapshot
)
</code></pre>
<ul>
<li>
<p>subscribe 为订阅函数，当数据改变的时候，会触发 subscribe，在 useSyncExternalStore 会通过带有记忆性的 getSnapshot 来判别数据是否发生变化，如果发生变化，那么会强制更新数据。</p>
</li>
<li>
<p>getSnapshot 可以理解成一个带有记忆功能的选择器。当 store 变化的时候，会通过 getSnapshot 生成新的状态值，这个状态值可提供给组件作为数据源使用，getSnapshot 可以检查订阅的值是否改变，改变的话那么会触发更新。</p>
</li>
<li>
<p>getServerSnapshot 用于 hydration 模式下的 getSnapshot。</p>
</li>
</ul>
<h2>三 useSyncExternalStore 基本使用</h2>
<p>接下来我们用 useSyncExternalStore 配合 redux ，来简单实现订阅外部数据源功能。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { combineReducers , createStore  } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>

<span class="hljs-comment">/* number Reducer */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numberReducer</span>(<span class="hljs-params">state=<span class="hljs-number">1</span>,action</span>)</span>{
    <span class="hljs-keyword">switch</span> (action.type){
      <span class="hljs-keyword">case</span> <span class="hljs-string">'ADD'</span>:
        <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>
      <span class="hljs-keyword">case</span> <span class="hljs-string">'DEL'</span>:
        <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span>
      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> state
    }
}

<span class="hljs-comment">/* 注册reducer */</span>
<span class="hljs-keyword">const</span> rootReducer = combineReducers({ <span class="hljs-attr">number</span>:numberReducer  })
<span class="hljs-comment">/* 创建 store */</span>
<span class="hljs-keyword">const</span> store = createStore(rootReducer,{ <span class="hljs-attr">number</span>:<span class="hljs-number">1</span>  })

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">/* 订阅外部数据源 */</span>
    <span class="hljs-keyword">const</span> state = useSyncExternalStore(store.subscribe,<span class="hljs-function">() =></span> store.getState().number)
    <span class="hljs-built_in">console</span>.log(state)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        {state}
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> store.dispatch({ type:'ADD' })} >点击<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<ul>
<li>点击按钮，会触发 reducer ，然后会触发 store.subscribe 订阅函数，执行 getSnapshot 得到新的 number ，判断 number 是否发生变化，如果变化，触发更新。</li>
</ul>
<p>有了 useSyncExternalStore 这个 hooks ，可以通过外部数据到内部数据的映射，当数据变化的时候，可以通知订阅函数 subscribe 去触发更新。</p>
<h2>四 useSyncExternalStore 原理</h2>
<p>接下来看一下 useSyncExternalStore 内部是如何实现的。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberHooks.new.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountSyncExternalStore</span>(<span class="hljs-params">subscribe,getSnapshot</span>)</span>{
    <span class="hljs-comment">/*  创建一个 hooks  */</span>
    <span class="hljs-keyword">const</span> hook = mountWorkInProgressHook();
    <span class="hljs-comment">/* 产生快照 */</span>
    <span class="hljs-keyword">let</span> nextSnapshot = getSnapshot(); 

    <span class="hljs-comment">/* 把快照记录下来 */</span>
    hook.memoizedState = nextSnapshot;
    <span class="hljs-comment">/* 快照记录在 inst 属性上 */</span>
    <span class="hljs-keyword">const</span> inst  = {
        <span class="hljs-attr">value</span>: nextSnapshot,
        getSnapshot,
    };
    hook.queue = inst;
    
    <span class="hljs-comment">/* 用一个 effect 来订阅状态 ，subscribeToStore 发起订阅 */</span>
    mountEffect(subscribeToStore.bind(<span class="hljs-literal">null</span>, fiber, inst, subscribe), [subscribe]);
    
    <span class="hljs-comment">/* 用一个 useEffect 来监听组件 render ，只要组件渲染就会调用 updateStoreInstance  */</span>
    pushEffect(
        HookHasEffect | HookPassive,
        updateStoreInstance.bind(<span class="hljs-literal">null</span>, fiber, inst, nextSnapshot, getSnapshot),
        <span class="hljs-literal">undefined</span>,
        <span class="hljs-literal">null</span>,
    );
    <span class="hljs-keyword">return</span> nextSnapshot;
}
</code></pre>
<p>mountSyncExternalStore 大致流程是这样的：</p>
<ul>
<li>第一步：创建一个 hooks 。我们都知道 hooks 更新是分两个阶段的，在初始化 hooks 阶段会创建一个 hooks ，在更新阶段会更新这个 Hook。</li>
<li>第二步：调用 getSnapshot 产生一个状态值，并保存起来。</li>
<li>第三步：用一个 effect 来订阅状态 <code>subscribeToStore</code> 发起订阅 。</li>
<li>第四步：用一个 useEffect 来监听组件 render ，只要组件渲染就会调用 <code>updateStoreInstance</code> 。这一步是关键所在，在 concurrent 模式下渲染会中断，那么如果中断恢复 render ，那么这个 effect 就解决了这个问题。当 render 就会触发 updateStoreInstance 。</li>
</ul>
<p>接下来看一下 subscribeToStore 和 updateStoreInstance 的实现。</p>
<p><strong>subscribeToStore</strong></p>
<blockquote>
<p>react-reconciler/src/subscribeToStore.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkIfSnapshotChanged</span>(<span class="hljs-params">inst</span>) </span>{
  <span class="hljs-keyword">const</span> latestGetSnapshot = inst.getSnapshot;
  <span class="hljs-comment">/* 取出上一次的快照信息 */</span>
  <span class="hljs-keyword">const</span> prevValue = inst.value;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">/* 最新的快照信息 */</span>
    <span class="hljs-keyword">const</span> nextValue = latestGetSnapshot();
    <span class="hljs-comment">/* 返回是否相等 */</span>
    <span class="hljs-keyword">return</span> !is(prevValue, nextValue);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}
<span class="hljs-comment">/* 直接发起调度更新  */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forceStoreRerender</span>(<span class="hljs-params">fiber</span>) </span>{
  scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subscribeToStore</span>(<span class="hljs-params">fiber, inst, subscribe</span>) </span>{
  <span class="hljs-keyword">const</span> handleStoreChange = <span class="hljs-function">() =></span> {
    <span class="hljs-comment">/* 检查 state 是否发生变化 */</span>
    <span class="hljs-keyword">if</span> (checkIfSnapshotChanged(inst)) {
       <span class="hljs-comment">/* 触发更新 */</span> 
      forceStoreRerender(fiber);
    }
  };
   <span class="hljs-comment">/* 发起订阅 */</span>
  <span class="hljs-keyword">return</span> subscribe(handleStoreChange);
}
</code></pre>
<p>subscribeToStore 的流程如下：</p>
<ul>
<li>通过 subscribe 订阅 handleStoreChange，当 state 改变会触发 handleStoreChange ，里面判断两次快照是否相等，如果不想等那么触发更新。</li>
</ul>
<p><strong>updateStoreInstance</strong></p>
<blockquote>
<p>react-reconciler/src/updateStoreInstance.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateStoreInstance</span>(<span class="hljs-params">fiber,inst,nextSnapshot,getSnapshot</span>) </span>{
  inst.value = nextSnapshot;
  inst.getSnapshot = getSnapshot;
  <span class="hljs-comment">/* 检查是否更新 */</span>
  <span class="hljs-keyword">if</span> (checkIfSnapshotChanged(inst)) {
    <span class="hljs-comment">/* 强制更新 */</span>
    forceStoreRerender(fiber);
  }
}
</code></pre>
<ul>
<li>updateStoreInstance 很简单就是判断 state 是否发生变化，变化就更新。</li>
</ul>
<p>通过如上原理分析，我们知道了 useSyncExternalStore 是如何防止 tearing 的了。为了让大家更清楚其流程 ，接下来我们来模拟一个  useSyncExternalStore 的实现。</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useMockSyncExternalStore</span>(<span class="hljs-params">subscribe,getSnapshot</span>)</span>{
  <span class="hljs-keyword">const</span> [ , forceupdate ] = React.useState(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">const</span> inst = React.useRef(<span class="hljs-literal">null</span>)

  <span class="hljs-keyword">const</span> nextValue = getSnapshot()

  inst.current = {
     <span class="hljs-attr">value</span>:nextValue,
     getSnapshot
  }
  <span class="hljs-comment">/* 检测是否更新 */</span>
  <span class="hljs-keyword">const</span> checkIfSnapshotChanged = <span class="hljs-function">() =></span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">/* 最新的快照信息 */</span>
      <span class="hljs-keyword">const</span> nextValue = inst.current.getSnapshot();
      <span class="hljs-comment">/* 返回是否相等 */</span>
      <span class="hljs-keyword">return</span> !inst.value === nextValue
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-comment">/* 处理 store 改变 */</span>
  <span class="hljs-keyword">const</span> handleStoreChange=<span class="hljs-function">()=></span>{
    <span class="hljs-keyword">if</span> (checkIfSnapshotChanged(inst)) {
      <span class="hljs-comment">/* 触发更新 */</span>
      forceupdate({})
   }
  }
  React.useEffect(<span class="hljs-function">()=></span>{
    subscribe(handleStoreChange)
  },[ subscribe ])

  <span class="hljs-comment">/* 注意这个 useEffect 没有依赖项 ，每次更新都会执行该 effect */</span>
  React.useEffect(<span class="hljs-function">()=></span>{
      handleStoreChange()
  })

  <span class="hljs-keyword">return</span> nextValue
}
</code></pre>
<p>如上就是 useSyncExternalStore 的模拟实现。</p>
<h2>五 总结</h2>
<p>本章节介绍了引入外部数据源的 hooks useSyncExternalStore，以及它的介绍，使用，以及原理。</p></div>
</body></html>