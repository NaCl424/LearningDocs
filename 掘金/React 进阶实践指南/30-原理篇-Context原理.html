<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>原理篇-Context原理</h1>
<p>接下来将介绍 <code>context</code> 原理。重点流程放在 context 的<strong>传递</strong>和<strong>更新</strong>两个方面。对于原理部分，我在这里只介绍了新版本 Context 的原理。感兴趣的同学可以看一下源码。</p>
<p>以 <code>React 16.8</code> 为例子🌰：</p>
<ul>
<li>新版本 Context 位置：<code>react-reconciler/src/ReactFiberNewContext.js</code></li>
<li>老版本 Context 位置：<code>react-reconciler/src/ReactFiberContext.js</code></li>
</ul>
<p>希望大家带着这些问题去阅读</p>
<ul>
<li>1 Provder 如何传递 context？</li>
<li>2 三种获取 context 原理 （ <code>Consumer</code>， <code>useContext</code>，<code>contextType</code> ）？</li>
<li>3 消费 <code>context</code> 的组件，context 改变，为什么会订阅更新 （如何实现） 。</li>
<li>4 context 更新，如何避免 <code>pureComponent</code> ， <code>shouldComponentUpdate</code> 渲染控制策略的影响。</li>
<li>5 如何实现的 context 嵌套传递 （ 多个 Povider ）?</li>
</ul>
<h3>1 context 对象</h3>
<p>上述所说的老版本 context 就是 Legacy Context 模式下的 context ，老版本的 context 是采用约定式的使用规则，于是有了 <code>getChildContext</code> 和 <code>childContextTypes</code> 协商的属性和方法，这种方式不仅不够灵活，而且对于函数组件也存在局限性，所以在 <code>v16.3</code> 推出了新版本的 <code>context</code>，开发者能够更加灵活的运用 Context。新版本引入 context 对象的概念，而且 context 对象上除了保留了传递的信息 <code>value</code> 外 ， 还有提供者 <code>Provder</code> 和消费者 <code>Consumer</code>。</p>
<h4>context 对象</h4>
<p>要想吃透 context ，首先要研究一下 Context 对象是什么。上述讲到可以通过 <code>createContext</code> 创建一个 context 。那么万物之源就是这个 API ，接下来一起揭开 context 对象面纱。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createContext</span>(<span class="hljs-params">defaultValue,calculateChangedBits</span>)</span>{
   <span class="hljs-comment">/* context 对象本质  */</span> 
  <span class="hljs-keyword">const</span> context  = {
        <span class="hljs-attr">$$typeof</span>: REACT_CONTEXT_TYPE, <span class="hljs-comment">/* 本质上就是 Consumer element 类型 */</span>
        <span class="hljs-attr">_calculateChangedBits</span>: calculateChangedBits,
        <span class="hljs-attr">_currentValue</span>: defaultValue,
        <span class="hljs-attr">_threadCount</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">Provider</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">Consumer</span>: <span class="hljs-literal">null</span>,
  };
  <span class="hljs-comment">/* 本质上就是 Provider element 类型。  */</span>
  context.Provider = {
    <span class="hljs-attr">$$typeof</span>: REACT_PROVIDER_TYPE,
    <span class="hljs-attr">_context</span>: context,
  };
  context.Consumer = context 
}
</code></pre>
<p>如上可以很容易的看清楚 context 对象的本质，这里重点介绍三个属性</p>
<ul>
<li><strong><code>Provider</code></strong> 本质上是一个 element 对象 $$typeof -> <code>REACT_PROVIDER_TYPE</code></li>
<li><strong><code>Consumer</code></strong> 本质上也是一个 element 对象 $$typeof -> <code>REACT_CONTEXT_TYPE</code></li>
<li><strong><code>_currentValue</code></strong> 这个用来保存传递给  Provider 的 value 。</li>
</ul>
<h4>Provider 提供者</h4>
<p>上述明白了 Provider 本质上是一个特殊的 React Element 对象，那么接下来重点看一下 Provider 的实现原理，研究 Provider 重点围绕这两个点。</p>
<ul>
<li>Provider 如何传递 context 状态的。</li>
<li>Provider 中 value 改变，如何通知订阅 context。</li>
</ul>
<p>之前的章节讲述了 <strong>jsx -> element -> fiber</strong> 的流程，按照这个逻辑，接下来看一下 Provdier 的处理。</p>
<ul>
<li>首先标签形式的 <code>&#x3C;Provider></code> 本质上就是 <code>REACT_PROVIDER_TYPE</code> 的 React Element 。<code>&#x3C;Provider></code> -> <code>REACT_PROVIDER_TYPE</code> React element 。</li>
<li>接下来 element 会转化成 fiber ，fiber 类型为 <strong>ContextProvider</strong> ， React element ->  <code>ContextProvide fiber</code>。</li>
</ul>
<p>ContextProvider 类型的 fiber ，在 fiber 调和阶段会进入到 <code>beginWork</code> 流程，这个阶段会发生两件事。</p>
<ul>
<li>如果当前类型的 fiber 不需要更新，那么会 <code>FinishedWork</code> 中止当前节点和子节点的更新。</li>
<li>如果当前类型 fiber 需要更新，那么会调用不同类型 fiber 的处理方法。当然 <code>ContextProvider</code> 也有特有的 fiber 更新方法 —— <code>updateContextProvider</code>，那么如果想要深入 <code>Provder</code> 的奥秘，有必要看一下这个方法做了些什么？</li>
</ul>
<blockquote>
<p>react-reconciler/src/ReactFiberBeginWork.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateContextProvider</span>(<span class="hljs-params">current ,workInProgress,renderExpirationTime,</span>) </span>{
  <span class="hljs-comment">/*  获取 Provder 上的 value  */</span>
  pushProvider(workInProgress, newProps.value;);
  <span class="hljs-comment">/* 更新 context  */</span>
  <span class="hljs-keyword">if</span> (oldProps !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> changedBits = calculateChangedBits(context, newProps.value;, oldProps.value);
    <span class="hljs-keyword">if</span> (changedBits === <span class="hljs-number">0</span>) {
      <span class="hljs-comment">//context 没有变化。如果孩子们都是一样的话。那么不需要更新</span>
      <span class="hljs-keyword">if</span> (
        oldProps.children === newProps.children &#x26;&#x26;
        !hasLegacyContextChanged() 
      ) {
         <span class="hljs-keyword">return</span> ...  <span class="hljs-comment">// 停止调合子节点,收尾工作</span>
      }
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* context 改变，更新 context */</span>
      propagateContextChange( workInProgress,context, changedBits, renderExpirationTime,);
    }
  }
  <span class="hljs-comment">/* 继续向下调和子代 fiber  */</span>
  ...
}
</code></pre>
<p>如上保留了 <code>updateContextProvider</code> 的核心流程如下：</p>
<ul>
<li>
<p>第一步： 首先会调用 <code>pushProvider</code>，<code>pushProvider</code> 会获取 type 属性上的 _context 对象，就是上述通过 <code>createContext</code> 创建的 context 对象。然后将 Provider 的 value 属性，赋值给 context 的 _currentValue 属性上。<strong>这里解释了 Provder 通过什么手段传递 context value，即通过挂载 context 的 _currentValue 属性。</strong></p>
</li>
<li>
<p>第二步： 通过 <code>calculateChangedBits</code> 计算出 changedBits ，<code>calculateChangedBits</code> 内部触发 context 对象上的 <code>_calculateChangedBits</code> ，细心的同学可以发现，在调用 <code>createContext</code> 的时候，实际上是有第二个参数的 <code>calculateChangedBits</code>，在更新 Provider 的时候这个参数就派上用场了，当它返回的 <code>changedBits === 0</code> 的时候，那么还会浅比较 children 是否发生变化，还有就是有没有 <code>legacy context</code>，如果这三点都满足的话，那么会判断当前 Provider 和子节点不需要更新，那么会 return 停止向下调和子节点。</p>
</li>
<li>
<p>第三步（<strong>重点</strong>）：在实际开发中，绝大多数当 value 发生变化，会走 <code>propagateContextChange</code> 这个流程，也是 Provider 更新的特点。那么这个方法到底做了些什么呢？接下来重点看一下这个函数做了些什么？</p>
</li>
</ul>
<p><strong>propagateContextChange</strong> 函数流程很繁琐，这里简化了流程，保留了最核心的部分。</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">propagateContextChange</span>(<span class="hljs-params">workInProgress,context</span>)</span>{
    <span class="hljs-keyword">let</span> fiber = workInProgress.child;
    <span class="hljs-keyword">if</span> (fiber !== <span class="hljs-literal">null</span>) {
        fiber.return = workInProgress;
    }
    <span class="hljs-keyword">while</span>(fiber !== <span class="hljs-literal">null</span>){
        <span class="hljs-keyword">const</span> list = fiber.dependencies;
         <span class="hljs-keyword">while</span> (dependency !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">if</span> (dependency.context === context){
                   <span class="hljs-comment">/* 类组件：不受 PureComponent 和 shouldComponentUpdate 影响 */</span>
                   <span class="hljs-keyword">if</span> (fiber.tag === ClassComponent) {
                         <span class="hljs-comment">/* 会走 forceUpdate 逻辑 */</span>
                        <span class="hljs-keyword">const</span> update = createUpdate(renderExpirationTime, <span class="hljs-literal">null</span>);
                        update.tag = ForceUpdate;
                        enqueueUpdate(fiber, update);
                   }
                   <span class="hljs-comment">/* 重要：<span class="hljs-doctag">TODO:</span> 提高 fiber 的优先级，让当前 fiber 可以 beginWork ，并且向上更新父级 fiber 链上的优先级 */</span>
                   ...
              } 
         }
    }
}
</code></pre>
<p><code>propagateContextChange</code> 非常重要，它的职责就是深度遍历所有的子代 fiber ，然后找到里面具有 <code>dependencies</code> 的属性，对比 dependencies 中的 context 和当前 Provider 的 context 是否是同一个，如果是同一个，那么如果当前 fiber 是类组件，那么会给绑定一个 forceUpdate 标识 。然后会提高  fiber 的更新优先级，让 fiber 在接下来的调和过程中，处于一个高优先级待更新的状态。接下来的代码比较长，我这里没有全部罗列出来，大致逻辑就是，找到当前 fiber 向上的父级链上的 fiber ，统一更新他们的优先级，使之变成高优先级待更新状态。</p>
<p>那么上述流程中暴露出几个问题：</p>
<ul>
<li>
<p>1 什么情况下 fiber 会存在 dependencies ，首先 dependencies 在第十七章中会讲到，它保存的是 context 的依赖项，那么什么情况下会存在 <strong>context 依赖项</strong>。</p>
</li>
<li>
<p>2 为什么对于 class 类组件会创建一个 ForceUpdate 类型的 update 对象呢？ <br> 知其然，知其所以然，首先看一下它是什么？</p>
</li>
</ul>
<p><strong>｜--------问与答--------｜</strong><br></p>
<p>问： <strong>ForceUpdate 类型 update</strong>： 什么是 forceUpdate 类型的 update 呢？</p>
<p>答：在类组件中，通过调用 <code>this.forceUpdate()</code> 带来的更新就会被打上 ForceUpdate 类型的 update tag，这里可以理解为强制更新。 生命周期章节讲过， 在类组件更新流程中，强制更新会跳过 <code>PureComponent</code> 和 <code>shouldComponentUpdate</code> 等优化策略。
<strong>｜---------end---------｜</strong></p>
<ul>
<li>3 存在 dependency 的 fiber ，为什么要向上更新父级 fiber 链上的优先级，让所有父级 fiber 都处于一个高优先级。</li>
</ul>
<p>对于上面这三个问题，跟上我的思路逐一突破。</p>
<p><strong>第一个问题：</strong>
首先就是 dependencies 属性，这个属性可以把当前的 fiber 和 context 建立起关联，那么可以理解成，使用了当前 context 的 fiber 会把 context 放在 dependencies 中，dependencies 属性本身是一个链表结构，一个 fiber 可以有多个 context 与之对应。反过来推测一下，什么情况下会使用 context 呢。那么有以下几种可能：</p>
<p>1 有 <code>contextType</code> 静态属性指向的类组件。<br>
2 使用 <code>useContext</code> hooks 的函数组件。 <br>
3 context 提供的 <code>Consumer</code>。</p>
<p>那么可以大胆的推测一下，<strong>使用过 contextType useContext 的组件对应 fiber,和 Consumer 类型 fiber，会和 dependencies 建立起联系，会把当前消费的 context 放入 dependencies 中。这个下面会给详细解释</strong></p>
<p><strong>第二个问题：</strong>
为什么对于 class 组件会创建一个 ForceUpdate 的 update 呢？</p>
<p>在<strong>生命周期章节</strong>和<strong>渲染控制章节</strong>，讲到过如果想要让类组件调用 render，得到新的 children，那么就要通过 <code>PureComponent</code> 和 <code>shouldComponentUpdate</code> 等层层阻碍，那么 context 要突破这些控制，就要做到当 value 改变，消费 context 的类组件更新，则需要通过 forceUpdate 强制更新。这样就解决了类组件更新限制。</p>
<p>那么总结一下流程，当 Provider 的 value 更新之后，Provider 下面的只要有消费了 context 的类组件，就会触发强制更新。这也就解释了最开始的问题——<strong>context 更新，如何避免 <code>pureComponent</code> ， <code>shouldComponentUpdate</code> 渲染控制策略的影响。</strong> 用一幅流程图表示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ad02d5d2b0640ca8d376abebff714a2~tplv-k3u1fbpfcp-watermark.image?" alt="context7.jpg"></p>
<p><strong>第三个问题：</strong> 这个问题就要从 Provider 类型的 fiber 调和开始讲。</p>
<h4>Provider 和 beiginWork 调和更新机制</h4>
<p>接下来重点介绍 Provider 和 beiginWork 调和更新机制。首先引出两个思考点：</p>
<ul>
<li>第一个类组件执行 render ，函数组件执行就是渲染么？</li>
<li>第二个 Context 改变如何做到消费 context 的组件更新的？（更新原理）</li>
</ul>
<p>先来看一下第一个思考点，关于渲染的思考，实际上在 React 整个 <code>Reconciler</code> 调和流程中，从更新调度任务的发起，再到在 commit 和 render 两大阶段，再到真实的 dom 元素绘制，每一个环节都属于渲染的一部分。而开发者能够控制的 render ，只是其中的一小部分——类组件执行 render ，函数组件执行。而且这些本质上都发生在 FunctionComponent fiber 和 ClassComponent fiber 上。但是整个 fiber 树在调和阶段都需要更新的。更新调和 fiber 的方法在 React 底层叫做 <strong><code>beginWork</code></strong>。有一个问题需要注意，就是 <code>beginWork</code> 非 render。先来看看两者的区别。</p>
<ul>
<li><code>beginWork</code> ： 在一次更新中，只要需要更新的 fiber 或者受到牵连的 fiber，都会执行 beginWork 。</li>
<li><code>render</code>   ： 在一次更新中，只有组件类型的 fiber 会执行 render ，得到新的 children 。如果组件触发 render 那么它一定经历过 <code>beginWork</code></li>
</ul>
<p>这里如果有同学不明白不要紧，接着往下看。</p>
<p>比如发生一次更新任务，此次更新可能发生整个 fiber 树的任意枝叶上，但是因为 context props 穿透影响，React 不知道此次更新的波及范围，那么如何处理呢？ React 会从 rootFiber 开始更新，每一个更新 fiber 都会走 <code>beginWork</code> 流程，开始找不同，找到有没有需要更新的地方，那么指标是什么呢，其中一个重要的指标就是<strong>更新的优先级</strong>，老版本用的是 <code>expirationTime</code> ，新版本用的是 <code>lane</code>，那么就要保证一个问题，就是如果更新发生在一个子代节点，那么只有父节点 <code>beginWork</code> 才能让子代节点 <code>beginWork</code>。这样就形成了一条 root fiber -> 父 fiber -> 子 fiber 的 <code>beginWork</code> 链。在 beginwork 过程中，有几种情况：</p>
<ul>
<li>第一种： 如果遇到组件，而且更新不涉及当前组件，也不在当前组件的父子递归链上，那么就不会 render，也不会向下 beginWork 。</li>
<li>第二种： 如果遇到组件，而且更新不涉及当前组件，但是更新组件属于当前组件的子孙后代，那么不会 render，但是会向下 beginWork ，目的很明确，找到对应的更新组件。</li>
<li>第三种： 如果遇到其他类型的 fiber 比如 hostComponent  <code>&#x3C;div></code> ，那么会对比当前的更新优先级，如果低优先级，那么不需要向下 beginWork 。反之向下 beginWork。</li>
</ul>
<p>这么说可能大家不是很理解，我举一个例子：</p>
<p>如下当点击 componentB 下面的 span 触发 setState 更新 ，如下可以清晰看见 beginWork 和 render 流程。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4be69acfeb8d42c68249f96b8bbb7b98~tplv-k3u1fbpfcp-watermark.image?" alt="context8.jpg"></p>
<ul>
<li>从 root 开始第一次调和， 三个 fiber 都会经历 beginWork ，通过对比优先级， <code>componentA</code> 和 <code>div</code> 停止向下 beginwork。</li>
<li>更新发生在 componentB ，所以 componentB 渲染，触发 <code>render</code> ，得到新的 element，通过对比， <code>div</code> <code>span</code> 都会 beginwork。</li>
<li>componentC 由于父组件更新，没有任何优化策略的情况，那么也会跟着 <code>render</code>，接着 div 也会跟着 beginwork。</li>
</ul>
<p>那么如上，如果 componentC 通过 <code>PureComponent</code> 或者 <code>shouldComponentUpdate</code> 限制更新之后。那么会变成如下的样子：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76bac2d4e134455dbdf31fa33cd7f27b~tplv-k3u1fbpfcp-watermark.image?" alt="context9.jpg"></p>
<ul>
<li>如上 componentC 通过 <code>PureComponent</code> 处理后，不再 render ，当然也不会再向下 beginwork。</li>
</ul>
<p>接下来，如果点击 componentC 下的 div，触发 setState 更新，那么又会发生什么呢？</p>
<ul>
<li>此时更新发生在 <code>componentC</code> 上，所以 componentB 只会发生 beginwork ，不会发生 render。</li>
<li><code>componentB</code> 下面的 <code>div</code> 会停止向下的 beiginwork 。</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/015b6ad8e1404fae88319b150cd05451~tplv-k3u1fbpfcp-watermark.image?" alt="context10.jpg"></p>
<p><strong>我们总结流程如下：</strong></p>
<ul>
<li>1 如果一个组件发生更新，那么当前组件到 fiber root 上的父级链上的所有 fiber ，更新优先级都会升高，都会触发 beginwork 。</li>
<li>2 render 不等于 beginWork，但是 render 发生，一定触发了 beginwork 。</li>
<li>3 一次 beginwork ，一个 fiber 下的同级兄弟 fiber 会发生对比，找到任务优先级高的 fiber 。向下 beginwork 。</li>
</ul>
<p>对于 beginwork 的流程，接下来会有专门的章节维护。</p>
<p><strong>Context 原理</strong></p>
<p>接下来言归正传，我们来研究一下 context 的更新原理，上面说到 <code>Provider</code> 更新，会递归所有的子组件，只要消费了 context 的子代 fiber ，都会给一个高优先级。而且向上更新父级 fiber 链上的优先级，让所有父级 fiber 都处于一个高优先级。那么接下来高优先级的 fiber 都会 beginWork 。</p>
<p>那么将上述例子进行修改，<code>propagateContextChange</code> 的流程会下如下一样，把父级 fiber 的优先级提高。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84210209b512493889a9d2c3a066324e~tplv-k3u1fbpfcp-watermark.image?" alt="context11.jpg"></p>
<p>那么整个 fiber 更新流程会像如下一样</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/761505beb9664b09a27599550b6a0cf7~tplv-k3u1fbpfcp-watermark.image?" alt="context12.jpg"></p>
<h3>2 Consumer</h3>
<p>我们已经讲了 Provider 核心原理，还有另外一部分就是 Consumer ，研究一下其原理。</p>
<h4>Consumer 流程</h4>
<p>上文说道，Consumer 本质上是类型为 <code>REACT_CONTEXT_TYPE</code> 的 element 对象。在调和阶段，会转化成 <code>ContextConsumer</code> 类型的 fiber 对象。在 beginwork 中，会调用 <code>updateContextConsumer</code> 方法。那么这个方法做了些什么呢？</p>
<blockquote>
<p>react/react-reconcider/src/ReactFiberBeginWork.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateContextConsumer</span>(<span class="hljs-params">current,workInProgress,renderExpirationTime,</span>) </span>{
  <span class="hljs-keyword">let</span> context  = workInProgress.type;
  <span class="hljs-keyword">const</span> newProps = workInProgress.pendingProps;
  <span class="hljs-comment">/* 得到 render props children */</span>
  <span class="hljs-keyword">const</span> render = newProps.children;
  <span class="hljs-comment">/* 读取 context */</span> 
  prepareToReadContext(workInProgress, renderExpirationTime);
  <span class="hljs-comment">/* 得到最新的新的 context value */</span>
  <span class="hljs-keyword">const</span> newValue = readContext(context, newProps.unstable_observedBits);
  <span class="hljs-keyword">let</span> newChildren;
  <span class="hljs-comment">/* 得到最新的 children element */</span>
  newChildren = render(newValue);
  workInProgress.effectTag |= PerformedWork;
  <span class="hljs-comment">/* 调和 children */</span>
  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
  <span class="hljs-keyword">return</span> workInProgress.child;
}
</code></pre>
<p><code>updateContextConsumer</code>的核心流程：</p>
<ul>
<li>首先调用 <code>readContext</code> 获取最新的 value 。</li>
<li>然后通过 <code>render props</code> 函数，传入最新的 value，得到最新的 <code>children</code> 。</li>
<li>接下来调和 children 。</li>
</ul>
<p>那么有一个问题<strong>就是 fiber 上的 dependencies 如何和 context 建立起关联。</strong> 那么就是 <strong><code>readContext</code></strong> 这个函数做的事，可以提前透露一下，useContext 和 contextType 本质上也是</p>
<h4>readContext</h4>
<p>readContext 是除了 <code>Provider</code> 之外，第二个核心知识点。</p>
<blockquote>
<p>react/react-reconcider/src/ReactFiberNewContext.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readContext</span>(<span class="hljs-params"> context,observedBits </span>)</span>{
    <span class="hljs-comment">/* 创建一个 contextItem */</span>
    <span class="hljs-keyword">const</span> contextItem = {
      context,
      <span class="hljs-attr">observedBits</span>: resolvedObservedBits,
      <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,
    };
    <span class="hljs-comment">/* 不存在最后一个 context Dependency  */</span>
    <span class="hljs-keyword">if</span> (lastContextDependency === <span class="hljs-literal">null</span>) {
      lastContextDependency = contextItem;
      currentlyRenderingFiber.dependencies = {
        <span class="hljs-attr">expirationTime</span>: NoWork,
        <span class="hljs-attr">firstContext</span>: contextItem,
        <span class="hljs-attr">responders</span>: <span class="hljs-literal">null</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* 存在的情况 */</span>
      lastContextDependency = lastContextDependency.next = contextItem;
    }
   
  <span class="hljs-keyword">return</span> isPrimaryRenderer ? context._currentValue : context._currentValue2;
}
</code></pre>
<ul>
<li>readContext 主要做的事情是这样的，首先会创建一个 contextItem ，上述说到过 fiber 上会存在多个 <code>dependencies</code> ，它们以链表的形式联系到一起，如果不存在最后一个 <code>context dependency</code> ，那证明 context dependencies 为空 ，那么会创建第一个 dependency ，如果存在最后一个 dependency ，那么 contextItem 会以链表形式保存，并变成最后一个 lastContextDependency 。</li>
</ul>
<h4>多个 Provider 嵌套</h4>
<p>如果有多个 Provider 的情况，那么后一个 contextValue 会覆盖前一个 contextValue，在开发者脑海中，要有一个定律就是：<strong><code>Provider</code> 是用来传递 value，而非保存 value 。</strong></p>
<h3>3 contextType 和 useContext</h3>
<h4>useContext 原理</h4>
<p><code>useContext</code> 原理，调用 useContext 本质上调用 <code>readContext</code> 方法。</p>
<blockquote>
<p>react/react-reconcider/src/ReactFiberHooks.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> HooksDispatcherOnMount ={
    <span class="hljs-attr">useContext</span>: readContext
}
</code></pre>
<ul>
<li>函数组件通过 readContext ，将函数组件的 <code>dependencies</code>和当前 context 建立起关联，context 改变，将当前函数组件设置高优先级，促使其渲染。</li>
</ul>
<h4>contextType 原理</h4>
<p>类组件的静态属性 <code>contextType</code> 和 useContext 一样，本质上就是调用 readContext 方法。</p>
<blockquote>
<p>react/react-reconcider/src/ReactFiberClassComponent.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constructClassInstance</span>(<span class="hljs-params">workInProgress,ctor,props</span>)</span>{
     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType === <span class="hljs-string">'object'</span> &#x26;&#x26; contextType !== <span class="hljs-literal">null</span>) {
         <span class="hljs-comment">/* 读取 context  */</span>
        context = readContext(contextType);
    } 

    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> ctor(props, context);
}
</code></pre>
<ul>
<li>静态属性 contextType ，在类组件实例化的时候被使用，本质上也是调用 <code>readContext</code>将 context 和 fiber 上的  <code>dependencies</code> 建立起关联。</li>
</ul>
<h3>4 Context 流程总结</h3>
<p>下面对整个 context 原理部分做总结。</p>
<ul>
<li>
<p>Provider 传递流程：Provider 的更新，会深度遍历子代 fiber，消费 context 的 fiber 和父级链都会提升更新优先级。 对于类组件的 fiber ，会 forceUpdate 处理。接下来所有消费的 fiber，都会 beginWork 。</p>
</li>
<li>
<p>context 订阅流程： <code>contextType</code> ， <code>useContext</code>， <code>Consumer</code> 会内部调用 <code>readContext</code> ，readContext 会把 fiber 上的 <code>dependencies</code> 属性和 context 对象建立起关联。</p>
</li>
</ul>
<h3>5 总结</h3>
<p>本章节知识点总结:</p>
<ul>
<li>context 原理，Provider 做了些什么。</li>
<li>beginWork 和 render 的更新原则和区别。</li>
<li>三种 context 传递模式原理。</li>
<li>context 订阅消费原理。</li>
<li>Provider 嵌套传递原理。</li>
</ul>
<p>透漏一下，接下来会更新另外一个新的章节 fiber 初始化和调和流程。</p></div>
</body></html>