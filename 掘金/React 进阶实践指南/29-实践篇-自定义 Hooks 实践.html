<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>实践篇-自定义 Hooks 实践</h1>
<h2>一 前言</h2>
<p>上章节讲到了自定义 hooks 的特性和设计原则，本章节将记录自定义 hooks 一些具体的应用场景。</p>
<h2>二 实践一：自动上报pv/click的埋点hooks—— useLog</h2>
<p>接下来实现一个能够自动上报 点击事件 | pv 的自定义 hooks 。通过这个自定义 hooks ，将带来的收获是：</p>
<ul>
<li>通过自定义 hooks 控制监听 DOM 元素。</li>
<li>分清自定义 hooks 依赖关系。</li>
</ul>
<p><strong>编写</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> LogContext = React.createContext({})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useLog</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">/* 一些公共参数 */</span>
    <span class="hljs-keyword">const</span> message = React.useContext(LogContext)
    <span class="hljs-keyword">const</span> listenDOM = React.useRef(<span class="hljs-literal">null</span>)

    <span class="hljs-comment">/* 分清依赖关系 -> message 改变，   */</span>
    <span class="hljs-keyword">const</span> reportMessage = React.useCallback(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data,type</span>)</span>{
        <span class="hljs-keyword">if</span>(type===<span class="hljs-string">'pv'</span>){ <span class="hljs-comment">// pv 上报</span>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'组件 pv 上报'</span>,message)
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type === <span class="hljs-string">'click'</span>){  <span class="hljs-comment">// 点击上报</span>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'组件 click 上报'</span>,message,data)
        }
    },[ message ])

    React.useEffect(<span class="hljs-function">()=></span>{
        <span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>)</span>{
            reportMessage(e.target,<span class="hljs-string">'click'</span>)
        }
        <span class="hljs-keyword">if</span>(listenDOM.current){
            listenDOM.current.addEventListener(<span class="hljs-string">'click'</span>,handleClick)
        }

        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{
            listenDOM.current &#x26;&#x26; listenDOM.current.removeEventListener(<span class="hljs-string">'click'</span>,handleClick)
        }
    },[ reportMessage  ])

    <span class="hljs-keyword">return</span> [ listenDOM , reportMessage  ]
}
</code></pre>
<ul>
<li>用 <code>useContext</code> 获取埋点的公共信息。当公共信息改变，会统一更新。</li>
<li>用 <code>useRef</code> 获取 DOM 元素。</li>
<li>用 <code>useCallback</code> 缓存上报信息 reportMessage 方法，里面获取 useContext 内容。把 context 作为依赖项。当依赖项改变，重新声明 reportMessage 函数。</li>
<li>用 <code>useEffect</code>监听 DOM 事件，把 reportMessage 作为依赖项，在 useEffect 中进行事件绑定，返回的销毁函数用于解除绑定。</li>
</ul>
<p><strong>依赖关系：</strong>  context 改变 -> 让引入 context 的 reportMessage 重新声明 -> 让绑定 DOM 事件监听的 useEffect 里面能够绑定最新的 reportMessage 。</p>
<p>如果上述没有分清楚依赖项关系，那么 context 改变，会让 reportMessage 打印不到最新的 context 值。</p>
<p><strong>使用</strong></p>
<pre><code class="hljs language-js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Home</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [ dom , reportMessage  ] = useLog()
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        {/* 监听内部点击 */}
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{dom}</span> ></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span> 《React进阶实践指南》<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span>></span> 按钮 one   (内部点击) <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span>></span> 按钮 two   (内部点击) <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span>></span> 按钮 three (内部点击)  <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        {/* 外部点击 */}
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span>  <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span>=></span>{ console.log(reportMessage)  }} > 外部点击 <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
<span class="hljs-keyword">const</span> Index = React.memo(Home) <span class="hljs-comment">/*  阻断 useState 的更新效应  */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Root</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [ value , setValue ] = useState({})
    <span class="hljs-keyword">return</span>  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">LogContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Index</span> /></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span>=></span> setValue({ name:'《React进阶实践指南》' , author:'我不是外星人'  })} >点击<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">LogContext.Provider</span>></span></span>
}
</code></pre>
<p>如上当 context 改变，能够达到正常上报的效果。有一个小细节，就是用 <code>React.memo</code> 来阻断 Root 组件改变 state 给 Home 组件带来的更新效应。</p>
<p><strong>效果</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a1a6243523d4b0388d8bc64a1a0b9bc~tplv-k3u1fbpfcp-watermark.image" alt="4.gif"></p>
<h2>三 实践二：带查询的分页加载长列表—— useQueryTable</h2>
<p>saas 管理系统中，大概率会存在带查询的表格场景，那么可不可以把整个表单和表格的数据逻辑层交给一个自定义 hooks 来搞定，这样的好处是接下来所有类似该功能的页面，只需要<strong>一个自定义 hooks + 公共组件 + 配置项</strong>就能搞定了。</p>
<p>接下来实现一个带查询分页的功能，把<strong>所有的逻辑</strong>都交给一个自定义 hooks 去处理，组件只负责接收自定义 hooks 的状态。</p>
<h3>设计原则</h3>
<p>useQueryTable 的设计主要分为两部分，分别为表格和查询表单。</p>
<ul>
<li>表格设计：表格的数据状态层，改变分页方法，请求数据的方法。</li>
<li>表单设计：表单的状态层，以及改变表单单元项的方法，重置表单重新请求数据。</li>
</ul>
<h3>设计模型图</h3>
<p>自定义 hooks —— useQueryTable 的设计模型图如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/213c059f312e45e8bb670602c11bf183~tplv-k3u1fbpfcp-watermark.image" alt="5.jpg"></p>
<h3>代码实现</h3>
<p><strong>编写：</strong></p>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 *
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>defaultQuery  表单查询默认参数
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>api           biaog
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useQueryTable</span>(<span class="hljs-params">defaultQuery = {},api</span>)</span>{
   <span class="hljs-comment">/* 保存查询表格表单信息 */</span>
   <span class="hljs-keyword">const</span> formData = React.useRef({})
   <span class="hljs-comment">/* 保存查询表格分页信息 */</span>
   <span class="hljs-keyword">const</span> pagination = React.useRef({
       <span class="hljs-attr">page</span>:defaultQuery.page || <span class="hljs-number">1</span>,
       <span class="hljs-attr">pageSize</span>:defaultQuery.pageSize || <span class="hljs-number">10</span>
   })

   <span class="hljs-comment">/* 强制更新 */</span>
   <span class="hljs-keyword">const</span> [, forceUpdate] = React.useState(<span class="hljs-literal">null</span>)

   <span class="hljs-comment">/* 请求表格数据 */</span>
   <span class="hljs-keyword">const</span> [tableData, setTableData] = React.useState({
     <span class="hljs-attr">data</span>: [],
     <span class="hljs-attr">total</span>: <span class="hljs-number">0</span>,
     <span class="hljs-attr">current</span>: <span class="hljs-number">1</span>
  })

   <span class="hljs-comment">/* 请求列表数据 */</span>
   <span class="hljs-keyword">const</span> getList = React.useCallback(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">payload={}</span>)</span>{
        <span class="hljs-keyword">if</span>(!api) <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> api({ ...defaultQuery, ...payload, ...pagination.current,...formData.current}) || {}
        <span class="hljs-keyword">if</span> (data.code == <span class="hljs-number">200</span>) {
            setTableData({ <span class="hljs-attr">list</span>:data.list,<span class="hljs-attr">current</span>:data.current,<span class="hljs-attr">total</span>:data.total })
        } <span class="hljs-keyword">else</span> {}
   },[ api ]) <span class="hljs-comment">/* 以api作为依赖项，当api改变，重新声明getList */</span>

    <span class="hljs-comment">/* 改变表单单元项 */</span>
    <span class="hljs-keyword">const</span> setFormItem = React.useCallback(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key,value</span>)</span>{
        <span class="hljs-keyword">const</span> form = formData.current
        form[key] = value
        forceUpdate({}) <span class="hljs-comment">/* forceUpdate 每一次都能更新，不会造成 state 相等的情况 */</span>
   },[])

   <span class="hljs-comment">/* 重置表单 */</span>
   <span class="hljs-keyword">const</span> reset = React.useCallback(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">const</span> current = formData.current
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> name <span class="hljs-keyword">in</span> current) {
            current[name] = <span class="hljs-string">''</span>
        }
        pagination.current.page = defaultQuery.page || <span class="hljs-number">1</span>
        pagination.current.pageSize = defaultQuery.pageSize || <span class="hljs-number">10</span>
        <span class="hljs-comment">/* 请求数据  */</span>
        getList()
   },[ getList ]) <span class="hljs-comment">/* getList 作为 reset 的依赖项  */</span>

   <span class="hljs-comment">/* 处理分页逻辑 */</span>
   <span class="hljs-keyword">const</span> handerChange = React.useCallback(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">page,pageSize</span>)</span>{
        pagination.current = {
            page,
            pageSize
        }
        getList()
   },[ getList ]) <span class="hljs-comment">/* getList 作为 handerChange 的依赖项  */</span>

   <span class="hljs-comment">/* 初始化请求数据 */</span>
   React.useEffect(<span class="hljs-function">()=></span>{
       getList()
   },[])

   <span class="hljs-comment">/* 组合暴露参数 */</span>
   <span class="hljs-keyword">return</span> [
        {  <span class="hljs-comment">/* 组合表格状态 */</span>
           tableData,
           handerChange,
           getList,
           <span class="hljs-attr">pagination</span>:pagination.current
        },
        {  <span class="hljs-comment">/* 组合搜索表单状态 */</span>
            <span class="hljs-attr">formData</span>:formData.current,
            setFormItem,
            reset
        }
    ]
}
</code></pre>
<p><strong>设计分析：</strong></p>
<p>接收参数 ：编写的自定义 hooks 接收两个参数。</p>
<ul>
<li><code>defaultQuery</code>：表格的默认参数，有些业务表格，除了查询和分页之外，有一些独立的请求参数。</li>
<li><code>api</code> ： api 为请求数据方法，内部用 <code>Promise</code> 封装处理。</li>
</ul>
<p>数据层：</p>
<ul>
<li>用第一个 useRef 保存查询表单信息 formData 。 第二个 useRef 保存表格的分页信息 pagination 。</li>
<li>用第一个 useState 做<strong>受控表单组件更新视图</strong>的渲染函数。第二个 useState 保存并负责更新表格的状态。</li>
</ul>
<p>控制层：控制层为<strong>控制表单表格整体联动</strong>的方法。</p>
<ul>
<li>编写内部和对外公共方法 <code>getList</code>，方法内部使用 api 函数发起请求，通过 <code>setTableData</code> 改变表格数据层状态，用 <code>useCallback</code> 做优化缓存处理 。</li>
<li>编写改变表单单元项的方法 <code>setFormItem</code>，这个方法主要给查询表单控件使用，内部改变 formData 属性，并通过 useState 更新组件，改变表单控件视图，用 <code>useCallback</code> 做优化缓存处理。</li>
<li>编写重置表单的方法 <code>reset</code> ，reset 会清空 formData 属性和重置分页的信息。然后重新调用 getList 请求数据，用 <code>useCallback</code> 做优化缓存处理。</li>
<li>编写给表格分页器提供的接口 <code>handerChange</code> 内部改变分页信息，然后重新请求数据，用 <code>useCallback</code> 做优化缓存处理。。</li>
<li>用 useEffect 作为初始化请求表格数据的副作用。</li>
</ul>
<p>返回状态：</p>
<ul>
<li>通过数组把表单和表格的聚合状态暴露出去。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>请求方法要与后端进行对齐，包括返回的参数结构，成功状态码等。</li>
<li>属性的声明要与 UI 组件对齐，这里统一用的是 antd 里面的表格和表单控件。</li>
</ul>
<p><strong>使用：</strong></p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 模拟数据请求 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTableData</span>(<span class="hljs-params">payload</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=></span>{
        <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">()=></span>{
            <span class="hljs-keyword">const</span> { list } = listData
            <span class="hljs-keyword">const</span> arr = threeNumberRandom()  <span class="hljs-comment">// 生成三个随机数 模拟数据交互</span>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'请求参数：'</span>,payload)
            resolve({
                ...listData,
                <span class="hljs-attr">list</span>:[ list[arr[<span class="hljs-number">0</span>]],list[arr[<span class="hljs-number">1</span>]],list[arr[<span class="hljs-number">2</span>]] ],
                <span class="hljs-attr">total</span>:list.length,
                <span class="hljs-attr">current</span>:payload.page || <span class="hljs-number">1</span>
            })
        })
    })
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span> (<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [ table,form ] = useQueryTable({ <span class="hljs-attr">pageSize</span>:<span class="hljs-number">3</span> },getTableData)
    <span class="hljs-keyword">const</span> { formData ,setFormItem , reset  } = form
    <span class="hljs-keyword">const</span> { pagination , tableData , getList  , handerChange } = table
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">margin:</span>'<span class="hljs-attr">30px</span>' }} ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">marginBottom:</span>'<span class="hljs-attr">24px</span>' }} ></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">Input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span>=></span> setFormItem('name',e.target.value)}
                placeholder="请输入名称"
                style={inputStyle}
                value={formData.name || ''}
            />
             <span class="hljs-tag">&#x3C;<span class="hljs-name">Input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span>=></span> setFormItem('price',e.target.value)}
                 placeholder="请输入价格"
                 style={inputStyle}
                 value={formData.price || ''}
             />
             <span class="hljs-tag">&#x3C;<span class="hljs-name">Select</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(value)</span> =></span> setFormItem('type',value)}
                 placeholder="请选择"
                 style={inputStyle}
                 value={formData.type}
             >
                 <span class="hljs-tag">&#x3C;<span class="hljs-name">Option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span> ></span>家电<span class="hljs-tag">&#x3C;/<span class="hljs-name">Option</span>></span>
                 <span class="hljs-tag">&#x3C;<span class="hljs-name">Option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span> ></span>生活用品<span class="hljs-tag">&#x3C;/<span class="hljs-name">Option</span>></span>
             <span class="hljs-tag">&#x3C;/<span class="hljs-name">Select</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"searchbtn"</span>
                <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> getList()}
            >提交<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
             <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"concellbtn"</span>
                 <span class="hljs-attr">onClick</span>=<span class="hljs-string">{reset}</span>
             ></span>重置<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        {useCallback( <span class="hljs-tag">&#x3C;<span class="hljs-name">Table</span>
            <span class="hljs-attr">columns</span>=<span class="hljs-string">{columns}</span>
            <span class="hljs-attr">dataSource</span>=<span class="hljs-string">{tableData.list}</span>
            <span class="hljs-attr">height</span>=<span class="hljs-string">"300px"</span>
            <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(res)</span>=></span>{ handerChange(res.current,res.pageSize) }}
            pagination={{ ...pagination, total: tableData.total ,current:tableData.current }}
            rowKey="id"
                      />,[tableData])}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p><strong>效果</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/636f36676b3f434d84136043fe97002c~tplv-k3u1fbpfcp-watermark.image" alt="6.gif"></p>
<ul>
<li>整个查询表格逻辑层基本就一个自定义 hooks —— <code>useQueryTable</code> 就搞定了。</li>
<li><code>getTableData</code> 模拟了数据交互过程 ，其内部的代码逻辑不必纠结 。</li>
<li><code>useCallback</code> 对 Table 的 React element 做缓存处理，这样频繁的表单控件更新，不会让 Table 组件重新渲染。</li>
</ul>
<h2>四 实践三：实现React-Redux功能—— useCreateStore | useConnect</h2>
<p>下面我将用<strong>两个自定义 hooks 实现 <code>React-Redux</code> 基本功能</strong>。 一个是注入 Store 的 <code>useCreateStore</code> ，另外一个是负责订阅更新的 <code>useConnect</code> ，通过这个实践 demo ，将收获以下知识点：</p>
<ul>
<li>如何将不同组件的自定义 hooks 建立通信，共享状态。</li>
<li>合理编写自定义 hooks ， 分析 hooks 之间的依赖关系。</li>
</ul>
<p>首先，看一下要实现的两个自定义 hooks 具体功能。</p>
<ul>
<li><code>useCreateStore</code> 用于产生一个状态 Store ，通过 context 上下文传递 ，为了让每一个自定义 hooks <code>useConnect</code> 都能获取 context 里面的状态属性。</li>
<li><code>useConnect</code> 使用这个自定义 hooks 的组件，可以获取改变状态的 dispatch 方法，还可以订阅 state ，被订阅的 state 发生变化，组件更新。</li>
</ul>
<h3>1 设计思路</h3>
<p><strong>如何让不同组件的自定义 hooks 共享状态并实现通信呢？</strong></p>
<p>首先不同组件的自定义 hooks ，可以通过 <code>useContext</code> 获得共有状态，而且还需要实现状态管理和组件通信，那么就需要一个状态调度中心来统一做这些事，可以称之为 <code>ReduxHooksStore</code> ，它具体做的事情如下：</p>
<ul>
<li>全局管理 state， state 变化，通知对应组件更新。</li>
<li>收集使用 <code>useConnect</code> 组件的信息。组件销毁还要清除这些信息。</li>
<li>维护并传递负责更新的 <code>dispatch</code> 方法。</li>
<li>一些重要 api 要暴露给 context 上下文，传递给每一个 <code>useConnect</code>。</li>
</ul>
<h4>useCreateStore 设计</h4>
<p>首先 <code>useCreateStore</code> 是在靠近根部组件的位置的， 而且全局只需要一个，目的就是创建一个 <code>Store</code> ，并通过 <code>Provider</code> 传递下去。</p>
<p>使用：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> store = useCreateStore( reducer , initState )
</code></pre>
<p>参数：</p>
<ul>
<li><code>reducer</code> ：全局 reducer，纯函数，传入 state 和 action ，返回新的 state 。</li>
<li><code>initState</code> ： 初始化 state 。</li>
</ul>
<p>返回值：为 store 暴露的主要功能函数。</p>
<h4>Store设计</h4>
<p>Store 为上述所说的调度中心，接收全局 reducer ，内部维护状态 state ，负责通知更新 ，收集用 useConnect 的组件。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Store = <span class="hljs-keyword">new</span> ReduxHooksStore(reducer,initState).exportStore()
</code></pre>
<p>参数：接收两个参数，透传 useCreateStore 的参数。</p>
<h4>useConnect设计</h4>
<p>使用 useConnect 的组件，将获得 dispatch 函数，用于更新 state ，还可以通过第一个参数订阅 state ，被订阅的 state 改变 ，会让组件更新。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 订阅 state 中的 number </span>
<span class="hljs-keyword">const</span> mapStoreToState = <span class="hljs-function">(<span class="hljs-params">state</span>)=></span>({ <span class="hljs-attr">number</span>: state.number  })
<span class="hljs-keyword">const</span> [ state , dispatch ] = useConnect(mapStoreToState)
</code></pre>
<p>参数：</p>
<ul>
<li><code>mapStoreToState</code>：将 Store 中 state ，映射到组件的 state 中，可以做视图渲染使用。</li>
<li>如果没有第一个参数，那么只提供 <code>dispatch</code> 函数，不会订阅 state 变化带来的更新。</li>
</ul>
<p>返回值：返回值是一个数组。</p>
<ul>
<li>数组第一项：为映射的 state 的值。</li>
<li>数组第二项：为改变 state 的 <code>dispatch</code> 函数。</li>
</ul>
<h4>原理图</h4>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/365036e1c9f44c648f6203b9b950c736~tplv-k3u1fbpfcp-watermark.image" alt="7.jpg"></p>
<h3>2 useCreateStore</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ReduxContext = React.createContext(<span class="hljs-literal">null</span>)
<span class="hljs-comment">/* 用于产生 reduxHooks 的 store */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useCreateStore</span>(<span class="hljs-params">reducer,initState</span>)</span>{
   <span class="hljs-keyword">const</span> store = React.useRef(<span class="hljs-literal">null</span>)
   <span class="hljs-comment">/* 如果存在——不需要重新实例化 Store */</span>
   <span class="hljs-keyword">if</span>(!store.current){
       store.current  = <span class="hljs-keyword">new</span> ReduxHooksStore(reducer,initState).exportStore()
   }
   <span class="hljs-keyword">return</span> store.current
}
</code></pre>
<p><code>useCreateStore</code> 主要做的是：</p>
<ul>
<li>
<p>接收 <code>reducer</code> 和 <code>initState</code> ，通过 ReduxHooksStore 产生一个 store ，不期望把 store 全部暴露给使用者，只需要暴露核心的方法，所以调用实例下的 <code>exportStore</code>抽离出核心方法。</p>
</li>
<li>
<p>使用一个 <code>useRef</code> 保存核心方法，传递给 <code>Provider</code> 。</p>
</li>
</ul>
<h3>3 状态管理者 —— ReduxHooksStore</h3>
<p>接下来看一下核心状态 ReduxHooksStore 。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { unstable_batchedUpdates } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReduxHooksStore</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">reducer,initState</span>)</span>{
       <span class="hljs-built_in">this</span>.name = <span class="hljs-string">'__ReduxHooksStore__'</span>
       <span class="hljs-built_in">this</span>.id = <span class="hljs-number">0</span>
       <span class="hljs-built_in">this</span>.reducer = reducer
       <span class="hljs-built_in">this</span>.state = initState
       <span class="hljs-built_in">this</span>.mapConnects = {}
    }
    <span class="hljs-comment">/* 需要对外传递的接口 */</span>
    exportStore=<span class="hljs-function">()=></span>{
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">dispatch</span>:<span class="hljs-built_in">this</span>.dispatch.bind(<span class="hljs-built_in">this</span>),
            <span class="hljs-attr">subscribe</span>:<span class="hljs-built_in">this</span>.subscribe.bind(<span class="hljs-built_in">this</span>),
            <span class="hljs-attr">unSubscribe</span>:<span class="hljs-built_in">this</span>.unSubscribe.bind(<span class="hljs-built_in">this</span>),
            <span class="hljs-attr">getInitState</span>:<span class="hljs-built_in">this</span>.getInitState.bind(<span class="hljs-built_in">this</span>)
        }
    }
    <span class="hljs-comment">/* 获取初始化 state */</span>
    getInitState=<span class="hljs-function">(<span class="hljs-params">mapStoreToState</span>)=></span>{
        <span class="hljs-keyword">return</span> mapStoreToState(<span class="hljs-built_in">this</span>.state)
    }
    <span class="hljs-comment">/* 更新需要更新的组件 */</span>
    publicRender=<span class="hljs-function">()=></span>{
        unstable_batchedUpdates(<span class="hljs-function">()=></span>{ <span class="hljs-comment">/* 批量更新 */</span>
            <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.mapConnects).forEach(<span class="hljs-function"><span class="hljs-params">name</span>=></span>{
                <span class="hljs-keyword">const</span> { update } = <span class="hljs-built_in">this</span>.mapConnects[name]
                update(<span class="hljs-built_in">this</span>.state)
            })
        })
    }
    <span class="hljs-comment">/* 更新 state  */</span>
    dispatch=<span class="hljs-function">(<span class="hljs-params">action</span>)=></span>{
       <span class="hljs-built_in">this</span>.state = <span class="hljs-built_in">this</span>.reducer(<span class="hljs-built_in">this</span>.state,action)
       <span class="hljs-comment">// 批量更新</span>
       <span class="hljs-built_in">this</span>.publicRender()
    }
    <span class="hljs-comment">/* 注册每个 connect  */</span>
    subscribe=<span class="hljs-function">(<span class="hljs-params">connectCurrent</span>)=></span>{
        <span class="hljs-keyword">const</span> connectName = <span class="hljs-built_in">this</span>.name + (++<span class="hljs-built_in">this</span>.id)
        <span class="hljs-built_in">this</span>.mapConnects[connectName] =  connectCurrent
        <span class="hljs-keyword">return</span> connectName
    }
    <span class="hljs-comment">/* 解除绑定 */</span>
    unSubscribe=<span class="hljs-function">(<span class="hljs-params">connectName</span>)=></span>{
        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.mapConnects[connectName]
    }
}
</code></pre>
<h4>状态</h4>
<ul>
<li><code>reducer</code>：这个 reducer 为全局的 reducer ，由 useCreateStore 传入。</li>
<li><code>state</code>：全局保存的状态 state ，每次执行 reducer 会得到新的 state 。</li>
<li><code>mapConnects</code>：里面保存每一个 useConnect 组件的更新函数。用于派发 state 改变带来的更新。</li>
</ul>
<h4>方法</h4>
<p><strong>负责初始化：</strong></p>
<ul>
<li><code>getInitState</code>：这个方法给自定义 hooks 的 useConnect 使用，用于获取初始化的 state 。</li>
<li><code>exportStore</code>：这个方法用于把 ReduxHooksStore 提供的核心方法传递给每一个 useConnect 。</li>
</ul>
<p><strong>负责绑定｜解绑：</strong></p>
<ul>
<li><code>subscribe</code>： 绑定每一个自定义 hooks useConnect 。</li>
<li><code>unSubscribe</code>：解除绑定每一个 hooks 。</li>
</ul>
<p><strong>负责更新：</strong></p>
<ul>
<li>
<p><code>dispatch</code>：这个方法提供给业务组件层，每一个使用 useConnect 的组件可以通过 dispatch 方法改变 state ，内部原理是通过调用 reducer 产生一个新的 state 。</p>
</li>
<li>
<p><code>publicRender</code>：当 state 改变需要通知每一个使用 useConnect 的组件，这个方法就是通知更新，至于组件需不需要更新，那是 useConnect  内部需要处理的事情，这里还有一个细节，就是考虑到 dispatch 的触发场景可以是异步状态下，所以用 React-DOM 中 unstable_batchedUpdates 开启批量更新原则。</p>
</li>
</ul>
<h3>4 useConnect</h3>
<p>useConnect 是整个功能的核心部分，它要做的事情是获取最新的 <code>state</code> ，然后通过订阅函数 <code>mapStoreToState</code> 得到订阅的 state ，判断订阅的 state 是否发生变化。如果发生变化渲染最新的 state 。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useConnect</span>(<span class="hljs-params">mapStoreToState=()=>{}</span>)</span>{
    <span class="hljs-comment">/* 获取 Store 内部的重要函数 */</span>
   <span class="hljs-keyword">const</span> contextValue = React.useContext(ReduxContext)
   <span class="hljs-keyword">const</span> { getInitState , subscribe ,unSubscribe , dispatch } = contextValue
   <span class="hljs-comment">/* 用于传递给业务组件的 state  */</span>
   <span class="hljs-keyword">const</span> stateValue = React.useRef(getInitState(mapStoreToState))

   <span class="hljs-comment">/* 渲染函数 */</span>
   <span class="hljs-keyword">const</span> [ , forceUpdate ] = React.useState()
   <span class="hljs-comment">/* 产生 */</span>
   <span class="hljs-keyword">const</span> connectValue = React.useMemo(<span class="hljs-function">()=></span>{
       <span class="hljs-keyword">const</span> state =  {
           <span class="hljs-comment">/* 用于比较一次 dispatch 中，新的 state 和 之前的state 是否发生变化  */</span>
           <span class="hljs-attr">cacheState</span>: stateValue.current,
           <span class="hljs-comment">/* 更新函数 */</span>
           <span class="hljs-attr">update</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newState</span>) </span>{
               <span class="hljs-comment">/* 获取订阅的 state */</span>
               <span class="hljs-keyword">const</span> selectState = mapStoreToState(newState)
               <span class="hljs-comment">/* 浅比较 state 是否发生变化，如果发生变化， */</span>
               <span class="hljs-keyword">const</span> isEqual = shallowEqual(state.cacheState,selectState)
               state.cacheState = selectState
               stateValue.current  = selectState
               <span class="hljs-keyword">if</span>(!isEqual){
                   <span class="hljs-comment">/* 更新 */</span>
                   forceUpdate({})
               }
           }
       }
       <span class="hljs-keyword">return</span> state
   },[ contextValue ]) <span class="hljs-comment">// 将 contextValue 作为依赖项。</span>

   React.useEffect(<span class="hljs-function">()=></span>{
       <span class="hljs-comment">/* 组件挂载——注册 connect */</span>
       <span class="hljs-keyword">const</span> name =  subscribe(connectValue)
       <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{
            <span class="hljs-comment">/* 组件卸载 —— 解绑 connect */</span>
           unSubscribe(name)
       }
   },[ connectValue ]) <span class="hljs-comment">/* 将 connectValue 作为 useEffect 的依赖项 */</span>

   <span class="hljs-keyword">return</span> [ stateValue.current , dispatch ]
}
</code></pre>
<p><strong>初始化</strong></p>
<ul>
<li>用 useContext 获取上下文中， ReduxHooksStore 提供的核心函数。</li>
<li>用 useRef 来保存得到的最新的 state 。</li>
<li>用 useState 产生一个更新函数 <code>forceUpdate</code> ，这个函数只是更新组件。</li>
</ul>
<p><strong>注册｜解绑流程</strong></p>
<ul>
<li>
<p>注册： 通过 <code>useEffect</code> 来向 ReduxHooksStore 中注册当前 useConnect 产生的 connectValue ，connectValue 是什么马上会讲到。subscribe 用于注册，会返回当前 connectValue 的唯一标识 name 。</p>
</li>
<li>
<p>解绑：在 useEffect 的销毁函数中，可以用调用 unSubscribe 传入 name 来解绑当前的 connectValue</p>
</li>
</ul>
<p><strong>connectValue是否更新组件</strong></p>
<ul>
<li>
<p>connectValue ：真正地向 ReduxHooksStore 注册的状态，首先用 <code>useMemo</code> 来对 connectValue 做缓存，connectValue 为一个对象，里面的 cacheState 保留了上一次的 mapStoreToState 产生的 state ，还有一个负责更新的 update 函数。</p>
</li>
<li>
<p><strong>更新流程</strong> ： 当触发 <code>dispatch</code> 在 ReduxHooksStore 中，会让每一个 connectValue 的 update 都执行， update 会触发映射函数 <code>mapStoreToState</code> 来得到当前组件想要的 state 内容。然后通过 <code>shallowEqual</code> 浅比较新老 state 是否发生变化，如果发生变化，那么更新组件。完成整个流程。</p>
</li>
<li>
<p>shallowEqual ： 这个浅比较就是 React 里面的浅比较，在第 11 章已经讲了其流程，这里就不讲了。</p>
</li>
</ul>
<p><strong>分清依赖关系</strong></p>
<ul>
<li>
<p>首先自定义 hooks useConnect 的依赖关系是上下文 contextValue 改变，那么说明 store 发生变化，所以重新通过 useMemo 产生新的 connectValue 。<strong>所以 useMemo 依赖 contextValue。</strong></p>
</li>
<li>
<p>connectValue 改变，那么需要解除原来的绑定关系，重新绑定。<strong>useEffect 依赖 connectValue。</strong></p>
</li>
</ul>
<p><strong>局限性</strong></p>
<p>整个 useConnect 有一些局限性，比如：</p>
<ul>
<li>没有考虑 mapStoreToState 可变性，无法动态传入 mapStoreToState 。</li>
<li>浅比较，不能深层次比较引用数据类型。</li>
</ul>
<h3>5 使用与验证效果</h3>
<p>接下来就是验证效果环节，我模拟了组件通信的场景。</p>
<h4>根部组件注入 Store</h4>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { ReduxContext , useConnect , useCreateStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'./hooks/useRedux'</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [ isShow , setShow ] =  React.useState(<span class="hljs-literal">true</span>)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'index 渲染'</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">CompA</span> /></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">CompB</span> /></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">CompC</span> /></span>
        {isShow &#x26;&#x26;  <span class="hljs-tag">&#x3C;<span class="hljs-name">CompD</span> /></span>}
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setShow(!isShow)} >点击<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Root</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> store = useCreateStore(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state,action</span>)</span>{
        <span class="hljs-keyword">const</span> { type , payload } =action
        <span class="hljs-keyword">if</span>(type === <span class="hljs-string">'setA'</span> ){
            <span class="hljs-keyword">return</span> {
                ...state,
                <span class="hljs-attr">mesA</span>:payload
            }
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type === <span class="hljs-string">'setB'</span>){
            <span class="hljs-keyword">return</span> {
                ...state,
                <span class="hljs-attr">mesB</span>:payload
            }
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type === <span class="hljs-string">'clear'</span>){ <span class="hljs-comment">//清空</span>
            <span class="hljs-keyword">return</span>  { <span class="hljs-attr">mesA</span>:<span class="hljs-string">''</span>,<span class="hljs-attr">mesB</span>:<span class="hljs-string">''</span> }
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">return</span> state
        }
    },
    { <span class="hljs-attr">mesA</span>:<span class="hljs-string">'111'</span>,<span class="hljs-attr">mesB</span>:<span class="hljs-string">'111'</span> })
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">ReduxContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{store}</span> ></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">Index</span>/></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">ReduxContext.Provider</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p><strong>Root根组件</strong></p>
<ul>
<li>通过 useCreateStore 创建一个 store ，传入 reducer 和 初始化的值 <code>{ mesA:'111',mesB:'111' }</code></li>
<li>用 Provider 传递 store。</li>
</ul>
<p><strong>Index组件</strong></p>
<ul>
<li>有四个子组件 CompA ， CompB ，CompC ，CompD 。其中 CompD 是 动态挂载的。</li>
</ul>
<h4>业务组件使用</h4>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CompA</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [ value ,setValue ] = useState(<span class="hljs-string">''</span>)
    <span class="hljs-keyword">const</span> [state ,dispatch ] = useConnect(<span class="hljs-function">(<span class="hljs-params">state</span>)=></span> ({ <span class="hljs-attr">mesB</span> : state.mesB }) )
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"component_box"</span> ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span> 组件A<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>组件B对我说 ： {state.mesB} <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span>=></span>setValue(e.target.value)}
            placeholder="对B组件说"
        />
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span>=></span> dispatch({ type:'setA' ,payload:value })} >确定<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CompB</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [ value ,setValue ] = useState(<span class="hljs-string">''</span>)
    <span class="hljs-keyword">const</span> [state ,dispatch ] = useConnect(<span class="hljs-function">(<span class="hljs-params">state</span>)=></span> ({ <span class="hljs-attr">mesA</span> : state.mesA }) )
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"component_box"</span> ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span> 组件B<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>组件A对我说 ： {state.mesA} <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span>=></span>setValue(e.target.value)}
            placeholder="对A组件说"
        />
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span>=></span> dispatch({ type:'setB' ,payload:value })} >确定<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CompC</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [state  ] = useConnect(<span class="hljs-function">(<span class="hljs-params">state</span>)=></span> ({ <span class="hljs-attr">mes1</span> : state.mesA,<span class="hljs-attr">mes2</span> : state.mesB }) )
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"component_box"</span> ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>组件A ： {state.mes1} <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>组件B ： {state.mes2} <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CompD</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [ ,dispatch  ] = useConnect( )
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'D 组件更新'</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"component_box"</span> ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span>=></span> dispatch({ type:'clear' })} > 清空 <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}

</code></pre>
<ul>
<li>CompA 和 CompB 模拟组件双向通信。</li>
<li>CompC 组件接收 CompA 和 CompB 通信内容，并映射到 <code>mes1 ，mes2</code> 属性上。</li>
<li>CompD 没有 mapStoreToState ，没有订阅 state ，state 变化组件不会更新，只是用 dispatch 清空状态。</li>
</ul>
<h4>效果</h4>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7b06820f28f461c91620d7240b63ed5~tplv-k3u1fbpfcp-watermark.image" alt="8.gif"></p>
<h2>五 持续更新中～</h2>
<p>本章节，第二十六章节，第十四章节为持续维护章节，会有更多精彩的自定义 hooks 实践场景。</p>
<h2>六 总结</h2>
<p>本章节为实践章节，记录了真实工作中使用的自定义 hooks 场景，还有一些自定义 hooks 巧妙设计思路。</p></div>
</body></html>