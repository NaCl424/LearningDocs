<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>原理篇-更新流程：进入调度任务</h1>
<p>小贴士：有一些同学反馈调和和调度的章节听着有点懵，不能很好的串联起来，那么笔者打算写本章节作为前两个章节的补充和完善。</p>
<h2>一 前言</h2>
<p>之前的<strong>调度</strong>和<strong>调和</strong>章节分别讲解了调度的本质（时间分片，请求帧）和调和的流程（两大阶段 render 和 commit ）。本章节将继续围绕着核心的两部分展开。</p>
<p>那么首先来回顾一下两者的概念：</p>
<ul>
<li><strong>调度</strong>：</li>
</ul>
<p>用一段简单的例子描述调度到底做了什么事？假设每一个更新，可以看作一个人拿着材料去办事处办理业务。那么办事处处理每一个人的业务需要时间，并且工作人员，需要维护办事处的正常运转，不能全身心投入给顾客办理业务，那么办事处应该如何处理呢？</p>
<p>1 首先需要所有来访的顾客排成一队。然后工作人员开始逐一受理业务，不能让工作人员一直办理业务，如果一直办理，假设任务过多的情况，那么会一直占用工作人员时间，前面说到办事处需要正常运转，如果这样就无法正常运转了。</p>
<p>2 那么工作人员每次办理一个任务后，就先维持办事处的正常运转，等到工作人员有闲暇的时间，再来办理下一个业务。</p>
<p><strong>那么调度的作用就显而易见了</strong>，首先调度一定是在多个任务情况下，单个更新任务就没调度可言了；多个任务情况下，如果一口气执行完所有更新任务，那么就会阻塞浏览器的正常渲染，给用户体验上就是卡住了。那么调度任务就是每一次执行一个任务，然后先让浏览器完成后续的渲染操作，然后在空暇时间，再执行下一个任务。</p>
<p>在 v18 调度任务还有一些调整。还是拿办理业务这个例子。</p>
<p><code>Legacy</code> 模式下：在 v17 及其以下版本，所有的任务都是紧急任务，那么所有来办理的人员都是平等的，所以工作人员只需要按序办理业务就可以了。</p>
<p><code>v18 Concurrent</code> 模式下：在 v18 模式下，正常紧急的任务都可以看作是会员，一些优先级低的任务比如 <code>transtion</code> 过渡任务，可以看作非会员。如果会员和非会员排列到一起，那么优先会办理会员的业务（正常的紧急优先任务），正常情况下，会办理完所有的会员业务，才开始办理非会员任务；但是在一些极端的情况下，怕会员一直办理，非会员无法办理（被饿死的情况），所以设置一个超时时间，达到超时时间，会破格执行一个非会员任务。</p>
<ul>
<li><strong>调和</strong>：</li>
</ul>
<p><strong>上面介绍了调度的本质，再来举一个例子描述一个调和流程。</strong> 假设我们的应用看作一台设备，那么每一次更新，看作一次检修维护更新，那么维修师傅应该如何检修呢？ 维修师傅会用一个机器 （workLoop可以看作这个机器） ，依次检查每一个需要维护更新的零件（fiber可以看作零件），每一个需要检修的零件都会进入检查流程，如果需要更新，那么会更新，如果有子零件更新（子代 fiber），那么父代本身也会进入到机器运转（ workloop ）流程中。</p>
<p><code>Legacy</code> 模式下：在这个模式下，所有的零件维修，没有优先级的区分，所有的更新工作都被维修师傅依次检查执行。</p>
<p><code>Concurrent</code> 模式下：我们都清楚，对于设备的维修，实际有很多种类，比如影响设备运转的，那么这种维修任务迫在眉睫，还有一种就是相比不是那么重要的，比如机器打蜡，清理等，那么在 Concurrent 下的 workloop，就像师傅在用机器检修零件，但是遇到更高优先处理的任务，就会暂定当前零件的检修，而去检修更重要的任务一样。</p>
<p>上面用两个例子描述了调度和调和的流程，那么两者之间的关系是什么呢？</p>
<ul>
<li>
<p><strong>调度</strong>：首先调度目的针对<strong>多个更新任务</strong>的情况，调度让多个任务井然有序的执行，执行任务的同时，也不要影响浏览器的绘制。调度决定着更新任务的执行时期。</p>
</li>
<li>
<p><strong>调和</strong>：一旦更新任务执行，那么就会进入调和流程，说白了就是根据 state 的改变，去切实地更新视图。</p>
</li>
</ul>
<p>接下来将重点介绍一下 Legacy 模式下调度任务是如何衔接的。</p>
<h2>二 更新之溯源</h2>
<p>在 Legacy 下的 React 应用中，更新本质上有两种：</p>
<ul>
<li>第一种就是初始化的时候第一次页面的呈现。</li>
<li>第二种就是初始化完毕，state 的更新，比如点击按钮，触发 <code>setState</code> 或者 <code>useState</code>。</li>
</ul>
<p>接下来一一分析上面两个流程。</p>
<h3>1 从 ReactDOM.render 看初始化流程</h3>
<p>假设现在开始初始化我们的应用，那么 Legacy 模式下是从 ReactDOM.render 开始的，一个传统的应用的开始应该是这个样子。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-comment">/* 通过 ReactDOM.render  */</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>,
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'app'</span>)
)
</code></pre>
<p>那么 ReactDOM.render 到底做了什么呢？ 在 ReactDOM.render 做的事情是形成一个 Fiber Tree 挂载到 app 上。来看一下主要流程。</p>
<blockquote>
<p>react-dom/src/client/ReactDOMLegacy.js -> legacyRenderSubtreeIntoContainer</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">legacyRenderSubtreeIntoContainer</span>(<span class="hljs-params">
    parentComponent,  <span class="hljs-comment">// null</span>
    children,         <span class="hljs-comment">// &#x3C;App/> 跟部组件</span>
    container,        <span class="hljs-comment">// app dom 元素</span>
    forceHydrate,
    callback          <span class="hljs-comment">// ReactDOM.render 第三个参数回调函数。</span>
</span>){
    <span class="hljs-keyword">let</span> root = container.<span class="hljs-property">_reactRootContainer</span>
    <span class="hljs-keyword">let</span> fiberRoot
    <span class="hljs-keyword">if</span>(!root){
        <span class="hljs-comment">/* 创建 fiber Root */</span>
        root = container.<span class="hljs-property">_reactRootContainer</span> = <span class="hljs-title function_">legacyCreateRootFromDOMContainer</span>(container,forceHydrate);
        fiberRoot = root.<span class="hljs-property">_internalRoot</span>;
        <span class="hljs-comment">/* 处理 callback 逻辑，这里可以省略 */</span>
        <span class="hljs-comment">/* 注意初始化这里用的是 unbatch */</span>
        <span class="hljs-title function_">unbatchedUpdates</span>(<span class="hljs-function">() =></span> {
            <span class="hljs-comment">/*  开始更新  */</span>
            <span class="hljs-title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);
        });
    }
}
</code></pre>
<p>调用  ReactDOM.render 本质上就是 <code>legacyRenderSubtreeIntoContainer</code> 方法。这个方法的主要做的事情是：</p>
<ul>
<li>创建整个应用的 <code>FiberRoot</code> 。</li>
<li>然后调用 <code>updateContainer</code> 开始初始化更新。</li>
<li>这里注意⚠️的是，用的是 <strong><code>unbatch</code></strong> （非批量的情况），并不是批量更新的 <code>batchUpdate</code> 。</li>
</ul>
<p>那么所有更新流程矛头都指向了 updateContainer ，那么接下来看一下 <code>updateContainer</code> 主要做了哪些事。</p>
<blockquote>
<p>react-reonciler/src/ReactFiberReconciler.js -> updateContainer</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContainer</span>(<span class="hljs-params">element,container,parentComponent,callback</span>){
    <span class="hljs-comment">/* 计算优先级，在v16及以下版本用的是 expirationTime ，在 v17 ,v18 版本，用的是 lane。  */</span>
    <span class="hljs-keyword">const</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(current);
    <span class="hljs-comment">/* 创建一个 update */</span>
    <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">createUpdate</span>(eventTime, lane);
    <span class="hljs-title function_">enqueueUpdate</span>(current, update, lane);
    <span class="hljs-comment">/* 开始调度更新 */</span>
    <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">scheduleUpdateOnFiber</span>(current, lane, eventTime);
}
</code></pre>
<p>通过上面代码的简化，可以清晰的看出来 updateContainer 做了哪些事。</p>
<ul>
<li>首先计算更新优先级 <code>lane</code> ，老版本用的是 <code>expirationTime</code>。</li>
<li>然后创建一个 <code>update</code> ，通过 <code>enqueueUpdate</code> 把当前的 update 放入到待更新队列 <code>updateQueue</code> 中。</li>
<li>接下来开始调用 <code>scheduleUpdateOnFiber</code> ，开始进入调度更新流程中。</li>
</ul>
<p>到此为止，可以总结出，初始化更新的时候，最后调用的是 scheduleUpdateOnFiber，开始进入更新流程。具体逻辑一会会讲到。</p>
<h3>2 从 useState | setState 看更新流程</h3>
<p>上面说到了初始化流程，接下来如果发生一次更新，比如一次点击事件带来的 state 的更新。我们这里分<strong>类组件</strong>和<strong>函数组件</strong>分别看一下：</p>
<p><strong>类组件之 <code>setState</code></strong>：</p>
<p>在 state 章节讲到过，当触发 setState 本质上是调用 <code>enqueueSetState</code>。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberClassComponent.js -> enqueueSetState</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-params">inst,payload,callback</span>){
    <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">createUpdate</span>(eventTime, lane);
    <span class="hljs-title function_">enqueueUpdate</span>(fiber, update, lane);
    <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);
}
</code></pre>
<p>可以看到 setState 流程和初始化的流程一样。那么再看一下 hooks 的 <code>useState</code>。</p>
<p><strong>函数组件之 <code>useState</code></strong></p>
<blockquote>
<p>react-reconciler/src/ReactFiberHooks.js -> dispatchAction</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchAction</span>(<span class="hljs-params">fiber, queue, action</span>) {
    <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);
    <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);
}
</code></pre>
<p>上面只保留了 dispatchAction 的核心逻辑，可以清楚的发现，无论是初始化，useState，setState 最后都是调用 <code>scheduleUpdateOnFiber</code> 方法。那么这个就是整个更新的入口。那么这个方法做了些什么事情呢？</p>
<h3>3 更新入口 scheduleUpdateOnFiber</h3>
<blockquote>
<p>react-reconciler/src/ReactFiberWorkLoop.js -> scheduleUpdateOnFiber</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span>(<span class="hljs-params">fiber,lane,eventTime</span>){
    <span class="hljs-keyword">if</span> (lane === <span class="hljs-title class_">SyncLane</span>) {
        <span class="hljs-keyword">if</span> (
            (executionContext &#x26; <span class="hljs-title class_">LegacyUnbatchedContext</span>) !== <span class="hljs-title class_">NoContext</span> &#x26;&#x26; <span class="hljs-comment">// unbatch 情况，比如初始化</span>
            (executionContext &#x26; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) === <span class="hljs-title class_">NoContext</span>) {
            <span class="hljs-comment">/* 开始同步更新，进入到 workloop 流程 */</span>    
            <span class="hljs-title function_">performSyncWorkOnRoot</span>(root);
         }<span class="hljs-keyword">else</span>{
               <span class="hljs-comment">/* 进入调度，把任务放入调度中 */</span>
               <span class="hljs-title function_">ensureRootIsScheduled</span>(root, eventTime);
               <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {
                   <span class="hljs-comment">/* 当前的执行任务类型为 NoContext ，说明当前任务是非可控的，那么会调用 flushSyncCallbackQueue 方法。 */</span>
                   <span class="hljs-title function_">flushSyncCallbackQueue</span>();
               }
         }
    }
}
</code></pre>
<p>scheduleUpdateOnFiber 的核心逻辑如上，正常情况下，大多数任务都是 <code>SyncLane</code>。即便在异步任务里面触发的更新，比如在 <code>Promise</code> 或者是 <code>setTimeout</code> 里面的更新，也是 <code>SyncLane</code>，两者之间没有太大的联系。所以上述核心代码中，只保留了 <code>SyncLane</code> 的逻辑。</p>
<p>那么在 <code>scheduleUpdateOnFiber</code> 内部主要做的事情是：</p>
<ul>
<li>在 <code>unbatch</code> 情况下，会直接进入到 performSyncWorkOnRoot ，接下来会进入到 <strong>调和流程</strong>，比如 <code>render</code> ，<code>commit</code>。</li>
<li>那么任务是 <code>useState</code> 和 <code>setState</code>，那么会进入到 <code>else</code> 流程，那么会进入到 <code>ensureRootIsScheduled</code> 调度流程。</li>
<li>当前的执行任务类型为 <code>NoContext</code> ，说明当前任务是非可控的，那么会调用 <code>flushSyncCallbackQueue</code> 方法。</li>
</ul>
<p>通过上面知道了，<strong>performSyncWorkOnRoot</strong> ： 这个方法会直接进入到调和阶段，会从 rootFiber 开始向下遍历。 <strong>ensureRootIsScheduled</strong>  ：会进入到调度流程。 <strong>flushSyncCallbackQueue</strong> ：用于立即执行更新队列里面的任务。至于为什么，接下来会讲到，请细心阅读。</p>
<p>在介绍 <code>ReactDOM.render</code> 的时候，初始化的更新会通过 unbatchedUpdates 包裹，那么<strong>初始化的更新会直接进入调和阶段同步更新，而不会放入到调度任务中</strong>。</p>
<p><strong><code>legacy</code> 模式下的可控任务和非可控任务。</strong></p>
<ul>
<li>
<p>可控任务：在事件系统章节和 state 章节讲到过，对于 React 事件系统中发生的任务，会被标记 <code>EventContext</code>，在 batchUpdate api 里面的更新任务，会被标记成 <code>BatchedContext</code>，那么这些任务是 React 可以检测到的，所以 <code>executionContext !== NoContext</code>，那么不会执行 <code>flushSyncCallbackQueue</code>。</p>
</li>
<li>
<p>非可控任务：如果在<strong>延时器（timer）队列</strong>或者是<strong>微任务队列（microtask）</strong>，那么这种更新任务，React 是无法控制执行时机的，所以说这种任务就是非可控的任务。比如 <code>setTimeout</code> 和 <code>promise</code> 里面的更新任务，那么 <code>executionContext === NoContext</code> ，接下来会执行一次 <code>flushSyncCallbackQueue</code> 。</p>
</li>
</ul>
<p>那么用流程图描述一下过程：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/155f7112d254465abbdb951c0f3a9137~tplv-k3u1fbpfcp-watermark.image?" alt="1.jpg"></p>
<h2>三 进入调度更新</h2>
<h3>1 控制进入调度</h3>
<p>上面非初始化类型的更新任务，那么最终会走到 ensureRootIsScheduled 流程中，所以来分析一下这个方法。</p>
<blockquote>
<p>react-reconciler/src/ReactFiberWorkLoop.js -> ensureRootIsScheduled</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureRootIsScheduled</span>(<span class="hljs-params">root,currentTime</span>){
    <span class="hljs-comment">/* 计算一下执行更新的优先级 */</span>
    <span class="hljs-keyword">var</span> newCallbackPriority = <span class="hljs-title function_">returnNextLanesPriority</span>();
    <span class="hljs-comment">/* 当前 root 上存在的更新优先级 */</span>
    <span class="hljs-keyword">const</span> existingCallbackPriority = root.<span class="hljs-property">callbackPriority</span>;
    <span class="hljs-comment">/* 如果两者相等，那么说明是在一次更新中，那么将退出 */</span>
    <span class="hljs-keyword">if</span>(existingCallbackPriority === newCallbackPriority){
        <span class="hljs-keyword">return</span> 
    }
    <span class="hljs-keyword">if</span> (newCallbackPriority === <span class="hljs-title class_">SyncLanePriority</span>) {
        <span class="hljs-comment">/* 在正常情况下，会直接进入到调度任务中。 */</span>
        newCallbackNode = <span class="hljs-title function_">scheduleSyncCallback</span>(performSyncWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root));
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-comment">/* 这里先忽略 */</span>
    }
    <span class="hljs-comment">/* 给当前 root 的更新优先级，绑定到最新的优先级  */</span>
    root.<span class="hljs-property">callbackPriority</span> = newCallbackPriority;
}
</code></pre>
<p>ensureRootIsScheduled 主要做的事情有：</p>
<ul>
<li>首先会计算最新的调度更新优先级 <code>newCallbackPriority</code>，接下来获取当前 root 上的 <code>callbackPriority</code> 判断两者是否相等。如果两者相等，那么将直接退出不会进入到调度中。</li>
<li>如果不想等那么会真正的进入调度任务 <code>scheduleSyncCallback</code> 中。注意的是放入调度中的函数就是<strong>调和流程</strong>的入口函数 <code>performSyncWorkOnRoot</code>。</li>
<li>函数最后会将 newCallbackPriority 赋值给 callbackPriority。</li>
</ul>
<p><strong>什么情况下会存在 existingCallbackPriority === newCallbackPriority，退出调度的情况？</strong></p>
<p>我们注意到在一次更新中最后 callbackPriority 会被赋值成 newCallbackPriority 。那么如果在正常模式下（非异步）一次更新中触发了多次 <code>setState</code> 或者 <code>useState</code> ，那么第一个 setState 进入到 ensureRootIsScheduled 就会有 root.callbackPriority = newCallbackPriority，那么接下来如果还有 setState | useState，那么就会退出，将不进入调度任务中，<strong>原来这才是批量更新的原理，多次触发更新只有第一次会进入到调度中。</strong></p>
<p><strong>对于整个批量更新和批量更新打破原理，在第四部分会讲到。</strong></p>
<h3>2 进入调度任务</h3>
<p>那么当进入到 scheduleSyncCallback 中会发生什么呢？顺着线索往下看：</p>
<blockquote>
<p>react-reconciler/src/ReactFiberSyncTaskQueue.js -> scheduleSyncCallback</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleSyncCallback</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-keyword">if</span> (syncQueue === <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">/* 如果队列为空 */</span>
        syncQueue = [callback];
        <span class="hljs-comment">/* 放入调度任务 */</span>
        immediateQueueCallbackNode = <span class="hljs-title class_">Scheduler</span>_scheduleCallback(<span class="hljs-title class_">Scheduler</span>_ImmediatePriority, flushSyncCallbackQueueImpl);
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-comment">/* 如果任务队列不为空，那么将任务放入队列中。 */</span>
        syncQueue.<span class="hljs-title function_">push</span>(callback);
    }
} 
</code></pre>
<p><code>flushSyncCallbackQueueImpl</code> 会真正的执行 <code>callback</code> ，本质上就是调和函数 <code>performSyncWorkOnRoot</code>。</p>
<p><code>Scheduler_scheduleCallback</code> 就是在调度章节讲的调度的执行方法，本质上就是通过 <strong><code>MessageChannel</code></strong> 向浏览器请求下一空闲帧，在空闲帧中执行更新任务。</p>
<p>scheduleSyncCallback 做的事情如下：</p>
<ul>
<li>如果执行队列为空，那么把当前任务放入队列中。然后执行调度任务。</li>
<li>如果队列不为空，此时已经在调度中，那么不需要执行调度任务，只需要把当前更新放入队列中就可以，调度中心会一个个按照顺序执行更新任务。</li>
</ul>
<p>到现在，已经知道了调和更新任务如何进入调度的。也知道了在初始化和改变 state 带来的更新原理。</p>
<p>接下来有一个问题就是，<strong>比如在浏览器空闲状态下发生一次 state 更新，那么最后一定会进入调度，等到下一次空闲帧执行吗？</strong></p>
<p>答案是否定的，如果这样，那么就是一种性能的浪费，因为正常情况下，发生更新希望的是在一次事件循环中执行完更新到视图渲染，如果在下一次事件循环中执行，那么更新肯定会延时。但是 <code>React</code> 是如何处理这个情况的呢？</p>
<h3>3 空闲期的同步任务</h3>
<p>在没有更新任务空闲期的条件下，为了让更新变成同步的，也就是本次更新不在调度中执行，那么 React 对于更新，会用 <code>flushSyncCallbackQueue</code> 立即执行更新队列，发起更新任务，<strong>目的就是让任务不延时到下一帧</strong>。但是此时调度会正常执行，不过调度中的任务已经被清空，</p>
<p>那么有的同学可以会产生疑问，既然不让任务进入调度，而选择同步执行任务，那么调度意义是什么呢?</p>
<p>调度的目的是处理存在多个更新任务的情况，比如发生了短时间内的连续的点击事件，每次点击事件都会更新 state ，那么对于这种更新并发的情况，第一个任务以同步任务执行，那么接下来的任务将放入调度，等到调度完成后，在下一空闲帧时候执行。</p>
<h4>可控更新任务</h4>
<p>那么知道了，发生一次同步任务之后，React 会让调度执行，但是会立即执行同步任务。原理就是通过 <code>flushSyncCallbackQueue</code> 方法。对于可控的更新任务，比如事件系统里的同步的 setState 或者 useState，再比如 batchUpdate，如果此时处理空闲状态，在内部都会触发一个 <code>flushSyncCallbackQueue</code>来立即更新。我们看一下:</p>
<p><strong>事件系统中的</strong></p>
<blockquote>
<p>react-reconciler/src/ReactFiberWorkLoop.js -> batchedEventUpdates</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedEventUpdates</span>(<span class="hljs-params">fn, a</span>){
     <span class="hljs-comment">/* 批量更新流程，没有更新状态下，那么直接执行任务 */</span>
     <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
     executionContext |= <span class="hljs-title class_">EventContext</span>;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a) <span class="hljs-comment">/* 执行事件本身，React 事件在这里执行，useState 和 setState 也会在这里执行 */</span>
    } <span class="hljs-keyword">finally</span> {
     <span class="hljs-comment">/* 重置状态 */</span> 
    executionContext = prevExecutionContext;
    <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) { 
      <span class="hljs-comment">/* 批量更新流程，没有更新状态下，那么直接执行任务 */</span>
      <span class="hljs-title function_">flushSyncCallbackQueue</span>();
    }
  }
}
</code></pre>
<p><strong>ReactDOM暴露的api <code>batchedUpdates</code></strong></p>
<blockquote>
<p>react-reconciler/src/ReactFiberWorkLoop.js -> batchedUpdates</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedUpdates</span>(<span class="hljs-params">fn, a</span>) {
    <span class="hljs-comment">/* 和上述流程一样 */</span>
    <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {
      <span class="hljs-title function_">flushSyncCallbackQueue</span>();
    }
}
</code></pre>
<p>如上可以看到，如果浏览器没有调度更新任务，那么如果发生一次可控更新任务，最后会默认执行一次 <code>flushSyncCallbackQueue</code> 来让任务同步执行。</p>
<h4>非可控更新任务</h4>
<p>如果是非可控的更新任务，比如在 <code>setTimeout</code> 或者 <code>Promise</code> 里面的更新，那么在 scheduleUpdateOnFiber 中已经讲过。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {
    <span class="hljs-comment">/* 执行 flushSyncCallbackQueue ，立即执行更新 */</span>
    <span class="hljs-title function_">flushSyncCallbackQueue</span>();
}
</code></pre>
<p>综上这也就说明了，为什么在异步内部的 <code>setState</code> | <code>useState</code> 会打破批量更新的原则，本质上是因为，执行一次 <code>setState</code> | <code>useState</code> 就会触发一次 <code>flushSyncCallbackQueue</code> 立即触发更新，所以就会进入到调和阶段，去真正的更新 fiber 树。</p>
<h2>四 同步异步模式下的更新流程实践</h2>
<p>为了强化本章节的学习，接下来我们来一起研究一下 legacy 模式下的更新流程。</p>
<h3>初始化情况</h3>
<p>首先看一下初始化流程。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e763eb7b683487f847380c15a94656a~tplv-k3u1fbpfcp-watermark.image?" alt="2.jpg"></p>
<ul>
<li>ReactDOM.render -> unbatchContext 开关打开 -> updateContainer。</li>
<li>updateContainer：scheduleUpdateOnFiber -> performSyncWorkOnRoot -> renderRoot -> commitRoot -> 浏览器绘制。</li>
<li>unbatchContext 开关关闭。</li>
</ul>
<h3>同步情况</h3>
<p>接下来一起看一下在同步（可控任务）和异步（非可控任务）下更新流程。</p>
<p>首先看一下同步的情况</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">const</span> [ number , setNumber ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>)=>{ <span class="hljs-comment">/* 同步条件下 */</span>
        <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">1</span>)
        <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">2</span>)
    }
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        {number}
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span> ></span>点击<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>如上当点击按钮的时候，会触发两次 <code>setNumber</code> ，那么这两次 <code>setNumber</code> 都做了些什么呢？</p>
<p>两次更新流程图如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93eead4ab14f42628cdd7ac4e0c00d25~tplv-k3u1fbpfcp-watermark.image?" alt="3.jpg"></p>
<p>整个流程过程：</p>
<ul>
<li><strong>事件上下文</strong>：开启事件开关 -> 进入第一次 <code>setNumber</code>。</li>
<li><strong>第一次 <code>setNumber</code> 上下文</strong>： <code>scheduleUpdateOnFiber</code> -> <code>ensureRootIsScheduled</code> -> <code>scheduleSyncCallback</code> (放入回调函数 <code>performSyncWorkOnRoot</code> )。</li>
<li><strong>第二次 <code>setNumber</code> 上下文</strong>： <code>scheduleUpdateOnFiber</code> -> <code>ensureRootIsScheduled</code> -> 退出。</li>
<li><strong>事件上下文</strong>：关闭事件开关 -> <code>flushSyncCallbackQueue</code>。</li>
<li><strong>flushSyncCallbackQueue</strong> -> 执行回调函数 <code>performSyncWorkOnRoot</code> -> 进入调和阶段 -> <code>renderRoot</code> -> <code>commitRoot</code> -> 浏览器绘制。</li>
</ul>
<h3>异步情况</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>)=>{
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> { <span class="hljs-comment">/* 异步条件下 */</span>
        <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">1</span>)
        <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">2</span>)
    },<span class="hljs-number">0</span>)    
}
</code></pre>
<p>两次更新流程图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2996f90757614edfbcd0230e02645d9c~tplv-k3u1fbpfcp-watermark.image?" alt="4.jpg"></p>
<p>整个流程过程：</p>
<ul>
<li><strong>事件上下文</strong>：开启事件开关 -> 关闭事件开关 -> flushSyncCallbackQueue (此时更新队列为空)。</li>
<li><strong>setTimeout上下文</strong>：执行第一次 <code>setNumber</code>。</li>
<li><strong>第一次 <code>setNumber</code> 上下文</strong>：<code>scheduleUpdateOnFiber</code> -> <code>ensureRootIsScheduled</code> -> <code>scheduleSyncCallback</code> (放入回调函数 <code>performSyncWorkOnRoot</code> ) -> <code>flushSyncCallbackQueue</code> -> 执行回调函数 <code>performSyncWorkOnRoot</code> -> 进入调和阶段 -> <code>renderRoot</code> -> <code>commitRoot</code>。</li>
<li><strong>回到 setTimeout 上下文</strong>：执行第二次 <code>setNumber</code>。</li>
<li><strong>第二次 <code>setNumber</code> 上下文</strong>：<code>scheduleUpdateOnFiber</code> -> <code>ensureRootIsScheduled</code> -> <code>scheduleSyncCallback</code> (放入回调函数 <code>performSyncWorkOnRoot</code> ) -> <code>flushSyncCallbackQueue</code> -> 执行回调函数 <code>performSyncWorkOnRoot</code> -> 进入调和阶段 -> <code>renderRoot</code> -> <code>commitRoot</code>。</li>
<li>js执行完毕，浏览器绘制。</li>
</ul>
<p>所以这种情况下 render 了两遍。到此为止 legacy 模式下更新流程真相大白。</p>
<h2>五 总结</h2>
<p>通过本章节的学习，收获的知识点如下：</p>
<ul>
<li>初始化和 <code>state</code> 改变的更新流程。</li>
<li>可控任务和非可控任务的更新原理。</li>
<li>如何进入调度任务。</li>
<li>强化 state | 调度 ｜ 调和 章节的学习。</li>
</ul></div>
</body></html>