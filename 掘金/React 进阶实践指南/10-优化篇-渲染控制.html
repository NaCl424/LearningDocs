<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>优化篇-渲染控制</h1>
<h2>一 前言</h2>
<p>从本节开始，我们将开始正式介绍 React 优化环节，React 优化会从<strong>渲染、加载、海量数据、细节</strong>四个方向入手，详细介绍 React 优化过程中的方法和技巧。本章节将重点谈谈 React 的渲染以及优化手段。</p>
<p>通过本章节的学习，你将收获 React 渲染控制的常规方法以及原理，并且学会性能优化的主要手段。</p>
<h2>二 再谈 React 渲染</h2>
<p>对于 React 渲染，你不要仅仅理解成类组件触发 render 函数，函数组件本身执行，事实上，从调度更新任务到调和 fiber，再到浏览器渲染真实 DOM，每一个环节都是渲染的一部分，至于对于每个环节的性能优化，React 在底层已经处理了大部分优化细节，包括设立任务优先级、异步调度、diff算法、时间分片都是 React 为了提高性能，提升用户体验采取的手段。所以，开发者只需要告诉 React 哪些组件需要更新，哪些组件不需要更新。于是，React 提供了 PureComponent，shouldComponentUpdated，memo 等优化手段。这些手段是什么呢？</p>
<h3>render阶段作用是什么？</h3>
<p>首先来思考一个问题，组件在一次更新中，类组件执行 render ，执行函数组件 renderWithHooks （ renderWithHook 内部执行 React 函数组件本身），他们的作用是什么呢？ 他们真实渲染了 DOM 了吗？显然不是，真实 DOM 是在 commit 阶段挂载的，之前章节打印过 render 后的内容。</p>
<p>那么<strong>render的作用</strong>是根据一次更新中产生的新状态值，通过 React.createElement ，替换成新的状态，得到新的 React element 对象，新的 element 对象上，保存了最新状态值。 createElement 会产生一个全新的props。到此 render 函数使命完成了。</p>
<p>接下来，React 会调和由 render 函数产生 chidlren，将子代 element 变成  fiber（这个过程如果存在 alternate，会复用 alternate 进行克隆，如果没有 alternate ，那么将创建一个），将 props 变成 pendingProps ，至此当前组件更新完毕。然后如果 children 是组件，会继续重复上一步，直到全部 fiber 调和完毕。完成 render 阶段。</p>
<h2>三 React 几种控制 render 方法</h2>
<p>React 提供了几种控制 render 的方式。我这里会介绍原理和使用。说到对render 的控制，究其本质，主要有以下两种方式：</p>
<ul>
<li>第一种就是从父组件直接隔断子组件的渲染，经典的就是 memo，缓存 element 对象。</li>
<li>第二种就是组件从自身来控制是否 render ，比如：PureComponent ，shouldComponentUpdate 。</li>
</ul>
<h3>1 缓存React.element对象</h3>
<p>第一种是对 React.element 对象的缓存。这是一种父对子的渲染控制方案，来源于一种情况，父组件 render ，子组件有没有必要跟着父组件一起 render ，如果没有必要，则就需要阻断更新流，如下先举两个小例子🌰：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 子组件 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Children</span> (<span class="hljs-params">{ number }</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'子组件渲染'</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>let us learn React!  { number } <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
<span class="hljs-comment">/* 父组件 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    state={
        <span class="hljs-attr">numberA</span>:<span class="hljs-number">0</span>,
        <span class="hljs-attr">numberB</span>:<span class="hljs-number">0</span>,
    }
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">Children</span> <span class="hljs-attr">number</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.state.numberA</span> } /></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> this.setState({ numberA:this.state.numberA + 1 }) } >改变numberA -{ this.state.numberA } <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> this.setState({ numberB:this.state.numberB + 1 }) } >改变numberB -{ this.state.numberB }<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
     }

}
</code></pre>
<p>对于子组件 Children ，只有 props 中 numberA 更新才是有用的， numberB 更新带来渲染，Children 根本不需要。但是如果不处理子组件的话，就会出现如下情况。无论改变 numberA 还是改变 numberB ，子组件都会重新渲染，显然这不是想要的结果。</p>
<p><strong>效果</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99e32bcd5b1344ea9654001fb56917c0~tplv-k3u1fbpfcp-watermark.image" alt="1.gif"></p>
<p>那么怎么样用缓存 element 来避免 children 没有必要的更新呢？将如上父组件做如下修改。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>{
        <span class="hljs-built_in">super</span>(props)
        <span class="hljs-built_in">this</span>.state={
            <span class="hljs-attr">numberA</span>:<span class="hljs-number">0</span>,
            <span class="hljs-attr">numberB</span>:<span class="hljs-number">0</span>,
        }
        <span class="hljs-built_in">this</span>.component =  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Children</span> <span class="hljs-attr">number</span>=<span class="hljs-string">{this.state.numberA}</span> /></span></span>
    }
    controllComponentRender=<span class="hljs-function">()=></span>{ <span class="hljs-comment">/* 通过此函数判断 */</span>
        <span class="hljs-keyword">const</span> { props } = <span class="hljs-built_in">this</span>.component
        <span class="hljs-keyword">if</span>(props.number !== <span class="hljs-built_in">this</span>.state.numberA ){ <span class="hljs-comment">/* 只有 numberA 变化的时候，重新创建 element 对象  */</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.component = React.cloneElement(<span class="hljs-built_in">this</span>.component,{ <span class="hljs-attr">number</span>:<span class="hljs-built_in">this</span>.state.numberA })
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.component
    }
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
       <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
          { this.controllComponentRender()  } 
          <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> this.setState({ numberA:this.state.numberA + 1 }) } >改变numberA<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> this.setState({ numberB:this.state.numberB + 1 }) }  >改变numberB<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
       <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    }
}
</code></pre>
<ul>
<li>首先把 Children 组件对应的 element 对象，挂载到组件实例的 component 属性下。</li>
<li>通过 controllComponentRender 控制渲染 Children 组件，如果 numberA 变化了，证明 Children的props 变化了，那么通过 cloneElement  返回新的 element 对象，并重新赋值给 component ，如果没有变化，那么直接返回缓存的 component 。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c60e3744029f45d3a6ef8a324c0e0327~tplv-k3u1fbpfcp-watermark.image" alt="2.gif"></p>
<p><strong>完美达到效果</strong></p>
<p>但是在这里不推荐在 React 类组价中这么写，对于基础不够扎实的同学，很容易出现错误。我还是推荐大家在函数组件里用 <code>useMemo</code> 达到同样的效果，代码如下所示。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [ numberA , setNumberA ] = React.useState(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> [ numberB , setNumberB ] = React.useState(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        { useMemo(()=> <span class="hljs-tag">&#x3C;<span class="hljs-name">Children</span> <span class="hljs-attr">number</span>=<span class="hljs-string">{numberA}</span> /></span>,[ numberA ]) }
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> setNumberA(numberA + 1) } >改变numberA<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> setNumberB(numberB + 1) } >改变numberB<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<ul>
<li>用 React.useMemo 可以达到同样的效果， 需要更新的值 numberA 放在 deps 中，numberA 改变，重新形成element对象，否则通过 useMemo 拿到上次的缓存值。达到如上同样效果。比起类组件，我更推荐函数组件用 useMemo 这种方式。</li>
</ul>
<p><strong>｜--------问与答---------｜</strong><br>
详细介绍一下 useMemo ？</p>
<p><strong>useMemo 用法：</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> cacheSomething = useMemo(create,deps)
</code></pre>
<ul>
<li><code>create</code>：第一个参数为一个函数，函数的返回值作为缓存值，如上 demo 中把 Children 对应的 element 对象，缓存起来。</li>
<li><code>deps</code>： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。</li>
<li><code>cacheSomething</code>：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存值。</li>
</ul>
<p><strong>useMemo原理：</strong></p>
<p>useMemo 会记录上一次执行 create 的返回值，并把它绑定在函数组件对应的 fiber 对象上，只要组件不销毁，缓存值就一直存在，但是 deps 中如果有一项改变，就会重新执行 create ，返回值作为新的值记录到 fiber 对象上。</p>
<p><strong>useMemo应用场景：</strong></p>
<ul>
<li>可以缓存 element 对象，从而达到按条件渲染组件，优化性能的作用。</li>
<li>如果组件中不期望每次 render 都重新计算一些值,可以利用 useMemo 把它缓存起来。</li>
<li>可以把函数和属性缓存起来，作为 PureComponent 的绑定方法，或者配合其他Hooks一起使用。</li>
</ul>
<p><strong>｜--------end---------｜</strong><br></p>
<p><strong>原理揭秘</strong></p>
<p>如上讲了利用 element 的缓存，实现了控制子组件不必要的渲染，究其原理是什么呢？</p>
<p>原理其实很简单，上述每次执行 render 本质上 createElement 会产生一个新的 props，这个 props 将作为对应 fiber 的 <code>pendingProps</code> ，在此 fiber 更新调和阶段，React 会对比 fiber 上老 oldProps 和新的 newProp （ pendingProps ）是否相等，如果相等函数组件就会放弃子组件的调和更新，从而子组件不会重新渲染；如果上述把 element 对象缓存起来，上面 props 也就和 fiber 上 oldProps 指向相同的内存空间，也就是相等，从而跳过了本次更新。</p>
<h3>2 PureComponent</h3>
<p>纯组件是一种发自组件本身的渲染优化策略，当开发类组件选择了继承 PureComponent ，就意味这要遵循其渲染规则。规则就是<strong>浅比较 state 和 props 是否相等</strong>。首先来看一下 PureComponent 的基本使用。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 纯组件本身 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Children</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span></span>{
    state={
        <span class="hljs-attr">name</span>:<span class="hljs-string">'alien'</span>,
        <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,
        <span class="hljs-attr">obj</span>:{
            <span class="hljs-attr">number</span>:<span class="hljs-number">1</span>,
        }
    }
    changeObjNumber=<span class="hljs-function">()=></span>{
        <span class="hljs-keyword">const</span> { obj } = <span class="hljs-built_in">this</span>.state
        obj.number++
        <span class="hljs-built_in">this</span>.setState({ obj })
    }
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'组件渲染'</span>)
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>  ></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> 组件本身改变state <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> this.setState({ name:'alien' }) } >state相同情况<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> this.setState({ age:this.state.age + 1  }) }>state不同情况<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.changeObjNumber</span> } ></span>state为引用数据类型时候<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>hello,my name is alien,let us learn React!<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    }
}
<span class="hljs-comment">/* 父组件 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Home</span> (<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [ numberA , setNumberA ] = React.useState(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> [ numberB , setNumberB ] = React.useState(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> 父组件改变props <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> setNumberA(numberA + 1) } >改变numberA<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> setNumberB(numberB + 1) } >改变numberB<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Children</span> <span class="hljs-attr">number</span>=<span class="hljs-string">{numberA}</span>  /></span> 
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>效果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23bb0f80f537418a8dedaf9a3fd88f1e~tplv-k3u1fbpfcp-watermark.image" alt="3.gif"></p>
<ul>
<li>对于 props ，PureComponent 会浅比较 props 是否发生改变，再决定是否渲染组件，所以只有点击 numberA 才会促使组件重新渲染。</li>
<li>对于 state ，如上也会浅比较处理，当上述触发 ‘ state 相同情况’ 按钮时，组件没有渲染。</li>
<li>浅比较只会比较基础数据类型，对于引用类型，比如 demo 中 state 的 obj ，单纯的改变 obj 下属性是不会促使组件更新的，因为浅比较两次 obj 还是指向同一个内存空间，想要解决这个问题也容易，浅拷贝就可以解决，将如上 changeObjNumber 这么修改。这样就是重新创建了一个 obj ，所以浅比较会不相等，组件就会更新了。</li>
</ul>
<pre><code class="hljs language-js">  changeObjNumber=<span class="hljs-function">()=></span>{
        <span class="hljs-keyword">const</span> { obj } = <span class="hljs-built_in">this</span>.state
        obj.number++
        <span class="hljs-built_in">this</span>.setState({ <span class="hljs-attr">obj</span>:{...obj} })
    }
</code></pre>
<p><strong>PureComponent 原理及其浅比较原则</strong></p>
<p>PureComponent 内部是如何工作的呢，首先当选择基于 PureComponent 继承的组件。原型链上会有 isPureReactComponent 属性。一起看一下创建 PureComponent 时候：</p>
<blockquote>
<p>react/src/ReactBaseClasses.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-comment">/* pureComponentPrototype 纯组件构造函数的 prototype 对象，绑定isPureReactComponent 属性。 */</span>
pureComponentPrototype.isPureReactComponent = <span class="hljs-literal">true</span>;
</code></pre>
<p><code>isPureReactComponent</code> 这个属性在更新组件 <code>updateClassInstance</code> 方法中使用的，在生命周期章节中已经讲过，相信看过的同学都会有印象，这个函数在更新组件的时候被调用，在这个函数内部，有一个专门负责检查是否更新的函数  <code>checkShouldComponentUpdate</code> 。</p>
<blockquote>
<p>react/react-reconciler/ReactFiberClassComponent.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkShouldComponentUpdate</span>(<span class="hljs-params"></span>)</span>{
     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.shouldComponentUpdate === <span class="hljs-string">'function'</span>) {
         <span class="hljs-keyword">return</span> instance.shouldComponentUpdate(newProps,newState,nextContext)  <span class="hljs-comment">/* shouldComponentUpdate 逻辑 */</span>
     } 
    <span class="hljs-keyword">if</span> (ctor.prototype &#x26;&#x26; ctor.prototype.isPureReactComponent) {
        <span class="hljs-keyword">return</span>  !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
    }
}
</code></pre>
<ul>
<li>isPureReactComponent 就是判断当前组件是不是纯组件的，如果是 PureComponent 会浅比较 props 和 state 是否相等。</li>
<li>还有一点值得注意的就是 shouldComponentUpdate 的权重，会大于 PureComponent。</li>
<li>shallowEqual 是如何浅比较的呢，由于我不想在章节中写过多的源码，我在这里就直接描述过程了。</li>
</ul>
<p>shallowEqual 浅比较流程：</p>
<ul>
<li>第一步，首先会直接比较新老 props 或者新老 state 是否相等。如果相等那么不更新组件。</li>
<li>第二步，判断新老 state 或者 props ，有不是对象或者为 null 的，那么直接返回 false ，更新组件。</li>
<li>第三步，通过 Object.keys 将新老 props 或者新老 state 的属性名 key 变成数组，判断数组的长度是否相等，如果不相等，证明有属性增加或者减少，那么更新组件。</li>
<li>第四步，遍历老 props 或者老 state ，判断对应的新 props 或新 state ，有没有与之对应并且相等的（这个相等是浅比较），如果有一个不对应或者不相等，那么直接返回 false ，更新组件。</li>
</ul>
<p>到此为止，浅比较流程结束， PureComponent 就是这么做渲染节流优化的。</p>
<p><strong>PureComponent注意事项</strong></p>
<p>PureComponent 可以让组件自发的做一层性能上的调优，但是，父组件给是 PureComponent 的子组件绑定事件要格外小心，避免两种情况发生：</p>
<p>1 避免使用箭头函数。不要给是 PureComponent 子组件绑定箭头函数，因为父组件每一次 render ，如果是箭头函数绑定的话，都会重新生成一个新的箭头函数， PureComponent 对比新老 props 时候，因为是新的函数，所以会判断不想等，而让组件直接渲染，PureComponent 作用终会失效。</p>
<pre><code class="hljs language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span></span>{}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    render=<span class="hljs-function">()=></span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Index</span> <span class="hljs-attr">callback</span>=<span class="hljs-string">{()</span>=></span>{}}   /></span>
}
</code></pre>
<p>2 PureComponent 的父组件是函数组件的情况，绑定函数要用 useCallback 或者 useMemo 处理。这种情况还是很容易发生的，就是在用 class + function  组件开发项目的时候，如果父组件是函数，子组件是 PureComponent ，那么绑定函数要小心，因为函数组件每一次执行，如果不处理，还会声明一个新的函数，所以 PureComponent 对比同样会失效，如下情况：</p>
<pre><code class="hljs language-js">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span></span>{}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> callback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handerCallback</span>(<span class="hljs-params"></span>)</span>{} <span class="hljs-comment">/* 每一次函数组件执行重新声明一个新的callback，PureComponent浅比较会认为不想等，促使组件更新  */</span>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Index</span> <span class="hljs-attr">callback</span>=<span class="hljs-string">{callback}</span>  /></span></span>
}
</code></pre>
<p>综上可以用 useCallback 或者 useMemo 解决这个问题，useCallback 首选，这个 hooks 初衷就是为了解决这种情况的。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> callback = React.useCallback(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handerCallback</span>(<span class="hljs-params"></span>)</span>{},[])
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Index</span> <span class="hljs-attr">callback</span>=<span class="hljs-string">{callback}</span>  /></span></span>
}
</code></pre>
<p>useCallback 接受二个参数，第一个参数就是需要缓存的函数，第二个参数为deps, deps 中依赖项改变返回新的函数。如上处理之后，就能从根本上解决 PureComponent 失效问题。</p>
<p><strong>｜--------问与答---------｜</strong><br></p>
<p><code>useCallback</code> 和 <code>useMemo</code> 有什么区别？</p>
<p>答：useCallback 第一个参数就是缓存的内容，useMemo 需要执行第一个函数，返回值为缓存的内容，比起 useCallback ， useMemo 更像是缓存了一段逻辑，或者说执行这段逻辑获取的结果。那么对于缓存 element 用 useCallback 可以吗，答案是当然可以了。</p>
<p><strong>｜----------------------｜</strong><br></p>
<h3>3 shouldComponentUpdate</h3>
<p>有的时候，把控制渲染，性能调优交给 React 组件本身处理显然是靠不住的，React 需要提供给使用者一种更灵活配置的自定义渲染方案，使用者可以自己决定是否更新当前组件，shouldComponentUpdate 就能达到这种效果。在生命周期章节介绍了 shouldComponentUpdate 的用法，接下来试一下 shouldComponentUpdate 如何使用。</p>
<pre><code class="hljs language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{ <span class="hljs-comment">//子组件</span>
    state={
        <span class="hljs-attr">stateNumA</span>:<span class="hljs-number">0</span>,
        <span class="hljs-attr">stateNumB</span>:<span class="hljs-number">0</span>
    }
    <span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params">newProp,newState,newContext</span>)</span>{
        <span class="hljs-keyword">if</span>(newProp.propsNumA !== <span class="hljs-built_in">this</span>.props.propsNumA || newState.stateNumA !== <span class="hljs-built_in">this</span>.state.stateNumA ){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">/* 只有当 props 中 propsNumA 和 state 中 stateNumA 变化时，更新组件  */</span>
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> 
    }
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'组件渲染'</span>)
        <span class="hljs-keyword">const</span> { stateNumA ,stateNumB } = <span class="hljs-built_in">this</span>.state
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> this.setState({ stateNumA: stateNumA + 1 }) } >改变state中numA<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> this.setState({ stateNumB: stateNumB + 1 }) } >改变stata中numB<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>hello,let us learn React!<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Home</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-comment">// 父组件</span>
    <span class="hljs-keyword">const</span> [ numberA , setNumberA ] = React.useState(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> [ numberB , setNumberB ] = React.useState(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> setNumberA(numberA + 1) } >改变props中numA<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span> setNumberB(numberB + 1) } >改变props中numB<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Index</span> <span class="hljs-attr">propsNumA</span>=<span class="hljs-string">{numberA}</span>  <span class="hljs-attr">propsNumB</span>=<span class="hljs-string">{numberB}</span>   /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p><strong>效果</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1be67563c9ba4e3487b8209664439491~tplv-k3u1fbpfcp-watermark.image" alt="4.gif"></p>
<p>shouldComponentUpdate 可以根据传入的新的 props 和 state ，或者  newContext 来确定是否更新组件，如上面例子🌰，只有当 props 中 propsNumA 属性和 state 中 stateNumA 改变的时候，组件才渲染。但是有一种情况就是如果子组件的 props 是引用数据类型，比如 object ，还是不能直观比较是否相等。那么如果想有对比新老属性相等，怎么对比呢，而且很多情况下，组件中数据可能来源于服务端交互，对于属性结构是未知的。</p>
<p><code>immutable.js</code> 可以解决此问题，immutable.js 不可变的状态，对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。鉴于这个功能，所以可以把需要对比的 props 或者 state 数据变成 Immutable 对象，通过对比 Immutable 是否相等，来证明状态是否改变，从而确定是否更新组件。</p>
<p>对于 shouldComponentUpdate 生命周期篇章和上面都有提及，它的执行是在 checkShouldComponentUpdate，会执行此生命周期。</p>
<h3>4 React.memo</h3>
<pre><code class="hljs language-js">React.memo(Component,compare)
</code></pre>
<p>React.memo 可作为一种容器化的控制渲染方案，可以对比 props 变化，来决定是否渲染组件，首先先来看一下 memo 的基本用法。React.memo 接受两个参数，第一个参数 Component 原始组件本身，第二个参数 compare 是一个函数，可以根据一次更新中 props 是否相同决定原始组件是否重新渲染。</p>
<p>memo的几个特点是：</p>
<ul>
<li>React.memo: 第二个参数 返回 true 组件不渲染 ， 返回 false 组件重新渲染。和 shouldComponentUpdate 相反，shouldComponentUpdate : 返回 true 组件渲染 ， 返回 false 组件不渲染。</li>
<li>memo 当二个参数 compare 不存在时，会用<strong>浅比较原则</strong>处理 props ，相当于仅比较 props 版本的 pureComponent 。</li>
<li>memo 同样适合类组件和函数组件。</li>
</ul>
<p>被 memo 包裹的组件，element 会被打成 <code>REACT_MEMO_TYPE</code> 类型的 element 标签，在 element 变成 fiber 的时候， fiber 会被标记成 MemoComponent 的类型。</p>
<blockquote>
<p>react/src/ReactMemo.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memo</span>(<span class="hljs-params">type,compare</span>)</span>{
  <span class="hljs-keyword">const</span> elementType = {
    <span class="hljs-attr">$$typeof</span>: REACT_MEMO_TYPE, 
    type,  <span class="hljs-comment">// 我们的组件</span>
    <span class="hljs-attr">compare</span>: compare === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : compare,  <span class="hljs-comment">//第二个参数，一个函数用于判断prop，控制更新方向。</span>
  };
  <span class="hljs-keyword">return</span> elementType
}
</code></pre>
<blockquote>
<p>react-reconciler/src/ReactFiber.js</p>
</blockquote>
<pre><code class="hljs language-js">  <span class="hljs-keyword">case</span> REACT_MEMO_TYPE:
  fiberTag = MemoComponent;
</code></pre>
<p>那么对于 MemoComponent React 内部又是如何处理的呢？首先 React 对 MemoComponent 类型的 fiber 有单独的更新处理逻辑 updateMemoComponent 。首先一起看一下主要逻辑：</p>
<blockquote>
<p>react-reconciler/src/ReactFiberBeginWork.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateMemoComponent</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">if</span> (updateExpirationTime &#x3C; renderExpirationTime) {
         <span class="hljs-keyword">let</span> compare = Component.compare;
         compare = compare !== <span class="hljs-literal">null</span> ? compare : shallowEqual <span class="hljs-comment">//如果 memo 有第二个参数，则用二个参数判定，没有则浅比较props是否相等。</span>
        <span class="hljs-keyword">if</span> (compare(prevProps, nextProps) &#x26;&#x26; current.ref === workInProgress.ref) {
            <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime); <span class="hljs-comment">//已经完成工作停止向下调和节点。</span>
        }
    }
    <span class="hljs-comment">// 返回将要更新组件,memo包装的组件对应的fiber，继续向下调和更新。</span>
}
</code></pre>
<p>memo 主要逻辑是</p>
<ul>
<li>通过 memo 第二个参数，判断是否执行更新，如果没有那么第二个参数，那么以浅比较 props 为 diff 规则。如果相等，当前 fiber 完成工作，停止向下调和节点，所以被包裹的组件即将不更新。</li>
<li>memo 可以理解为包了一层的高阶组件，它的阻断更新机制，是通过控制下一级 children ，也就是 memo 包装的组件，是否继续调和渲染，来达到目的的。</li>
</ul>
<p>接下来做一个小案例，利用 memo 做到自定义 props 渲染。
规则： 控制 props 中的 number 。</p>
<ul>
<li>1 只有 number 更改，组件渲染。</li>
<li>2 只有 number 小于 5 ，组件渲染。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TextMemo</span>(<span class="hljs-params">props</span>)</span>{ / /子组件
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'子组件渲染'</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>hello,world<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span> 
}
<span class="hljs-keyword">const</span> controlIsRender = <span class="hljs-function">(<span class="hljs-params">pre,next</span>)=></span>{
   <span class="hljs-keyword">return</span> ( pre.number === next.number ) ||  (pre.number !== next.number &#x26;&#x26; next.number > <span class="hljs-number">5</span>) <span class="hljs-comment">// number不改变或number 改变但值大于5->不渲染组件 | 否则渲染组件</span>
}
<span class="hljs-keyword">const</span> NewTexMemo = memo(TextMemo,controlIsRender)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>{
        <span class="hljs-built_in">super</span>(props)
        <span class="hljs-built_in">this</span>.state={
            <span class="hljs-attr">number</span>:<span class="hljs-number">1</span>,
            <span class="hljs-attr">num</span>:<span class="hljs-number">1</span>
        }
    }
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">const</span> { num , number }  = <span class="hljs-built_in">this</span>.state
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
                改变num：当前值 { num }  
                <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span>this.setState({ num:num + 1 }) } >num++<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
                <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span>this.setState({ num:num - 1 }) } >num--<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>  
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
                改变number： 当前值 { number } 
                <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span>this.setState({ number:number + 1 }) } > number ++<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
                <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> ()=></span>this.setState({ number:number - 1 }) } > number -- <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>  
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">NewTexMemo</span> <span class="hljs-attr">num</span>=<span class="hljs-string">{</span> <span class="hljs-attr">num</span> } <span class="hljs-attr">number</span>=<span class="hljs-string">{number}</span>  /></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    }
}
</code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823787ff6ac5492c9da013b1acb4dfbc~tplv-k3u1fbpfcp-watermark.image" alt="memo.gif"></p>
<p><strong>完美达到效果</strong></p>
<p>memo 注意事项，像如下这样，一般情况下不要试图组件通过第二个参数直接返回 true 来阻断渲染。这样可能会造成很多麻烦。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 尽量不要这么尝试</span>
<span class="hljs-keyword">const</span> NewIndex = React.memo(Index,<span class="hljs-function">() =></span> <span class="hljs-literal">true</span> )
</code></pre>
<h3>5 打破渲染限制</h3>
<ul>
<li>
<p>1 forceUpdate。类组件更新如果调用的是 forceUpdate 而不是  setState ，会跳过 PureComponent 的浅比较和 shouldComponentUpdate 自定义比较。其原理是组件中调用 forceUpdate 时候，全局会开启一个 hasForceUpdate 的开关。当组件更新的时候，检查这个开关是否打开，如果打开，就直接跳过 shouldUpdate 。</p>
</li>
<li>
<p>2 context穿透，上述的几种方式，都不能本质上阻断 context 改变，而带来的渲染穿透，所以开发者在使用 Context 要格外小心，既然选择了消费 context ，就要承担 context 改变，带来的更新作用。</p>
</li>
</ul>
<h3>6 渲染控制流程图</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3df03000a39549bead3c84750c62576c~tplv-k3u1fbpfcp-watermark.image" alt="5.jpg"></p>
<h2>四 对于render的思考</h2>
<h3>1 有没有必要在乎组件不必要渲染。</h3>
<p>在正常情况下，无须过分在乎 React 没有必要的渲染，要理解执行 render 不等于真正的浏览器渲染视图，render 阶段执行是在 js 当中，js 中运行代码远快于浏览器的 Rendering 和 Painting 的，更何况 React 还提供了 diff 算法等手段，去复用真实 DOM 。</p>
<h3>2 什么时候需要注意渲染节流。</h3>
<p>但是对于以下情况，值得开发者注意，需要采用渲染节流：</p>
<ul>
<li>
<p>第一种情况数据可视化的模块组件（展示了大量的数据），这种情况比较小心因为一次更新，可能伴随大量的 diff ，数据量越大也就越浪费性能，所以对于数据展示模块组件，有必要采取 memo ， shouldComponentUpdate 等方案控制自身组件渲染。</p>
</li>
<li>
<p>第二种情况含有大量表单的页面，React 一般会采用受控组件的模式去管理表单数据层，表单数据层完全托管于 props 或是 state ，而用户操作表单往往是频繁的，需要频繁改变数据层，所以很有可能让整个页面组件高频率 render 。</p>
</li>
<li>
<p>第三种情况就是越是靠近 app root 根组件越值得注意，根组件渲染会波及到整个组件树重新 render ，子组件 render ，一是浪费性能，二是可能执行 useEffect ，componentWillReceiveProps 等钩子，造成意想不到的情况发生。</p>
</li>
</ul>
<h3>3 一些开发中的细节问题</h3>
<ul>
<li>开发过程中对于大量数据展示的模块，开发者有必要用 shouldComponentUpdate ，PureComponent来优化性能。</li>
<li>对于表单控件，最好办法单独抽离组件，独自管理自己的数据层，这样可以让 state 改变，波及的范围更小。</li>
<li>如果需要更精致化渲染，可以配合 immutable.js 。</li>
<li>组件颗粒化，配合 memo 等 api ，可以制定私有化的渲染空间。</li>
</ul>
<h2>五 总结</h2>
<p>本节主要讲了：</p>
<ol>
<li>详细介绍React的几种控制渲染，优化渲染的手段及其原理。</li>
<li>关于React什么情况下适合做渲染优化。及其开发过程中一些细节问题。</li>
</ol></div>
</body></html>