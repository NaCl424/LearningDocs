<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>生态篇-React-mobx</h1>
<h2>一 前言</h2>
<p>本章节将继续介绍 React 的另外一个状态管理工具 React-Mobx 。希望通过本章节的学习，你能收获：</p>
<ul>
<li>Mobx 的特性及其基本使用；</li>
<li>Mobx ，React-Mobx 原理解析（源码级别）；</li>
<li>Mobx 和 Redux 区别。</li>
</ul>
<blockquote>
<p>注意：今天讲的 Mobx 为 <code>v6</code> 版本，Mobx-React 为 <code>v7</code> 版本。</p>
</blockquote>
<h2>二 Mobx特性</h2>
<p>同为状态管理工具，Mobx 和 Redux 本质上上有很大的区别，但是 Mobx 和 Redux 都是独立的，不依赖于 React 本身；为了把 React 和 Mobx 关联起来，在 React 应用中更好的使用 Mobx ，出现了 mobx-react ， mobx-react 提供了 HOC ，可以获取状态管理 Mobx 的数据层，也能接受 mobx 数据改变带来的更新。</p>
<p><strong>①观察者模式</strong></p>
<p>Mobx 采用了一种'观察者模式'——<code>Observer</code>，整个设计架构都是围绕 Observer 展开：</p>
<ul>
<li>在 mobx 的状态层，每一个需要观察的属性都会添加一个观察者，可以称之为 <code>ObserverValue</code> 。</li>
<li>有了观察者，那么就需要向观察者中收集 listener ，mobx 中有一个 Reaction 模块，可以对一些行为做依赖收集，在 React 中，是通过劫持 render 函数执行行为，进行的依赖收集。</li>
<li>如何监听改变，用自定义存取器属性中的 get 和 set ，来进行的依赖收集和更新派发，当状态改变，观察者会直接精确通知每个 listener 。</li>
</ul>
<p><strong>②状态提升</strong></p>
<p>在正常情况下，在 React 应用中使用 Mobx ，本质上 mobx 里面的状态，并不是存在 React 组件里面的，是在外部由一个个 mobx 的模块 model 构成，每一个 model 可以理解成一个对象，状态实质存在 model 中，model 状态通过 props 添加到组件中，可以用 mobx-react 中的 Provder 和 inject 便捷获取它们，虽然 mobx 中响应式处理这些状态，但是不要试图直接修改 props 来促使更新，这样违背了 React Prop 单向数据流的原则。正确的处理方法，还是通过 model 下面的 action 方法，来改变状态，React 实质上调用的是 action 方法。</p>
<p><strong>③装饰器模式</strong></p>
<p>为了建立观察者模式，便捷地获取状态/监听状态，mobx 很多接口都支持装饰器模式的写法，所以在 mobx 中，装饰器模式是最常用的写法，如果不知道装饰器的同学，建议先了解一下下 ts 中<code>decorator</code>，由于不是本章节的内容，我这里就不介绍了。比如如下就是 mobx 中装饰器的体现：</p>
<pre><code class="hljs language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Root</span></span>{
    @observable name = <span class="hljs-string">'alien'</span> <span class="hljs-comment">/* 建立观察者name属性 */</span>
    @action <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params">name</span>)</span>{  <span class="hljs-built_in">this</span>.name = name   }  <span class="hljs-comment">/* 改变 name 属性 */</span>
}
</code></pre>
<p>目前 typescript 已经全面支持如上写法，如果在 javascript 中直接使用会报错，所以通常需要在<code>.babelrc</code> 中这么配置一下：</p>
<pre><code class="hljs language-json">{
    <span class="hljs-attr">"plugins"</span>:[
         [
          <span class="hljs-string">"@babel/plugin-proposal-decorators"</span>,
          {
            <span class="hljs-attr">"legacy"</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">"loose"</span>: <span class="hljs-literal">true</span>
          }
        ],
        <span class="hljs-string">"@babel/plugin-proposal-class-properties"</span>,
    ]
}
</code></pre>
<p>如上添加配置后，就可以在 js 中正常使用装饰器模式了。</p>
<p><strong>④精确颗粒化收集</strong></p>
<p>mobx 还有一个重要特点，就是对于属性的依赖收集是精确的，颗粒化的，为什么这么说呢？比如在 mobx 一个模块如下写道：</p>
<pre><code class="hljs language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Root</span> </span>{
    @observable object = {                  <span class="hljs-comment">//C组件使用</span>
         <span class="hljs-attr">name</span>:<span class="hljs-string">'alien'</span>,                     <span class="hljs-comment">// A组件使用</span>
         <span class="hljs-attr">mes</span>:<span class="hljs-string">'let us learn React!'</span>         <span class="hljs-comment">// B组件使用</span>
    }
    @action <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params">name</span>)</span>{ <span class="hljs-built_in">this</span>.object.name = name  }
    @action <span class="hljs-function"><span class="hljs-title">setMes</span>(<span class="hljs-params">mes</span>)</span>{ <span class="hljs-built_in">this</span>.object.mes = mes }
    @action <span class="hljs-function"><span class="hljs-title">setObject</span>(<span class="hljs-params">object</span>)</span>{ <span class="hljs-built_in">this</span>.object = object  }
}
</code></pre>
<ul>
<li>对于 observable 处理过的属性，每一个属性都会有 ObserverValue ，比如上面的结构会产生三个 ObserverValue ，分别对应 object ，name ，mes 。</li>
<li>当上面通过 setName 改变 name 属性的时候，只有组件 A 会更新。也就是 name ObserverValue 只收集了用到 name 的依赖项 A 组件。</li>
<li>调用 setMes 同理，只有组件 B 更新。 mes  ObserverValue 只收集了 B 组件的依赖。</li>
<li>当上面通过 setObject 改变 object 的时候，即使 object 里面name ，mes 的值没有变化，也会让组件 A ，组件 B ，组件 C ，全部渲染。object 的 Observer 同样收集了name的 ObserverValue 和 mes 的 ObserverValue 。</li>
</ul>
<p>模型图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1268c78788bd436887d91d9d997b680a~tplv-k3u1fbpfcp-watermark.image" alt="2.jpg"></p>
<p><strong>⑤引用类型处理</strong></p>
<p>observable 对于引用数据类型，比如 Object ，Array ，Set ，Map等，除了新建一个 observable 之外，还会做如下两点操作。</p>
<ul>
<li>
<p>一 <code>Proxy</code>：会把原始对象用 Proxy 代理，Proxy 会精确响应原始对象的变化，比如增加属性——给属性绑定 ObserverValue ，删除属性——给属性解绑 ObserverValue 等。</p>
</li>
<li>
<p>二 <code>ObservableAdministration</code>： 对于子代属性，会创建一个 <code>ObservableAdministration</code>，用于管理子代属性的ObserverValue。</p>
</li>
<li>
<p>对于外层 Root ，在 <code>constructor</code> 使用 <code>makeObservable</code> ，mobx 会默认给最外层的 Root 添加 ObservableAdministration 。</p>
</li>
</ul>
<h2>三 基本用法</h2>
<h3>1 Mobx基本使用</h3>
<h4>mobx常用api</h4>
<p>把上述每一个 class 称之为一个模块，如上述 Root 就是一个模块。mobx的 api 基本用于构建每一个响应式模块。</p>
<p><strong>① makeObservable</strong></p>
<p>在新版本 mobx 中，想要让整个模块变成可响应式的，那么需要在 constructor 调用 makeObservable。老版本的 mobx 不需要这么做。</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>{ makeObservable(<span class="hljs-built_in">this</span>) }
</code></pre>
<p><strong>② observable</strong></p>
<p>会给属性值加一个观察者对象，使其能变成可观察的，当属性值改变的时候，观察者会通知每一个依赖项。</p>
<pre><code class="hljs language-js">@observable name = <span class="hljs-string">'《React进阶实践指南》'</span>
</code></pre>
<p><strong>③action</strong></p>
<p>通过 action 包裹的函数，可以用来修改 mobx 中的状态。</p>
<pre><code class="hljs language-js">@action <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params">newName</span>)</span>{ <span class="hljs-built_in">this</span>.name = newName  }
</code></pre>
<p><strong>④computed</strong></p>
<p>根据现有的状态或其它计算值衍生出的值。如下 total 是通过 price 和 count 衍生出来的新值。</p>
<pre><code class="hljs language-js">@observable price = <span class="hljs-number">666</span>  <span class="hljs-comment">// 可观察属性——价格</span>
@observable count = <span class="hljs-number">1</span>    <span class="hljs-comment">// 可观察属性——数量</span>
@computed <span class="hljs-keyword">get</span> <span class="hljs-title">total</span>() {  
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.price * <span class="hljs-built_in">this</span>.count
}
</code></pre>
<h4>mobx-react 常用 api</h4>
<p>mobx-react 中的 api ，用于把 mobx 中的状态，提供给组件，并把组件也变成可观察的 —— mobx 状态改变，组件触发更新。</p>
<p><strong>①Provider</strong></p>
<p>用于把 mobx 的各个模块，用 Context 上下文形式，保存起来，供给组件使用。</p>
<pre><code class="hljs language-js">&#x3C;Provider Root={Root} > { <span class="hljs-comment">/* ... */</span> } &#x3C;/Provider>
</code></pre>
<p><strong>②inject</strong></p>
<p>inject 高阶组件可以把 Provider 中的 mobx 模块，混入到组件的 props 中，所以就可以在组件中消费状态，或者调用改变状态的方法。</p>
<pre><code class="hljs language-js">@inject(<span class="hljs-string">'Root'</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{}
</code></pre>
<p><strong>③observer</strong></p>
<p>被 observer 高阶组件包装的组件，如果组件内部引入了 mobx 可观察属性值，当值改变的时候，会追溯到当前组件，促使当前组件更新。</p>
<pre><code class="hljs language-js">@observer
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{}
</code></pre>
<p>上面介绍了一遍 mobx 和 mobx-react 的各个部分功能，接下来针对两种使用场景进行实践。</p>
<h3>2 实践——实现状态共享</h3>
<p>接下来用 mobx 实现状态共享场景。首先创建 Root 模块，用于保存全局的一些数据。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { observable ,action ,makeObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">'mobx'</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Root</span></span>{
   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>{
      makeObservable(<span class="hljs-built_in">this</span>)
   }
   @observable info={ <span class="hljs-attr">name</span>:<span class="hljs-string">'xxx'</span>, <span class="hljs-attr">mes</span>:<span class="hljs-string">'xxx'</span> }
   <span class="hljs-comment">// @observable number = 1</span>
   @action <span class="hljs-function"><span class="hljs-title">setInfo</span>(<span class="hljs-params">info</span>)</span>{  <span class="hljs-built_in">this</span>.info = info }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Root()
</code></pre>
<p>根本组件注入状态：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> Root <span class="hljs-keyword">from</span> <span class="hljs-string">'./mobx'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Provider</span> <span class="hljs-attr">Root</span>=<span class="hljs-string">{Root}</span> ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Child</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">Provider</span>></span></span>
}
</code></pre>
<ul>
<li>全局通过 mobx-react 中的 Provider 传递内容。</li>
</ul>
<p>使用状态：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> getUserInfo = <span class="hljs-function">() =></span> {
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((<span class="hljs-function"><span class="hljs-params">resolve</span>=></span>{
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=></span>{resolve({ <span class="hljs-attr">name</span>:<span class="hljs-string">'alien'</span>, <span class="hljs-attr">mes</span>:<span class="hljs-string">'let us learn React!'</span>})
       },<span class="hljs-number">1000</span>)
   }))
}
@inject(<span class="hljs-string">'Root'</span>)
@observer
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>{
       <span class="hljs-comment">/*  模拟数据交互 */</span>
       <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> getUserInfo()
       <span class="hljs-built_in">this</span>.props.Root.setInfo(res)
    }
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">const</span> { info } = <span class="hljs-built_in">this</span>.props.Root
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"box"</span> ></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span> 姓名：{info.name} <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span> 想对大家说：{info.mes} <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    }
}
</code></pre>
<ul>
<li>inject 引入 Root，observer 做数据响应，模拟数据交互，调用 setInfo 改变 Root 中 info 内容。 info 内容改变，重新渲染视图。</li>
</ul>
<h3>3 实践——实现组件通信</h3>
<p>接下来模拟组件通信场景：首先注册模块用于组件通信。</p>
<pre><code class="hljs language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Communi</span> </span>{
   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>{
       makeObservable(<span class="hljs-built_in">this</span>)
   }
   @observable mesA = <span class="hljs-string">''</span>
   @observable mesB = <span class="hljs-string">''</span>
   @action <span class="hljs-function"><span class="hljs-title">setMesA</span>(<span class="hljs-params">mes</span>)</span>{ <span class="hljs-built_in">this</span>.mesA = mes }
   @action <span class="hljs-function"><span class="hljs-title">setMesB</span>(<span class="hljs-params">mes</span>)</span>{ <span class="hljs-built_in">this</span>.mesB = mes }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Communi()
</code></pre>
<p>然后建立A，B组件实现通信功能：</p>
<pre><code class="hljs language-js">@inject(<span class="hljs-string">'Communi'</span>)
@observer
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{ <span class="hljs-comment">/* 组件A */</span>
    state={ <span class="hljs-attr">CompAsay</span>:<span class="hljs-string">''</span>}
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">const</span> { CompAsay } = <span class="hljs-built_in">this</span>.state
        <span class="hljs-keyword">const</span> { mesB  } = <span class="hljs-built_in">this</span>.props.Communi
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"box"</span> ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>我是组件A<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> B组件对我说：{mesB} <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        我对B组件说： <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> this.setState({ CompAsay :e.target.value })} placeholder="CompAsay" />
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> this.props.Communi.setMesA(CompAsay)} >确定<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    }
}
@inject(<span class="hljs-string">'Communi'</span>)
@observer
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{ <span class="hljs-comment">/* 组件B */</span>
   state={ <span class="hljs-attr">compBsay</span>:<span class="hljs-string">''</span>}
   <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
       <span class="hljs-keyword">const</span> { compBsay } = <span class="hljs-built_in">this</span>.state
       <span class="hljs-keyword">const</span> {  mesA  } = <span class="hljs-built_in">this</span>.props.Communi
       <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"box pt50"</span> ></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>我是组件B<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> A组件对我说：{mesA} <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
           我对A组件说：<span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> this.setState({ compBsay :e.target.value })}  placeholder="CompAsay" />
           <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> this.props.Communi.setMesB(compBsay)} >确定<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
       <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
   }
}
</code></pre>
<p>效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b80f4d277744fe6999e214f036d97fb~tplv-k3u1fbpfcp-watermark.image" alt="1.gif"></p>
<h2>四 Mobx流程分析和原理揭秘</h2>
<p>接下来开始正式进入 Mobx 流程分析和原理揭秘环节。从本章节的第二部分，就开始介绍了 mobx 内部，可观察属性 ObserverValue 最后会被mobx 底层处理的样子。于是顺藤摸瓜，剖析 mobx 的整个流程。</p>
<p>可以从三个角度分析 mobx 和 mobx-react 整个流程：</p>
<ul>
<li><strong>初始化</strong>：首先就是 mobx 在初始化的时候，是如何处理 observable 可观察属性的。</li>
<li><strong>依赖收集</strong>：第二点就是通过 mobx-react 中的 observer ，如何收集依赖项，与 observable 建立起关系的。</li>
<li><strong>派发更新</strong>：最后就是当改变可观察属性的值的时候，如何更新对应组件的。</li>
</ul>
<p>比如如下在 mobx 中的一个模块这么写道（这里称之为 <strong>DEMO1</strong> ）：</p>
<pre><code class="hljs language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Root</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>{ makeObservable(<span class="hljs-built_in">this</span>) }
    @observable authorInfo = {
        <span class="hljs-attr">name</span>:<span class="hljs-string">'alien'</span>,
        <span class="hljs-attr">mes</span>:{
            <span class="hljs-attr">say</span>:<span class="hljs-string">'let us learn React!'</span>,
        }
    }
    @observable name=<span class="hljs-string">'《React进阶实践指南》'</span>
    @action <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params">newName</span>)</span>{ <span class="hljs-built_in">this</span>.name = newName  }
}
</code></pre>
<p>以上面的 DEMO1 作为基础参考。</p>
<h3>1 模块初始化</h3>
<p>首先是模块初始化流程。可以从 <code>makeObservable</code> 和 <code>observable</code> 入手。</p>
<p>首先被 observable 装饰器包裹的属性到底做了些什么呢？</p>
<h4>①绑定状态——observable</h4>
<blockquote>
<p>mobx/src/api/observable.ts</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObservable</span>(<span class="hljs-params">target,name,descriptor</span>)</span>{ <span class="hljs-comment">// 对于如上DEMO1，target——Root类，name——属性名称 authorInfo 或者 name ，descriptor——属性描述，枚举性，可读性等</span>
     <span class="hljs-keyword">if</span>(isStringish(name)){ <span class="hljs-comment">/* 装饰器模式下 */</span>
         target[<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"mobx-stored-annotations"</span>)][name] = { <span class="hljs-comment">/* 向类的mobx-stored-annotations属性的name属性上，绑定 annotationType_ ， extend_ 等方法。 */</span>
            <span class="hljs-attr">annotationType_</span>: <span class="hljs-string">'observable'</span>,  <span class="hljs-comment">//这个标签证明是 observable，除了observable，还有 action， computed 等。</span>
            <span class="hljs-attr">options_</span>: <span class="hljs-literal">null</span>,
            make_,  <span class="hljs-comment">// 这个方法在类组件 makeObservable 会被激活</span>
            extend_ <span class="hljs-comment">// 这个方法在类组件 makeObservable 会被激活</span>
        }
     }       
}
</code></pre>
<ul>
<li>被 observable 装饰器包装的属性，本质上就是调用createObservable 方法。</li>
<li>通过 <code>createObservable</code> 将类上绑定当前 observable 对应的配置项，说白了，就是给 observable 绑定的属性添加一些额外的状态，这些状态将在类实例化的时候 <code>makeObservable</code> 中被激活。</li>
</ul>
<p>这里有必要先记录一下 <code>make_</code> 和 <code>extend_</code> 方法，都做了些什么。</p>
<blockquote>
<p>mobx/src/types/createObservableAnnotation.ts</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make_</span>(<span class="hljs-params">adm,key,descriptor</span>)</span>{ <span class="hljs-comment">/*  */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.extend_(adm,key,descriptor)
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend_</span>(<span class="hljs-params">adm,key,descriptor</span>)</span>{
    <span class="hljs-keyword">return</span> adm.defineObservableProperty_(key,descriptor,options)
}
</code></pre>
<ul>
<li>需要记住一点就是：当调用 observable 配置项的 make_ ，本质上调用 <code>adm.defineObservableProperty_</code> ，至于这个是什么，马上就会讲到。</li>
</ul>
<h4>②激活状态——makeObservable</h4>
<p>上边讲到过，在新版本 mobx 中，必须在类的 constructor 中调用<code>makeObservable(this)</code> 才能建立响应式。一起看一下makeObservable。</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeObservable</span> (<span class="hljs-params">target</span>)</span>{ <span class="hljs-comment">// target 模块实例——this</span>
    <span class="hljs-keyword">const</span> adm = <span class="hljs-keyword">new</span> ObservableObjectAdministration(target) <span class="hljs-comment">/* 创建一个管理者——这个管理者是最上层的管理者，管理模块下的observable属性 */</span>
    target[<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"mobx administration"</span>)] = adm  <span class="hljs-comment">/* 将管理者 adm 和 class 实例建立起关联 */</span>
    startBatch()
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">let</span> annotations = target[<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"mobx-stored-annotations"</span>] <span class="hljs-comment">/* 上面第一步说到，获取状态 */</span>
        <span class="hljs-built_in">Reflect</span>.ownKeys(annotations)  <span class="hljs-comment">/* 得到每个状态名称 */</span>
        .forEach(<span class="hljs-function"><span class="hljs-params">key</span> =></span> adm.make_(key, annotations[key])) <span class="hljs-comment">/* 对每个属性调用 */</span>
    }<span class="hljs-keyword">finally</span>{
        endBatch()
    }
}
</code></pre>
<p>makeObservable 主要做的事有以下两点：</p>
<ul>
<li>创建一个管理者 <code>ObservableAdministration</code> ，上面讲到过，管理者就是为了管理子代属性的 ObservableValue 。并和模块实例建立起关系。</li>
<li>然后会遍历观察者状态下的每一个属性，将每个属性通过<code>adm.make_</code>处理，值得注意的是，<strong>这个make_是管理者的，并不是属性状态的make_，这一点不要弄混淆了</strong>。</li>
</ul>
<p>接下来一起看一下，管理者 ObservableAdministration 里面是如何管理状态的。</p>
<h4>③观察者属性管理者——ObservableAdministration</h4>
<p>细心的同学应该会发现，上述初始化创建的管理者，调用的是  <code>ObservableObjectAdministration</code> ，实际在 mobx 内部会存在多个种类的管理者，比如数组，对象数据类型。因为不同的类型，里面的方法和状态都是不同的。本文是以对象的管理者作为参考。</p>
<blockquote>
<p>mobx/src/types/observableobject.ts</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableObjectAdministration</span></span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">target_,values_</span>)</span>{
        <span class="hljs-built_in">this</span>.target_ = target_
        <span class="hljs-built_in">this</span>.values_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>() <span class="hljs-comment">//存放每一个属性的ObserverValue。</span>
    }
    <span class="hljs-comment">/* 调用 ObserverValue的 get —— 收集依赖  */</span>
    <span class="hljs-function"><span class="hljs-title">getObservablePropValue_</span>(<span class="hljs-params">key</span>)</span>{ 
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.values_.get(key)!.get()
    }
    <span class="hljs-comment">/* 调用 ObserverValue的 setNewValue_   */</span>
    <span class="hljs-function"><span class="hljs-title">setObservablePropValue_</span>(<span class="hljs-params">key,newValue</span>)</span>{
        <span class="hljs-keyword">const</span> observable = <span class="hljs-built_in">this</span>.values_.get(key)
        observable.setNewValue_(newValue) <span class="hljs-comment">/* 设置新值 */</span>
    }
    <span class="hljs-function"><span class="hljs-title">make_</span>(<span class="hljs-params">key,annotation</span>)</span>{ <span class="hljs-comment">// annotation 为每个observable对应的配置项的内容，{ make_,extends }</span>
        <span class="hljs-keyword">const</span> outcome = annotation.make_(<span class="hljs-built_in">this</span>, key, descriptor, source)
    }
    <span class="hljs-comment">/* 这个函数很重要，用于劫持对象上的get,set */</span>
    <span class="hljs-function"><span class="hljs-title">defineObservableProperty_</span>(<span class="hljs-params">key,value</span>)</span>{
        <span class="hljs-keyword">try</span>{
            startBatch()
            <span class="hljs-keyword">const</span> descriptor = {
                <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>{      <span class="hljs-comment">// 当我们引用对象下的属性，实际上触发的是 getObservablePropValue_</span>
                   <span class="hljs-built_in">this</span>.getObservablePropValue_(key)
                },
                <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">value</span>)</span>{ <span class="hljs-comment">// 当我们改变对象下的属性，实际上触发的是 setObservablePropValue_</span>
                   <span class="hljs-built_in">this</span>.setObservablePropValue_(key,value)
                }
            }
            <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">this</span>.target_, key , descriptor)
            <span class="hljs-keyword">const</span> observable = <span class="hljs-keyword">new</span> ObservableValue(value) <span class="hljs-comment">// 创建一个 ObservableValue</span>
            <span class="hljs-built_in">this</span>.values_.set(key, observable)             <span class="hljs-comment">// 设置observable到value中</span>
        }<span class="hljs-keyword">finally</span>{
            endBatch()
        }
    }
}
</code></pre>
<p>回到主流程上来，当 mobx 底层遍历观察者属性，然后调用 make_ 方法的时候，本质上调用的是如上 make_ 方法，会激活当前的 observable 属性，触发 observable 配置项上的 make_ 方法，然后就会进入真正的添加观察者属性环节 <code>defineObservableProperty_</code> 。</p>
<ul>
<li>首先会通过 <strong>Object.defineProperty</strong> ，拦截对象的属性，添加get，set ，比如组件中引用对象上的属性，调用 get ——本质上调用 <code>getObservablePropValue_</code> ，在 observableValues 调用的是 get 方法；当修改对象上的属性，调用 set ——本质上调用  <code>setObservablePropValue_</code> ，setObservablePropValue_ 调用的是 ObservableValues 上的 <code>setNewValue_</code> 方法。</li>
<li>对于每一个属性会增加一个观察者 ObservableValue ，然后把当前 ObservableValue 放入管理者 ObservableAdministration 的 values_ 属性上。</li>
</ul>
<p>到此为止，形成了如下的模型图结构：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b46e88e4ac7c4a24a61c4e9bc56617e8~tplv-k3u1fbpfcp-watermark.image" alt="3.jpg"></p>
<h3>2 依赖收集</h3>
<p>如上详细介绍了初始化过程，接下来一起研究一下依赖收集流程。通过初始化过程，还遗留一点就是 ObservableValue 做了哪些事？</p>
<h4>①观察者——ObservableValue</h4>
<p>上面我知道了只要通过 @observable 包裹，就会创建一个 ObservableValue 。</p>
<p>在 Mobx 有一个核心的思想就是 Atom 主要是收集依赖，通知依赖。先来看一下 Atom 的重点方法:</p>
<blockquote>
<p>mobx/src/core/atom.ts</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Atom</span></span>{
    observers_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>() <span class="hljs-comment">/* 存放每个组件的 */</span>
    <span class="hljs-comment">/* value改变，通知更新 */</span>
    <span class="hljs-function"><span class="hljs-title">reportChanged</span>(<span class="hljs-params"></span>)</span> {
        startBatch()
        propagateChanged(<span class="hljs-built_in">this</span>)
        endBatch()
    }
    <span class="hljs-comment">/* 收集依赖 */</span>
    <span class="hljs-function"><span class="hljs-title">reportObserved</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">return</span> reportObserved(<span class="hljs-built_in">this</span>)
    }
}
</code></pre>
<p>ObservableValue 继承了 Atom。</p>
<blockquote>
<p>mobx/src/types/observablevalue.ts</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableValue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Atom</span></span>{
    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-comment">//adm.getObservablePropValue_ 被调用</span>
        <span class="hljs-built_in">this</span>.reportObserved() <span class="hljs-comment">// 调用Atom中 reportObserved</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dehanceValue(<span class="hljs-built_in">this</span>.value_)
    }
    <span class="hljs-function"><span class="hljs-title">setNewValue_</span>(<span class="hljs-params">newValue</span>)</span> { <span class="hljs-comment">// adm.setObservablePropValue_</span>
        <span class="hljs-keyword">const</span> oldValue = <span class="hljs-built_in">this</span>.value_
        <span class="hljs-built_in">this</span>.value_ = newValue
        <span class="hljs-built_in">this</span>.reportChanged()  <span class="hljs-comment">// 调用Atom中reportChanged</span>
    }
}
</code></pre>
<p>重点看一下在观察者属性管理者最终调用的两个方法—— <code>get</code> 和 <code>setNewValue_</code> 。</p>
<h4>②注入模块——Provider和inject（mobx-react）</h4>
<p>既然观察者模块已经搞定，那么接下来看一下，<code>mobx-react</code> 如何将模块注入到对应的组件中的。</p>
<p><strong>Provider</strong></p>
<blockquote>
<p>mobx-react/src/Provider.tsx</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> MobXProviderContext = React.createContext({})
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Provider</span>(<span class="hljs-params">props</span>) </span>{
    <span class="hljs-comment">/* ... */</span>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">MobXProviderContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>></span>{children}<span class="hljs-tag">&#x3C;/<span class="hljs-name">MobXProviderContext.Provider</span>></span></span>
}
</code></pre>
<ul>
<li>mobx-react 中的 Provide r非常简单，就是创建一个上下文 context ，并通过 context.Provider 传递上下文。</li>
</ul>
<p><strong>inject</strong></p>
<blockquote>
<p>mobx-react/src/inject.ts</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inject</span>(<span class="hljs-params">...storeNames</span>)</span>{
   <span class="hljs-keyword">const</span> Injector = React.forwardRef((<span class="hljs-function">(<span class="hljs-params">props, ref</span>)=></span>{
        <span class="hljs-keyword">let</span> newProps = { ...props }
        <span class="hljs-keyword">const</span> context = React.useContext(MobXProviderContext)
        storeNames.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">storeName</span>)</span>{ <span class="hljs-comment">//storeNames - [ 'Root' ]</span>
            <span class="hljs-keyword">if</span>(storeName <span class="hljs-keyword">in</span> newProps) <span class="hljs-keyword">return</span> 
            <span class="hljs-keyword">if</span>(!(storeName <span class="hljs-keyword">in</span> context)){
                <span class="hljs-comment">/* 将mobx状态从context中混入到props中。 */</span>
                newProps[storeName] = context[storeName]
            }
        })
        <span class="hljs-keyword">return</span> React.createElement(component, newProps)
   }))
   <span class="hljs-keyword">return</span> Injector 
}
</code></pre>
<p>为了让大家更清晰流程，inject 是合并加上简化后的。</p>
<ul>
<li>inject 作用很简单，就是将 mobx 的状态，从 context 中混入 props 中。</li>
</ul>
<h4>③可观察组件—— observer（ mobx-react ）</h4>
<p>被 observe 的组件，被赋予一项功能，就是可观察的，当里面引用了 mobx 中的 ObservableValue ，当 ObservableValue 改变，组件会更新。
接下来就是核心了，需要看一下被 observe 包裹的组件会<strong>有哪些新特征</strong>，<strong>以及如何收集的依赖</strong>，<strong>又是如何更新的</strong>。被 observe 的组件分为函数组件和类组件两种情况，为了让大家明白流程，我这里只讲了类组件的情况。</p>
<p><strong>observer</strong></p>
<blockquote>
<p>mobx-react/src/observer.tsx</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observer</span>(<span class="hljs-params">componentClass</span>)</span>{
    <span class="hljs-comment">/* componentClass 是类组件的情况 (函数组件我们暂且忽略) */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeClassComponentObserver</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">const</span> target = componentClass.prototype
        <span class="hljs-keyword">const</span> baseRender = target.render <span class="hljs-comment">/* 这个是原来组件的render */</span>
        <span class="hljs-comment">/* 劫持render函数 */</span>
        target.render = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> makeComponentReactive.call(<span class="hljs-built_in">this</span>, baseRender)
        }
    }
}
</code></pre>
<ul>
<li>到这里基本可以弄清楚 mobx-react 中 observer HOC 的作用了——<strong>渲染 render 的劫持</strong>。通过劫持 render 函数执行，收集里面的依赖。</li>
</ul>
<p><strong>makeComponentReactive</strong></p>
<blockquote>
<p>mobx-react/src/observerClass.ts</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeComponentReactive</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> baseRender = render.bind(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// baseRender为真正的render方法</span>
     <span class="hljs-comment">/* 创建一个反应器，绑定类组件的更新函数 —— forceUpdate  */</span>
     <span class="hljs-keyword">const</span> reaction = <span class="hljs-keyword">new</span> Reaction(<span class="hljs-string">`<span class="hljs-subst">${initialName}</span>.render()`</span>,<span class="hljs-function">()=></span>{
          Component.prototype.forceUpdate.call(<span class="hljs-built_in">this</span>) <span class="hljs-comment">/* forceUpdate 为类组件更新函数 */</span>
     })
    reaction[<span class="hljs-string">"reactComponent"</span>] = <span class="hljs-built_in">this</span>    <span class="hljs-comment">/* Reaction 和 组件实例建立起关联 */</span>
    reactiveRender[<span class="hljs-string">"$mobx"</span>] = reaction
    <span class="hljs-built_in">this</span>.render = reactiveRender 
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveRender</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">/* 改造的响应式render方法 */</span>
        reaction.track(<span class="hljs-function">() =></span> {  <span class="hljs-comment">// track中进行真正的依赖收集</span>
            <span class="hljs-keyword">try</span> {
                rendering = baseRender() <span class="hljs-comment">/* 执行更新函数 */</span>
            } 
        })
        <span class="hljs-keyword">return</span> rendering
    }
    <span class="hljs-keyword">return</span> reactiveRender.call(<span class="hljs-built_in">this</span>)
}
</code></pre>
<p><code>makeComponentReactive</code> 通过改造 render 函数，来实现依赖的收集，里面包含了很多核心流程。</p>
<ul>
<li>
<p>每一个组件会创建一个 Reaction，Reaction 的第二个参数内部封装了更新组件的方法。那么如果触发可观察属性的 set ，那么最后触发更新的就是这个方法，对于类组件本质上就是的 <code>forceUpdate</code> 方法。</p>
</li>
<li>
<p>对 render 函数进行改造，改造成 reactiveRender ，在 reactiveRender 中，reaction.track 是真正的进行依赖的收集，track 回调函数中，执行真正的 render 方法，得到 element 对象 rendering 。</p>
</li>
</ul>
<h4>④反应器——Reaction</h4>
<p>那么接下来重点看一下 Reaction 如何处理更新函数，还有就是 track 方法是如何收集依赖的。在如下 track 中，我标记了三个阶段，阅读的同学请细心看这个三阶段都做了些什么。</p>
<blockquote>
<p>mobx/src/core/reaction.ts</p>
</blockquote>
<pre><code class="hljs language-js"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reaction</span></span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name_,onInvalidate_</span>)</span>{
       <span class="hljs-built_in">this</span>.name_ = name_
       <span class="hljs-built_in">this</span>.onInvalidate_ = onInvalidate_ <span class="hljs-comment">/* onInvalidate_ 里面有组件的forceUpdate函数，用于更新组件 */</span>
    }
    <span class="hljs-function"><span class="hljs-title">onBecomeStale_</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">this</span>.schedule_() <span class="hljs-comment">/* 触发调度更新 */</span>
    }
    <span class="hljs-comment">/* 开启调度更新 */</span>
    <span class="hljs-function"><span class="hljs-title">schedule_</span>(<span class="hljs-params"></span>)</span>{
       <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isScheduled_) {
            <span class="hljs-built_in">this</span>.isScheduled_ = <span class="hljs-literal">true</span>
            globalState.pendingReactions.push(<span class="hljs-built_in">this</span>)
            runReactions()
        }
    }
    <span class="hljs-comment">/* 更新 */</span>
    <span class="hljs-function"><span class="hljs-title">runReaction_</span>(<span class="hljs-params"></span>)</span>{
        startBatch()
        <span class="hljs-built_in">this</span>.isScheduled_ = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">const</span> prev = globalState.trackingContext
        globalState.trackingContext = <span class="hljs-built_in">this</span>
        <span class="hljs-built_in">this</span>.onInvalidate_() <span class="hljs-comment">/* 更新组件  */</span>
        globalState.trackingContext = prev
        endBatch()
    }
    <span class="hljs-comment">/* 收集依赖 */</span>
    <span class="hljs-function"><span class="hljs-title">track</span>(<span class="hljs-params">fn</span>)</span>{
        startBatch()
        <span class="hljs-comment">/* 第一阶段 */</span>
        <span class="hljs-keyword">const</span> prevTracking = globalState.trackingDerivation
        globalState.trackingDerivation = <span class="hljs-built_in">this</span>
        <span class="hljs-comment">/* 第二阶段 */</span>
        <span class="hljs-keyword">const</span> result = fn.call(context)
        globalState.trackingDerivation = prevTracking
        <span class="hljs-comment">/* 第三阶段 */</span>
        bindDependencies(<span class="hljs-built_in">this</span>) 
    }
 }
</code></pre>
<p><strong>这个函数特别重要，是整个收集依赖核心。</strong></p>
<ul>
<li>
<p>第一阶段： 首先在执行 track 的时候，会把全局变量的 <code>trackingDerivation</code>，指向当前的 trackingDerivation 。这样在收集依赖的过程中，可以直接收集当前的 trackingDerivation ，也就是为什么 ObservableValue 能精确收集每一个 Reaction 。</p>
</li>
<li>
<p>第二阶段：首先当被 observer 包装的组件，只要执行 render 函数，就会执行 track 方法，<code>fn.call(context)</code>，真正的r ender 函数会在里面执行，如果在 render 的过程中，引用了 mobx 可观察模块，比如：</p>
</li>
</ul>
<pre><code class="hljs language-js">@inject(<span class="hljs-string">'Root'</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> 
           <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{ this.props.Root.name }<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span> 
           <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> this.props.Root.setName('《React进阶实践指南》666')} >改变Mobx中name<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    }
}
</code></pre>
<ul>
<li>第二阶段：当如上 render 执行的时候，首先会触发 track ，将当前Reaction 赋值给 trackingDerivation ，然后访问了 Root 下面的name 属性，那么首先会触发观察状态管理者的 adm 的 getObservablePropValue_ ，接下来会触发 name 属性的观察者 ObservableValue 下面的 get 方法，最后执行的是 <code>reportObserved(this)</code>，看一下 reportObserved 里面做了写什么？</li>
</ul>
<blockquote>
<p>mobx/src/core/observable.ts</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reportObserved</span>(<span class="hljs-params">observable</span>)</span>{
    <span class="hljs-comment">/* 此时获取到当前函数对应的 Reaction。 */</span>
    <span class="hljs-keyword">const</span> derivation = globalState.trackingDerivation 
    <span class="hljs-comment">/* 将当前的 observable 存放到 Reaction 的 newObserving_ 中。 */</span>
    derivation.newObserving_![derivation.unboundDepsCount_++] = observable 
}
</code></pre>
<ul>
<li>第二阶段：reportObserved 做的事情非常直接，就是将当前的 observable 放入 Reaction 的 newObserving_ 中，这样就把观察者属性（如上例子中的name）和组件对应的 Reaction 建立起关联。</li>
</ul>
<p>当组件中 render 函数执行完毕，也就是 jsx 中的依赖全部收集完成，就会到第三阶段，细心的同学发现，上述只是 ObservableValue 到 Reaction 收集，但是没有 Reaction 到 ObservableValue ，也就是说 ObservableValue 里面还没有组件的 Reaction，别着急，这个都是第三阶段的 <code>bindDependencies</code> 做的事。</p>
<blockquote>
<p>mobx/src/core/derivation.ts</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindDependencies</span>(<span class="hljs-params">Reaction</span>)</span>{ <span class="hljs-comment">/* 当前组件的 Reaction */</span>
    <span class="hljs-keyword">const</span> prevObserving = derivation.observing_ <span class="hljs-comment">/* 之前的observing_ */</span>
    <span class="hljs-keyword">const</span> observing = (derivation.observing_ = derivation.newObserving_!) <span class="hljs-comment">/* 新的observing_  */</span>
    <span class="hljs-keyword">let</span> l = prevObserving.length
    <span class="hljs-keyword">while</span> (l--) { <span class="hljs-comment">/* observableValue 删除之前的 Reaction  */</span>
        <span class="hljs-keyword">const</span> observableValue = prevObserving[l]
        observable.observers_.delete(Reaction)
    }
    <span class="hljs-keyword">let</span> i0 = observing.length 
    <span class="hljs-keyword">while</span> (i0--) { <span class="hljs-comment">/* 给renderhanobservableValue重新添加 Reaction  */</span>
        <span class="hljs-keyword">const</span> observableValue = observing[i0]
         observable.observers_.add(Reaction)
    }
}
</code></pre>
<ul>
<li>第三阶段： bindDependencies 主要做的事情如下：</li>
</ul>
<p>①  对于有<strong>当前 Reaction</strong>的 observableValue，observableValue会统一删除掉里面的 Reaction。<br>
②  会给这一次 render 中用到的新的依赖 observableValue ，统一添加当前的 Reaction 。<br>
③  还会有一些细节，比如说在 render 中，引入两次相同的值（如上的 demo 中的 name ），会统一收集一次依赖。</p>
<p>依赖收集流程图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5712e9017d4946fbac0876ddf2542e6c~tplv-k3u1fbpfcp-watermark.image" alt="4.jpeg"></p>
<h3>3 派发更新</h3>
<p>接下来就是一次更新中，比如在（ DEMO1 ）中点击按钮，通过 action ，改变 mobx 中的 name 属性。那么会发生什么呢。</p>
<ul>
<li>
<p><strong>第一步：</strong> 首先对于观察者属性管理者 ObservableAdministration 会触发 setObservablePropValue_ ，然后找到对应的 ObservableValue 触发 setNewValue_ 方法。</p>
</li>
<li>
<p><strong>第二步：</strong> setNewValue_ 本质上会触发Atom中的reportChanged ，然后调用 <code>propagateChanged</code>。首先来看一下propagateChanged：</p>
</li>
</ul>
<blockquote>
<p>mobx/src/core/observable.ts</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">propagateChanged</span>(<span class="hljs-params">observable</span>)</span>{
    observable.observers_.forEach(<span class="hljs-function">(<span class="hljs-params">Reaction</span>)=></span>{
        Reaction.onBecomeStale_()
    })
}
</code></pre>
<p>调用 <code>propagateChanged</code> 触发，依赖于当前组件的所有 Reaction 会触发 onBecomeStale_ 方法。</p>
<ul>
<li><strong>第三步：</strong>  Reaction 的 onBecomeStale_ 触发，会让Reaction 的 schedule_ 执行，注意一下这里 schedule_ 会开启更新调度。什么叫更新调度呢。就是 schedule_ 并不会马上执行组件更新，而是把当前的 Reaction 放入 globalState.pendingReactions（待更新 Reaction 队列）中，然后会执行 runReactions 外部方法。</li>
</ul>
<blockquote>
<p>mobx/src/core/reaction.ts</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runReactions</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">if</span> (globalState.inBatch > <span class="hljs-number">0</span> || globalState.isRunningReactions) <span class="hljs-keyword">return</span>
    globalState.isRunningReactions = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">const</span> allReactions = globalState.pendingReactions
    <span class="hljs-comment">/* 这里的代码是经过修改过后的，源码中要比 */</span>
    allReactions.forEach(<span class="hljs-function"><span class="hljs-params">Reaction</span>=></span>{
         <span class="hljs-comment">/* 执行每一个组件的更新函数 */</span>
         Reaction.runReaction_()
    })
    globalState.pendingReactions = []
    globalState.isRunningReactions = <span class="hljs-literal">false</span>
}
</code></pre>
<ul>
<li><strong>第四步：</strong> 执行每一个 Reaction ，当一个 ObservableValue 的属性值改变，可以收集了多个组件的依赖，所以 mobx 用这个调度机制，先把每一个 Reaction 放入 pendingReactions 中，然后集中处理这些 Reaction ， Reaction 会触发 <code>runReaction_()</code> 方法，会触发 onInvalidate_ ——类组件的 forceupdate 方法完成组件更新。</li>
</ul>
<p>借此完成整个流程。</p>
<p>状态派发流程图：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/606265172f9649e59b16c783923f4dd4~tplv-k3u1fbpfcp-watermark.image" alt="5.jpeg"></p>
<h2>五 Mobx与Redux区别</h2>
<ul>
<li>首先在 Mobx 在上手程度上，要优于 Redux ，比如 Redux 想使用异步，需要配合中间价，流程比较复杂。</li>
<li>Redux 对于数据流向更规范化，Mobx 中数据更加多样化，允许数据冗余。</li>
<li>Redux 整体数据流向简单，Mobx 依赖于 Proxy， Object.defineProperty 等，劫持属性 get ，set ，数据变化多样性。</li>
<li>Redux 可拓展性比较强，可以通过中间件自定义增强 dispatch 。</li>
<li>在 Redux 中，基本有一个 store ，统一管理 store 下的状态，在 mobx 中可以有多个模块，可以理解每一个模块都是一个 store ，相互之间是独立的。</li>
</ul>
<h2>六 总结</h2>
<p>希望通过本章节的学习，可以学到一下内容：</p>
<ul>
<li>mobx 基本使用，实践状态管理和组件通信两种场景。</li>
<li>mobx 和 mobx-react 原理。</li>
<li>mobx 和 redux 的区别。</li>
</ul></div>
</body></html>