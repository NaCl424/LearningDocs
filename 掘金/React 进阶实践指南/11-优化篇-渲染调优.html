<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>优化篇-渲染调优</h1>
<h2>一前言</h2>
<p>上节主要讲了 React 对组件渲染的控制方法以及原理，本章节将继续围绕 React 渲染话题，谈一谈整个 React 渲染过程中细节问题怎么解决。</p>
<p>通过本章节，你将学会 Suspense 用法和原理，React.lazy 用法和配合 Suspense 实现代码分割，渲染错误边界、渲染异常的处理手段， 以及 diff 流程以及 key 的合理使用。</p>
<h2>二懒加载和异步渲染</h2>
<h3>异步渲染</h3>
<p>Suspense 是 React 提出的一种同步的代码来实现异步操作的方案。Suspense 让组件‘等待’异步操作，异步请求结束后在进行组件的渲染，也就是所谓的异步渲染，但是这个功能目前还在实验阶段，相信不久这种异步渲染的方式就能和大家见面了。</p>
<p><strong>Suspense 用法</strong></p>
<p>Suspense 是组件，有一个 fallback 属性，用来代替当 Suspense 处于 loading 状态下渲染的内容，Suspense 的 children 就是异步组件。多个异步组件可以用 Suspense 嵌套使用。</p>
<p>我写了一个异步渲染的例子如下。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 子组件</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserInfo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 获取用户数据信息，然后再渲染组件。</span>
  <span class="hljs-keyword">const</span> user = getUserInfo();
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{user.name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span></span>;
}
<span class="hljs-comment">// 父组件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&#x3C;<span class="hljs-attr">h1</span>></span>Loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>}>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">UserInfo</span>/></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">Suspense</span>></span></span>
}
</code></pre>
<ul>
<li>Suspense 包裹异步渲染组件 UserInfo ，当 UserInfo 处于数据加载状态下，展示 Suspense 中 fallback 的内容。</li>
</ul>
<p>如上所示，异步渲染的 UserInfo 组件可以直接通过 getUserInfo 请求数据，直接用数据 user 进行渲染，很显然现在是做不到的。现在的异步请求方式比较繁琐，主要是是通过类组件 componentDidMount 或者函数组件 useEffect 进行数据交互，获得数据后通过调用 setState 或 useState 改变 state 触发视图的更新。</p>
<p>传统模式：挂载组件-> 请求数据 -> 再渲染组件。<br>
异步模式：请求数据-> 渲染组件。</p>
<p>那么异步渲染相比传统数据交互相比好处就是：</p>
<ul>
<li>不再需要 componentDidMount 或 useEffect 配合做数据交互，也不会因为数据交互后，改变 state 而产生的二次更新作用。</li>
<li>代码逻辑更简单，清晰。</li>
</ul>
<h3>动态加载（懒加载）</h3>
<p>现在的 Suspense 配合 React.lazy 可以实现动态加载功能。</p>
<p><strong>React.lazy</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> LazyComponent = React.lazy(<span class="hljs-function">()=></span><span class="hljs-keyword">import</span>(<span class="hljs-string">'./text'</span>))
</code></pre>
<p>React.lazy 接受一个函数，这个函数需要动态调用 <code>import()</code> 。它必须返回一个 Promise ，该 Promise 需要 resolve 一个 default export 的 React 组件。</p>
<p>先来看一下基本使用：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> LazyComponent = React.lazy(<span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./test.js'</span>))

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span>{
   <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&#x3C;<span class="hljs-attr">div</span>></span>loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>} >
       <span class="hljs-tag">&#x3C;<span class="hljs-name">LazyComponent</span> /></span>
   <span class="hljs-tag">&#x3C;/<span class="hljs-name">Suspense</span>></span></span>
}
</code></pre>
<ul>
<li>用 React.lazy 动态引入 test.js 里面的组件，配合 Suspense 实现动态加载组件效果。<strong>这样很利于代码分割，不会让初始化的时候加载大量的文件。</strong></li>
</ul>
<p>原理揭秘： <strong>React.lazy和Suspense实现动态加载原理</strong></p>
<p>整个 render 过程都是同步执行一气呵成的，但是在 Suspense 异步组件情况下允许<strong>调用 Render => 发现异步请求 => 悬停，等待异步请求完毕 => 再次渲染展示数据</strong>。</p>
<p>那么整个流程是如何实现的，逐步分析一下：<br></p>
<p><strong>Suspense原理：</strong> <br></p>
<p>Suspense 在执行内部可以通过 <code>try{}catch{}</code> 方式捕获异常，这个异常通常是一个 <code>Promise</code> ，可以在这个 Promise 中进行数据请求工作，Suspense 内部会处理这个 Promise ，Promise 结束后，Suspense 会再一次重新 render 把数据渲染出来，达到异步渲染的效果。<br></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60d20c4fad834541873697ead2ec6dda~tplv-k3u1fbpfcp-watermark.image" alt="5.jpg"></p>
<p><strong>React.lazy原理：</strong></p>
<p>再看一下 React.lazy，lazy 内部模拟一个 promiseA 规范场景。完全可以理解 React.lazy 用 Promise 模拟了一个请求数据的过程，但是请求的结果不是数据，而是一个动态的组件。下一次渲染就直接渲染这个组件，所以是 React.lazy 利用 Suspense <strong>接收 Promise ，执行 Promise ，然后再渲染</strong>这个特性做到动态加载的。说到这可能有很多同学不明白什么意思，不要紧，接下来通过以下代码加深一下对 lazy + susponse 的理解。</p>
<blockquote>
<p>react/src/ReactLazy.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazy</span>(<span class="hljs-params">ctor</span>)</span>{
    <span class="hljs-keyword">return</span> {
         <span class="hljs-attr">$$typeof</span>: REACT_LAZY_TYPE,
         <span class="hljs-attr">_payload</span>:{
            <span class="hljs-attr">_status</span>: -<span class="hljs-number">1</span>,  <span class="hljs-comment">//初始化状态</span>
            <span class="hljs-attr">_result</span>: ctor,
         },
         <span class="hljs-attr">_init</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">payload</span>)</span>{
             <span class="hljs-keyword">if</span>(payload._status===-<span class="hljs-number">1</span>){ <span class="hljs-comment">/* 第一次执行会走这里  */</span>
                <span class="hljs-keyword">const</span> ctor = payload._result;
                <span class="hljs-keyword">const</span> thenable = ctor();
                payload._status = Pending;
                payload._result = thenable;
                thenable.then(<span class="hljs-function">(<span class="hljs-params">moduleObject</span>)=></span>{
                    <span class="hljs-keyword">const</span> defaultExport = moduleObject.default;
                    resolved._status = Resolved; <span class="hljs-comment">// 1 成功状态</span>
                    resolved._result = defaultExport;<span class="hljs-comment">/* defaultExport 为我们动态加载的组件本身  */</span> 
                })
             }
            <span class="hljs-keyword">if</span>(payload._status === Resolved){ <span class="hljs-comment">// 成功状态</span>
                <span class="hljs-keyword">return</span> payload._result;
            }
            <span class="hljs-keyword">else</span> {  <span class="hljs-comment">//第一次会抛出Promise异常给Suspense</span>
                <span class="hljs-keyword">throw</span> payload._result; 
            }
         }
    }
}
</code></pre>
<p>整个流程是这样的，React.lazy 包裹的组件会标记 <code>REACT_LAZY_TYPE</code> 类型的 element，在调和阶段会变成 LazyComponent 类型的 fiber ，React 对 LazyComponent 会有单独的处理逻辑：</p>
<ul>
<li>
<p>第一次渲染首先会执行 init 方法，里面会执行 lazy 的第一个函数，得到一个Promise，绑定 Promise.then 成功回调，回调里得到将要渲染组件 <code>defaultExport</code> ，这里要注意的是，如上面的函数当第二个 if 判断的时候，因为此时状态不是 Resolved ，所以会走 else ，抛出异常 Promise，抛出异常会让当前渲染终止。</p>
</li>
<li>
<p>这个异常 Promise 会被 Suspense 捕获到，Suspense 会处理 Promise ，Promise 执行成功回调得到 defaultExport（将想要渲染组件），然后 Susponse 发起第二次渲染，第二次 init 方法已经是 Resolved 成功状态，那么直接返回 result 也就是真正渲染的组件。这时候就可以正常渲染组件了。</p>
</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6792d24862464d89b2034bfa4cf9e5a8~tplv-k3u1fbpfcp-watermark.image" alt="4.jpg"></p>
<h2>三 渲染错误边界</h2>
<p>React 组件渲染过程如果有一个环节出现问题，就会导致整个组件渲染失败，那么整个组件的 UI 层都会显示不出来，这样造成的危害是巨大的，如果越靠近 APP 应用的根组件，渲染过程中出现问题造成的影响就越大，有可能直接造成白屏的情况。</p>
<p>比如如下例子</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ErrorTest</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> 
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>let us learn React!<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}

 <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{ 
    <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">...arg</span>)</span>{
       <span class="hljs-built_in">console</span>.log(arg)
    }
   <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{  
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">ErrorTest</span> /></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> hello, my name is alien! <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Test</span> /></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
   }
}
</code></pre>
<ul>
<li>造成错误，由于 ErrorTest 不是一个真正的组件但是却用来渲染，结果会造成整个 Index 组件渲染异常，Test 也会受到牵连，UI 都不能正常显示。</li>
</ul>
<p>为了防止如上的渲染异常情况 React 增加了 <code>componentDidCatch</code> 和 <code>static getDerivedStateFromError()</code> 两个额外的生命周期，去挽救由于渲染阶段出现问题造成 UI 界面无法显示的情况。</p>
<h3>componentDidCatch</h3>
<p>componentDidCatch 可以捕获异常，它接受两个参数：</p>
<ul>
<li>1 error —— 抛出的错误。</li>
<li>2 info —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。</li>
</ul>
<p>先来打印一下，生命周期 componentDidCatch 参数长什么样子？</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17c55d44dfe94d2a9544030ce5c426c1~tplv-k3u1fbpfcp-watermark.image" alt="2.jpg"></p>
<p>那么 componentDidCatch 中可以再次触发 setState，来降级UI渲染，componentDidCatch() 会在commit阶段被调用，因此允许执行副作用。</p>
<pre><code class="hljs language-js"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
   state={
       <span class="hljs-attr">hasError</span>:<span class="hljs-literal">false</span>
   }  
   <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">...arg</span>)</span>{
       uploadErrorLog(arg)  <span class="hljs-comment">/* 上传错误日志 */</span>
       <span class="hljs-built_in">this</span>.setState({  <span class="hljs-comment">/* 降级UI */</span>
           <span class="hljs-attr">hasError</span>:<span class="hljs-literal">true</span>
       })
   }
   <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{  
      <span class="hljs-keyword">const</span> { hasError } =<span class="hljs-built_in">this</span>.state
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
          {  hasError ? <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>组件出现错误<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span> : <span class="hljs-tag">&#x3C;<span class="hljs-name">ErrorTest</span> /></span>  }
          <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> hello, my name is alien! <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Test</span> /></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
   }
}
</code></pre>
<p>效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e97c84689a4493d9f3c6e05b4723499~tplv-k3u1fbpfcp-watermark.image" alt="3.jpg">
componentDidCatch 作用：</p>
<ul>
<li>可以调用 setState 促使组件渲染，并做一些错误拦截功能。</li>
<li>监控组件，发生错误，上报错误日志。</li>
</ul>
<h3>static getDerivedStateFromError</h3>
<p>React更期望用 getDerivedStateFromError 代替 componentDidCatch 用于处理渲染异常的情况。getDerivedStateFromError 是静态方法，内部不能调用 setState。getDerivedStateFromError 返回的值可以合并到 state，作为渲染使用。用 getDerivedStateFromError 解决如上的情况。</p>
<pre><code class="hljs language-js"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
   state={
       <span class="hljs-attr">hasError</span>:<span class="hljs-literal">false</span>
   }  
   <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromError</span>(<span class="hljs-params"></span>)</span>{
       <span class="hljs-keyword">return</span> { <span class="hljs-attr">hasError</span>:<span class="hljs-literal">true</span> }
   }
   <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{  
      <span class="hljs-comment">/* 如上 */</span>
   }
}
</code></pre>
<p>如上完美解决了 ErrorTest 错误的问题。注意事项： 如果存在 getDerivedStateFromError 生命周期钩子，那么将不需要 componentDidCatch 生命周期再降级 ui。</p>
<h2>四 从diff children看key的合理使用</h2>
<p>上述内容讲了异步渲染和渲染错误边界，都是对一些特殊情况下渲染的处理。上章节讲到，大部分优化环节 React 都自己在内部处理了。但是有一种情况也值得开发者注意，那就是列表中 key 的使用。合理的使用 key 有助于能精准的找到用于新节点复用的老节点。 React 是如何 diff children 的呢。</p>
<p>我这里为了方便大家了解流程，就不放过多源码了，我用如下几个案例来描述 React diffChild 核心流程。之前做过一期 vue3.0 diff算法的文章，实际在处理手法上还是有一些相似之处的。首先 React 在一次更新中当发现通过 render 得到的 children 如果是一个数组的话。就会调用 reconcileChildrenArray 来调和子代 fiber ，整个对比的流程就是在这个函数中进行的。</p>
<h3>diff children流程</h3>
<p><strong>第一步：遍历新 children ，复用 oldFiber</strong></p>
<blockquote>
<p>react-reconciler/src/ReactChildFiber.js</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildrenArray</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">/* 第一步  */</span>
    <span class="hljs-keyword">for</span> (; oldFiber !== <span class="hljs-literal">null</span> &#x26;&#x26; newIdx &#x3C; newChildren.length; newIdx++) {  
        <span class="hljs-keyword">if</span> (oldFiber.index > newIdx) {
            nextOldFiber = oldFiber;
            oldFiber = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> {
            nextOldFiber = oldFiber.sibling;
        }
        <span class="hljs-keyword">const</span> newFiber = updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime,);
        <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) { <span class="hljs-keyword">break</span> }
        <span class="hljs-comment">// ..一些其他逻辑</span>
        }  
        <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {  <span class="hljs-comment">// shouldTrackSideEffects 为更新流程。</span>
            <span class="hljs-keyword">if</span> (oldFiber &#x26;&#x26; newFiber.alternate === <span class="hljs-literal">null</span>) { <span class="hljs-comment">/* 找到了与新节点对应的fiber，但是不能复用，那么直接删除老节点 */</span>
                deleteChild(returnFiber, oldFiber);
            }
        }
    }
}
</code></pre>
<ul>
<li>第一步对于 React.createElement 产生新的 child 组成的数组，首先会遍历数组，因为 fiber 对于同一级兄弟节点是用 sibling 指针指向，所以在遍历children 遍历，sibling 指针同时移动，找到与 child 对应的 oldFiber 。</li>
<li>然后通过调用 updateSlot ，updateSlot 内部会判断当前的 tag 和 key 是否匹配，如果匹配复用老 fiber 形成新的 fiber ，如果不匹配，返回 null ，此时 newFiber 等于 null 。</li>
<li>如果是处于更新流程，找到与新节点对应的老 fiber ，但是不能复用 <code>alternate === null </code>，那么会删除老 fiber 。</li>
</ul>
<p><strong>第二步：统一删除oldfiber</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (newIdx === newChildren.length) {
    deleteRemainingChildren(returnFiber, oldFiber);
    <span class="hljs-keyword">return</span> resultingFirstChild;
}
</code></pre>
<ul>
<li>第二步适用于以下情况，当第一步结束完 <code>newIdx === newChildren.length</code> 此时证明所有 newChild 已经全部被遍历完，那么剩下没有遍历 oldFiber 也就没有用了，那么调用 deleteRemainingChildren 统一删除剩余 oldFiber 。</li>
</ul>
<p>情况一：节点删除</p>
<ul>
<li><strong>oldChild: A B C D</strong></li>
<li><strong>newChild: A B</strong></li>
</ul>
<p>A , B 经过第一步遍历复制完成，那么 newChild 遍历完成，此时 C D 已经没有用了，那么统一删除 C D。</p>
<p><strong>第三步：统一创建newFiber</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span>(oldFiber === <span class="hljs-literal">null</span>){
   <span class="hljs-keyword">for</span> (; newIdx &#x3C; newChildren.length; newIdx++) {
       <span class="hljs-keyword">const</span> newFiber = createChild(returnFiber,newChildren[newIdx],expirationTime,)
       <span class="hljs-comment">// ...</span>
   }
}
</code></pre>
<ul>
<li>第三步适合如下的情况，当经历过第一步，oldFiber 为 null ， 证明 oldFiber 复用完毕，那么如果还有新的 children ，说明都是新的元素，只需要调用 createChild 创建新的 fiber 。</li>
</ul>
<p>情况二：节点增加</p>
<ul>
<li><strong>oldChild: A B</strong></li>
<li><strong>newChild: A B C D</strong></li>
</ul>
<p>A B 经过第一步遍历复制完，oldFiber 没有可以复用的了，那么直接创建 C D。</p>
<p><strong>第四步：针对发生移动和更复杂的情况</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);
<span class="hljs-keyword">for</span> (; newIdx &#x3C; newChildren.length; newIdx++) {
    <span class="hljs-keyword">const</span> newFiber = updateFromMap(existingChildren,returnFiber)
    <span class="hljs-comment">/* 从mapRemainingChildren删掉已经复用oldFiber */</span>
}
</code></pre>
<ul>
<li>mapRemainingChildren 返回一个 map ，map 里存放剩余的老的 fiber 和对应的 key (或 index )的映射关系。</li>
<li>接下来遍历剩下没有处理的 Children ，通过 updateFromMap ，判断 mapRemainingChildren 中有没有可以复用 oldFiber ，如果有，那么复用，如果没有，新创建一个 newFiber 。</li>
<li>复用的 oldFiber 会从 mapRemainingChildren 删掉。</li>
</ul>
<p>情况三：节点位置改变</p>
<ul>
<li><strong>oldChild: A B C D</strong></li>
<li><strong>newChild: A B D C</strong></li>
</ul>
<p>如上 A B 在第一步被有效复用，第二步和第三步不符合，直接进行第四步，C D 被完全复用，existingChildren 为空。</p>
<p><strong>第五步：删除剩余没有复用的oldFiber</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (shouldTrackSideEffects) {
    <span class="hljs-comment">/* 移除没有复用到的oldFiber */</span>
    existingChildren.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =></span> deleteChild(returnFiber, child));
}
</code></pre>
<p>最后一步，对于没有复用的 oldFiber ，统一删除处理。</p>
<p>情况四：复杂情况(删除 + 新增 + 移动)</p>
<ul>
<li><strong>oldChild: A B C D</strong></li>
<li><strong>newChild: A E D B</strong></li>
</ul>
<p>首先 A 节点，在第一步被复用，接下来直接到第四步，遍历 newChild ，E被创建，D B 从 existingChildren 中被复用，existingChildren 还剩一个 C 在第五步会删除 C ，完成整个流程。</p>
<h3>关于diffChild思考和key的使用</h3>
<ul>
<li>1  React diffChild 时间复杂度 O(n^3) 优化到 O(n)。</li>
<li>2  React key 最好选择唯一性的id，如上述流程，如果选择 Index 作为 key ，如果元素发生移动，那么从移动节点开始，接下来的 fiber 都不能做得到合理的复用。 index 拼接其他字段也会造成相同的效果。</li>
</ul>
<h2>五实践 - React.lazy + Susponse模拟异步组件功能</h2>
<p>接下来 React.lazy + Susponse 来完全模拟实现一个异步组件。</p>
<p><strong>实现效果：</strong></p>
<ul>
<li>异步组件要实现的功能，异步请求数据，请求完数据再挂载组件。没有加载完数据显示 loading 效果。</li>
<li>可量化生产。</li>
</ul>
<p><strong>主要思路：</strong></p>
<ul>
<li>可以使用 React.lazy 实现动态加载，那么可以先请求数据，然后再加载组件，这时候以 props 形式将数据传递给目标组件，实现异步效果。</li>
</ul>
<p><strong>编写：</strong></p>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 * 
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>Component  需要异步数据的component 
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>api        请求数据接口,返回Promise，可以再then中获取与后端交互的数据
 * <span class="hljs-doctag">@returns </span>
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AysncComponent</span>(<span class="hljs-params">Component,api</span>)</span>{
    <span class="hljs-keyword">const</span> AysncComponentPromise = <span class="hljs-function">() =></span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (resolve)=>{
          <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> api()
          resolve({
              <span class="hljs-attr">default</span>: <span class="hljs-function">(<span class="hljs-params">props</span>) =></span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Component</span> <span class="hljs-attr">rdata</span>=<span class="hljs-string">{data}</span> { <span class="hljs-attr">...props</span>}  /></span></span>
          })
    })
    <span class="hljs-keyword">return</span> React.lazy(AysncComponentPromise)
}
</code></pre>
<p><strong>思路：</strong></p>
<ul>
<li>用 AysncComponent 作为一个 HOC 包装组件，接受两个参数，第一个参数为当前组件，第二个参数为请求数据的 api 。</li>
<li>声明一个函数给 React.lazy 作为回调函数，React.lazy 要求这个函数必须是返回一个 Promise 。在 Promise 里面通过调用 api 请求数据，然后根据返回来的数据 rdata 渲染组件，别忘了接受并传递 props 。</li>
</ul>
<p><strong>使用：</strong></p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 数据模拟 */</span>
<span class="hljs-keyword">const</span> getData=<span class="hljs-function">()=></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=></span>{
        <span class="hljs-comment">//模拟异步</span>
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
             resolve({
                 <span class="hljs-attr">name</span>:<span class="hljs-string">'alien'</span>,
                 <span class="hljs-attr">say</span>:<span class="hljs-string">'let us learn React!'</span>
             })
        }, <span class="hljs-number">1000</span>)
    })
}
<span class="hljs-comment">/* 测试异步组件 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span>(<span class="hljs-params">{ rdata  , age}</span>)</span>{
    <span class="hljs-keyword">const</span> { name , say } = rdata
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'组件渲染'</span>)
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> hello , my name is { name } <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>age : { age } <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span> i want to say { say } <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
<span class="hljs-comment">/* 父组件 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    LazyTest = AysncComponent(Test,getData) <span class="hljs-comment">/* 需要每一次在组件内部声明，保证每次父组件挂载，都会重新请求数据 ，防止内存泄漏。 */</span>
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">const</span> { LazyTest } = <span class="hljs-built_in">this</span>
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&#x3C;<span class="hljs-attr">div</span>></span>loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>} >
              <span class="hljs-tag">&#x3C;<span class="hljs-name">LazyTest</span> <span class="hljs-attr">age</span>=<span class="hljs-string">{18}</span>  /></span>
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">Suspense</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    }
}
</code></pre>
<p><strong>效果：</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/240879ad371f4031999dded287e27142~tplv-k3u1fbpfcp-watermark.image" alt="1.gif"></p>
<ul>
<li>如上 name 和 say 都是数据交互获取的数据。</li>
<li>组件只渲染了一次，实现了异步渲染的效果。</li>
</ul>
<p><strong>总结：</strong></p>
<p>这个demo仅供大家参考，加深以下对异步组件和 HOC 的理解，但是这种在真实的开发场景也会遇到一些问题。</p>
<ul>
<li>1 需要约定好接受数据格式rdata和数据交互形式api。</li>
<li>2 因为数据本质是用闭包缓存的，所以绑定需要在在组件内部，这样才能保证每次父组件挂载，都会重新请求数据，另外也防止内存泄漏情况发生。</li>
<li>3 数据源更新维护困难。</li>
</ul>
<h2>六总结</h2>
<p>这节主要讲了 React 未来版本的异步组件，React.lazy + Susponse 动态加载原理，渲染的错误边界及其处理，diff 性能调优，以及用一个实践 demo ，lazy + susponse 模拟实现了异步组件。</p></div>
</body></html>