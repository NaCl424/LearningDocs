<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Flexbox 布局基础使用</h1>
<p>自 2009 年 W3C 发布 <strong>Flexible Box Layout Module</strong> （WD 版本）至今已有十多年了，在近十年来，该模块得到了快速发展，现已成为最流行的 Web 布局技术之一。在 Web 开发者中，该模块也常称为 <strong>Flexbox 布局</strong> 。</p>
<p>Flexbox 是一种布局机制，它被设计为一维布局模型，并作为一种可以提供界面中项目之间的空间分配和强大功能的方法。正因如此，Flexbox 布局对于很多 Web 开发者而言，并不是容易的，甚至有很多困惑。</p>
<p>接下来，将分为几节课和大家一起开启 Flexbox 布局的探讨，帮助大家更好地掌握 Flexbox 布局技术。</p>
<h2>Flexbox 布局简介</h2>
<blockquote>
<p><strong>Flexbox 布局 是一种布局机制，用于在一个维度上为项目组设置布局！</strong></p>
</blockquote>
<p>Flexbox 模块中的主要功能就是 Web 布局。Flexbox 布局可以明确地指明容器空间的分布方式、内容对齐和元素的视觉顺序。使用 Flexbox 布局，可以轻易地实现横向或纵向布局，还可以沿着一个轴布局，或折断成多行。可以说，<strong>使用 Flexbox 布局可以轻易地构建你想要的任何布局</strong>。</p>
<p>另外，使用 Flexbox 布局还可以让 Web 内容的渲染不再受 HTML 文档源码顺序的限制。然而，这只是视觉上的调整，Flexbox 模块中的相关属性并不会改变屏幕阅读器对内容的读取顺序。</p>
<p>和以往的 Web 布局技术相比，Flexbox 布局所涉及的概念更多、更复杂，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c30bdb31294e40f8a98768024de75e09~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>看上去有很多东西，其实也没有大家想象的那么难。接下来的内容能很好地让你掌握 Flexbox 布局。</p>
<h2>一些术语和概念</h2>
<p>我想你对 Flexbox 布局有一定的了解，而且在互联网上有关于 Flexbox 布局的教程也是玲琅满目，为此我想从 Flexbox 布局相关的术语和概念开始，因为术语的统一更有助于我们后面更好地讨论和解决问题。</p>
<p>用下图来描述 Flexbox 中的术语：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/573539dfa0a4447bba9e78a5f676bb63~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>首先要理解的概念就是 <strong>Flex</strong> <strong>容器</strong> （也常称为 <strong>Flexbox</strong> <strong>容器</strong> ）。简单地说，HTML 上的大多数元素都可以是 Flex 容器，比如 <code>div</code> 、<code>ul</code> 、<code>main</code> 块元素，<code>span</code> 、<code>em</code> 这样的内联元素。只需要在 HTML 元素上显式设置 <code>display</code> 的值为 <code>flex</code> 或 <code>inline-flex</code> 即可。</p>
<blockquote>
<p><strong>注意，HTML 中的可替代元素是无法成为 Flex 容器的，比如<code>img</code>、 <code>input</code>、 <code>select</code>等元素！</strong></p>
</blockquote>
<p>当一个元素变成了 Flex 容器之后，它的子元素，包括其伪元素 <code>::before</code> 、<code>::after</code> 和 文本节点 都将成为 <strong>Flex 项目</strong> 。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b4d9872f994445d9a16ff66cae810bf~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>有一点非常的重要，<strong>在 Flexbox 布局中， Flex 容器和 Flex 项目之间的关系永远是父子关系。</strong> 因此，Flex 项目也可以是它的子元素的 Flex 容器，即 显式地在 Flex 项目设置 <code>display</code> 属性值为 <code>flex</code> 或 <code>inline-flex</code> ，该 Flex 项目就成为一个 Flex 容器，而它的子元素就成为 Flex 项目。但它将是一个单独的 Flex 容器，它不会继承祖辈的 Flex 容器上的属性（Flexbox属性）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8afb306f1a4f4574a48dc584b542c898~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>在 CSS 坐标系中，物理坐标系有 <code>x</code> 轴（水平轴）和 <code>y</code> 轴（垂直轴）之分，逻辑坐标系有内联轴（Inline Axis） 和块轴（Block Axis）之分。在 Flexbox 中，Flex 容器内也有两个轴，而且这两个轴只存在于 Flex 容器中，分别叫 <strong>主轴</strong> （Main Axis）和 <strong>侧轴</strong> （Cross Axis）。</p>
<p>Flexbox 中的主轴由 <code>flex-direction</code> 属性设置，默认情况下，主轴沿行方向（内联轴 Inline Axis）分布，如果该属性为 <code>column</code> ，则主轴沿列方向（块轴 Block Axis）分布：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68666475866b47989c495d453f057e52~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>需要注意的是，Flexbox 布局中的主轴、主方向、侧轴和侧方向不是固定不变的，它们会随着<code>writing-mode</code>（书写模式）和 <code>direction</code>（阅读方向）而改变。 也就是说，Flex 项目在 Flex 容器中的排列方向同时会受 <code>flex-direction</code> 属性和 CSS 的书写模式 <code>writing-mode</code> 或 阅读模式 <code>direction</code> 影响。</p>
<p>另外，在 Flexbox 布局中，不管是主轴还是侧轴，都有方向性。既然有方向，就有开始处（即起点）和结束处（即终点）之分。根据起点和终点之分，Flex 容器中的每根轴又有 <strong>主轴起点</strong> 、<strong>主轴终点</strong> 、<strong>侧轴起点</strong> 和 <strong>侧轴终点</strong> 之分。而且每根轴的起点和终点是由 <code>flex-direction</code> 和 <code>writing-mode</code> (或 <code>direction</code>) 来决定的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d75744e3adb9450298eba491b5ee884e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>如果 <code>flex-direction</code> 为默认值 <code>row</code> 时，书写模式和阅读模式分别是：</p>
<ul>
<li><code>ltr</code> （Left-To-Right），如英文，主轴起点在 Flex 容器左侧边缘，主轴的终点在 Flex 容器右侧边缘；</li>
</ul>

<ul>
<li><code>rtl</code> （Right-To-Left），如阿拉伯文，主轴起点在 Flex 容器右侧边缘，主轴的终点在 Flex 容器的左侧边缘。</li>
</ul>
<p>在这两种情况下，侧轴的起点都在 Flex 容器的顶部，而终点都在 Flex 容器的底部，这主要是因为两种语言都是水平书写模式。</p>
<blockquote>
<p>注意，Flex 容器两轴的起点和终端同样受 <code>flex-direction</code> 、<code>writing-mode</code> 或 <code>direction</code> 属性值的影响。</p>
</blockquote>
<p>众所周之， CSS 中的每个元素都是一个容器，是容器它就有大小。Flexbox 布局中的 Flex 容器 和 Flex 项目同样是元素，它们也有大小。不同的是，对于 Flex 容器而言，它有 <strong>主轴尺寸</strong> （Main Size）和 <strong>侧轴尺寸</strong> （Cross Size）之分。它们的差别是：</p>
<ul>
<li><strong>主轴尺寸</strong> 是指主轴起点到终点之间的距离；</li>
</ul>

<ul>
<li><strong>侧轴尺寸</strong> 是指侧轴起点到终点之间的距离 。</li>
</ul>
<p>也就是说，主轴尺寸和侧轴尺寸可以用来决定一个 Flex 容器的大小。但它们并不完全等同于 Flex 容器的宽高（<code>width x height</code> ）。这是因为 <code>flex-direction</code> 和 <code>writing-mode</code> 或 <code>direction</code> 属性值不同时，用于描述 Flex 容器的物理属性 <code>width</code> 和 <code>height</code> 有可能会互换的。比如：</p>
<ul>
<li>当 <code>flex-direction</code> 为 <code>row</code> ，且书写模式和阅读模式是 LTR 时，主轴的尺寸对应的就是 Flex 容器的宽度，侧轴的尺寸对应的则是 Flex 容器的高度；</li>
</ul>

<ul>
<li>当 <code>flex-direction</code> 为 <code>column</code> ，且书写模式和阅读模式是 LTR 时，主轴的尺寸对应的就是 Flex 容器的高度，侧轴的尺寸对应的则是 Flex 容器的宽度。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b07d9b08b3ca487a84ad054aa7bd8910~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>另外，可以在 Flex 容器上显式使用 CSS 的物理属性 <code>width</code> 和 <code>height</code> ，或使用 CSS 的逻辑属性 <code>inline-size</code> 和 <code>block-size</code> 设置 Flex 容器主轴和侧轴的尺寸 ，也可以使用 <code>min-*</code> 和 <code>max-*</code> 对 Flex 容器主轴和侧轴的尺寸加以限制。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97f114cfde4e4f46a9b8e39f52e4171c~tplv-k3u1fbpfcp-watermark.image?" alt="fig-02-09.png"></p>
<p>如果没有显式给 Flex 容器设置尺寸，则会根据所有 Flex 项目的大小来决定，或根据 Flex 容器的父容器来决定。</p>
<blockquote>
<p><strong>注意，如果需要显式设置 Flex 容器尺寸的话，使用逻辑属性</strong> <strong><code>inline-size</code></strong> <strong>或</strong> <strong><code>block-size</code></strong> <strong>更符合多语言的 Web 布局！</strong></p>
</blockquote>
<p>现在，我们已经知道了， <strong><code>主轴尺寸 x 侧轴尺寸</code></strong> <strong>可以决定一个 Flex 容器的大小。</strong> 在一个 Flex 容器中可能会包含一个或多个 Flex 项目，且每个 Flex 项目也会有其自身的尺寸大小，这样一来，就有可能造成：</p>
<ul>
<li>所有 Flex 项目宽度（或高度）小于 Flex 容器的宽度（或高度），Flex 容器就会有多余的空间没有被填充，那么这个多出来的空间常称为 <strong>Flex 容器的剩余空间</strong> （Positive Free Space）。</li>
</ul>

<ul>
<li>所有 Flex 项目宽度（或高度）大于 Flex 容器的宽度（或高度），Flex 项目将会溢出 Flex 容器，那么这个溢出的空间常称为 <strong>Flex 容器的不足空间</strong> （Negative Free Space），也称为 <strong>负空间</strong> 。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d934f676b6a421cb451c42aa4f0432f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>Flexbox 布局中有一个强大的特性，当 Flex 容器有剩余空间时：</p>
<ul>
<li>可以使用主轴的对齐方式 <code>justify-content</code> 来分配主尺寸的剩余空间；</li>
</ul>

<ul>
<li>可以使用侧轴的对齐方式 <code>align-content</code> 来分配侧尺寸的剩余空间。</li>
</ul>
<p>也可以使用 <code>flex</code> 属性中的 <code>flex-grow</code> 按比例因子来扩展 Flex 项目的尺寸；当 Flex 容器是不足空间（Flex 项目溢出 Flex 容器），你可以使用 <code>flex</code> 属性中的 <code>flex-shrink</code> 按比例因子来对 Flex 项目进行收缩。这个计算在 Flexbox 布局中是复杂的，而且会涉及一定的数学计算，后面我们将会有一个节课专门来介绍这方面的知识。</p>
<p>到此，你对 Flexbox 布局中的主要术语和概念有了一定的了解了，接下来，我们一起来探讨 Flexbox 布局中的几个重要特性。</p>
<h2>Flexbox 布局模块相关特性</h2>
<p>Flexbox 布局模块除了概念多之外，就是可用于 Flexbox 布局的属性也多，这些属性分为两个部分，其中一部分用于 <strong>Flex 容器</strong> 上，另一部分用于 <strong>Flex 项目</strong> 上。</p>
<p>可用于 Flex 容器上的属性主要有：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/584b5a15ed2b45bba8615773ca4291cc~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>可用于 Flex 项目上的属性相比于 Flex 容器上要少一点，它主要有：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d832f3e72844710b90bfb3f067cb0c7~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<blockquote>
<p>注意，在这里我们并不会针对每个属性进行介绍！</p>
</blockquote>
<h2>控制 Flex 项目的方向</h2>
<p>在 Flex 容器中，即使你没有显式设置 <code>flex-direction</code> 属性的值，Flex 容器中的所有 Flex 项目也会显式为一行，因为 <code>flex-direction</code> 属性的初始值是 <code>row</code> 。如果你希望 Flex 项目在 Flex 容器中不是按行呈现，而是按列呈现，则可以将其设置为 <code>column</code> 或 <code>column-reverse</code> 。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e355c20b12a47b89c7d100f04f7080a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>来看一个简单的示例：</p>
<pre><code class="hljs language-ini">&#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex项目<span class="hljs-number">1</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex项目<span class="hljs-number">2</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex项目<span class="hljs-number">3</span>&#x3C;/div>
&#x3C;/div>
</code></pre>
<pre><code class="hljs language-CSS"><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attr">--direction</span>: row;
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-direction</span>: <span class="hljs-built_in">var</span>(--direction);
}
</code></pre>
<blockquote>
<p>Demo 地址： <a href="https://codepen.io/airen/full/MWGeyLw" target="_blank" rel="nofollow noopener noreferrer">https://codepen.io/airen/full/MWGeyLw</a></p>
</blockquote>
<p>尝试改变 Demo 中 <code>flex-direction</code> 属性的值，你将看到的效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/057f3e4f17c548898a4ad7b806fa617a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>前面我们说过，默认情况下，Flex 项目排成一行，这一行与书写模式（或阅读模式）的方向是相同的，比如上面示例，使用的是英文，它的阅读模式是 <code>ltr</code> ，Flex 项目紧挨着 Flex 容器左侧边缘（左对齐）。这意味着，如果我们使用的是阿拉伯语系，即书写模式是 <code>rtl</code> ，则 Flex 项目将紧挨着 Flex 容器的右侧边缘（右侧对齐）：</p>
<pre><code class="hljs language-ini">&#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex项目<span class="hljs-number">1</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex项目<span class="hljs-number">2</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex项目<span class="hljs-number">3</span>&#x3C;/div>
&#x3C;/div>
​
&#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span> dir=<span class="hljs-string">"rtl"</span>>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>عنصر فليكس<span class="hljs-number">1</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>عنصر فليكس<span class="hljs-number">2</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>عنصر فليكس<span class="hljs-number">3</span>&#x3C;/div>
&#x3C;/div>
</code></pre>
<pre><code class="hljs language-CSS"><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attr">--direction</span>: row;
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-direction</span>: <span class="hljs-built_in">var</span>(--direction);
}
</code></pre>
<blockquote>
<p>Demo 地址：<a href="https://codepen.io/airen/full/MWGeeLo" target="_blank" rel="nofollow noopener noreferrer">https://codepen.io/airen/full/MWGeeLo</a></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad5d213431894ffaa8f07cb529586fe8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>另外，CSS 的 <code>writing-mode</code> 属性的值也将影响 <code>flex-direction</code> 属性最终呈现的效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae3b869319834fbd9c9832f6cdefe73e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<blockquote>
<p>Demo 地址：<a href="https://codepen.io/airen/full/rNvLLgJ" target="_blank" rel="nofollow noopener noreferrer">https://codepen.io/airen/full/rNvLLgJ</a></p>
</blockquote>
<p>因此，默认情况下，Flex 项目的行为与文档的书写模式相关。大多数教程使用英语编写，或者采用另一种从左到右的水平书写模式编写。这样就可以很容易地假设弹性项目<strong>在左侧</strong>对齐并沿<strong>水平方向</strong>分布。</p>
<p>在实际的业务开发中，使用 Flexbox 布局时，<code>flex-direction</code> 是非常有用的，比如下图这个布局效果，红色虚线框中的 Flex 项目是按行排列，<code>flex-direction</code> 不需要显式设置，但黑色虚线框是按列排列，需要显式将 <code>flex-direction</code> 属性的值设置为 <code>column</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a74db025d40949dbb09675e6725b3424~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p><code>flex-direction</code> 中的 <code>row</code> 和 <code>row-reverse</code> （或 <code>column</code> 和 <code>column-reverse</code>）可以让主轴的起点和终点（或侧轴的起点和终点）互换。它们在一些布局中也是非常有用的，比如像下图这样的效果，希望双数的卡片的缩略图靠右，单数的缩略图居左。我们只需要一行代码即可：</p>
<pre><code class="hljs language-scss"><span class="hljs-selector-class">.card</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>n) {
    <span class="hljs-attribute">flex-direction</span>: row-reverse;
}
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3b45f29e8744b02baa24c9cf26c6a39~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<blockquote>
<p>Demo 地址： <a href="https://codepen.io/airen/full/oNdLzov" target="_blank" rel="nofollow noopener noreferrer">https://codepen.io/airen/full/oNdLzov</a></p>
</blockquote>
<p>不过，在使用 <code>flex-direction</code> 属性值 <code>row-reverse</code> 和 <code>column-reverse</code> 时，会对 Web 可访问性造成负面影响，因为该属性只是对<strong>视觉呈现</strong>进行重排，其对应的 HTML 文档的源码顺序是不受该属性影响的。</p>
<h2>Flex 项目换行</h2>
<p>默认情况之下，Flex 容器中的所有 Flex 项目沿着主轴方向依次排列（不会换行的或换列），即使是 Flex 项目溢出了 Flex 容器也是如此。这主要是因为 <code>flex-wrap</code> 属性的默认值为 <code>nowrap</code> ：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0ef9f273ec5443d82442739086e2aab~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>需要注意的是，如果 Flex 容器没有足够多的空间，Flex 项目在溢出之前，每一个 Flex 项目将会尽可能缩小到其最小内容（<code>min-content</code>）的尺寸。即 <strong>Flex 项目一旦达到最小内容（<code>min-content</code>）大小， Flex 项目将开始溢出 Flex 容器</strong> ！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bdcaaabc2fe4909b7ca695f25efe45a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<blockquote>
<p>Demo 地址：<a href="https://codepen.io/airen/full/ZEoOpPV" target="_blank" rel="nofollow noopener noreferrer">https://codepen.io/airen/full/ZEoOpPV</a></p>
</blockquote>
<p>如果你希望避免这个现象，只需要在 Flex 容器上显式设置 <code>flex-wrap</code> 属性的值为 <code>wrap</code> ：</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">flex-wrap</span>: wrap;
 }
</code></pre>
<blockquote>
<p>Demo 地址：<a href="https://codepen.io/airen/full/XWqKNrL" target="_blank" rel="nofollow noopener noreferrer">https://codepen.io/airen/full/XWqKNrL</a></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24549d3c13624bfa9df4a5bf7672dd57~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>Flex 容器在换行后会创建多个 <strong>Flex 行</strong> 。在空间分布方面，每一行就像一个新的 Flex 容器。因此，如果你要换行，则无法让第 2 行中的某些内容与它上面第 1 行中的某些内容对齐。这就是所谓的 Flex 容器是一维框（盒子）。你只可以在独立的轴上（主轴或侧轴）也就是一行或一列上对齐 Flex 项目，但不能像 CSS Grid 那样同时在两个轴上控制 Grid 项目。</p>
<p>为此，在使用 Flexbox 布局时，为了让你的布局更具灵活性（代码更健壮，具有一定的防御性），个人建议你在显式声明的 Flex 容器上同时加上 <code>flex-wrap</code> 的值为 <code>wrap</code> :</p>
<pre><code class="hljs language-css"><span class="hljs-comment">/* 不具防御性的 CSS */</span>
<span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">display</span>: flex; <span class="hljs-comment">/* 或 inline-flex */</span>
}
​
<span class="hljs-comment">/* 具有防御性的 CSS */</span>
<span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">display</span>: flex; <span class="hljs-comment">/* 或 inline-flex */</span>
    <span class="hljs-attribute">flex-wrap</span>: wrap;
}
</code></pre>
<p>当然，如果你的布局不需要换行，那么 Flex 容器的 <code>flex-wrap</code> 采用默认值 <code>nowrap</code> 更理想。如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1df9b812fd045aa90c265c12b09aeb4~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>事实上它并不是我们所期望的效果，我们所期望的效果是下图这样的，布局需要换行，就需要显式的设置 <code>flex-wrap</code> 为 <code>wrap</code> 。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68c26d40fbe541269c6b1297f537007c~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p><code>flex-wrap</code> 属性除了取值为 <code>wrap</code> 会让 Flex 项目换行排列之外，其另一个属性 <code>wrap-reverse</code> 也会让 Flex 项目换行排列，只不过行的排列方向和 <code>wrap</code> 相反。假如你使用的语言是英文，即书写模式和阅读模式都是 <code>ltr</code> ，那么 <code>flex-wrap</code> 取值为 <code>wrap</code> 时，Flex 行的排列将会沿着 Flex 容器侧轴方向从开始处（Flex 容器顶部）向下排列；反之 <code>flex-wrap</code> 取值为 <code>wrap-reverse</code> 时， Flex 行的排列将会沿着 Flex 容器侧轴方向从终点处（Flex 容器底部）向上排列：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84081b99393446f9a696e4a047e81e35~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p><code>flex-wrap: wrap-reverse</code> 同样也受 <code>flex-direction</code> 属性取值的影响：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff43e82c27794ccbbb4cafeb3b16e985~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<blockquote>
<p>Demo 地址： <a href="https://codepen.io/airen/full/KKRadzb" target="_blank" rel="nofollow noopener noreferrer">https://codepen.io/airen/full/KKRadzb</a></p>
</blockquote>
<p>还有一点需要特别的注意，<strong><code>flex-wrap: wrap</code></strong> <strong>(或</strong> <strong><code>flex-wrap: wrap-reverse</code>)碰到了设置 <code>flex:1</code> 项目时，只有在 Flex 容器没有足够空间容纳 Flex 项目时（即，同一 Flex 行所有 Flex 项目最小内容宽度总和大于 Flex 容器宽度），才会让 Flex 项目换行（或列），另外使用</strong> <strong><code>flex-wrap: wrap</code></strong> <strong>要有一个心理预判，不然也有可能会让</strong> <strong>UI</strong> <strong>视觉上不美，但不会撑破布局（如上例所示）！</strong> 选择总是痛苦的（^_^）。</p>
<p>CSS 中有很多简写属性，简写属性可以包含多个子属性。 如果你在编写 CSS 的时候，需要同时显式设置 <code>flex-direction</code> 和 <code>flex-wrap</code> 属性时，那么可以使用它们的简写属性 <strong><code>flex-flow</code></strong> :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.flex-container</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">flex-flow</span>: column wrap;
}
​
<span class="hljs-comment">/* 等同于 */</span>
<span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-direction</span>: column;
    <span class="hljs-attribute">flex-wrap</span>: wrap;
}
</code></pre>
<p>我们在使用 <code>flex-flow</code> 属性时，<strong>可以只显式设置一个值，也可以显式设置两个值：</strong></p>
<ul>
<li><code>flex-flow</code> 只显式设置一个值，并且该值和 <code>flex-direction</code> 相匹配时， <code>flex-wrap</code> 会取值 <code>initial</code> ；</li>
</ul>

<ul>
<li><code>flex-flow</code> 只显式设置一个值，并且该值和 <code>flex-wrap</code> 相匹配时，<code>flex-direction</code> 会取值 <code>initial</code> ；</li>
</ul>

<ul>
<li><code>flex-flow</code> 显式设置两个值时， <code>flex-direction</code> 和 <code>flow-wrap</code> 没有先后顺序之分，即 <code>flex-flow: column wrap</code> 和 <code>flex-flow: wrap column</code> 所起作用是等同的。</li>
</ul>
<p>来看具体代码：</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-flow</span>: column;
    
    <span class="hljs-comment">/* flex-flow 等同于 */</span>
    <span class="hljs-attribute">flex-direction</span>: colmun;
    <span class="hljs-attribute">flex-wrap</span>: initial;
}
​
<span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-flow</span>: wrap;
    
    <span class="hljs-comment">/* flex-flow 等同于 */</span>
    <span class="hljs-attribute">flex-direction</span>: initial;
    <span class="hljs-attribute">flex-wrap</span>: wrap;
}
​
<span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-flow</span>: column wrap;
    
    <span class="hljs-comment">/* flex-flow 等同于 */</span>
    <span class="hljs-attribute">flex-flow</span>: wrap column;
    
    <span class="hljs-comment">/* flex-flow 还等同于 */</span>
    <span class="hljs-attribute">flex-direction</span>: column;
    <span class="hljs-attribute">flex-wrap</span>: wrap;
}
</code></pre>
<h2>Flex 项目排序</h2>
<p>Web 页面是由多个 HTML 元素组建而成，HTML 文档中的元素是按照其在文档中出现的先后顺序决定的，比如下面这样的一个 HTML 文档：</p>
<pre><code class="hljs language-css">&#x3C;<span class="hljs-selector-tag">body</span>>
    &#x3C;<span class="hljs-selector-tag">header</span>>&#x3C;/<span class="hljs-selector-tag">header</span>>
    &#x3C;<span class="hljs-selector-tag">main</span>>&#x3C;/<span class="hljs-selector-tag">main</span>>
    &#x3C;<span class="hljs-selector-tag">aside</span>>&#x3C;/<span class="hljs-selector-tag">aside</span>>
    &#x3C;<span class="hljs-selector-tag">footer</span>>&#x3C;/<span class="hljs-selector-tag">footer</span>>
&#x3C;/<span class="hljs-selector-tag">body</span>>
</code></pre>
<p>在没有任何 CSS 约束之下，它呈现的顺序将会是如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f02937df03a642b3aaa58f7a269b4015~tplv-k3u1fbpfcp-watermark.image?" alt="fig-03-23.jpg"></p>
<p>通过前面的内容我们知道了 Flexbox 布局中，我们可以在 Flex 容器上使用 <code>flex-direction</code> 属性的值 <code>row-reverse</code> 和 <code>column-reverse</code> 来改变主轴和侧轴上 Flex 项目的排列顺序。但不能单独改变某个 Flex 项目的顺序。如果仅是单独对某个（或某几个） Flex 项目重新排序的话，就需要使用可用于 Flex 项目上的 <code>order</code> 属性。</p>
<p>使用 <code>order</code> 属性可以为 Flex 容器中的项目重新排序。此属性可用于对<strong>有序组</strong>中的项目进行排序。项目按照 <code>flex-direction</code> 指定的方向排列，最小值在最前面。如果多个项目具有相同的值，它将与具有该值的其他项目一起显示（按其在源码文档的顺序排列）。</p>
<p><code>order</code> 初始值是 <code>0</code> ，可以是正值，也可以是负值，属性值越大，越排在主轴的后面，反之越在主轴的前面。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af09ce83d2964b56ab3e449ea74c5c6d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>如上图所示。</p>
<ul>
<li>第一组中所有 Flex 项目未显式设置 <code>order</code> 值（即默认值为<code>0</code>），Flex 项目按照 HTML 文档的源码顺序沿着主轴排列 。</li>
</ul>

<ul>
<li>第二组中第二个 Flex 项目显式设置 <code>order</code> 的值为 <code>1</code>，这个时候该 Flex 项目会排列在最末尾 。</li>
</ul>

<ul>
<li>第三组中第四个 Flex 项目显式设置 <code>order</code> 的值为 <code>-1</code>，这个时候该 Flex 项目会排列在最前面 。</li>
</ul>
<p>来看一个简单的示例：</p>
<pre><code class="hljs language-ini">&#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex Item1&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex Item2&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex Item3&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex Item4&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex Item5&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>>Flex Item6&#x3C;/div>
&#x3C;/div>
</code></pre>
<pre><code class="hljs language-CSS"><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">display</span>: flex:
    flex-wrap: wrap;
}
​
<span class="hljs-selector-pseudo">:root</span> {
  <span class="hljs-attr">--order</span>: <span class="hljs-number">0</span>;
}
​
<span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) {
  <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;
}
​
<span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) {
  <span class="hljs-attribute">order</span>: <span class="hljs-built_in">var</span>(--order);
}
​
<span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">4</span>) {
  <span class="hljs-attribute">order</span>: <span class="hljs-number">3</span>;
}
</code></pre>
<blockquote>
<p>Demo 地址： <a href="https://codepen.io/airen/full/ZEoORVY" target="_blank" rel="nofollow noopener noreferrer">https://codepen.io/airen/full/ZEoORVY</a></p>
</blockquote>
<p>示例中我们显式指定了第二个 Flex 项目的 <code>order</code> 值为 <code>-1</code> ，第四个 Flex 项目的 <code>order</code> 值为 <code>3</code> ，并且动态调整第三个 Flex 项目的 <code>order</code> 值，你将看到的效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32c99570323b4684a86188b3bfdba637~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>在 Flexbox 布局中，在 Flex 项目上使用 <code>order</code> 属性可以和在 Flex 容器上使用 <code>flex-direction</code> 的 <code>row-reverse</code> （或 <code>column-reverse</code> ）等同的效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b88537414eb24c65a8463ef7ed9d084b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p><code>order</code> 属性也适用于页面级别的布局，比如下面这个示例：</p>
<pre><code class="hljs language-css">&#x3C;!-- <span class="hljs-selector-tag">HTML</span> --> 
&#x3C;<span class="hljs-selector-tag">header</span>><span class="hljs-selector-tag">Header</span> <span class="hljs-selector-tag">Section</span>&#x3C;/<span class="hljs-selector-tag">header</span>> 
&#x3C;<span class="hljs-selector-tag">main</span>> 
    &#x3C;<span class="hljs-selector-tag">article</span>><span class="hljs-selector-tag">Article</span> <span class="hljs-selector-tag">Section</span>&#x3C;/<span class="hljs-selector-tag">article</span>> 
    &#x3C;<span class="hljs-selector-tag">nav</span>><span class="hljs-selector-tag">Nav</span> <span class="hljs-selector-tag">Section</span>&#x3C;/<span class="hljs-selector-tag">nav</span>> 
    &#x3C;<span class="hljs-selector-tag">aside</span>><span class="hljs-selector-tag">Aside</span> <span class="hljs-selector-tag">Section</span>&#x3C;/<span class="hljs-selector-tag">aside</span>> 
&#x3C;/<span class="hljs-selector-tag">main</span>> 
&#x3C;<span class="hljs-selector-tag">footer</span>><span class="hljs-selector-tag">Footer</span> <span class="hljs-selector-tag">Section</span>&#x3C;/<span class="hljs-selector-tag">footer</span>>
</code></pre>
<p>其中 <code>&#x3C;article></code> 放在 <code>&#x3C;nav></code> 和 <code>&#x3C;aside></code> 前面，主要是为了内容为先。针对这样的 DOM 结构，如果我们希望 <code>&#x3C;nav></code> 在 <code>&#x3C;article></code> 左侧，<code>&#x3C;aside></code> 在 <code>&#x3C;article></code> 右侧时，<code>order</code> 属性就可以起关键性的作用：</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">nav</span> {
    <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;
}
​
<span class="hljs-selector-tag">main</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-tag">nav</span> {
    <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>;
}
​
<span class="hljs-selector-tag">main</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-tag">aside</span> {
    <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;
}
</code></pre>
<blockquote>
<p>Demo 地址：<a href="https://codepen.io/airen/full/MWGeBKa" target="_blank" rel="nofollow noopener noreferrer">https://codepen.io/airen/full/MWGeBKa</a></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab2d833ec8464ee28b045b2b0be87b94~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>需要注意的是，<code>order</code> 在使用时与 <code>flex-direction</code> 的值 <code>row-reverse</code> 和 <code>column-reverse</code> 存在相同的问题。它对 Web 可访问性是不友好的。请勿使用 <code>order</code>，因为你需要修复文档中的乱序问题。</p>
<h2>Flex 项目之间的间距</h2>
<p>以往在 CSS 中，常常使用 <code>margin</code> 属性来设置元素与元素之间的间距。在今天，Flexbox 布局中，你可以使用 <code>gap</code> 属性来设置元素与元素之间的间距。实质上，<code>gap</code> 是用来定义<strong>列与列</strong> 或 <strong>行与行</strong> 之间的间距。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af369fe12e87402ea1d0080a6b9354a7~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p><code>gap</code> 属性的使用非常的简单，只需要在 Flex 容器显式指定<code>gap</code> 属性值即可：</p>
<pre><code class="hljs language-css"><span class="hljs-selector-pseudo">:root</span> {
  <span class="hljs-attr">--gap</span>: <span class="hljs-number">1rem</span>;
  <span class="hljs-attr">--columns</span>: <span class="hljs-number">5</span>;
}
​
<span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">gap</span>: <span class="hljs-built_in">var</span>(--gap);
}
​
<span class="hljs-selector-class">.item</span> {
  <span class="hljs-attribute">flex-basis</span>: <span class="hljs-built_in">calc</span>((<span class="hljs-number">100%</span> - (<span class="hljs-built_in">var</span>(--columns) - <span class="hljs-number">1</span>) * <span class="hljs-built_in">var</span>(--gap)) / <span class="hljs-built_in">var</span>(--columns));
}
</code></pre>
<blockquote>
<p>Demo 地址：<a href="https://codepen.io/airen/full/LYmZJjo" target="_blank" rel="nofollow noopener noreferrer">https://codepen.io/airen/full/LYmZJjo</a></p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5af4dd37046748fdb143c7d448d3f08f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p><code>gap</code> 属性可接受一个值，也可以接受两个值，当只显式设置一个值时，那么第二个值和第一个值等同，如果显式设置两个值，第一个值是 <code>row-gap</code> 属性的值，第二个则是 <code>column-gap</code> 属性的值：</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>;
    
    <span class="hljs-comment">/* 等同于 */</span>
    <span class="hljs-attribute">row-gap</span>: <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">10px</span>;
}
​
<span class="hljs-selector-class">.flex-container</span> {
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;
    
    <span class="hljs-comment">/* 等同于 */</span>
    <span class="hljs-attribute">row-gap</span>: <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;
}
</code></pre>
<p>在上面我们介绍 Flexbox 术语和概念时提到过，<code>gap</code> 和 <code>margin</code> 虽然都可以设置元素与元素之间的间距，但它们之间有明显的差异：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23af3fc956fd4b71a952065dee652177~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p><code>margin</code> 除了难以达到设计预期效果之外，它们使用的地方也略有差异：</p>
<ul>
<li><code>gap</code> 运用在 Flex 容器上，但它无法给 Flex 项目设置不同的外间距；</li>
</ul>

<ul>
<li><code>margin</code> 运用在 Flex 项目上，可以给 Flex 项目设置不同的外间距。</li>
</ul>
<p>另外，使用 <code>margin</code> 会让 Flex 项目与 Flex 容器之间有空白间距：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecc6f70f8f4649439ef9ca6a512841c8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>在 <code>gap</code> 属性还没出现之前，往往都是使用 <code>margin</code> 来模拟 <code>gap</code> 属性的效果：</p>
<pre><code class="hljs language-ini">&#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>>
  &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__container flex__container--margin"</span> data-gutter=<span class="hljs-string">"margin"</span>>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">1</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">2</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">3</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">4</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">5</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">1</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">2</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">3</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">4</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">5</span>&#x3C;/div>
  &#x3C;/div>
&#x3C;/div>
&#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>>
  &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__container flex__container--gap"</span> data-gutter=<span class="hljs-string">"gap"</span>>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">1</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">2</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">3</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">4</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">5</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">1</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">2</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">3</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">4</span>&#x3C;/div>
    &#x3C;div <span class="hljs-attr">class</span>=<span class="hljs-string">"flex__item"</span>>Flex Item <span class="hljs-number">5</span>&#x3C;/div>
  &#x3C;/div>
&#x3C;/div>
</code></pre>
<pre><code class="hljs language-CSS"><span class="hljs-selector-pseudo">:root</span> {
  <span class="hljs-attr">--flexDirection</span>: row;
  <span class="hljs-attr">--flexWrap</span>: wrap;
  <span class="hljs-attr">--item-basis</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attr">--gap</span>: <span class="hljs-number">1rem</span>;
  <span class="hljs-attr">--columns</span>: <span class="hljs-number">5</span>;
}
​
<span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(
    <span class="hljs-built_in">var</span>(--item-basis) * <span class="hljs-built_in">var</span>(--columns) + <span class="hljs-built_in">var</span>(--gap) * (<span class="hljs-built_in">var</span>(--columns) - <span class="hljs-number">1</span>) + <span class="hljs-number">6px</span>
  );
}
​
<span class="hljs-selector-class">.flex__container</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">flex-flow</span>: <span class="hljs-built_in">var</span>(--flexDirection) <span class="hljs-built_in">var</span>(--flexWrap);
}
​
<span class="hljs-selector-class">.flex__container--margin</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-built_in">calc</span>(-<span class="hljs-number">1</span> * <span class="hljs-built_in">var</span>(--gap)) <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-built_in">calc</span>(-<span class="hljs-number">1</span> * <span class="hljs-built_in">var</span>(--gap));
}
​
<span class="hljs-selector-class">.flex__container--margin</span> > <span class="hljs-selector-class">.flex__item</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-built_in">var</span>(--gap) <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-built_in">var</span>(--gap);
}
​
<span class="hljs-selector-class">.flex__container--gap</span> {
  <span class="hljs-attribute">gap</span>: <span class="hljs-built_in">var</span>(--gap);
}
​
<span class="hljs-selector-class">.flex__item</span> {
  <span class="hljs-attribute">inline-size</span>: <span class="hljs-built_in">var</span>(--item-basis);
  aspect-ratio: <span class="hljs-number">1</span>;
}
</code></pre>
<blockquote>
<p>Demo 地址： <a href="https://codepen.io/airen/full/wvjWERe" target="_blank" rel="nofollow noopener noreferrer">https://codepen.io/airen/full/wvjWERe</a></p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e1f4925940143f4aca7f422f2ad035e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h2>小结</h2>
<p>通过这一节的学习，我想你对 Flexbox 布局应该有了进一步的了解。知道了如何使用 <code>flex-direction</code> 和 <code>order</code> 来控制 Flex 项目的排序；如何使用 <code>flex-wrap</code> 属性让 Flex 项目换行以及使用 <code>gap</code> （或 <code>margin</code>）控制 Flex 项目之间的间距等。</p>
<p>这些只是 Flexbox 布局基础知识的几个关键功能，其实 Flexbox 布局中还有另一个关键功能，那就是 Flex 容器空间分配。接下来的课程中，我将着重和大家一起探讨 Flex 容器的空间是如何分配的，也就是 Flexbox 布局中对齐模式。</p></div>
</body></html>