<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>实战项目二：实现“日记”项目多页面管理</h1>
<p>从本讲开始，进入《日记》实战项目的开发部分，这款应用缘起《你的名字》动漫。先来通过下面的 GIF 动画大致了解下最终的“成品”。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5a9d45760264707af5b579a151f9a2c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>从图中可以看到，这其实是在使用 Android 手机运行 iOS 风格的程序。得益于 Flutter 中组件设计上的自由，动图中虽然使用 Android 模拟器运行，但整体程序风格仍保持 iOS 风格该有的样式。除了动图中展示的功能外，首次运行程序还将引导用户完成性别和主题色选择，还有日记编辑功能。</p>
<p>显然，和之前的《一言》程序相比，《日记》则更加复杂。最直观的感受可能就是页面变多了，功能也变多了。</p>
<p>这节课我们会对整体的项目页面结构进行设计与实现，为了实现多页面的组织管理，还要引入一个新的概念——<strong>页面导航</strong>。</p>
<h2>设计页面导航</h2>
<p>通俗地说，<strong>页面导航就是多页面跳转的“地图”，它指明了所有页面的所有出口和入口</strong>。举例来说，下图便是一个简单的游戏页面导航图设计：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a49b0fe396d9441b98c5582b4bd67f8f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<blockquote>
<p>注：该图摘自 Android Developer 网站（<a href="https://developer.android.google.cn/guide/navigation/navigation-design-graph" target="_blank" rel="nofollow noopener noreferrer">设计导航图 | Android 开发者 | Android Developers (google.cn)</a>）</p>
</blockquote>
<p>可以看到，游戏<strong>所有的页面都罗列在导航图中</strong>，<strong>箭头表明了跳转的方向</strong>，<strong>线条表明了跳转的起点和目的地</strong>。</p>
<p>下面回到《日记》应用，除了调用系统相机页面外，总共包含 4 个页面，分别是：</p>
<ul>
<li>首次运行时的资料配置页；</li>
<li>浏览日记列表页；</li>
<li>写日记页面；</li>
<li>读日记页面。</li>
</ul>
<p><code>💡 提示：为什么其它程序的界面不包含在导航图中呢？这是因为其它程序是如何设计的，我们并不知道，也不太可能知道。我们的可控范围只局限在我们要开发的软件中。</code></p>
<p>接下来，对比下面两个设计图，大家想想哪一种设计更合理？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/821dfa7e70224443bae774ee162b75de~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>仔细观察 A 和 B，它们有两个不同点：</p>
<ul>
<li>程序启动后的首页不同；</li>
<li>A 中，资料配置页面只能单向跳转到日记列表页面，B 中二者可以双向跳转。</li>
</ul>
<p>可能很多人会选择 A，因为它最符合“流程”：软件启动后先进行资料配置，完成后进入日记列表页，在列表页可以查看历史日记（跳转到读日记页面）和写新的日记（跳转到写日记页面）。这套逻辑似乎无可厚非，但真的合适吗？</p>
<p>想象一下，首次启动软件，确实可以按上述逻辑进行。但如果是第二次、第三次呢？用户会感觉很奇怪：我明明之前设置过了各种资料，为什么又让我设置一次？同理，类似有登录/注册功能的软件也是如此。明明登录过，为何又让我登录一次……</p>
<p>一种解决之道（A）是在资料配置页面做判断。</p>
<p>如果之前配置过就直接跳转到日记列表页面。这确实解决了重复配置的问题，但新的问题随之出现：“做判断”的逻辑包含在资料配置页之中，这就意味着该页面无论如何也要出现一次，然后才有可能发生跳转。也就意味着用户无论如何也要面对一次他有可能无需面对的页面……</p>
<p>当然，也不是没有优化方法：如果需要配置，则绘制页面组件；不需要配置则直接跳转，同时无需执行页面跳转动画。天呢！真是太麻烦了，搞不好会引入 Bug……</p>
<p>另一种解决之道（B）是把日记列表页作为起始页，程序启动则立即判断是否已经配置了资料，没有配置的话则跳转到资料配置页面；如果配置过了就呆在这，继续显示日记列表页，哪儿都不跳。</p>
<p>相比起来，B 方案无论在体验方面还是开发上都更优，这也是目前大部分软件都采用的一种方案，但并不是全部。有些安全等级要求高的软件依然需要登录，比如银行、交易类的软件。甚至还会在某个时机跳出手势或面部识别页面进行验证，这就需要大家在设计页面导航时考虑更多条件分支，更为妥善处理了。</p>
<h2>页面堆栈</h2>
<p>当页面跳转时，旧的页面不会消失。默认情况下，新的页面会在旧页面的“上方”，“挡住”旧页面，就好像叠罗汉一样。这种“叠罗汉”的结构，被称为“页面堆栈”。要理解“页面堆栈”的概念，最好是“看图说话”。我们一起来看下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b97b7e4d4a5c4e66b6f5fa481399345c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个图描绘的是页面跳转的过程，即由页面 A 跳转到页面 B，再跳转到页面 C。同时，存在 <strong>“页面堆栈”，它“记录”着页面跳转的历史，以栈的形式存在，所有页面的存入和取出都在栈顶进行</strong>。这就意味着，当用户从页面 C 进行返回操作时，页面 B 会再次出现。</p>
<p>这样的返回逻辑<strong>满足了大部分的场景</strong>需求，但总有那么一小撮需求独具特色。</p>
<p>回到《日记》，日记列表页和资料配置页面就属于那“一小撮”。程序运行后，日记列表页会首先显示，当没有配置资料时，跳转到资料配置页面，随后再跳回日记列表页。此时，用户若进行返回操作，在默认情况下，将再次回到资料配置页。再返回的话，又会回到最初的日记列表页……还是看图说话：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cdd7046f1f2457987b658419c81a26a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>要破局，有两种解决之道：</p>
<ul>
<li>一是不跳转，让当前页面直接出栈。这种方式适用于资料配置页跳转到日记列表页，让资料配置页直接出栈就行了。不过这样做需要“告知”日记列表页：配置发生更改了，你要赶快应用最新的参数；</li>
<li>二是跳转的同时清理堆栈，也就是说跳转后自己成为栈底，之前的页面都不在了。这样一来，无论用户怎么返回，也不会回到错误的页面上。</li>
</ul>
<p>上述两种方式<strong>孰优孰劣要根据实际情况做判定</strong>，对于《日记》，显然第二种更简单易行。还是用图来表示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ab30c21af8344b9b67e5292b5ea2997~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><code>💡 提示：无需担心返回会直接退出程序。想象一下，在进行首次资料配置时，用户按了返回键，相当于放弃使用。退出程序不正是很合理的响应吗？</code></p>
<p>使用<strong>页面“路由”是实现页面跳转的途径</strong>。可以<strong>按照“key-value”的形式理解，key 是路径，value 表示某个页面及跳转处理逻辑</strong>。跳转时，<strong>通过key来指明跳转的目的地。同时，还能附带数据、设置跳转动画、设置是否清除</strong> <strong>堆栈</strong>。具体的实现步骤，稍后将结合实际代码讲解。</p>
<h2>创建项目，并添加“占位”页面</h2>
<p>我们先创建一个项目，名为 diary。同时别忘了修改默认包名，选中所有支持的平台，修改 Android 开发语言为 Java，iOS 开发语言为 Objective-C。如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be249062022f4c1d82a9c06687123c88~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>接着，按照如下图所示的结构创建项目结构。每个文件及目录的意义在下图中都已经标明，供大家参考：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86d667b8432548aba50d2576fcd69bf2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><code>💡 提示：读日记页面去哪儿了？在一开始的动图中可以看到，读日记页面其实是一个对话框。在 Flutter 中，对话框通过 showCupertinoDialog() 或类似函数显示，和全屏页面不同。具体内容将在后面的章节中详述。根据实际需求，读日记对话框的源码位置在 ui\index\widget 中。</code></p>
<p>可以看到，每个页面都有各自的 widget 目录，在 ui 目录中，还有一个公共的 widget 目录。前者存放的自定义组件仅用于所属的页面中，若某个自定义组件的使用范围超过单个页面，则应将其放在公共 widget 目录中。</p>
<p>日记列表页面包含全部日记列表页面和按日期筛选日记列表页面，源码组织形式结构与此保持一致。</p>
<p>最后，为了确认页面跳转逻辑的正确性，每个页面都暂时摆放一个居中的标题文本框。比如资料配置页面，它的完整代码如下：</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/cupertino.dart'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfigurationPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> AppConfigurationPage({Key? key}) : <span class="hljs-keyword">super</span>(key: key);
  <span class="hljs-meta">@override</span>
  State&#x3C;AppConfigurationPage> createState() => _AppConfigurationPageState();
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_AppConfigurationPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&#x3C;<span class="hljs-title">AppConfigurationPage</span>> </span>{
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> CupertinoPageScaffold(child: Center(child: Text(<span class="hljs-string">'资料配置页面'</span>)));
  }
}
</code></pre>
<p>依葫芦画瓢，其它页面修改类名和文本框中的文字内容即可，这里就不再详述了。</p>
<p>值得注意的是，写日记页面需要传入日记 id 以便实现编辑功能。当 id 存在时，从数据库加载相应内容，最后更新数据库；当 id 不存在时，保持内容为空，最后向数据库写入新数据。</p>
<p>另外还需创建一个路由出错的页面，用于找不到路由“key”值时的默认跳转目的地（尽管这不太可能发生，但万一呢）。</p>
<h2>实战 fluro 路由库的使用</h2>
<p>Flutter 框架内置了页面跳转的 API，但为了更高效地编程，我更推荐大家使用成熟的库，fluro 便是其中一款。</p>
<p>集成 fluro 的方法非常简单，在 fluro 库<a href="https://pub.flutter-io.cn/packages/fluro" target="_blank" rel="nofollow noopener noreferrer">首页</a>就能找到最新的版本，添加到 pubspec.yaml 中即可。我使用的版本号是 2.0.3，相应代码如下：</p>
<pre><code class="hljs language-dart">dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^<span class="hljs-number">1.0</span><span class="hljs-number">.2</span>
  ...
  # 全局路由
  fluro: ^<span class="hljs-number">2.0</span><span class="hljs-number">.3</span>
  ...
</code></pre>
<p>添加好后，执行一次 flutter pub get 获取包内容。</p>
<p>接下来，在 lib 目录中新建一个 router 目录，用来存放 routes.dart，这个文件中定义了具体的路由跳转路径。</p>
<p>通过阅读官方指导文档，我们了解到路由的定义通过 <code>router.define()</code> 方法实现，<strong>该方法需要两个参数，一个是路径，另一个是 handler 类型的变量</strong>。</p>
<p>前文中提到：我们可以把路由看作是“key-value”结构，key 相当于路径，value 包含某个页面及跳转处理逻辑。换言之，<strong>跳转目的地和处理逻辑都在 handler 中</strong>。</p>
<p>《日记》程序的起始页是日记列表页，对应到代码中是 index.dart。因此，路由如下定义：</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:fluro/fluro.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/cupertino.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'../ui/index/index.dart'</span>;
<span class="hljs-comment">//主页面</span>
<span class="hljs-keyword">var</span> indexHandler = Handler(
    handlerFunc: (BuildContext? context, <span class="hljs-built_in">Map</span>&#x3C;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">String</span>>> params) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> IndexPage();
});
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Routes</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> indexPage = <span class="hljs-string">'/'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> configureRoutes(FluroRouter router) {
    router.define(indexPage, handler: indexHandler);
  }
}
</code></pre>
<p>对于无需传递参数的页面而言，如此便定义好了路由。而对于需要传递参数的页面而言，则需要做些特定的处理了。比如写日记页面，该页面承担了新增日记和编辑旧日记的功能。其关键在于有无 id 参数。当 id 存在且不为空字符串时为编辑状态；反之则是新增。因此，写日记页面的路由定义如下：</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:fluro/fluro.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/cupertino.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'../ui/write_new/write_new.dart'</span>;
<span class="hljs-keyword">var</span> writeDiaryHandler = Handler(
    handlerFunc: (BuildContext? context, <span class="hljs-built_in">Map</span>&#x3C;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">String</span>>> params) {
  <span class="hljs-keyword">if</span> (params.isNotEmpty &#x26;&#x26; params[<span class="hljs-string">'id'</span>] != <span class="hljs-keyword">null</span>) {
    <span class="hljs-keyword">return</span> WriteNewPage(id: params[<span class="hljs-string">'id'</span>]![<span class="hljs-number">0</span>]);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> WriteNewPage(id: <span class="hljs-string">""</span>);
  }
});
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Routes</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> writeDiaryPage = <span class="hljs-string">'/writeDiary'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> configureRoutes(FluroRouter router) {
     router.define(<span class="hljs-string">"<span class="hljs-subst">$writeDiaryPage</span>/:id"</span>, handler: writeDiaryHandler);
  }
}
</code></pre>
<p>请大家注意此时 router.define() 方法传入的路径格式。如果你还不清楚如何构建可接受参数的 WriteNewPage 页面，请参考文末的附录。</p>
<p>全部日记列表和按日期筛选日记列表页是日记列表页面的子页面，有日记列表页面的 Tab 结构管理，无需进行路由定义。这样一来，《日记》程序总共需要 4 个页面被路由管理，其中包含 1 个默认跳转页面（或称为找不到地址页面、404 页面……）。</p>
<p>完整的 routes.dart 源码如下所示：</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:fluro/fluro.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/cupertino.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'../ui/app_configuration/app_configuration.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'../ui/write_new/write_new.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'../ui/default/default_page.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'../ui/index/index.dart'</span>;
<span class="hljs-comment">//路由出错的默认页面</span>
<span class="hljs-keyword">var</span> errorHandler = Handler(
    handlerFunc: (BuildContext? context, <span class="hljs-built_in">Map</span>&#x3C;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">String</span>>> params) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> DefaultPage();
    });
<span class="hljs-comment">//程序参数配置页面</span>
<span class="hljs-keyword">var</span> appConfigurationHandler = Handler(
    handlerFunc: (BuildContext? context, <span class="hljs-built_in">Map</span>&#x3C;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">String</span>>> params) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> AppConfigurationPage();
    });
<span class="hljs-comment">//主页面</span>
<span class="hljs-keyword">var</span> indexHandler = Handler(
    handlerFunc: (BuildContext? context, <span class="hljs-built_in">Map</span>&#x3C;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">String</span>>> params) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> IndexPage();
    });
<span class="hljs-comment">//写日记</span>
<span class="hljs-keyword">var</span> writeDiaryHandler = Handler(
    handlerFunc: (BuildContext? context, <span class="hljs-built_in">Map</span>&#x3C;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">String</span>>> params) {
      <span class="hljs-keyword">if</span> (params.isNotEmpty &#x26;&#x26; params[<span class="hljs-string">'id'</span>] != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> WriteNewPage(id: params[<span class="hljs-string">'id'</span>]![<span class="hljs-number">0</span>]);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> WriteNewPage(id: <span class="hljs-string">""</span>);
      }
    });
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Routes</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> indexPage = <span class="hljs-string">'/'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> errorPage = <span class="hljs-string">'/error'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> writeDiaryPage = <span class="hljs-string">'/writeDiary'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> appConfigurationPage = <span class="hljs-string">'/appConfiguration'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> configureRoutes(FluroRouter router) {
    router.define(appConfigurationPage, handler: appConfigurationHandler);
    router.define(indexPage, handler: indexHandler);
    router.define(<span class="hljs-string">"<span class="hljs-subst">$writeDiaryPage</span>/:id"</span>, handler: writeDiaryHandler);
    router.notFoundHandler = errorHandler;
  }
}
</code></pre>
<p>回到 main.dart，按照 fluro 文档中所述创建 FluroRouter 实例（router）；然后调用刚刚实现的 Routes 类中 configureRoutes() 方法，将 router 作为参数传入其中；最后，在 CupertinoApp 中将 router.generator 作为 onGenerateRoute 参数的值使用。代码如下：</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:diary/router/routes.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:diary/ui/index/index.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:fluro/fluro.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/cupertino.dart'</span>;
<span class="hljs-keyword">final</span> router = FluroRouter();
<span class="hljs-keyword">void</span> main() {
  <span class="hljs-comment">// 配置路由</span>
  Routes.configureRoutes(router);
  runApp(<span class="hljs-keyword">const</span> MyApp());
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({Key? key}) : <span class="hljs-keyword">super</span>(key: key);
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> CupertinoApp(onGenerateRoute: router.generator, home: <span class="hljs-keyword">const</span> Diary());
  }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Diary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> Diary({Key? key}) : <span class="hljs-keyword">super</span>(key: key);
  <span class="hljs-meta">@override</span>
  State&#x3C;Diary> createState() => _DiaryState();
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_DiaryState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&#x3C;<span class="hljs-title">Diary</span>> </span>{
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> IndexPage();
  }
}
</code></pre>
<p>好了，运行一下程序吧，出现下图所示的界面就代表大功告成了！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6171ff7f5d7444b80a89a52d8acc8e4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>最后，如果要实现从日记列表页跳转到资料配置页面，该如何做呢？</p>
<p>答案还是按照 fluro 官方文档的指导即可：</p>
<pre><code class="hljs language-dart">router.navigateTo(context, Routes.appConfigurationPage, clearStack: <span class="hljs-keyword">true</span>);
</code></pre>
<p>请注意，这里 clearStack 给了 true，意思是清理页面跳转堆栈。该值默认为 false。</p>
<p><strong>在 Flutter 中，setState()、页面跳转等操作都要求当前界面处于 mounted 状态，否则会出现异常</strong>。由于页面跳转的时机非常靠前，因此就要确保当前界面为 mounted 状态才行。</p>
<p><strong>Flutter 中提供了 WidgetsBinding.instance.addPostFrameCallback() 回调方法来保证这一点</strong>，具体请参考下面的代码片段：</p>
<pre><code class="hljs language-dart"><span class="hljs-meta">@override</span>
<span class="hljs-keyword">void</span> initState() {
  <span class="hljs-keyword">super</span>.initState();
  WidgetsBinding.instance.addPostFrameCallback((_) {
    <span class="hljs-comment">// 未进行资料配置，跳转到相应页面进行</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) {
      router.navigateTo(context, Routes.appConfigurationPage,
          clearStack: <span class="hljs-keyword">true</span>);
    }
  });
}
</code></pre>
<p>再次运行程序，显示如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84a7555928be4dfc9fbf8fd2b37669c5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>此时在按返回键，程序将直接退出。</p>
<h2>总结</h2>
<p>🎉 恭喜，您完成了本次课程的学习！</p>
<p>📌 以下是本次课程的重点内容总结：</p>
<p>本讲详细规划设计了《日记》项目中<strong>所有页面的跳转逻辑</strong>。具体来说，我们首先设计了“<strong>页面导航图</strong>”，它<strong>指明了程序的入口页面以及每个页面的所有出口和入口路径</strong>。同时，<strong>由于“页面堆栈”机制的存在，还需在必要时清除堆栈</strong>。</p>
<p>为了实现导航图中所描绘的“愿景”，引入了“<strong>页面路由</strong>”的概念。使用时的思路<strong>类似“key-value”的形式，通过 key 来指明跳转的目的地，value 表示详细的跳转动作</strong>。跳转时还可包含数据、指定跳转动画以及设置是否清除堆栈。<strong>fluro 库</strong>可以帮我们轻松实现页面跳转。</p>
<p>在项目创建伊始，程序的功能往往并未准备就绪，因此我们使用若干“<strong>占位页面</strong>”实现了所有页面跳转。 同时，这些 <strong>“占位页面”充当了整个程序的 UI 结构</strong>，为后面的开发工作指明了方向。</p>
<p>最后，需要特别注意的一点：在页面尚未处于“mounted”状态时，强行跳转会发生异常。此处我们<strong>使用WidgetsBinding.instance.addPostFrameCallback() 回调方法等待页面进入“mounted”</strong> 后再执行跳转。</p>
<p>到此，《日记》项目的整体 UI 框架就构建得差不多了，后面到了填“肉”的环节。</p>
<p>➡️ 在下次课程中，我们会继续《日记》程序的开发，具体内容是：</p>
<ul>
<li>本地持久化的实现，具体包括首选项与本地数据库（SQLite）的设计、实现与封装。</li>
</ul>
<h2>附录：WriteNewDiary.dart 源码</h2>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/cupertino.dart'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteNewPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> WriteNewPage({Key? key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.id}) : <span class="hljs-keyword">super</span>(key: key);
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> id;
  <span class="hljs-meta">@override</span>
  State&#x3C;WriteNewPage> createState() => _WriteNewPageState();
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_WriteNewPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&#x3C;<span class="hljs-title">WriteNewPage</span>> </span>{
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> CupertinoPageScaffold(child: Center(child: Text(<span class="hljs-string">'写日记'</span>)));
  }
}
</code></pre></div>
</body></html>