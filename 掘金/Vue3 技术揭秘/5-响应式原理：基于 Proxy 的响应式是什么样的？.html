<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>响应式原理：基于 Proxy 的响应式是什么样的？</h1>
<h2>前言</h2>
<p>本小节我们开启响应式原理的篇章，在开启这个篇章之前，我们先来了解一下 <code>Vue3</code> 中一个基于 <code>Composition API</code> 响应式应用的例子是如何编写的：</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">template</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
    {{ state.msg }} {{ count }}
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">template</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">import</span> { reactive, ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
        <span class="hljs-attr">msg</span>: <span class="hljs-string">'hello world'</span>
      })
      
      <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
      
      <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeMsg</span> = (<span class="hljs-params"></span>) => {
        state.<span class="hljs-property">msg</span> = <span class="hljs-string">'world hello'</span>
      }

      <span class="hljs-keyword">return</span> {
        state,
        count,
        changeMsg,
      }
    }
  }
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
</code></pre>
<p>此时我们通过 <code>reactive API</code> 或者 <code>ref API</code> 来定义响应式对象。</p>
<p>对于 <code>reactive API</code> 而言，核心是用来定义集合类型的数据，比如：普通对象、数组和 <code>Map</code>、<code>Set</code>。</p>
<p>对于 <code>ref API</code> 而言，可以用来对 <code>string</code>、<code>number</code>、<code>boolean</code> 这些原始类型数据进行响应式定义。</p>
<p>关于二者使用上的更多区别和差异，小伙伴们可以直接参见 <code>Vue 3</code> 官网上<a href="https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html" target="_blank" rel="nofollow noopener noreferrer">《响应式基础》</a>这个章节中的介绍。对于二者的核心实现原理，其实都是依托于 <code>Vue 3</code> 的响应式基础，本小节将以 <code>reactive API</code> 作为切入点，核心分析 <code>Vue 3</code> 的响应式原理。</p>
<h2>Reactive</h2>
<p>找到源码中关于 <code>reactive</code> 部分的定义：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target: object</span>) {
  <span class="hljs-comment">// 不需要对 readonly 的对象进行响应式</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isReadonly</span>(target)) {
    <span class="hljs-keyword">return</span> target
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createReactiveObject</span>(
    target,
    <span class="hljs-literal">false</span>,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  )
}
</code></pre>
<p>这个函数核心也就是通过 <code>createReactiveObject</code> 把我们传入的 <code>target</code> 变成响应式的：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactiveObject</span>(<span class="hljs-params">target, isReadonly, baseHandlers, collectionHandlers, proxyMap</span>) {
  <span class="hljs-comment">// 如果目标不是对象，则直接返回</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(target)) {
    <span class="hljs-keyword">return</span> target
  }
  <span class="hljs-comment">// 已经是一个响应式对象了，也直接返回</span>
  <span class="hljs-keyword">if</span> (
    target[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">RAW</span>] &#x26;&#x26;
    !(isReadonly &#x26;&#x26; target[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>])
  ) {
    <span class="hljs-keyword">return</span> target
  }
  <span class="hljs-comment">// proxyMap 中已经存入过 target，直接返回</span>
  <span class="hljs-keyword">const</span> existingProxy = proxyMap.<span class="hljs-title function_">get</span>(target)
  <span class="hljs-keyword">if</span> (existingProxy) {
    <span class="hljs-keyword">return</span> existingProxy
  }
  <span class="hljs-comment">// 只有特定类型的值才能被 observe.</span>
  <span class="hljs-keyword">const</span> targetType = <span class="hljs-title function_">getTargetType</span>(target)
  <span class="hljs-keyword">if</span> (targetType === <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">INVALID</span>) {
    <span class="hljs-keyword">return</span> target
  }
  <span class="hljs-comment">// 通过 proxy 来构造一个响应式对象</span>
  <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(
    target,
    targetType === <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">COLLECTION</span> ? collectionHandlers : baseHandlers
  )
  <span class="hljs-comment">// 缓存 target proxy</span>
  proxyMap.<span class="hljs-title function_">set</span>(target, proxy)
  <span class="hljs-keyword">return</span> proxy
}
</code></pre>
<p>上述整个核心流程就是首先经过一系列判断，判断符合要求的 <code>target</code> 才能被响应式，整理的判断包括了<code>target</code> 的类型、是否是响应式的、是否已经被定义过了，以及是否是符合要求的类型这些步骤，最后执行的是 <code>new Proxy()</code> 这样的一个响应式代理 <code>API</code>。一起来看看这个 <code>API</code> 的实现：</p>
<pre><code class="hljs language-js">  <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(
    target,
    targetType === <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">COLLECTION</span> ? collectionHandlers : baseHandlers
  )
</code></pre>
<p><code>Proxy</code> 根据 <code>targetType</code> 来确定执行的是 <code>collectionHandlers</code> 还是 <code>baseHandlers</code>。那 <code>targetType</code> 是什么时候确定的呢？可以看一下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> targetType = <span class="hljs-title function_">getTargetType</span>(target)

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getTargetType</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">return</span> value[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">SKIP</span>] || !<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isExtensible</span>(value)
    ? <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">INVALID</span>
    : <span class="hljs-title function_">targetTypeMap</span>(<span class="hljs-title function_">toRawType</span>(value))
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">toRawType</span> = (<span class="hljs-params">value</span>) => {
  <span class="hljs-comment">// toTypeString 转换成字符串的方式，比如 "[object RawType]"</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">toTypeString</span>(value).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>)
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">targetTypeMap</span>(<span class="hljs-params">rawType</span>) {
  <span class="hljs-keyword">switch</span> (rawType) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Object'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Array'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">COMMON</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Map'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Set'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'WeakMap'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'WeakSet'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">COLLECTION</span>
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">INVALID</span>
  }
}
</code></pre>
<p>因为 <code>target</code> 传入进来的是一个 <code>Object</code>，所以 <code>toRawType(value)</code> 得到的值是 <code>Object</code>。所以这里的 <code>targetType</code> 的值等于 <code>TargetType.COMMON</code> 也就是执行了 <code>baseHandlers</code> 。而当我们的 <code>reactive(target)</code> 中的 <code>target</code> 是个 <code>WeakMap</code> 或者 <code>WeakSet</code> 时，那么执行的就是 <code>collectionHandlers</code> 了。</p>
<p>接下来看一下 <code>baseHandlers</code> 的实现：</p>
<pre><code class="hljs language-arduino"><span class="hljs-keyword">export</span> <span class="hljs-type">const</span> mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
}
</code></pre>
<p>这里就是 <code>Proxy</code> 中的定义 <code>handler</code> 的一些属性。</p>
<ul>
<li>get：属性读取操作的捕捉器。</li>
<li>set：属性设置操作的捕捉器。</li>
<li>deleteProperty：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete" target="_blank" rel="nofollow noopener noreferrer">delete</a> 操作符的捕捉器。</li>
<li>has：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in" target="_blank" rel="nofollow noopener noreferrer">in</a> 操作符的捕捉器。</li>
<li>ownKeys：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" target="_blank" rel="nofollow noopener noreferrer">Object.getOwnPropertyNames</a> 方法和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="nofollow noopener noreferrer">Object.getOwnPropertySymbols</a> 方法的捕捉器。</li>
</ul>
<p>而关于响应式核心的部分就在 <code>set</code> 和 <code>get</code> 中，我们一起来看一下二者的定义实现。</p>
<h3>1. get</h3>
<p>其中 <code>get</code> 的实现：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> get = <span class="hljs-comment">/*#__PURE__*/</span> <span class="hljs-title function_">createGetter</span>()
</code></pre>
<p>可以看到核心其实通过 <code>createGetter</code> 来实现的：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createGetter</span>(<span class="hljs-params">isReadonly = <span class="hljs-literal">false</span>, shallow = <span class="hljs-literal">false</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">target: Target, key: string | symbol, receiver: object</span>) {
    <span class="hljs-comment">// 对 ReactiveFlags 的处理部分</span>
    <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>) {
      <span class="hljs-keyword">return</span> !isReadonly
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_READONLY</span>) {
      <span class="hljs-keyword">return</span> isReadonly
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_SHALLOW</span>) {
      <span class="hljs-keyword">return</span> shallow
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
      key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">RAW</span> &#x26;&#x26;
      receiver ===
        (isReadonly
          ? shallow
            ? shallowReadonlyMap
            : readonlyMap
          : shallow
          ? shallowReactiveMap
          : reactiveMap
        ).<span class="hljs-title function_">get</span>(target)
    ) {
      <span class="hljs-keyword">return</span> target
    }
    
    <span class="hljs-keyword">const</span> targetIsArray = <span class="hljs-title function_">isArray</span>(target)
    <span class="hljs-keyword">if</span> (!isReadonly) {
      <span class="hljs-comment">// 数组的特殊方法处理</span>
      <span class="hljs-keyword">if</span> (targetIsArray &#x26;&#x26; <span class="hljs-title function_">hasOwn</span>(arrayInstrumentations, key)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(arrayInstrumentations, key, receiver)
      }
      <span class="hljs-comment">// 对象 hasOwnProperty 方法处理</span>
      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'hasOwnProperty'</span>) {
        <span class="hljs-keyword">return</span> hasOwnProperty
      }
    }
    <span class="hljs-comment">// 取值</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)
    
    <span class="hljs-comment">// Symbol Key 不做依赖收集</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSymbol</span>(key) ? builtInSymbols.<span class="hljs-title function_">has</span>(key) : <span class="hljs-title function_">isNonTrackableKeys</span>(key)) {
      <span class="hljs-keyword">return</span> res
    }
    
    <span class="hljs-comment">// 进行依赖收集</span>
    <span class="hljs-keyword">if</span> (!isReadonly) {
      <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">GET</span>, key)
    }
    
    <span class="hljs-comment">// 如果是浅层响应，那么直接返回，不需要递归了</span>
    <span class="hljs-keyword">if</span> (shallow) {
      <span class="hljs-keyword">return</span> res
    }
    
    
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRef</span>(res)) {
      <span class="hljs-comment">// 跳过数组、整数 key 的展开</span>
      <span class="hljs-keyword">return</span> targetIsArray &#x26;&#x26; <span class="hljs-title function_">isIntegerKey</span>(key) ? res : res.<span class="hljs-property">value</span>
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(res)) {
      <span class="hljs-comment">// 如果 isReadonly 是 true，那么直接返回 readonly(res)</span>
      <span class="hljs-comment">// 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式</span>
      <span class="hljs-keyword">return</span> isReadonly ? <span class="hljs-title function_">readonly</span>(res) : <span class="hljs-title function_">reactive</span>(res)
    }

    <span class="hljs-keyword">return</span> res
  }
}
</code></pre>
<p>因为调用 <code>createGetter</code> 时，默认参数 <code>isReadonly = false</code>，所以这里可以先忽略 <code>isReadonly</code> 的部分。整体而言，该函数还是比较通俗易懂的，首先对 <code>key</code> 属于 <code>ReactiveFlags</code> 的部分做了特殊处理，这也是为什么在 <code>createReactiveObject</code> 函数中判断响应式对象是否存在 <code>ReactiveFlags.RAW</code> 属性，如果存在就返回这个响应式对象本身。</p>
<p>然后当我们的 <code>target</code> 是数组，且 <code>key</code> 值存在 <code>arrayInstrumentations</code> 中时，返回 <code>arrayInstrumentations</code> 中对应的 <code>key</code> 值。再来看看 <code>arrayInstrumentations</code> 是个什么：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arrayInstrumentations = <span class="hljs-title function_">createArrayInstrumentations</span>()

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createArrayInstrumentations</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> instrumentations = {};
  ([<span class="hljs-string">'includes'</span>, <span class="hljs-string">'indexOf'</span>, <span class="hljs-string">'lastIndexOf'</span>]).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =></span> {
    instrumentations[key] = <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">this</span>, ...args</span>) {
      <span class="hljs-comment">// toRaw 可以把响应式对象转成原始数据</span>
      <span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">toRaw</span>(<span class="hljs-variable language_">this</span>)
      
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &#x3C; l; i++) {
        <span class="hljs-comment">// 对数组的每一项进行依赖收集</span>
        <span class="hljs-title function_">track</span>(arr, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">GET</span>, i + <span class="hljs-string">''</span>)
      }
      <span class="hljs-comment">// 先尝试用参数本身，可能是响应式数据</span>
      <span class="hljs-keyword">const</span> res = arr[key](...args)
      <span class="hljs-keyword">if</span> (res === -<span class="hljs-number">1</span> || res === <span class="hljs-literal">false</span>) {
        <span class="hljs-comment">// 如果失败，再尝试把参数转成原始数据</span>
        <span class="hljs-keyword">return</span> arr[key](...args.<span class="hljs-title function_">map</span>(toRaw))
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> res
      }
    }
  })
  <span class="hljs-comment">// instrument length-altering mutation methods to avoid length being tracked</span>
  <span class="hljs-comment">// which leads to infinite loops in some cases (#2137)</span>
  ;([<span class="hljs-string">'push'</span>, <span class="hljs-string">'pop'</span>, <span class="hljs-string">'shift'</span>, <span class="hljs-string">'unshift'</span>, <span class="hljs-string">'splice'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =></span> {
    instrumentations[key] = <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">this</span>: unknown[], ...args: unknown[]</span>) {
      <span class="hljs-title function_">pauseTracking</span>()
      <span class="hljs-keyword">const</span> res = (<span class="hljs-title function_">toRaw</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-keyword">as</span> any)[key].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)
      <span class="hljs-title function_">resetTracking</span>()
      <span class="hljs-keyword">return</span> res
    }
  })
  <span class="hljs-keyword">return</span> instrumentations
}
</code></pre>
<p>当<code>reactive</code>函数传入数组时，<code>get</code>捕获器会先在<code>arrayInstrumentations</code>对象上查找，如果找不到，再在代理对象<code>target</code>上查找。<code>arrayInstrumentations</code>对象会重写两类函数，一类是查询类函数: <code>includes</code>、 <code>indexOf</code>、 <code>lastIndexOf</code>，代表对数组的读取操作。在这些函数中会执行<code>track</code>函数，对数组上的索引和<code>length</code>属性进行追踪。</p>
<p>一类是修改类函数<code>push</code>、 <code>pop</code>、 <code>shift</code>、 <code>unshift</code>、 <code>splice</code>，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。关于这里的一些说明也可以参见 <a href="https://github.com/vuejs/core/issues/2137" target="_blank" rel="nofollow noopener noreferrer">Vue issue</a>。</p>
<p>再回过头看 <code>createGetter</code> 中，接下来的操作就是通过 <code>track(target, TrackOpTypes.GET, key)</code> 进行依赖收集，我们再来一起看一下 <code>track</code> 的实现：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 是否应该收集依赖</span>
<span class="hljs-keyword">let</span> shouldTrack = <span class="hljs-literal">true</span>
<span class="hljs-comment">// 当前激活的 effect</span>
<span class="hljs-keyword">let</span> activeEffect
<span class="hljs-comment">// 存放所有 reactive 传入的 receiver 容器</span>
<span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, type, key</span>) {
  <span class="hljs-keyword">if</span> (shouldTrack &#x26;&#x26; activeEffect) {
    <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)
    <span class="hljs-keyword">if</span> (!depsMap) {
      targetMap.<span class="hljs-title function_">set</span>(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()))
    }
    <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key)
    <span class="hljs-keyword">if</span> (!dep) {
      depsMap.<span class="hljs-title function_">set</span>(key, (dep = <span class="hljs-title function_">createDep</span>()))
    }

    <span class="hljs-title function_">trackEffects</span>(dep)
  }
}


<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">trackEffects</span>(<span class="hljs-params">
  dep,
  debuggerEventExtraInfo
</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">if</span> (shouldTrack) {
    <span class="hljs-comment">// 把 activeEffect 添加到 dep 中</span>
    dep.<span class="hljs-title function_">add</span>(activeEffect!)
    activeEffect!.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep)
  }
}

</code></pre>
<p>上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1ad474b1f154b8dbc1211ce2c82aa34~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>我们创建了全局的 <code>targetMap</code> ，它的键是 <code>target</code>，值是 <code>depsMap</code>；这个 <code>depsMap</code> 的键是 <code>target</code> 的 <code>key</code>，值是 <code>dep</code> 集合，<code>dep</code> 集合中存储的是依赖的副作用函数 <code>effect</code>。</p>
<p>另外，关于 <code>trackEffects</code> 的实现细节，我们后面的小节再详细介绍。</p>
<blockquote>
<p>注意到 <code>Proxy</code> 在访问对象属性时才递归执行劫持对象属性，相比 <code>Object.defineProperty</code> 在定义时就遍历把所有层级的对象设置成响应式而言，在性能上有所提升。</p>
</blockquote>
<h3>2. set</h3>
<p>上面说完了 <code>get</code> 的流程，我们了解了依赖收集后的数据结构存储在了 <code>targetMap</code> 中，接下来我们接着看 <code>set</code> 的过程：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> set = <span class="hljs-comment">/*#__PURE__*/</span> <span class="hljs-title function_">createSetter</span>()
</code></pre>
<p>可以看到核心其实通过 <code>createSetter</code> 来实现的：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSetter</span>(<span class="hljs-params">shallow = <span class="hljs-literal">false</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) {
    <span class="hljs-keyword">let</span> oldValue = target[key]
    <span class="hljs-comment">// 不是浅层响应式，这里默认是 false</span>
    <span class="hljs-keyword">if</span> (!shallow) {
      <span class="hljs-comment">// 不是浅层响应式对象</span>
      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isShallow</span>(value) &#x26;&#x26; !<span class="hljs-title function_">isReadonly</span>(value)) {
        oldValue = <span class="hljs-title function_">toRaw</span>(oldValue)
        value = <span class="hljs-title function_">toRaw</span>(value)
      }
      <span class="hljs-comment">// ...</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 在浅模式中，对象被设置为原始值，而不管是否是响应式</span>
    }

    <span class="hljs-keyword">const</span> hadKey =
      <span class="hljs-title function_">isArray</span>(target) &#x26;&#x26; <span class="hljs-title function_">isIntegerKey</span>(key)
        ? <span class="hljs-title class_">Number</span>(key) &#x3C; target.<span class="hljs-property">length</span>
        : <span class="hljs-title function_">hasOwn</span>(target, key)
    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)
     <span class="hljs-comment">// 如果目标的原型链也是一个 proxy，通过 Reflect.set 修改原型链上的属性会再次触发 setter，这种情况下就没必要触发两次 trigger 了</span>
    <span class="hljs-keyword">if</span> (target === <span class="hljs-title function_">toRaw</span>(receiver)) {
      <span class="hljs-keyword">if</span> (!hadKey) {
        <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">ADD</span>, key, value)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasChanged</span>(value, oldValue)) {
        <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">SET</span>, key, value, oldValue)
      }
    }
    <span class="hljs-keyword">return</span> result
  }
}
</code></pre>
<p>可以看到 <code>set</code> 的核心逻辑是先根据是否是浅层响应式来确定原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行 <code>toRaw</code> 转换，然后通过 <code>Reflect.set</code> 设置值，最后通过 <code>trigger</code> 函数派发通知 ，并依据 <code>key</code> 是否存在于 <code>target</code> 上来确定通知类型是 <code>add</code>（新增） 还是 <code>set</code>（修改）。</p>
<p>接下来核心就是 <code>trigger</code> 的逻辑，是如何实现触发响应的:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target,type,key,newValue,oldValue,oldTarget</span>) {
  <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)
  <span class="hljs-keyword">if</span> (!depsMap) {
    <span class="hljs-keyword">return</span>
  }
  <span class="hljs-keyword">let</span> <span class="hljs-attr">deps</span>: (<span class="hljs-title class_">Dep</span> | <span class="hljs-literal">undefined</span>)[] = []
  <span class="hljs-keyword">if</span> (type === <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">CLEAR</span>) {
    deps = [...depsMap.<span class="hljs-title function_">values</span>()]
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'length'</span> &#x26;&#x26; <span class="hljs-title function_">isArray</span>(target)) {
    depsMap.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">dep, key</span>) =></span> {
      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'length'</span> || key >= <span class="hljs-title function_">toNumber</span>(newValue)) {
        deps.<span class="hljs-title function_">push</span>(dep)
      }
    })
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (key !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) {
      deps.<span class="hljs-title function_">push</span>(depsMap.<span class="hljs-title function_">get</span>(key))
    }

    <span class="hljs-keyword">switch</span> (type) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">ADD</span>:
        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isArray</span>(target)) {
          deps.<span class="hljs-title function_">push</span>(depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">ITERATE_KEY</span>))
          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isMap</span>(target)) {
            deps.<span class="hljs-title function_">push</span>(depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">MAP_KEY_ITERATE_KEY</span>))
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isIntegerKey</span>(key)) {
          deps.<span class="hljs-title function_">push</span>(depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">'length'</span>))
        }
        <span class="hljs-keyword">break</span>
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">DELETE</span>:
        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isArray</span>(target)) {
          deps.<span class="hljs-title function_">push</span>(depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">ITERATE_KEY</span>))
          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isMap</span>(target)) {
            deps.<span class="hljs-title function_">push</span>(depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">MAP_KEY_ITERATE_KEY</span>))
          }
        }
        <span class="hljs-keyword">break</span>
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">SET</span>:
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isMap</span>(target)) {
          deps.<span class="hljs-title function_">push</span>(depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">ITERATE_KEY</span>))
        }
        <span class="hljs-keyword">break</span>
    }
  }

  <span class="hljs-keyword">if</span> (deps.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (deps[<span class="hljs-number">0</span>]) {
      <span class="hljs-title function_">triggerEffects</span>(deps[<span class="hljs-number">0</span>])
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">effects</span>: <span class="hljs-title class_">ReactiveEffect</span>[] = []
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dep <span class="hljs-keyword">of</span> deps) {
      <span class="hljs-keyword">if</span> (dep) {
        effects.<span class="hljs-title function_">push</span>(...dep)
      }
    }
    <span class="hljs-title function_">triggerEffects</span>(<span class="hljs-title function_">createDep</span>(effects))
  }
}
</code></pre>
<p>内容有点多，看起来有点头大，我们来简化一下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, type, key</span>) {
  <span class="hljs-keyword">const</span> dep = targetMap.<span class="hljs-title function_">get</span>(target)
  dep.<span class="hljs-title function_">get</span>(key).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =></span> effect.<span class="hljs-title function_">run</span>())
}
</code></pre>
<p>核心其实就是通过 <code>target</code> 找到 <code>targetMap</code> 中的 <code>dep</code>，再根据 <code>key</code> 来找到所有的副作用函数 <code>effect</code> 遍历执行。副作用函数就是上面 <code>get</code> 收集起来的。</p>
<p>这里有个有意思的地方是对数组的操作监听，我们来看一段代码：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>([]);

<span class="hljs-title function_">effect</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`state: <span class="hljs-subst">${state[<span class="hljs-number">1</span>]}</span>`</span>)
});

<span class="hljs-comment">// 不会触发 effect</span>
state.<span class="hljs-title function_">push</span>(<span class="hljs-number">0</span>);

<span class="hljs-comment">// 触发 effect</span>
state.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);
</code></pre>
<p>上面的 <code>demo</code> 中，我们第一次访问了 <code>state[1]</code>， 所以，对 <code>state[1]</code> 进行了依赖收集，而第一次的 <code>state.push(0)</code> 设置的是 <code>state</code> 的第 <code>0</code> 个元素，所以不会触发响应式更新。而第二次的 <code>push</code> 触发了对 <code>state[1]</code> 的更新。这看起来很合理，没啥问题。那么我们再来看另外一个示例：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 响应式数据</span>
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>([])

<span class="hljs-comment">// 观测变化</span>
<span class="hljs-title function_">effect</span>(<span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'state map: '</span>, state.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =></span> item))

state.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>)
</code></pre>
<p>按照常理来说，<code>state.map</code> 由于 <code>state</code> 是个空数组，所以理论上不会对数组的每一项进行访问，所以 <code>state.push(1)</code> 理论上也不会触发 <code>effect</code>。但实际上是会的，为什么呢？我们再来看一下一个 <code>proxy</code> 的 <code>demo</code>：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> raw = []
<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(raw, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'get'</span>, key)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key)
  },
  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'set'</span>, key)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value)
  }
})

arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">v</span> =></span> v)
</code></pre>
<p>可以看到打印的内容如下：</p>
<pre><code class="hljs language-js">get map
get length
get constructor
</code></pre>
<p>可以看到 <code>map</code> 函数的操作，会触发对数组的 <code>length</code> 访问！这就有意思了，当访问数组 <code>length</code> 的时候，我们进行了对 <code>state</code> 的依赖收集，而数组的 <code>push</code> 操作也会改变 <code>length</code> 的长度，如果我们对 <code>length</code> 做监听，那么此时便会触发 <code>effect</code>！而 <code>Vue</code> 也是这么做的，也就是这段代码：</p>
<pre><code class="hljs language-js">deps.<span class="hljs-title function_">push</span>(depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">'length'</span>))
</code></pre>
<p>同理，对于 <code>for in, forEach, map ... </code> 都会触发 <code>length</code> 的依赖收集，从而 <code>pop, push, shift...</code> 等等操作都会触发响应式更新！</p>
<p>另外，除了数组，对象的 <code>Object.keys</code> , <code>for ... of ...</code> 等等对象遍历操作都会触发响应式的依赖收集，这是因为 <code>Vue</code> 在定义 <code>Proxy</code> 的时候，定义了 <code>ownKeys</code> 这个函数：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target</span>) {
  <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">ITERATE</span>, <span class="hljs-title function_">isArray</span>(target) ? <span class="hljs-string">'length'</span> : <span class="hljs-variable constant_">ITERATE_KEY</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(target)
}
</code></pre>
<p><code>ownKeys</code> 函数内部执行了 <code>track</code> 进行了对 <code>Object</code> 的 <code>ITERATE_KEY</code> 的依赖收集。而在 <code>setter</code> 的时候，则对 <code>ITERATE_KEY</code> 进行了响应式触发：</p>
<pre><code class="hljs language-js">deps.<span class="hljs-title function_">push</span>(depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">ITERATE_KEY</span>))
</code></pre>
<h2>总结</h2>
<p>至此，我们讲完了对响应式的依赖收集和触发过程，但有个概览我们没有说清楚，那就是 <code>effect</code> 到底是什么，以及是如何产生的被收集到 <code>dep</code> 当中的。下一节我们将具体介绍。</p>
<h2>课外知识</h2>
<p>这里细心的小伙伴，可能会注意到在上面的源码中出现了一个有意思的标识符 <code>/*#__PURE__*/</code>。要说这个东西，那就需要说到和这玩意相关的 <code>Tree-Shaking</code> 副作用了。我们知道 <code>Tree-Shaking</code> 可以删除一些 <code>DC（dead code）</code> 代码。但是对于一些有副作用的函数代码，却是无法进行很好的识别和删除，举个例子：</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">foo</span>()

<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>) {
  obj?.<span class="hljs-property">a</span>
}
</code></pre>
<p>上述代码中，<code>foo</code> 函数本身是没有任何意义的，仅仅是对对象 <code>obj</code> 进行了属性 <code>a</code> 的读取操作，但是 <code>Tree-Shaking</code> 是无法删除该函数的，因为上述的属性读取操作可能会产生副作用，因为 <code>obj</code> 可能是一个响应式对象，我们可能对 <code>obj</code> 定了一个 <code>getter</code> 在 <code>getter</code> 中触发了很多不可预期的操作。</p>
<p>如果我们确认 <code>foo</code> 函数是一个不会有副作用的<strong>纯净的函数</strong>，那么这个时候 <code>/*#__PURE__*/</code> 就派上用场了，其作用就是<strong>告诉打包器，对于 <code>foo</code> 函数的调用不会产生副作用，你可以放心地对其进行 <code>Tree-Shaking</code></strong>。</p>
<p>另外，值得一提的是，在 <code>Vue 3</code> 源码中，包含了大量的 <code>/*#__PURE__*/</code> 标识符，可见 <code>Vue 3</code> 对源码体积的控制是多么的用心！</p></div>
</body></html>