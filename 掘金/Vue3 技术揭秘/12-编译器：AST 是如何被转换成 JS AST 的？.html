<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>编译器：AST 是如何被转换成 JS AST 的？</h1>
<h2>前言</h2>
<p>上一小节我们介绍完了关于模版是如何编译成 <code>AST</code> 的结构的，接下来进入模版编译的第二步 <code>transform</code>，<code>transform</code> 的目标是为了生成 <code>JavaScript AST</code>。因为渲染函数是一堆 <code>js</code> 代码构成的，编译器最终产物就是渲染函数，所以理想中的 <code>AST</code> 应该是用来描述渲染函数的 <code>JS</code> 代码。</p>
<p>那么接下来，我们一起看看 <code>transfrom</code> 转换的实现细节吧！</p>
<h2>Transform</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">baseCompile</span>(<span class="hljs-params">template, options</span>) {
  <span class="hljs-keyword">const</span> isModuleMode = options.<span class="hljs-property">mode</span> === <span class="hljs-string">'module'</span>
  <span class="hljs-comment">// 用来标记代码生成模式</span>
  <span class="hljs-keyword">const</span> prefixIdentifiers =
    !__BROWSER__ &#x26;&#x26; (options.<span class="hljs-property">prefixIdentifiers</span> === <span class="hljs-literal">true</span> || isModuleMode)
  <span class="hljs-comment">// 获取节点和指令转换的方法</span>
  <span class="hljs-keyword">const</span> [nodeTransforms, directiveTransforms] = <span class="hljs-title function_">getBaseTransformPreset</span>()
  <span class="hljs-comment">// AST 转换成 Javascript AST</span>
  <span class="hljs-title function_">transform</span>(
    ast,
    <span class="hljs-title function_">extend</span>({}, options, {
      prefixIdentifiers,
      <span class="hljs-attr">nodeTransforms</span>: [
        ...nodeTransforms,
        ...(options.<span class="hljs-property">nodeTransforms</span> || [])
      ],
      <span class="hljs-attr">directiveTransforms</span>: <span class="hljs-title function_">extend</span>(
        {},
        directiveTransforms,
        options.<span class="hljs-property">directiveTransforms</span> || {}
      )
    })
  )
}
</code></pre>
<p>其中第一个参数 <code>prefixIdentifiers</code> 是用于标记前缀代码生成模式的。举个例子，以下代码：</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
  {{msg}}
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
</code></pre>
<p>在 <code>module</code> 模式下，生成的渲染函数是一个通过 <code>with(_ctx) { ... }</code> 包裹后的，大致为：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx</span>) {
  <span class="hljs-keyword">with</span> (_ctx) {
    <span class="hljs-keyword">const</span> { toDisplayString, openBlock, createElementBlock } = <span class="hljs-title class_">Vue</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-title function_">openBlock</span>(), <span class="hljs-title function_">createElementBlock</span>(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-title function_">toDisplayString</span>(msg), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>))
  }
}
</code></pre>
<p>而在 <code>function</code> 模式下，生成的渲染函数中的动态内容，则会被转成 <code>_ctx.msg</code> 的模式：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { toDisplayString, openBlock, createElementBlock } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx</span>) {
  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">openBlock</span>(), <span class="hljs-title function_">createElementBlock</span>(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-title function_">toDisplayString</span>(ctx.<span class="hljs-property">msg</span>), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>))
}
</code></pre>
<p>而参数 <code>nodeTransforms</code> 和 <code>directiveTransforms</code> 对象则是由 <code>getBaseTransformPreset</code> 生成的一系列预设函数：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getBaseTransformPreset</span>(<span class="hljs-params">prefixIdentifiers</span>) {
  <span class="hljs-keyword">return</span> [
    [
      transformOnce,
      transformIf,
      transformFor,
      transformExpression,
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      <span class="hljs-attr">on</span>: transformOn,
      <span class="hljs-attr">bind</span>: transformBind,
      <span class="hljs-attr">model</span>: transformModel
    }
  ]
}
</code></pre>
<p><code>nodeTransforms</code> 涵盖了特殊节点的转换函数，比如文本节点、<code>v-if</code> 节点等等， <code>directiveTransforms</code> 则包含了一些指令的转换函数。</p>
<p>这些转换函数的细节，不是这里的核心，我们将在下文进行几个重点函数的介绍，其余的有兴趣的小伙伴可以自行翻阅 <code>vue3</code> 源码查看实现的细节。接下来我们将核心介绍 <code>transform</code> 函数的实现：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">root, options</span>) {
  <span class="hljs-comment">// 生成 transform 上下文</span>
  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">createTransformContext</span>(root, options)
  <span class="hljs-comment">// 遍历处理 ast 节点</span>
  <span class="hljs-title function_">traverseNode</span>(root, context)
  <span class="hljs-comment">// 静态提升</span>
  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">hoistStatic</span>) {
    <span class="hljs-title function_">hoistStatic</span>(root, context)
  }
  <span class="hljs-comment">// 创建根代码生成节点</span>
  <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">ssr</span>) {
    <span class="hljs-title function_">createRootCodegen</span>(root, context)
  }
  <span class="hljs-comment">// 最终确定元信息</span>
  root.<span class="hljs-property">helpers</span> = [...context.<span class="hljs-property">helpers</span>.<span class="hljs-title function_">keys</span>()]
  root.<span class="hljs-property">components</span> = [...context.<span class="hljs-property">components</span>]
  root.<span class="hljs-property">directives</span> = [...context.<span class="hljs-property">directives</span>]
  root.<span class="hljs-property">imports</span> = context.<span class="hljs-property">imports</span>
  root.<span class="hljs-property">hoists</span> = context.<span class="hljs-property">hoists</span>
  root.<span class="hljs-property">temps</span> = context.<span class="hljs-property">temps</span>
  root.<span class="hljs-property">cached</span> = context.<span class="hljs-property">cached</span>
}
</code></pre>
<h2>1. 生成 transform 上下文</h2>
<p>在正式开始 <code>transform</code> 前，需要创建生成一个 <code>transformContext</code>，即 <code>transform</code> 上下文。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createTransformContext</span>(<span class="hljs-params">root, TransformOptions</span>) {
  <span class="hljs-keyword">const</span> context = {
    <span class="hljs-comment">// 选项配置</span>
    hoistStatic,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// 状态数据</span>
    root,
    <span class="hljs-attr">helpers</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(),
    <span class="hljs-attr">components</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(),
    <span class="hljs-attr">directives</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(),
    <span class="hljs-attr">hoists</span>: [],
    <span class="hljs-comment">// ....</span>
    <span class="hljs-comment">// 一些函数</span>
    <span class="hljs-title function_">helper</span>(<span class="hljs-params">name</span>) {},
    <span class="hljs-title function_">removeHelper</span>(<span class="hljs-params">name</span>) {},
    <span class="hljs-title function_">helperString</span>(<span class="hljs-params">name</span>) {},
    <span class="hljs-title function_">replaceNode</span>(<span class="hljs-params">node</span>) {},
    <span class="hljs-title function_">removeNode</span>(<span class="hljs-params">node</span>) {},
    <span class="hljs-attr">onNodeRemoved</span>: <span class="hljs-function">() =></span> {},
    <span class="hljs-title function_">addIdentifiers</span>(<span class="hljs-params">exp</span>) {},
    <span class="hljs-title function_">removeIdentifiers</span>(<span class="hljs-params">exp</span>) {},
    <span class="hljs-title function_">hoist</span>(<span class="hljs-params">exp</span>) {},
    <span class="hljs-title function_">cache</span>(<span class="hljs-params">exp, isVNode = <span class="hljs-literal">false</span></span>) {}
  }

  <span class="hljs-keyword">return</span> context
}
</code></pre>
<p>可以看到这个上下文对象 <code>context</code> 内主要包含三部分：<code>tansform</code> 过程中的一些配置属性，一些状态数据，以及在 <code>transform</code> 过程中可能会调用的一些辅助函数。</p>
<h2>2. 遍历AST节点</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverseNode</span>(<span class="hljs-params">node, context</span>) {
  context.<span class="hljs-property">currentNode</span> = node
  <span class="hljs-comment">// 节点转换函数</span>
  <span class="hljs-keyword">const</span> { nodeTransforms } = context
  <span class="hljs-keyword">const</span> exitFns = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; nodeTransforms.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-comment">// 执行节点转换函数，返回得到一个退出函数</span>
    <span class="hljs-keyword">const</span> onExit = nodeTransforms[i](node, context)
    <span class="hljs-comment">// 收集所有退出函数</span>
    <span class="hljs-keyword">if</span> (onExit) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArray</span>(onExit)) {
        exitFns.<span class="hljs-title function_">push</span>(...onExit)
      } <span class="hljs-keyword">else</span> {
        exitFns.<span class="hljs-title function_">push</span>(onExit)
      }
    }
    <span class="hljs-keyword">if</span> (!context.<span class="hljs-property">currentNode</span>) {
      <span class="hljs-comment">// 节点被移除</span>
      <span class="hljs-keyword">return</span>
    } <span class="hljs-keyword">else</span> {
      node = context.<span class="hljs-property">currentNode</span>
    }
  }

  <span class="hljs-keyword">switch</span> (node.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">COMMENT</span>:
      <span class="hljs-keyword">if</span> (!context.<span class="hljs-property">ssr</span>) {
        <span class="hljs-comment">// context 中 helpers 添加 CREATE_COMMENT 辅助函数</span>
        context.<span class="hljs-title function_">helper</span>(<span class="hljs-variable constant_">CREATE_COMMENT</span>)
      }
      <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">INTERPOLATION</span>:
      <span class="hljs-comment">// context 中 helpers 添加 TO_DISPLAY_STRING 辅助函数</span>
      <span class="hljs-keyword">if</span> (!context.<span class="hljs-property">ssr</span>) {
        context.<span class="hljs-title function_">helper</span>(<span class="hljs-variable constant_">TO_DISPLAY_STRING</span>)
      }
      <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">IF</span>:
      <span class="hljs-comment">// 递归遍历每个分支节点</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; node.<span class="hljs-property">branches</span>.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-title function_">traverseNode</span>(node.<span class="hljs-property">branches</span>[i], context)
      }
      <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">IF_BRANCH</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">FOR</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">ELEMENT</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">ROOT</span>:
      <span class="hljs-comment">// 遍历子节点</span>
      <span class="hljs-title function_">traverseChildren</span>(node, context)
      <span class="hljs-keyword">break</span>
  }
  
  context.<span class="hljs-property">currentNode</span> = node
  <span class="hljs-comment">// 执行上面收集到的所有退出函数</span>
  <span class="hljs-keyword">let</span> i = exitFns.<span class="hljs-property">length</span>
  <span class="hljs-keyword">while</span> (i--) {
    exitFns[i]()
  }
}
</code></pre>
<p><code>traverseNode</code> 递归的遍历 <code>ast</code> 中的每个节点，然后执行一些转换函数 <code>nodeTransforms</code>，这些转换函数就是我们上面介绍的通过 <code>getBaseTransformPreset</code> 生成的对象，值得注意的是：<code>nodeTransforms</code> 返回的是一个数组，说明这些转换函数是有序的，顺序代表着优先级关系，比如对于<code>if</code>的处理优先级就比 <code>for</code> 要高，因为如果条件不满足很可能有大部分内容都没必要进行转换。</p>
<p>另外，如果转换函数执行完成后，有返回退出函数 <code>onExit</code> 的话，那么会被统一存贮到 <code>exitFns</code> 当中，在所有字节点处理完成统一执行调用。</p>
<h3>transformElement</h3>
<p>根据上文我们知道了对节点进行处理，就是通过一系列函数对节点的的各个部分的内容分别进行处理。鉴于这些函数很多内容也很庞杂，我们拿其中一个函数<code>transformElement</code>进行分析，理解对<strong>AST</strong>的转化过程：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">transformElement</span> = (<span class="hljs-params">node, context</span>) => {
  <span class="hljs-comment">// 这里就是返回了一个退出函数</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">postTransformElement</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>
    node.<span class="hljs-property">codegenNode</span> = <span class="hljs-title function_">createVNodeCall</span>(
      context,
      vnodeTag,
      vnodeProps,
      vnodeChildren,
      vnodePatchFlag,
      vnodeDynamicProps,
      vnodeDirectives,
      !!shouldUseBlock,
      <span class="hljs-literal">false</span> <span class="hljs-comment">/* disableTracking */</span>,
      isComponent,
      node.<span class="hljs-property">loc</span>
    )
  }
}
</code></pre>
<p>可以看到，<code>transformElement</code> 的核心目的就是通过调用<code>createVNodeCall</code>函数获取 <code>VNodeCall</code> 对象，并赋值给 <code>node.codegenNode</code>。</p>
<p>到这里，我们就大致明白了，我们前面一直提到需要把 <code>AST</code> 转成 <code>JavaScript AST</code>，实际上就是给 <code>AST</code> 的<code>codegenNode</code> 属性赋值。接下来，我们接着看 <code>createVNodeCall</code> 函数的实现：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createVNodeCall</span>(<span class="hljs-params">context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = <span class="hljs-literal">false</span>, disableTracking = <span class="hljs-literal">false</span>, loc = locStub</span>) {
  <span class="hljs-keyword">if</span> (context) {
    <span class="hljs-keyword">if</span> (isBlock) {
      context.<span class="hljs-title function_">helper</span>(<span class="hljs-variable constant_">OPEN_BLOCK</span>)
      context.<span class="hljs-title function_">helper</span>(<span class="hljs-title function_">getVNodeBlockHelper</span>(context.<span class="hljs-property">inSSR</span>, isComponent))
    } <span class="hljs-keyword">else</span> {
      context.<span class="hljs-title function_">helper</span>(<span class="hljs-title function_">getVNodeHelper</span>(context.<span class="hljs-property">inSSR</span>, isComponent))
    }
    <span class="hljs-keyword">if</span> (directives) {
      context.<span class="hljs-title function_">helper</span>(<span class="hljs-variable constant_">WITH_DIRECTIVES</span>)
    }
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">VNODE_CALL</span>,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    loc
  }
}
</code></pre>
<p>该函数也非常容易理解，本质就是为了返回一个 <code>VNodeCall</code> 对象，该对象是用来描述 <code>js</code> 代码的。</p>
<p>这里的函数 <code>context.helper</code> 是会把一些 <code>Symbol</code> 对象添加到 <code>context.helpers Set</code> 的数据结构当中，在接下来的代码生成阶段，会判断当前 <code>JS AST</code> 中是否存在 <code>helpers</code> 内容，如果存在，则会根据 <code>helpers</code> 中标记的 <code>Symbol</code> 对象，来生成辅助函数。</p>
<p>接下来看一下之前的这样一个 <code>demo</code></p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">template</span>></span>
  <span class="hljs-comment">&#x3C;!-- 这是一段注释 --></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{{ msg }}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">template</span>></span>
</code></pre>
<p>经过遍历<code>AST</code>节点 <code>traverseNode</code> 函数调用之后之后的结果大致如下：</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"children"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"ns"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"tag"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"p"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"tagType"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"props"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"isSelfClosing"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"children"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"loc"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"codegenNode"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">13</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"tag"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"\"p\""</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"children"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"content"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"isStatic"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"constType"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"content"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"msg"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"loc"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
              <span class="hljs-attr">"start"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
              <span class="hljs-attr">"end"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
              <span class="hljs-attr">"source"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"msg"</span>
            <span class="hljs-punctuation">}</span>
          <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"loc"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"start"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"end"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"source"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"{{ msg }}"</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"patchFlag"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1 /* TEXT */"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"isBlock"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"disableTracking"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"isComponent"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"loc"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"start"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"end"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"source"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&#x3C;p>{{ msg }}&#x3C;/p>"</span>
        <span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"helpers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"components"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"directives"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"hoists"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"imports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"cached"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"temps"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"loc"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"start"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"end"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"source"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"\n  &#x3C;p>{{ msg }}&#x3C;/p>\n"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>可以看到，相比原节点，转换后的节点无论是在语义化还是在信息上，都更加丰富，我们可以依据它在代码生成阶段生成所需的代码。</p>
<h2>3. 静态提升</h2>
<p>经过上一步的遍历 <code>AST</code> 节点后，我们接着来看一下静态提升做了哪些工作。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hoistStatic</span>(<span class="hljs-params">root, context</span>) {
  <span class="hljs-title function_">walk</span>(
    root,
    context,
    <span class="hljs-comment">// 根节点是不可提升的</span>
    <span class="hljs-title function_">isSingleElementRoot</span>(root, root.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>])
  )
}
</code></pre>
<p><code>hoistStatic</code> 核心调用的就是 <code>walk</code> 函数：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">node, context, doNotHoistNode = <span class="hljs-literal">false</span></span>) {
  <span class="hljs-keyword">const</span> { children } = node
  <span class="hljs-comment">// 记录那些被静态提升的节点数量</span>
  <span class="hljs-keyword">let</span> hoistedCount = <span class="hljs-number">0</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; children.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> child = children[i]
    <span class="hljs-comment">// 普通元素节点可以被提升</span>
    <span class="hljs-keyword">if</span> (
      child.<span class="hljs-property">type</span> === <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">ELEMENT</span> &#x26;&#x26;
      child.<span class="hljs-property">tagType</span> === <span class="hljs-title class_">ElementTypes</span>.<span class="hljs-property">ELEMENT</span>
    ) {
      <span class="hljs-comment">// 根据 doNotHoistNode 判断是否可以提升</span>
      <span class="hljs-comment">// 设置 constantType 的值</span>
      <span class="hljs-keyword">const</span> constantType = doNotHoistNode
        ? <span class="hljs-title class_">ConstantTypes</span>.<span class="hljs-property">NOT_CONSTANT</span>
        : <span class="hljs-title function_">getConstantType</span>(child, context)
      <span class="hljs-comment">// constantType = CAN_SKIP_PATCH || CAN_HOIST || CAN_STRINGIFY</span>
      <span class="hljs-keyword">if</span> (constantType > <span class="hljs-title class_">ConstantTypes</span>.<span class="hljs-property">NOT_CONSTANT</span>) {
        <span class="hljs-comment">// constantType = CAN_HOIST || CAN_STRINGIFY</span>
        <span class="hljs-keyword">if</span> (constantType >= <span class="hljs-title class_">ConstantTypes</span>.<span class="hljs-property">CAN_HOIST</span>) {
          <span class="hljs-comment">// 可提升状态中，codegenNode = PatchFlags.HOISTED</span>
          child.<span class="hljs-property">codegenNode</span>.<span class="hljs-property">patchFlag</span> =
            <span class="hljs-title class_">PatchFlags</span>.<span class="hljs-property">HOISTED</span> + (__DEV__ ? <span class="hljs-string">` /* HOISTED */`</span> : <span class="hljs-string">``</span>)
  
          <span class="hljs-comment">// 提升节点，将节点存储到 转换上下文context 的 hoist 数组中</span>
          child.<span class="hljs-property">codegenNode</span> = context.<span class="hljs-title function_">hoist</span>(child.<span class="hljs-property">codegenNode</span>!)
          <span class="hljs-comment">// 提升节点数量自增 1</span>
          hoistedCount++
          <span class="hljs-keyword">continue</span>
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 动态子节点可能存在一些静态可提升的属性</span>
        <span class="hljs-keyword">const</span> codegenNode = child.<span class="hljs-property">codegenNode</span>!
        <span class="hljs-keyword">if</span> (codegenNode.<span class="hljs-property">type</span> === <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">VNODE_CALL</span>) {
          <span class="hljs-comment">// 判断 props 是否可提升</span>
          <span class="hljs-keyword">const</span> flag = <span class="hljs-title function_">getPatchFlag</span>(codegenNode)
          <span class="hljs-keyword">if</span> (
            (!flag ||
              flag === <span class="hljs-title class_">PatchFlags</span>.<span class="hljs-property">NEED_PATCH</span> ||
              flag === <span class="hljs-title class_">PatchFlags</span>.<span class="hljs-property">TEXT</span>) &#x26;&#x26;
            <span class="hljs-title function_">getGeneratedPropsConstantType</span>(child, context) >=
              <span class="hljs-title class_">ConstantTypes</span>.<span class="hljs-property">CAN_HOIST</span>
          ) {
            <span class="hljs-comment">// 提升 props</span>
            <span class="hljs-keyword">const</span> props = <span class="hljs-title function_">getNodeProps</span>(child)
            <span class="hljs-keyword">if</span> (props) {
              codegenNode.<span class="hljs-property">props</span> = context.<span class="hljs-title function_">hoist</span>(props)
            }
          }
          <span class="hljs-comment">// 将节点的动态 props 添加到转换上下文对象中</span>
          <span class="hljs-keyword">if</span> (codegenNode.<span class="hljs-property">dynamicProps</span>) {
            codegenNode.<span class="hljs-property">dynamicProps</span> = context.<span class="hljs-title function_">hoist</span>(codegenNode.<span class="hljs-property">dynamicProps</span>)
          }
        }
      }
    }

    <span class="hljs-keyword">if</span> (child.<span class="hljs-property">type</span> === <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">ELEMENT</span>) {
      <span class="hljs-comment">// 组件是 slot 的情况</span>
      <span class="hljs-keyword">const</span> isComponent = child.<span class="hljs-property">tagType</span> === <span class="hljs-title class_">ElementTypes</span>.<span class="hljs-property">COMPONENT</span>
      <span class="hljs-keyword">if</span> (isComponent) {
        context.<span class="hljs-property">scopes</span>.<span class="hljs-property">vSlot</span>++
      }
      <span class="hljs-comment">// 如果节点类型是组件，则进行递归判断操作</span>
      <span class="hljs-title function_">walk</span>(child, context)
      <span class="hljs-keyword">if</span> (isComponent) {
        context.<span class="hljs-property">scopes</span>.<span class="hljs-property">vSlot</span>--
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.<span class="hljs-property">type</span> === <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">FOR</span>) {
      <span class="hljs-comment">// 再循环节点中，只有一个子节点的情况下，不需要提升</span>
      <span class="hljs-title function_">walk</span>(child, context, child.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.<span class="hljs-property">type</span> === <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">IF</span>) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; child.<span class="hljs-property">branches</span>.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-comment">// 在 v-if 这样的条件节点上，如果也只有一个分支逻辑的情况</span>
        <span class="hljs-title function_">walk</span>(
          child.<span class="hljs-property">branches</span>[i],
          context,
          child.<span class="hljs-property">branches</span>[i].<span class="hljs-property">children</span>.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>
        )
      }
    }
  }
  <span class="hljs-comment">// 预字符串化</span>
  <span class="hljs-keyword">if</span> (hoistedCount &#x26;&#x26; context.<span class="hljs-property">transformHoist</span>) {
    context.<span class="hljs-title function_">transformHoist</span>(children, context, node)
  }
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>该函数看起来比较复杂，其实就是通过 <code>walk</code> 这个递归函数，不断的判断节点是否符合可以静态提升的条件：只有普通的元素节点是可以提升的。</p>
<p>如果满足条件，则会给节点的 <code>codegenNode</code> 属性中的 <code>patchFlag</code> 的值设置成 <code>PatchFlags.HOISTED</code>。</p>
<p>接着执行转换器上下文中的 <code>context.hoist</code> 方法：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hoist</span>(<span class="hljs-params">exp</span>) {
  <span class="hljs-comment">// 存储到 hoists 数组中</span>
  context.<span class="hljs-property">hoists</span>.<span class="hljs-title function_">push</span>(exp);
  <span class="hljs-keyword">const</span> identifier = <span class="hljs-title function_">createSimpleExpression</span>(<span class="hljs-string">`_hoisted_<span class="hljs-subst">${context.hoists.length}</span>`</span>, <span class="hljs-literal">false</span>, exp.<span class="hljs-property">loc</span>, <span class="hljs-literal">true</span>)
  identifier.<span class="hljs-property">hoisted</span> = exp
  <span class="hljs-keyword">return</span> identifier
}
</code></pre>
<p>该函数的作用就是将这个可以被提升的节点存储到转换上下文 <code>context</code> 的 <code>hoist</code> 数组中。这个数据就是用来存储那些可被提升节点的列表。</p>
<p>接下来，我们再来说一下，为什么要做静态提升呢？ 如下模板所示：</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>text<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
</code></pre>
<p>在没有被提升的情况下其渲染函数相当于：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { createElementVNode <span class="hljs-keyword">as</span> _createElementVNode, openBlock <span class="hljs-keyword">as</span> _openBlock, createElementBlock <span class="hljs-keyword">as</span> _createElementBlock } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) {
  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createElementBlock</span>(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [
    <span class="hljs-title function_">_createElementVNode</span>(<span class="hljs-string">"p"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"text"</span>)
  ]))
}
</code></pre>
<p>很明显，<code>p</code> 标签是静态的，它不会改变。但是如上渲染函数的问题也很明显，如果组件内存在动态的内容，当渲染函数重新执行时，即使 <code>p</code> 标签是静态的，那么它对应的 <code>VNode</code> 也会重新创建。</p>
<p><strong>所谓的 “静态提升”，就是将一些静态的节点或属性提升到渲染函数之外</strong>。如下面的代码所示：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { createElementVNode <span class="hljs-keyword">as</span> _createElementVNode, openBlock <span class="hljs-keyword">as</span> _openBlock, createElementBlock <span class="hljs-keyword">as</span> _createElementBlock } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>

<span class="hljs-keyword">const</span> _hoisted_1 = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-title function_">_createElementVNode</span>(<span class="hljs-string">"p"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"text"</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)
<span class="hljs-keyword">const</span> _hoisted_2 = [
  _hoisted_1
]

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) {
  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createElementBlock</span>(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, _hoisted_2))
}
</code></pre>
<p>这就实现了减少 <code>VNode</code> 创建的性能消耗。</p>
<p>而这里的静态提升步骤生成的 <code>hoists</code>，会在 <code>codegenNode</code> 会在生成代码阶段帮助我们生成静态提升的相关代码。</p>
<h3>预字符串化</h3>
<p>注意到在 <code>walk</code> 函数结束时，进行了静态提升节点的 <code>预字符串化</code>。什么是预字符串化呢？一起来看个示例：</p>
<pre><code class="hljs language-xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">template</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
  ... 共 20+ 节点
  <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">template</span>></span>
</code></pre>
<p>对于这样有大量静态提升的模版场景，如果不考虑 <code>预字符串化</code> 那么生成的渲染函数将会包含大量的 <code>createElementVNode</code> 函数：假设如上模板中有大量连续的静态的 <code>p</code> 标签，此时渲染函数生成的结果如下：</p>
<pre><code class="hljs language-php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">_hoisted_1</span> = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-title function_ invoke__">_createElementVNode</span>(<span class="hljs-string">"p"</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">_hoisted_20</span> = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-title function_ invoke__">_createElementVNode</span>(<span class="hljs-string">"p"</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">_hoisted_21</span> = [
  _hoisted_1,
  <span class="hljs-comment">// ...</span>
  _hoisted_20,
]

export <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache, <span class="hljs-variable">$props</span>, <span class="hljs-variable">$setup</span>, <span class="hljs-variable">$data</span>, <span class="hljs-variable">$options</span></span>) </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-title function_ invoke__">_openBlock</span>(), <span class="hljs-title function_ invoke__">_createElementBlock</span>(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, _hoisted_21))
}
</code></pre>
<p><code>createElementVNode</code> 大量连续性创建 <code>vnode</code> 也是挺影响性能的，所以可以通过 <code>预字符串化</code> 来一次性创建这些静态节点，采用 <code>与字符串化</code> 后，生成的渲染函数如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> _hoisted_1 = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-title function_">_createStaticVNode</span>(<span class="hljs-string">"&#x3C;p>&#x3C;/p>...&#x3C;p>&#x3C;/p>"</span>, <span class="hljs-number">20</span>)
<span class="hljs-keyword">const</span> _hoisted_21 = [
  _hoisted_1
]

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) {
  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createElementBlock</span>(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, _hoisted_21))
}
</code></pre>
<p>这样一方面降低了 <code>createElementVNode</code> 连续创建带来的性能损耗，也降侧面减少了代码体积。关于 <strong>预字符串化</strong> 实现的细节函数 <code>transformHoist</code> 有兴趣的小伙伴可以再去深入了解。</p>
<h2>4. 创建根代码生成节点</h2>
<p>介绍完了静态提升后，我们还剩最后一个 <code>createRootCodegen</code> 创建根代码生成节点，接下来一起看一下 <code>createRootCodegen</code> 函数的实现：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRootCodegen</span>(<span class="hljs-params">root, context</span>) {
  <span class="hljs-keyword">const</span> { helper } = context
  <span class="hljs-keyword">const</span> { children } = root
  <span class="hljs-keyword">if</span> (children.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">const</span> child = children[<span class="hljs-number">0</span>]
    <span class="hljs-comment">// 如果子节点是单个元素节点，则将其转换成一个 block</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSingleElementRoot</span>(root, child) &#x26;&#x26; child.<span class="hljs-property">codegenNode</span>) {
      <span class="hljs-keyword">const</span> codegenNode = child.<span class="hljs-property">codegenNode</span>
      <span class="hljs-keyword">if</span> (codegenNode.<span class="hljs-property">type</span> === <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">VNODE_CALL</span>) {
        <span class="hljs-title function_">makeBlock</span>(codegenNode, context)
      }
      root.<span class="hljs-property">codegenNode</span> = codegenNode
    } <span class="hljs-keyword">else</span> {
      root.<span class="hljs-property">codegenNode</span> = child
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (children.<span class="hljs-property">length</span> > <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// 如果子节点是多个节点，则返回一个 fragement 的代码生成节点</span>
    <span class="hljs-keyword">let</span> patchFlag = <span class="hljs-title class_">PatchFlags</span>.<span class="hljs-property">STABLE_FRAGMENT</span>
    <span class="hljs-keyword">let</span> patchFlagText = <span class="hljs-title class_">PatchFlagNames</span>[<span class="hljs-title class_">PatchFlags</span>.<span class="hljs-property">STABLE_FRAGMENT</span>]
    
    root.<span class="hljs-property">codegenNode</span> = <span class="hljs-title function_">createVNodeCall</span>(
      context,
      <span class="hljs-title function_">helper</span>(<span class="hljs-variable constant_">FRAGMENT</span>),
      <span class="hljs-literal">undefined</span>,
      root.<span class="hljs-property">children</span>,
      patchFlag + (__DEV__ ? <span class="hljs-string">` /* <span class="hljs-subst">${patchFlagText}</span> */`</span> : <span class="hljs-string">``</span>),
      <span class="hljs-literal">undefined</span>,
      <span class="hljs-literal">undefined</span>,
      <span class="hljs-literal">true</span>,
      <span class="hljs-literal">undefined</span>,
      <span class="hljs-literal">false</span> <span class="hljs-comment">/* isComponent */</span>
    )
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// no children = noop. codegen will return null.</span>
  }
}
</code></pre>
<p>我们知道，<code>Vue3</code> 中是可以在 <code>template</code> 中写多个字节点的：</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">template</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>1<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>2<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">template</span>></span>
</code></pre>
<p><code>createRootCodegen</code>，核心就是创建根节点的 <code>codegenNode</code> 对象。所以当有多个子节点时，也就是 <code>children.length > 1</code> 时，调用 <code>createVNodeCall</code> 来创建一个新的 <code>fragement</code> 根节点 <code>codegenNode</code>。</p>
<p>否则，就代表着只有一个根节点，直接让根节点的 <code>codegenNode</code> 等于第一个子节点的根节点的<code>codegenNode</code>即可。</p>
<p><code>createRootCodegen</code> 完成之后，接着把 <code>transform</code> 上下文在转换 <code>AST</code> 节点过程中创建的一些变量赋值给 <code>root</code> 节点对应的属性，这样方便在后续代码生成的过程中访问到这些变量。</p>
<pre><code class="hljs language-js">root.<span class="hljs-property">helpers</span> = [...context.<span class="hljs-property">helpers</span>.<span class="hljs-title function_">keys</span>()]
root.<span class="hljs-property">components</span> = [...context.<span class="hljs-property">components</span>]
root.<span class="hljs-property">directives</span> = [...context.<span class="hljs-property">directives</span>]
root.<span class="hljs-property">imports</span> = context.<span class="hljs-property">imports</span>
root.<span class="hljs-property">hoists</span> = context.<span class="hljs-property">hoists</span>
root.<span class="hljs-property">temps</span> = context.<span class="hljs-property">temps</span>
root.<span class="hljs-property">cached</span> = context.<span class="hljs-property">cached</span>
</code></pre>
<h2>总结</h2>
<p>这里我们介绍了关于 <code>transform</code> 相关的知识，再来回顾一下，<code>transform</code> 节点的核心功能就是语法分析阶段，把 <code>AST</code> 节点做进一层转换，构造出语义化更强，信息更加丰富的 <code>codegenCode</code>。便于在下一小节 <code>generate</code> 中使用。</p></div>
</body></html>