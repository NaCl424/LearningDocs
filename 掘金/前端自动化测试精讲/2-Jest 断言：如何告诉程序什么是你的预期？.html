<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Jest 断言：如何告诉程序什么是你的预期？</h1>
<blockquote>
<p>代码仓库：<a href="https://github.com/czm1290433700/test_demo" target="_blank" rel="nofollow noopener noreferrer">https://github.com/czm1290433700/test_demo</a></p>
</blockquote>
<p>上节课我们详细聊了技术选型，选用了 Jest + React Testing Library 来作为单元测试的技术栈，Jest 是一个 JavaScript 集大成的测试库，是我们单元测试的基础，而 React Testing Library 则提供了一些 React Component 的 Api ，来协助我们进行 React Dom 和事件相关的单测编写。</p>
<p>这节课将详细介绍我们是如何通过 Jest 来描述我们的预期的，在开始这节课的学习前，我们来看看上节写的单元测试。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./src/App.test.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;

<span class="hljs-title function_">test</span>(<span class="hljs-string">'renders learn react link'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>);
  <span class="hljs-keyword">const</span> linkElement = screen.<span class="hljs-title function_">getByText</span>(<span class="hljs-regexp">/learn react/i</span>);
  <span class="hljs-title function_">expect</span>(linkElement).<span class="hljs-title function_">toBeInTheDocument</span>();
});
</code></pre>
<p>其中 test 用于定义单个的用例， 与此类似的还有 describe 和 it，describe 表示一组分组，其中可以包含多组 test，而 it 是 test 的别名，有相同的作用，例如上节课中 Enzyme 的例子。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./App.test.tsx</span>
<span class="hljs-keyword">import</span> { mount } <span class="hljs-keyword">from</span> <span class="hljs-string">"enzyme"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./App"</span>;

<span class="hljs-title function_">describe</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-title function_">it</span>(<span class="hljs-string">"first unit test"</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">mount</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>);
    <span class="hljs-title function_">expect</span>(app.<span class="hljs-title function_">find</span>(<span class="hljs-string">".read-the-docs"</span>).<span class="hljs-title function_">getDOMNode</span>().<span class="hljs-property">textContent</span>).<span class="hljs-title function_">toEqual</span>(
      <span class="hljs-string">"Click on the Vite and React logos to learn more"</span>
    );
  });
});
</code></pre>
<p>我们来看其中的 Callback 逻辑，在这则单测中我们判断了 Learn react 这则文案是否在我们的 DOM 中，<code>screen.getByText</code>用于元素的查找，是 React Testing Library 提供给我们的 API，这部分会在 <a href="https://juejin.cn/book/7174044519350927395/section/7176804322653503528" target="_blank" rel="nofollow noopener noreferrer">6 | DOM断言：页面元素的断言</a> 详细举例介绍，我们这边不过多介绍。</p>
<pre><code class="hljs language-scss"><span class="hljs-built_in">expect</span>(linkElement)<span class="hljs-selector-class">.toBeInTheDocument</span>();
</code></pre>
<p>在选取完元素后，上面这行代码告诉了单测程序，我们希望选取的元素可以存在页面正文中。其实从语义上也很好理解，expect(期望）linkElement(这个元素）toBeInTheDocument（可以在页面正文）。</p>
<p>其中<code>expect</code>在我们后面的每次测试中都会频繁用到，其中的参数填入你需要进行判断的对象，<code>toBeInTheDocument</code> 这个 Api 是匹配器，也称断言，用来告诉程序你的预期是什么，通过对预期的对象进行断言就是单元测试的基本原理。</p>
<p>在 Jest 中有提供很多基础的断言，来帮助描述我们需求中的常见场景，这节课我们就先来学习 Jest 提供哪些断言的 Api 来帮助我们编写测试预期（<code>toBeInTheDocument</code>是React Testing Library 提供的额外断言 Api，我们在<a href="https://juejin.cn/book/7174044519350927395/section/7176804322653503528" target="_blank" rel="nofollow noopener noreferrer">6 | DOM断言：页面元素的断言</a> 一起介绍）。</p>
<h2>Jest 常见断言场景</h2>
<p>我根据常用断言的使用场景分成了以下六个方向：</p>

































<table><thead><tr><th>场景方向</th><th>涉及的断言Api</th></tr></thead><tbody><tr><td>基础类型的比较</td><td><code>not</code>  <code>toBe(value)</code>  <code>toBeTruthy(value)</code>  <code>toBeFalsy(value)</code>  <code>toBeDefined()</code>  <code>toBeUndefined()</code>  <code>toBeCloseTo(value)</code> <code>toBeNaN()</code></td></tr><tr><td>引用类型的比较</td><td><code>toEqual(value)</code></td></tr><tr><td>数字符号</td><td><code>toBeGreaterThan(value)</code>  <code>toBeLessThan(value)</code>  <code>toBeGreaterThanOrEqual(value)</code>  <code>toBeLessThanOrEqual(value)</code></td></tr><tr><td>正则匹配</td><td><code>toMatch(value)</code>  <code>toMatchObject(value)</code></td></tr><tr><td>表单验证</td><td><code>toContain(value)</code>  <code>arrayContaining(value)</code> <code>toContainEqual(value)</code>  <code>toHaveLength(value)</code>  <code>toHaveProperty(value)</code></td></tr><tr><td>错误抛出</td><td><code>toThrow()</code>  <code>toThrowError()</code></td></tr></tbody></table>
<p>下面我们就按照上述方向，依次来学习以下对应断言的应用，首先我们在 src 目录下创建一个 <strong>test</strong> 来存放我们纯逻辑的单测。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-title function_">describe</span>(<span class="hljs-string">"examples for jest expect"</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-comment">// ... 本节课后续的test就放在这里</span>
});
</code></pre>
<h3>基础类型的比较</h3>
<p>我们知道，JavaScript 中分为基础类型和引用类型，其中基础类型中，大部分比较都可以通过 <code>toBe</code> 来完成，而<code>not</code>则用来表示非的判断，比如下面的简单例子。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("基础类型的比较", () => {
    <span class="hljs-comment">// tobe</span>
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>)<span class="hljs-selector-class">.toBe</span>(<span class="hljs-number">2</span>);
    <span class="hljs-comment">// not</span>
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>)<span class="hljs-selector-class">.not</span><span class="hljs-selector-class">.toBe</span>(<span class="hljs-number">3</span>);
})
</code></pre>
<p>不仅是数字，包括 boolean 和 undefined 在内都是可以的。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("基础类型的比较", () => {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// boolean</span>
    <span class="hljs-built_in">expect</span>(true)<span class="hljs-selector-class">.toBe</span>(true);
    <span class="hljs-comment">// undefined</span>
    <span class="hljs-built_in">expect</span>(undefined)<span class="hljs-selector-class">.toBe</span>(undefined); 
})
</code></pre>
<p>虽然这些可以通过 toBe 判断，但是同时 Jest 还提供了 4 个 API 来判断 true、 false、undefined、defined，效果与 toBe 来判断是都相同的。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("基础类型的比较", () => {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// boolean</span>
    <span class="hljs-built_in">expect</span>(true)<span class="hljs-selector-class">.toBe</span>(true);
    <span class="hljs-built_in">expect</span>(true)<span class="hljs-selector-class">.toBeTruthy</span>();
    <span class="hljs-built_in">expect</span>(false)<span class="hljs-selector-class">.toBeFalsy</span>();
    <span class="hljs-comment">// undefined</span>
    <span class="hljs-built_in">expect</span>(undefined)<span class="hljs-selector-class">.toBe</span>(undefined);
    <span class="hljs-built_in">expect</span>(undefined)<span class="hljs-selector-class">.not</span><span class="hljs-selector-class">.toBeDefined</span>();
    <span class="hljs-built_in">expect</span>(undefined)<span class="hljs-selector-class">.toBeUndefined</span>();
})
</code></pre>
<p>不仅是针对变量，对函数返回值的判断也是可以的，比如：</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("基础类型的比较", () => {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// undefined</span>
    const test = () => {
      console<span class="hljs-selector-class">.log</span>(test);
    };
    <span class="hljs-built_in">expect</span>(test())<span class="hljs-selector-class">.toBeUndefined</span>();
})
</code></pre>
<p>虽然 toBe 的能力很强大，但是针对浮点类型就不行了，比如：</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("基础类型的比较", () => {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// 浮点数</span>
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>)<span class="hljs-selector-class">.toBe</span>(<span class="hljs-number">0.3</span>);
})
</code></pre>
<p>针对这个用例，我们会得到下面的结果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f978abe072014a10b50f95a0849291dc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个倒不是 Jest 的原因，而是由于 JavaScript 本身的特性导致的，我们知道 JavaScript 中数字只有一个 number 类型，与 Java 等语言不同，JavaScript 并没有类似 float 或是 double 的浮点类型，浮点的实现都采用 double(双精度存储）。</p>
<p>大学时候计组课程我们学过，针对双精度存储，包含 8 个字节，也就是 64 位二进制（1 位符号位，11 位阶码（指数位），52 位尾数位），而十进制转二进制可能是除不尽的，52 位尾数位后面的位数就会被抹掉。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3fae277329c45f6975caa765fac5524~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>所以针对 0.1 + 0.2 的计算其实是这样的过程，首先需要把 0.1 和 0.2 转化成对应的二进制。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cf227e85559421ba728236d150e511c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这样加起来得到的结果就是 0.0100110011001100110011001100110011001100110011001101，因为上面我们说过 JavaScript 是会把 52位尾数后的内容抹掉的，所以这个结果并不是完全精准的，转换为十进制就是 0.30000000000000004，所以没办法全等。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47631ca418a647b9ad044db5d58c0b3e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>所以针对浮点数的比较，Jest 有提供一个专门的断言来进行判断，那就是 toBeCloseTo，和它的字面意思相同，这个断言用来判断对象和预期的精度是否足够接近，而不再是全等，例如下面的例子：</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("基础类型的比较", () => {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// 浮点数</span>
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>)<span class="hljs-selector-class">.toBe</span>(<span class="hljs-number">0.3</span>);
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>)<span class="hljs-selector-class">.toBeCloseTo</span>(<span class="hljs-number">0.3</span>);
})
</code></pre>
<p>这样看下来，toBe 是不是和我们平时常用的 === 很像，不过严格意义上说，toBe 的效果并不等同于 全等===， <strong>它是一种更加精确的匹配，应该说等同于 Object.is</strong>，这个是 ES6 提供的新方法，相比 ===， 它修复了 JavaScript 历史的两个问题，NaN 和 +(-)0 。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e19bb9320bfc4d798202b6357b0edb7d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>对于 Object.is 这两个不合理的判断都得到了修复。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9d5a0250352438e817f18e99b45931a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>针对这两个场景，我们可以写如下的断言，其中<code>toBeNaN</code> 也是 Jest 提供的额外基础断言 API，效果上与<code>toBe(NaN)</code> 也是相同的。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("基础类型的比较", () => {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// NaN</span>
    <span class="hljs-built_in">expect</span>(NaN)<span class="hljs-selector-class">.toBe</span>(NaN);
    <span class="hljs-built_in">expect</span>(NaN)<span class="hljs-selector-class">.toBeNaN</span>();
    <span class="hljs-comment">// +0 -0</span>
    <span class="hljs-built_in">expect</span>(+<span class="hljs-number">0</span>)<span class="hljs-selector-class">.not</span><span class="hljs-selector-class">.toBe</span>(-<span class="hljs-number">0</span>);
})
</code></pre>
<h3>引用类型的比较</h3>
<p>除了基础类型外，我们知道 JavaScript 还有引用类型，与基础类型不同的是，引用类型的全等，是对引用类型的内存指针进行比较，对于深拷贝或是属性完全相同的对象，使用 toBe 的断言是不能满足预期的，所以 Jest 有专门为这类情况提供断言 toEqual(value)，相比 toBe，toEqual 会深度递归对象的每个属性，进行深度比较，只要原始值相同，那就可以通过断言。我们来看下面的例子。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("引用类型的比较", () => {
    const <span class="hljs-selector-tag">a</span> = { obj1: { name: <span class="hljs-string">"obj1"</span>, obj2: { name: <span class="hljs-string">"obj2"</span> } } };
    const <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.assign</span>(a);
    const c = JSON<span class="hljs-selector-class">.parse</span>(JSON.stringify(a));
    <span class="hljs-built_in">expect</span>(a)<span class="hljs-selector-class">.toBe</span>(b);
    <span class="hljs-built_in">expect</span>(a)<span class="hljs-selector-class">.not</span><span class="hljs-selector-class">.toBe</span>(c);
    <span class="hljs-built_in">expect</span>(a)<span class="hljs-selector-class">.toEqual</span>(b);
    <span class="hljs-built_in">expect</span>(a)<span class="hljs-selector-class">.toEqual</span>(c);
})
</code></pre>
<p>其中有 a, b, c 三个对象，b 对象是基于 a 对象的浅拷贝，而 c 对象是基于 a 对象的深拷贝，我们可以看到，a 和 b 是可以通过 toBe 来验证的，因为它们指向同一个内存指针，而 c 是完全开创出来的独立的内存空间，所以不能用全等进行验证，这里我们采用 toEqual 进行验证。</p>
<p>值得一提的是，toEqual 能不能用于验证基础类型呢？也是可以的，我们看下面的例子。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("引用类型的比较", () => {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>)<span class="hljs-selector-class">.toEqual</span>(<span class="hljs-number">2</span>);
})
</code></pre>
<p>我们上面有提到，toEqual 是采用深度递归的方式进行的原始值比较，虽然基础类型本身并不是对象，但是在对它们的 proto 进行递归比较的时候，会调用它们对应的包装类型创建实例，实例本身是可以作为对象进行比较的，所以 toEqual 同样可以用于基础类型的比较，比较的结果预期将是所有递归属性的值相等。</p>
<h3>数字符号</h3>
<p>我们在书写单测验证一些场景的时候，经常会有数字值比较的需求，比如 > ， &#x3C; 等，这些也有对应的基础断言可以进行验证，比较简单就不过多讲解了，大家可以看看下面的例子。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("数字符号", () => {
    <span class="hljs-comment">// ></span>
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">3</span>)<span class="hljs-selector-class">.toBeGreaterThan</span>(<span class="hljs-number">2</span>);
    <span class="hljs-comment">// &#x3C;</span>
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">3</span>)<span class="hljs-selector-class">.toBeLessThan</span>(<span class="hljs-number">4</span>);
    <span class="hljs-comment">// >=</span>
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">3</span>)<span class="hljs-selector-class">.toBeGreaterThanOrEqual</span>(<span class="hljs-number">3</span>);
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">3</span>)<span class="hljs-selector-class">.toBeGreaterThanOrEqual</span>(<span class="hljs-number">2</span>);
    <span class="hljs-comment">// &#x3C;=</span>
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">3</span>)<span class="hljs-selector-class">.toBeLessThanOrEqual</span>(<span class="hljs-number">3</span>);
    <span class="hljs-built_in">expect</span>(<span class="hljs-number">3</span>)<span class="hljs-selector-class">.toBeLessThanOrEqual</span>(<span class="hljs-number">4</span>);
  });
</code></pre>
<h3>正则匹配</h3>
<p>正则匹配同样也是我们开发中比较常见的场景，针对这个场景，Jest 断言中有两个常用的匹配器会经常使用，分别是 <code>toMatch(regexp)</code> 和 <code>toMatchObj(value)</code>，其中 <code>toMatch(regexp)</code> 会匹配字符串是否能够满足正则的验证，而<code>toMatchObj(value)</code>则用来验证对象能否包含 value 的全部属性，即 value 是否是匹配对象的子集，我们来看下面的例子。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("正则匹配", () => {
    <span class="hljs-built_in">expect</span>("This is a regexp validation")<span class="hljs-selector-class">.toMatch</span>(/regexp/);
    const obj = { prop1: <span class="hljs-string">"test"</span>, prop2: <span class="hljs-string">"regexp validation"</span> };
    const childObj = { prop1: <span class="hljs-string">"test"</span> };
    <span class="hljs-built_in">expect</span>(obj)<span class="hljs-selector-class">.toMatchObject</span>(childObj);
  });
</code></pre>
<p>其中“This is a regexp validation” 包含 “regexp”字符串，childObj 也作为 obj 的子集，所以这个验证是可以通过的。</p>
<h3>表单验证</h3>
<p>我们在需求中经常会有很多表单，对于表单值的判断也是一个很常遇到的场景，表单验证中我们经常会有值为数组或是对象的判定，所以验证某个字段是否在对象或者数组中是很有必要的。表单验证中也有提供对应能力的断言：</p>
<ul>
<li><code>toContain(value)</code> ：判定某个值是否存在在数组中。</li>
<li><code>arrayContaining(value)</code>：匹配接收到的数组，与 toEqual 结合使用可以用于判定某个数组是否是另一个数组的子集。</li>
<li><code>toContainEqual(value)</code> ：用于判定某个对象元素是否在数组中。</li>
<li><code>toHaveLength(value)</code>：断言数组的长度 。</li>
<li><code>toHaveProperty(value)</code>：断言对象中是否包含某个属性，针对多层级的对象可以通过 xx.yy 的方式进行传参断言。</li>
</ul>
<p>我们来结合下面的例子具体说明：</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("表单验证", () => {
    <span class="hljs-comment">// 数组元素验证</span>
    <span class="hljs-built_in">expect</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<span class="hljs-selector-class">.toContain</span>(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">expect</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<span class="hljs-selector-class">.toEqual</span>(expect.arrayContaining([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]));
    <span class="hljs-built_in">expect</span>([{ a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> }])<span class="hljs-selector-class">.toContainEqual</span>({ a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> });
    <span class="hljs-comment">// 数组长度</span>
    <span class="hljs-built_in">expect</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<span class="hljs-selector-class">.toHaveLength</span>(<span class="hljs-number">3</span>);
    <span class="hljs-comment">// 对象属性验证</span>
    const testObj = {
      prop1: <span class="hljs-number">1</span>,
      prop2: {
        child1: <span class="hljs-number">2</span>,
        child2: <span class="hljs-string">"test"</span>,
      },
    };
    <span class="hljs-built_in">expect</span>(testObj)<span class="hljs-selector-class">.toHaveProperty</span>("prop1");
    <span class="hljs-built_in">expect</span>(testObj)<span class="hljs-selector-class">.toHaveProperty</span>("prop2.child1");
  });
</code></pre>
<p>在上面的例子中，我们分别对基础元素、数组子集、对象子集的包含关系、数组长度、对象包含的属性进行了断言，对于复合属性断言的场景，我们可以采用类似 <code>expect(testObj).toHaveProperty("prop2.child1")</code>的方式进行传参，用 . 来体现对应的层级关系即可。</p>
<p>值得一提的是，<code>expect([1, 2, 3]).toEqual(expect.arrayContaining([1, 2]));</code>与之前的断言不同，我们使用<code>expect.arrayContaining([1, 2])</code>来替代了文字值，也就是能匹配所有能够涵括它的数组。只要 [1, 2] 是数组 A 的子集，那么数组 A 就可以成为 <code>arrayContaining</code> 的匹配对象。</p>
<h3>错误抛出</h3>
<p>最后一个要介绍的场景就是错误抛出，无论是业务或是基础组件代码，错误抛出都是一个常见的场景，对于这些异常情况的断言，也是我们单元测试的一个重要部分。针对这种场景，Jest 提供了 <code>toThrow</code> 和 <code>toThrowError</code> 两个匹配器，这两个匹配器能力都相同，<code>toThrowError</code> 可以理解成是 <code>toThrow</code> 的一个别名，我们来看下面的例子。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-built_in">test</span>("错误抛出", () => {
    const throwError = () => {
      const err = new <span class="hljs-built_in">Error</span>("console err: this is a test error!");
      throw err;
    };
    <span class="hljs-built_in">expect</span>(throwError)<span class="hljs-selector-class">.toThrow</span>();
    <span class="hljs-built_in">expect</span>(throwError)<span class="hljs-selector-class">.toThrowError</span>();

    const catchError = () => {
      try {
        const err = new <span class="hljs-built_in">Error</span>("console err: this is a test error!");
        throw err;
      } catch (err) {
        console<span class="hljs-selector-class">.log</span>(err);
      }
    };
    <span class="hljs-built_in">expect</span>(catchError)<span class="hljs-selector-class">.not</span><span class="hljs-selector-class">.toThrow</span>();
    <span class="hljs-built_in">expect</span>(catchError)<span class="hljs-selector-class">.not</span><span class="hljs-selector-class">.toThrowError</span>();
  });
</code></pre>
<p>对于上面的例子，值得一提的是<code>expect(throwError).toThrow();</code>中，throwError方法只需要传入即可，不需要执行，即<code>expect(throwError).toThrow();</code>，直接执行会抛出未捕获的错误，中断后续的测试进程。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b8835a12dea4f2d86da86df54283ab2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如果我们在方法中，已经有了错误的捕获，那么断言本身是无法生效的，这个大家需要注意一下。</p>
<h2>自定义断言</h2>
<p>上文我们已经针对常见的断言场景，介绍了 Jest 提供的一些常用的匹配器 API，当然官方还提供了一些别的匹配器，不过在日常需求中并不常用，感兴趣的同步可以移步<a href="https://jestjs.io/docs/expect#expectarraycontainingarray" target="_blank" rel="nofollow noopener noreferrer">官网</a>了解更多。</p>
<p>除了基础的已经定义好的断言 API，Jest 也支持我们自定义断言匹配器，来覆盖基础的断言不能覆盖到的特殊业务场景，我们可以使用 Expect.extend 来自定义断言，我们先通过这个 API 的类型，来对它的能力有个初步的了解。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/194ab4b520474c2d9c29d0cb53ff8396~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cec6d70ee244136958845c7f8091d8e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>可以看到 <code>extend</code> 可以接收一个 key - matcher 的映射 map，不难猜到，key 是自定义匹配器的名称，而 CustomMatcher 则对应匹配器的定义。通过 CustomMatcher 的类型定义我们可以看到，自定义匹配器包含同步（CustomeMatcherResult) 和 异步（Promise)两种，它们都接收类型为 <code>{ pass: boolean; message: () => string } </code>的返回值，其中 pass 表示这个断言是否通过，而 message 则作为这个结果的备注信息。</p>
<p>我们首先来尝试定义一个同步的匹配器，想象一个场景，假如我们需要断言一个数字是否在 0 到 10 之间，应该怎么实现这个匹配器呢？我们来看下面的例子。</p>
<pre><code class="hljs language-dart"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
test(<span class="hljs-string">"同步自定义匹配器"</span>, () => {
    <span class="hljs-keyword">const</span> toBeBetweenZeroAndTen = (<span class="hljs-built_in">num</span>: number) => {
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">num</span> >= <span class="hljs-number">0</span> &#x26;&#x26; <span class="hljs-built_in">num</span> &#x3C;= <span class="hljs-number">10</span>) {
        <span class="hljs-keyword">return</span> {
          message: () => <span class="hljs-string">""</span>,
          pass: <span class="hljs-keyword">true</span>,
        };
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> {
          message: () => <span class="hljs-string">"expected num to be a number between zero and ten"</span>,
          pass: <span class="hljs-keyword">false</span>,
        };
      }
    };
    expect.extend({
      toBeBetweenZeroAndTen,
    });
    expect(<span class="hljs-number">8</span>).toBeBetweenZeroAndTen();
    expect(<span class="hljs-number">11</span>).not.toBeBetweenZeroAndTen();
  });
</code></pre>
<p>可以看到同步匹配器的实现很简单，我们只需要在我们预期的判断逻辑中返回对应的结构体，然后将对应的匹配器方法传给 extend 后，就可以通过 expect 来调用对应的匹配器了。现在我们来改造一下这个匹配器，使得它可以支持异步的场景。</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// ./src/__test__/expect.test.ts</span>
<span class="hljs-title function_">test</span>(<span class="hljs-string">"异步自定义匹配器"</span>, <span class="hljs-keyword">async</span> () => {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">toBeBetweenZeroAndTen</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">num: <span class="hljs-built_in">number</span></span>) => {
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&#x3C;{ <span class="hljs-attr">message</span>: <span class="hljs-function">() =></span> <span class="hljs-built_in">string</span>; <span class="hljs-attr">pass</span>: <span class="hljs-built_in">boolean</span> }>(
        <span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {
          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
            <span class="hljs-keyword">if</span> (num >= <span class="hljs-number">0</span> &#x26;&#x26; num &#x3C;= <span class="hljs-number">10</span>) {
              <span class="hljs-title function_">resolve</span>({
                <span class="hljs-attr">message</span>: <span class="hljs-function">() =></span> <span class="hljs-string">""</span>,
                <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
              });
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-title function_">resolve</span>({
                <span class="hljs-attr">message</span>: <span class="hljs-function">() =></span>
                  <span class="hljs-string">"expected num to be a number between zero and ten"</span>,
                <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
              });
            }
          }, <span class="hljs-number">1000</span>);
        }
      );
      <span class="hljs-keyword">return</span> (
        res || {
          <span class="hljs-attr">message</span>: <span class="hljs-function">() =></span> <span class="hljs-string">"expected num to be a number between zero and ten"</span>,
          <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
        }
      );
    };
    expect.<span class="hljs-title function_">extend</span>({
      toBeBetweenZeroAndTen,
    });
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">expect</span>(<span class="hljs-number">8</span>).<span class="hljs-title function_">toBeBetweenZeroAndTen</span>();
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">expect</span>(<span class="hljs-number">11</span>).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeBetweenZeroAndTen</span>();
  });
</code></pre>
<p>可以看到，异步场景只是在同步的基础上加上了 async/await 相关的逻辑，然后在 expect 调用对应匹配器的时候，使用 await 等待结果返回即可。</p>
<h2>怎么调试单测程序？</h2>
<p>上文我们介绍了 Jest 提供的常用断言匹配器，以及如何自定义一个断言匹配器，这里加一个小彩蛋，很多同学可能并不知道怎么调试测试代码，与业务逻辑不同，测试代码运行在 node，所以并不能通过浏览器 console 调试，我们可以采用和调试 node 服务相同的方式来调试我们的单测程序。下面简单举例说明一下。</p>
<p>首先我们在需要断点的位置写入 debugger，或是在左侧点击断点红点都可。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b7c09738b4e4980af773dabb6009bdf~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>然后通过 vscode JavaScript 调试终端而非普通运行终端，运行对应的单测命令。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c06c29c9e567412186e8c53edc333ef8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>可以看到对应断点处就已经停顿下来了，并且可以在左侧视图层看到当前状态下的变量值，顶部也会有步进等调试的按钮，后面我们就像平时调试代码一样正常调试代码就好了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ce534ab89fb4c62a7dd15f1ad60a11c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>小结</h2>
<p>这节课我们学习了怎么告诉测试程序你的预期，我们通过不同的断言来对每个需要验证的对象提出自己的预期，当断言的结果与预期不符的时候，测试程序就会将错误和未通过的用例反馈给你。</p>
<p>针对断言有很多种类，我们基于场景分类，分别学习了基础类型比较，引用类型比较、数字符号、正则匹配等常见的 Jest 断言匹配器。同时我们还尝试自己自定义了断言匹配器，来覆盖基础断言器不足以满意的业务需求。</p>
<p>最后我们还了解了怎么去测试一个单测程序，因为与常规业务代码不同，测试程序执行于 node 环境，所以我们采用开发 node 服务类似的调试方式对测试用例进行调试。</p>
<p>相信经过这节课的学习，同学们已经入门了对纯逻辑的单元测试进行用例的编写，但是这样还远远不够，因为我们的单元测试主要还是覆盖于包含 DOM 的组件场景下，下一节课，我们将来学习 React Testing Library 给我们提供的 DOM 扩展能力，掌握如何对期望 DOM 区域进行选取。</p></div>
</body></html>