<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>技术选型：React Testing Library Or Enzyme？</h1>
<blockquote>
<p>代码仓库(后续学习都在这个仓库，CRA创建）：<a href="https://github.com/czm1290433700/test_demo" target="_blank" rel="nofollow noopener noreferrer">https://github.com/czm1290433700/test_demo</a></p>
<p>配置示例仓库：<a href="https://github.com/czm1290433700/test_demo_for_config" target="_blank" rel="nofollow noopener noreferrer">https://github.com/czm1290433700/test_demo_for_config</a></p>
</blockquote>
<p>上一节，我们站在研发的角度大体分析了怎么写前端的自动化测试，不可否认的是，在特定的场景下，合适的自动化测试对项目的维稳和日后的迭代都有深远的意义。</p>
<p>通常，根据自动化测试的维度，可以分为单元测试和端对端测试。单元测试是更细粒度的、从代码组件层次进行的功能测试，而端对端测试是从用户视角，从项目整体展开的测试。从这节课开始，我们先学习单元测试。</p>
<p>针对单元测试，JavaScript 技术栈通常会选用 Jest 作为基础测试框架，它是 Facebook 开发的 JavaScript 测试框架，用于创建、运行和编写测试的 JavaScript 库。但是，<strong>仅通过 Jest</strong> <strong>，</strong> <strong>没办法完成前端的所有单元测试</strong>，因为与常规的接口逻辑测试不同，前端的单元测试涉及到 Dom 和事件的模拟，我们还需要选用一个辅助库来协助我们模拟相关的场景。</p>
<p>有两个主流的辅助库选择，Enzyme 和 React Testing Library，这两个库都是非常优秀的辅助库，它们都提供了测试应用程序所需的所有工具，都能够满足我们的单测需求，但从配置以及测试思路的角度上看，我更推荐大家使用 React Testing Library，下面我们将具体说明。</p>
<h2>配置</h2>
<h3>Jest</h3>
<blockquote>
<p>配置可参考配置示例仓库 test_demo_for_config master 分支。</p>
<p>Node 版本 14 +</p>
</blockquote>
<p>Jest 是基础的测试库，是安装 Enzyme 和 React Testing Library 的前置条件，在 create-react-app 脚手架中，会一并自动打包进来，我们这里以非 CRA 场景的例子，来示范一下怎么进行 Jest 的配置。仓库可以使用尤大的 @vitejs/app 来帮助我们初始化一个空白的项目（只是便于创建一个空项目，后续流程与 Vite 无关，Webpack 同样适用）。</p>
<pre><code class="hljs language-csharp"> npm <span class="hljs-keyword">init</span> vite test_demo
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7460e61b3624ff99c74f1ffe00f21b3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>配置上我们选择 React + TS 就可，然后我们打开项目看看，可以看到，一个没有单测能力的项目创建好了, 我们可以打开项目看看。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed8132663b674e65bf0eaf8998bbdd8c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>首先我们来安装一下 Jest 相关的依赖。</p>
<pre><code class="hljs language-scss">npm install <span class="hljs-attr">--save-dev</span> jest <span class="hljs-keyword">@types</span>/jest <span class="hljs-keyword">@jest</span>/types
</code></pre>
<p>安装好了以后，我们初始化一下 Jest 的 配置。</p>
<pre><code class="hljs language-csharp">npx jest --<span class="hljs-keyword">init</span>
</code></pre>
<p>可以参照下面进行选择。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93162d834f0f4de3aeb3c89547ca997c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这里简单解释一下我们为什么这么选：</p>
<ul>
<li>前两个配置选项是字面意思，不赘述了。</li>
<li>单测环境（jsdom)：因为我们会涉及到 dom 的单测，不仅仅是纯逻辑，如果是纯逻辑的选 node。</li>
<li>是否需要覆盖率报告（no)：暂时用不上，后面覆盖率章节会着重介绍。</li>
<li>编译代码（babel)： 可以转 ES5，避免一些兼容性问题。</li>
<li>每次测试完是否清理 mock、实例等结果（yes): 每次测试完成后会清理 mock 等上次测试的结果，可以避免用例之间的互相影响</li>
</ul>
<p>到这里我们 Jest 的基本配置就已经完成了，可以看到根目录已经生成了对应的 jest.config.ts 文件，大家也可以根据自己的需要增加额外的自定义配置，具体可以参考<a href="https://jestjs.io/docs/configuration" target="_blank" rel="nofollow noopener noreferrer"> Configuring</a>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ec402d7879b431bbbd87683a4aa8e23~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>因为我们选用了 babel 作为单测的编译，所以这边还需要增加一下对应的配置。</p>
<pre><code class="hljs language-scss">npm install <span class="hljs-attr">--save-dev</span> babel-jest <span class="hljs-keyword">@babel</span>/core <span class="hljs-keyword">@babel</span>/preset-env <span class="hljs-keyword">@babel</span>/preset-react <span class="hljs-keyword">@babel</span>/preset-typescript
</code></pre>
<p>这边除 babel 基础的配置集（presets)，我们还安装了 React 和 TypeScript 的配置集，来帮助我们的单测可以支持使用 ts 来书写，安装完成后，我们在根目录创建一个 babel.config.js 文件用于 babel 的配置，其中@babel/preset-react ，我们为它加上 <code>runtime: "automatic"</code>的配置，这是为了帮助我们可以自动导入 React，不然后续单测的开发会要求对 React 进行 import。</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// ./babel.config.js</span>
module<span class="hljs-selector-class">.exports</span> = {
  presets: [
    [<span class="hljs-string">"@babel/preset-env"</span>, { targets: { node: <span class="hljs-string">"current"</span> } }],
    <span class="hljs-selector-attr">[<span class="hljs-string">"@babel/preset-react"</span>,{ runtime: <span class="hljs-string">"automatic"</span> }]</span>, <span class="hljs-comment">// 自动导入react</span>
    "<span class="hljs-keyword">@babel</span>/preset-typescript<span class="hljs-string">",
  ],
};
</span></code></pre>
<p>这时候我们新增一个单测实验一下，执行一下<code>npm run test</code>。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// App.test.ts</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-title function_">test</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-title function_">expect</span>(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">2</span>);
});
</code></pre>
<p>这时候发现会有 ts-node 需要安装的报错提醒。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/527c1f09c996450091fd6b0ffae7aab5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我们先来看一下 jest-config 的依赖配置，因为配置文件是 ts，所以需要依赖 ts-node 进行编译，如果子依赖中没直接包含的话，的确会有这样的问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/195f53a6171e49e99242502f02b092e0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>的确和我们想的一样，那我们自己安装一下 ts-node 就好了。</p>
<pre><code class="hljs language-css">npm install ts-node <span class="hljs-attr">--save-dev</span>
</code></pre>
<p>我们再试试看，可能会遇到下面的报错。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef616b5b412049848be57d9a0e32781d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>和之前的原因类似，jest-environment-jsdom 也不会作为子依赖自动安装，我们自己安装一下就好。</p>
<pre><code class="hljs language-css">npm install jest-environment-jsdom <span class="hljs-attr">--save-dev</span>
</code></pre>
<p>再试试看，发现还有一个问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a9b3825d5844a1e8662c6b76588fda4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个是因为尤大的 vitejs 脚手架中，在 package.json 中设置了 <code>type: module</code>，这将指明这个包是采用何种方式进行导入的，针对<code>type: module</code>，babel.config 的后缀类型应该使用 cjs，改成如下图。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7afe7a3c04244117b66964416654eac0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如果没有这项的同学应该是正常的，就可以忽略了，如果大家这时候尝试一下 <code>npm run test</code>，会发现应该已经可以了，这些是基于 babel 的配置，<a href="https://jestjs.io/zh-Hans/docs/getting-started" target="_blank" rel="nofollow noopener noreferrer">Jest 官网</a>也提供了 ts-jest 的配置方案，大家可以下来试试看。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ce132050894d6290d6140bc86054d6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>到这里，Jest 的基础配置就已经完成了，但是还有一些特殊情况，我们需要额外进行一些配置。</p>
<ul>
<li>额外的扩展名识别：因为Jest 不使用 Webpack 等打包工具，因此它不知道如何加载除 js/jsx 之外的其他文件扩展名，所以我们需要为它加一个转换器。</li>
</ul>
<pre><code class="hljs language-scss"><span class="hljs-comment">// jest.config.ts</span>
export default {
  <span class="hljs-comment">// ... other config</span>
  <span class="hljs-attribute">transform</span>: {
    <span class="hljs-comment">// ...</span>
    "^.+\.(js|ts|tsx)$": <span class="hljs-string">"&#x3C;rootDir>/node_modules/babel-jest"</span>,
  },
};
</code></pre>
<ul>
<li>Svg mock 转换：我们项目中可能会有用到 svg 等图片，这个对于 Jest 同样也是无法识别的，我们需要对它进行 mock，返回相同的输出结果。</li>
</ul>
<pre><code class="hljs language-scss"><span class="hljs-comment">// jest.config.ts</span>
export default {
  <span class="hljs-comment">// ... other config</span>
  <span class="hljs-attribute">transform</span>: {
    <span class="hljs-comment">// ...</span>
    "^.+\<span class="hljs-selector-class">.svg</span>$": <span class="hljs-string">"&#x3C;rootDir>/svg-transform.js"</span>,
  },
};
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./svg-transform.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">process</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">code</span>: <span class="hljs-string">"module.exports = {};"</span> };
  },
  <span class="hljs-title function_">getCacheKey</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"svgTransform"</span>; <span class="hljs-comment">// SVG固定返回这个字符串</span>
  },
};
</code></pre>
<ul>
<li>CSS 代理：Jest 本身不知道如何处理不同扩展的文件，我们可以通过配置代理的方式，告诉 Jest 将此对象模拟为导入的 CSS 模块。</li>
</ul>
<pre><code class="hljs language-css">npm install <span class="hljs-attr">--save-dev</span> identity-obj-proxy
</code></pre>
<pre><code class="hljs language-arduino"><span class="hljs-comment">// jest.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// ... other config</span>
  moduleNameMapper: {
    <span class="hljs-string">"\.(css|less)$"</span>: <span class="hljs-string">"identity-obj-proxy"</span> <span class="hljs-comment">// 有使用 sass 需求的同学可以把正则换成 ^\.(css|less|sass|scss)$</span>
  }
};
</code></pre>
<p>大家做到这一步，可以<code>git init</code>一下，提交一个 commit 进行保存，下面我们将来配置辅助库。 因为 Jest 的配置都是相同的，后续大家在配置辅助库时，stash 一下之前的配置就可以重新开始了，会方便清晰很多。</p>
<h3>React Testing Library</h3>
<blockquote>
<p>配置可参考配置示例仓库 test_demo_for_config feat/react_testing_library 分支。</p>
</blockquote>
<p>接下来我们来配置 React Testing Library，我们先来安装一下依赖，这几个库我们会在后面的课程中着重学习：</p>
<ul>
<li>@testing-library/jest-dom：用于 dom、样式类型等元素的选取。</li>
<li>@testing-library/react：提供针对 React 的单测渲染能力。</li>
<li>@testing-library/user-event：用于单测场景下事件的模拟。</li>
</ul>
<pre><code class="hljs language-dart">npm install <span class="hljs-meta">@testing</span>-<span class="hljs-keyword">library</span>/jest-dom <span class="hljs-meta">@testing</span>-<span class="hljs-keyword">library</span>/react <span class="hljs-meta">@testing</span>-<span class="hljs-keyword">library</span>/user-event --save-dev
</code></pre>
<p>针对 @testing-library/jest-dom 我们全局导入一下，使得 expect 可以适配 React testing library 提供的相关断言，我们在根目录创建一个 jest-dom-setup.js (名字可自取)，用于全局导入 @testing-library/jest-dom。</p>
<pre><code class="hljs language-arduino"><span class="hljs-comment">//  jest_dom_setup.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'@testing-library/jest-dom'</span>
</code></pre>
<p>然后我们将这个文件配置到 jest.config.ts 的 setupFilesAfterEnv 属性中，这个字段的作用是，将指定的配置文件，在安装测试框架之后，执行测试代码本身之前运行，这样我们就不需要每个单测文件都单独导入一次 @testing-library/jest-dom 了。</p>
<pre><code class="hljs language-arduino"><span class="hljs-comment">// jest.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// ... other config</span>
  setupFilesAfterEnv: [<span class="hljs-string">"&#x3C;rootDir>/jest-dom-setup.js"</span>],
};
</code></pre>
<p>到这里 React Testing Library 的配置就已经完成了，我们可以修改我们的单测来试验一下效果，可以看到已经可以了。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./src/App.test.tsx</span>
<span class="hljs-comment">// 这里文件后缀修改为 tsx，因为需要测试 dom</span>
<span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">"@testing-library/react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"@testing-library/jest-dom"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./App"</span>;

<span class="hljs-title function_">describe</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-title function_">test</span>(<span class="hljs-string">"first unit test"</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>);
    <span class="hljs-title function_">expect</span>(screen.<span class="hljs-title function_">getByText</span>(<span class="hljs-string">"Vite + React"</span>)).<span class="hljs-title function_">toBeInTheDocument</span>();
  });
});
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25ee1334f28e416aa4a0228bfbb43490~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如果大家是使用 create-react-app 创建一个新项目的话，React Testing Library 的配置相比手工配置会方便很多，脚手架帮我们完成了 Jest 到 React Testing Library 所有的配置，我们打开终端执行下面的命令。</p>
<pre><code class="hljs language-lua">npm i <span class="hljs-built_in">create</span>-react-app -g 
npx <span class="hljs-built_in">create</span>-react-app test_demo <span class="hljs-comment">--template typescript</span>
</code></pre>
<p>执行完成后，会在对应目录下生成如下的项目结构。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7169869b1729424a84b9649eddddf8f4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>其中包含<code>test</code>即为单测的文件，我们先来看下 package.json。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec2d159b089d48ebafd6f269783ed7fd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>可以看到我们上面自己手动配置的依赖都有安装，比较奇怪的是，Jest 去哪里了，我们知道 React Testing Library 只是辅助库，单测基础库还是要使用到 Jest 的，我们到 package.json 中搜一下 <code>"jest"</code> 看看。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a78eeaa106f14f1b8b07686d5cf1a16b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>可以看到 create-react-app 将 Jest 作为 react-scripts 这个依赖的子依赖单独打包进来了。现在我们来看看脚手架自动生成的单测，这个单测的效果是测试 App 组件下是否包含 learn react 的文案。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./src/App.test.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;

<span class="hljs-title function_">test</span>(<span class="hljs-string">'renders learn react link'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>);
  <span class="hljs-keyword">const</span> linkElement = screen.<span class="hljs-title function_">getByText</span>(<span class="hljs-regexp">/learn react/i</span>);
  <span class="hljs-title function_">expect</span>(linkElement).<span class="hljs-title function_">toBeInTheDocument</span>();
});
</code></pre>
<p>我们可以尝试执行 script 中的 test 命令看下效果，可以看到用例通过的信息， create-react-app 其实还是很方便的，不需要我们再配置啥，可以很方便地开始单测地学习，后面的课程我们也会基于这个项目进一步展开。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62a0af0a7ad049048d205f770d6eb6ab~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3>Enzyme</h3>
<blockquote>
<p>配置可参考配置示例仓库 test_demo_for_config feat/enzyme 分支。</p>
</blockquote>
<p>现在我们来配置 Enzyme， 首先我们来安装一下依赖，对于 Enzyme 我们需要安装三个依赖：</p>
<ul>
<li>enzyme：基础库。</li>
<li>enzyme-adapter-react：对 React 的适配器，需要安装对应 React 版本的适配器。</li>
<li>jest-enzyme：用于 enzyme 对 Jest 的环境适配。</li>
</ul>
<p>Enzyme 的使用是依赖于适配器（enzyme-adapter-react）的，大家如果到 npm 等<a href="https://www.npmjs.com/search?q=enzyme-adapter-react-17" target="_blank" rel="nofollow noopener noreferrer">包管理平台</a>去搜索，会发现 Enzyme 适配的速度其实是要远慢于 React 的迭代速度的，从 React 17 开始，提供的适配器就已经是开发者自行实现的了，这是 Enzyme目前最大的问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afb3d9ec1d3c4d5eb6cf99332d81cbc4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>这种稳定性可能没有办法得到有效的保证，对于新项目如果想体验 React 高版本所提供的一些优化（例如流式渲染），可能会遇到一些因没有完全适配而导致的问题</strong>，并且更糟糕的是，目前 Enzyme 只剩一名开发者 <a href="https://twitter.com/ljharb" target="_blank" rel="nofollow noopener noreferrer">Jordan Harband</a>来提供基础的维护，对于一些 issue 的解决可能没办法那么及时。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10af85d861d0481c862791127ef6ec29~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>因为 vitejs 脚手架初始的项目用的是 React 18，所以我们到包管理里搜一下<a href="https://www.npmjs.com/package/@cfaester/enzyme-adapter-react-18" target="_blank" rel="nofollow noopener noreferrer"> star 最多的项目</a> 进行下载，可以看到 readme 里作者也直接说了这不是官方的，可能会有一些问题 =。=</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3eec6eddde748b882ad905c41ab1e8f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我们现在来安装一下依赖。</p>
<pre><code class="hljs language-sql">npm install enzyme <span class="hljs-variable">@types</span><span class="hljs-operator">/</span>enzyme jest<span class="hljs-operator">-</span>enzyme <span class="hljs-variable">@cfaester</span><span class="hljs-operator">/</span>enzyme<span class="hljs-operator">-</span>adapter<span class="hljs-operator">-</span>react<span class="hljs-number">-18</span> <span class="hljs-comment">--save-dev</span>
</code></pre>
<p>接下来，我们来创建 Enzyme 的实例，并通过 Jest 的 setupFiles 进行安装时的全局注入。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./enzyme_setup.ts</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"@cfaester/enzyme-adapter-react-18"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Enzyme</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"enzyme"</span>;

<span class="hljs-title class_">Enzyme</span>.<span class="hljs-title function_">configure</span>({ <span class="hljs-attr">adapter</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>() });

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Enzyme</span>;
</code></pre>
<pre><code class="hljs language-arduino"><span class="hljs-comment">// ./jest.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// ... other config</span>
  setupFiles: [<span class="hljs-string">"&#x3C;rootDir>/enzyme_setup.ts"</span>],
};
</code></pre>
<p>Jest 环境适配的依赖，我们也需要同样配置到 config 中，把对应的入口文件导入就行。</p>
<pre><code class="hljs language-arduino"><span class="hljs-comment">// ./jest.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// ... other config</span>
  setupFilesAfterEnv: [<span class="hljs-string">"&#x3C;rootDir>/node_modules/jest-enzyme/lib/index.js"</span>],
};
</code></pre>
<p>到这里 Enzyme 的配置就完成了，我们写一条单测来试试。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ./App.test.tsx</span>
<span class="hljs-keyword">import</span> { mount } <span class="hljs-keyword">from</span> <span class="hljs-string">"enzyme"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./App"</span>;

<span class="hljs-title function_">describe</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-title function_">it</span>(<span class="hljs-string">"first unit test"</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">mount</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>);
    <span class="hljs-title function_">expect</span>(app.<span class="hljs-title function_">find</span>(<span class="hljs-string">".read-the-docs"</span>).<span class="hljs-title function_">getDOMNode</span>().<span class="hljs-property">textContent</span>).<span class="hljs-title function_">toEqual</span>(
      <span class="hljs-string">"Click on the Vite and React logos to learn more"</span>
    );
  });
});
</code></pre>
<p>看错误栈可以看到，这个非官方的 React 18 适配器报错了，看样子是没有导入对应的全局依赖，我们切到对应的错误栈，帮它加一下试试。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f71f69ebbdd4364a79ae4acf6a5ba4b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d6d80c994694102906829a7c5ee7faf~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我们再试试看，看看有没有别的问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c6f66197ec84934b76660e71cc4675d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个是因为从 React 15.5.0 开始，PropTypes 已作为单独的依赖项从核心 React 包中删除，依赖包本身并没有去安装这个依赖，我们替它装一下。</p>
<pre><code class="hljs language-css">npm install <span class="hljs-attr">--save-dev</span> prop-types
</code></pre>
<p>再试试看，发现已经可以了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d75d688a8d3c4c2ca16c9bf0c353ba07~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如果大家要使用 18 版本的话，我建议 fork 这个依赖的仓库，然后按照我们上述进行微调后发包使用，或者给这个仓库提一个 mr 修复一下上述的问题都可。</p>
<p>如果是 React 17 版本应该就不会遇到上面的问题了，换用这个 <a href="https://www.npmjs.com/package/@wojtekmaj/enzyme-adapter-react-17" target="_blank" rel="nofollow noopener noreferrer">@wojtekmaj/enzyme-adapter-react-17</a> 适配器即可，目前还没有发现什么问题，至于到 React16 版本及以前，就都是官方提供的适配器了，稳定性有保障，可以放心使用。</p>
<h2>测试思路</h2>
<p>不得不说我在进行小册技术选型的时候纠结了很久，因为历史原因，包括 Semi 在内的使用的其实都是 Enzyme，不可否认它是一个很优秀的辅助库，对于项目性能的维稳和日后迭代都提供了很大的助力和信心，如果说官方适配器没办法跟上 React 版本，非官方适配器稳定性又没有保障是导火索，那么测试思路就是使我最后决定的那根稻草。</p>
<p>Enzyme 允许访问组件的内部工作原理。我们可以读取和设置状态，并且可以模拟子项，以使测试运行得更快。所以Enzyme 的单元测试是基于 component 的 props 展开的，是从代码逻辑的层面验证组件，例如下面的例子。</p>
<pre><code class="hljs language-javascript"><span class="hljs-title function_">it</span>(<span class="hljs-string">'input with custom className &#x26; style'</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallow</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Input</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'test'</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{color:</span> '<span class="hljs-attr">red</span>'}}/></span></span>);
    <span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">exists</span>(<span class="hljs-string">'.test'</span>)).<span class="hljs-title function_">toEqual</span>(<span class="hljs-literal">true</span>);
    <span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">find</span>(<span class="hljs-string">'div.test'</span>)).<span class="hljs-title function_">toHaveStyle</span>(<span class="hljs-string">'color'</span>, <span class="hljs-string">'red'</span>);
 });
</code></pre>
<p>而 React Testing Library 采取完全不同的单测思路，它并不在意组件实现的细节，它的测试将基于组件能力本身，从用户视角去进行测试，例如脚手架生成的单测例子。</p>
<pre><code class="hljs language-scss"><span class="hljs-built_in">test</span>('renders learn react link', () => {
  <span class="hljs-built_in">render</span>(&#x3C;App />);
  const linkElement = screen<span class="hljs-selector-class">.getByText</span>(/learn react/i);
  <span class="hljs-built_in">expect</span>(linkElement)<span class="hljs-selector-class">.toBeInTheDocument</span>();
});
</code></pre>
<p>就我看来，这两种方案其实各有优劣，Enzyme 所推崇的单测思路虽然在编写上会更麻烦，但是可以有效帮助开发审视自己的类名、结构等封装是否合理，尤其如果作为多业务线复用的组件，这个效果会更加明显，因为作为通用组件，类名等设计的是否合理，会决定到这个组件的复用程度（比如复用过程中 global 样式是否容易编写）。</p>
<p>但是从业务项目长久维护上看，Enzyme 的单测其实是一种<strong>脆弱且不可靠的单测</strong>，我们知道在业务代码中，产品需求可能是会频繁变动的，有些需求 pm 当时拍脑袋决定后，可能过段时间发现并不合理，进行调整或者推倒重来，这种情况是很常见的。</p>
<p>针对这种情况，从业务角度上，更需要关注的其实是历史功能是否可以得到完整保留，而不是组件本身的逻辑保持不变，对于业务项目，Enzyme 的单测注定会需要随需求频繁变动，这些时间成本其实都是研发人员难以接受的，我们更需要一个稳定可靠不经常变动的单测来协助我们。所以出于这方面的考虑，这本小册将使用 React Testing Library 来给大家展开单元测试的学习。</p>
<h2>小结</h2>
<p>这节课是我们单元测试章节的启蒙课，在这节课，我们了解到，<strong>单元测试是从组件层面更细粒度展开的测试</strong>，我们通常使用 Jest 作为我们展开单元测试的基础测试库，Jest 的配置相对还是比较繁琐的，大家可以参考下面的思维导图再整理一下思路。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb6a77c318b842d99929c69a69d33d79~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>因为前端需要模拟浏览器 DOM、事件的原因，所以我们还需要使用一个辅助库来协助我们进行浏览器环境的模拟。主流的库有 Enzyme 和 React Testing Library ，虽然它们都是优秀的单测辅助库，但是它们的思路不尽相同。</p>
<p>Enzyme 提供的能力让我们从组件逻辑细节来展开单测，对于需求频繁变动的场景，这是一种脆弱的单测，可能会需要开发人员频繁修改单元测试。而React Testing Library 并不在意组件实现的细节，是从组件能力本身去展开测试，这样对于代码组件层面的重构和优化，只要最后功能相同，单测将都可以复用，更适合业务场景。</p>
<p>同时考虑到 Enzyme 目前官方适配器更新缓慢，依赖社区非官方适配的原因，所以小册后面的学习，我们将使用 React Testing Library 来进行环境的模拟。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e8279b44fbd45db98158426e57f959b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下一节课，我们将来学习 Jest 的断言，通过它，能够告诉我们的单测程序什么是我们的预期。</p></div>
</body></html>