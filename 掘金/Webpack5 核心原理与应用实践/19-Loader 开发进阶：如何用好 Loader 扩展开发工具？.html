<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>Loader 开发进阶：如何用好 Loader 扩展开发工具？</h1>
<p>在上一篇文章中，我们已经详细了解了开发 Webpack Loader 需要用到的基本技能，包括：Loader 基本形态、如何构建测试环境、如何使用 Loader Context 接口等。接下来我们继续拓展学习一些 Loader 辅助工具，包括：</p>
<ul>
<li>了解 <code>loader-utils</code>，并使用 <code>loader-utils</code> 拼接文件名；</li>
<li>了解 <code>schema-tiles</code>，以及其背后的 <code>ajv</code> 库与 JSON-Schema 协议，学习使用 <code>schema-utils</code> 实现参数校验。</li>
</ul>
<p>文章最后还会深入剖析 <code>vue-loader</code> 组件源码，通过实战方式帮助大家更深入理解：如何开发一个成熟 Loader。</p>
<h2>使用 <code>schema-utils</code></h2>
<p>Webpack，以及 Webpack 生态下的诸多 Loader、Plugin 基本上都会提供若干“<strong>配置项</strong>”，供用户调整组件的运行逻辑，这些组件内部通常都会使用 <a href="https://www.npmjs.com/package/schema-utils" target="_blank" rel="nofollow noopener noreferrer">schema-utils</a> 工具库校验用户传入的配置是否满足要求。</p>
<p>因此，若我们开发的 Loader 需要对外暴露配置项，建议也尽量使用这一工具，基本用法：</p>
<ol>
<li>安装依赖：</li>
</ol>
<pre><code class="hljs language-csharp">yarn <span class="hljs-keyword">add</span> -D schema-utils
</code></pre>
<ol start="2">
<li>编写配置对象的 Schema 描述，例如：</li>
</ol>
<pre><code class="hljs language-json"><span class="hljs-comment">// options.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"object"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"boolean"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"required"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"name"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"additionalProperties"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ol start="3">
<li>在 Loader 中调用 <code>schema-utils</code> 校验配置对象：</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { validate } <span class="hljs-keyword">from</span> <span class="hljs-string">"schema-utils"</span>;
<span class="hljs-keyword">import</span> schema <span class="hljs-keyword">from</span> <span class="hljs-string">"./options.json"</span>;

<span class="hljs-comment">// 调用 schema-utils 完成校验</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loader</span>(<span class="hljs-params">source</span>) {
  <span class="hljs-keyword">const</span> options = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOptions</span>();
  <span class="hljs-title function_">validate</span>(schema, options);

  <span class="hljs-keyword">return</span> source;
}

<span class="hljs-comment">// Webpack5 之后还可以借助 Loader Context 的 `getOptions` 接口完成校验</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loader</span>(<span class="hljs-params">source</span>) {
  <span class="hljs-keyword">const</span> options = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOptions</span>(schema);

  <span class="hljs-keyword">return</span> source;
}
</code></pre>
<blockquote>
<p>提示：示例代码已上传到小册 <a href="https://github1s.com/Tecvan-fe/webpack-book-samples/blob/main/loader-validate/package.json" target="_blank" rel="nofollow noopener noreferrer">仓库</a>。</p>
</blockquote>
<p>之后，若用户传入不符合 Schema 描述的参数对象，会报类似下面这种错误提示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/077c1aab02994c9a912f3614de6f60c0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p><code>schema-utils</code> 的校验能力很强，能够完美支撑起 Webpack 生态下非常复杂的参数校验需求，但官方文档非常语焉不详，翻阅源码后发现，它底层主要依赖于 <a href="https://ajv.js.org/guide/getting-started.html" target="_blank" rel="nofollow noopener noreferrer">ajv</a> ，这是一个应用广泛、功能强大且性能优异的校验工具：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461958492c45459bb25cff296651d89e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<blockquote>
<p>提示：<code>ajv</code> 在对象校验、JSON 序列化/反序列化方面的性能表现非常突出，许多知名<a href="https://www.npmjs.com/browse/depended/ajv" target="_blank" rel="nofollow noopener noreferrer">开源框架</a> 如：ESLint、fast-json-stringify、middy、swagger、tailwind 等底层都依赖于 <code>ajv</code>，值得我们学习、复用到业务项目中。</p>
</blockquote>
<p><code>ajv</code> 功能非常完备，基本上已经覆盖了“使用 JSON 描述对象约束”的所有场景，我们不可能在一篇文章里介绍所有细节，所以我下面只摘要介绍一些比较重要的能力与实例，更多信息建议参考 <a href="https://ajv.js.org/guide/why-ajv.html" target="_blank" rel="nofollow noopener noreferrer">官网</a>。</p>
<blockquote>
<p><code>ajv</code> 数据描述格式基础知识：</p>
</blockquote>
<p><code>schema-utils</code> 内部使用 <code>ajv</code> 的 <a href="https://ajv.js.org/json-schema.html" target="_blank" rel="nofollow noopener noreferrer">JSON-Schema</a> 模式实现参数校验，而 JSON-Schema 是一种以 JSON 格式描述数据结构的 <a href="https://json-schema.org/specification.html" target="_blank" rel="nofollow noopener noreferrer">公共规范</a>，使用时至少需要提供 <code>type</code> 参数，如：</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"number"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><code>ajv</code> 默认支持七种基本数据类型。</p>
<ul>
<li><a href="https://ajv.js.org/json-schema.html#keywords-for-numbers" target="_blank" rel="nofollow noopener noreferrer">number</a>：数值型，支持整数、浮点数，支持如下校验规则：
<ul>
<li><code>maximum</code>、<code>minimum</code>：属性值必须大于等于 <code>minimum</code> ，且小于等于 <code>maximum</code>；</li>
<li><code>exclusiveMaximum</code>、<code>exclusiveMinimum</code>：属性值必须大于 <code>exclusiveMinimum</code> ，且小于 <code>exclusiveMinimum</code>；</li>
<li><code>multipleOf</code>：属性值必须为 <code>multipleOf</code> 的整数倍，例如对于 <code>multipleOf = 5</code>，则 <code>10/20/5</code> 均符合预期，但 <code>8/9/1</code> 等不符合预期。</li>
</ul>
</li>
<li><code>interger</code>：整数型，与 <code>number</code> 类似，也支持上面介绍的 <code>maximum</code> 等校验规则；</li>
<li><a href="https://ajv.js.org/json-schema.html#keywords-for-strings" target="_blank" rel="nofollow noopener noreferrer">string</a>：字符串型，支持如下校验规则：
<ul>
<li><code>maxLength</code>、<code>minLength</code>：限定字符串的最大长度、最小长度；</li>
<li><code>pattern</code>：以正则表达式方式限定字符串内容；</li>
<li><code>format</code>：声明字符串内容格式，<code>schema-utils</code> 底层调用了 <code>[ajv-formats](https://github.com/ajv-validator/ajv-formats)</code> 插件，开箱支持 <code>date/ipv4/regex/uuid</code> 等格式。</li>
</ul>
</li>
<li><code>boolean</code>：bool 值；</li>
<li><a href="https://ajv.js.org/json-schema.html#keywords-for-arrays" target="_blank" rel="nofollow noopener noreferrer">array</a>：数组型，支持如下校验属性：
<ul>
<li><code>maxItems</code>、<code>minItems</code>：限定数组的最多、最少的元素数量；</li>
<li><code>uniqueItems</code>：限定数组元素是否必须唯一，不可重复；</li>
<li><code>items</code>：声明数组项的 Schema 描述，数组项内可复用 JSON-Schema 的任意规则，从而形成嵌套定义结构；</li>
</ul>
</li>
<li><code>null</code>：空值，常用于复合 <code>type</code> 类型，如 <code>type = ['object', 'null']</code> 支持传入对象结构或 <code>null</code> 值；</li>
<li><a href="https://ajv.js.org/json-schema.html#keywords-for-objects" target="_blank" rel="nofollow noopener noreferrer">object</a>：对象结构，这是一个比较负责的结构，支持如下校验属性：
<ul>
<li><code>maxProperties</code> / <code>minProperties</code>：限定对象支持的最多、最少属性数量；</li>
<li><code>required</code>：声明哪些属性不可为空，例如 <code>required = ['name', 'age']</code> 时，传入的值必须至少提供 <code>name/age</code> 属性；</li>
<li><code>properties</code>：定义特定属性的 Schema 描述，与 <code>array</code> 的 <code>items</code> 属性类似，支持嵌套规则，例如：</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">"object"</span>,
  <span class="hljs-attr">properties</span>: {
    <span class="hljs-attr">foo</span>: {<span class="hljs-attr">type</span>: <span class="hljs-string">"string"</span>},
    <span class="hljs-attr">bar</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">"number"</span>,
      <span class="hljs-attr">minimum</span>: <span class="hljs-number">2</span>
    }
  }
}
</code></pre>
<ul>
<li><code>patternProperties</code>：同样用于定义对象属性的 Schema，但属性名支持正则表达式形式，例如：</li>
</ul>
<pre><code class="hljs language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">"object"</span>,
  <span class="hljs-attr">patternProperties</span>: {
    <span class="hljs-string">"^fo.*$"</span>: {<span class="hljs-attr">type</span>: <span class="hljs-string">"string"</span>},
    <span class="hljs-string">"^ba.*$"</span>: {<span class="hljs-attr">type</span>: <span class="hljs-string">"number"</span>}
  }
}
</code></pre>
<ul>
<li><code>additionalProperties</code>：限定对象是否可以提供除 <code>properties</code>、<code>patternProperties</code> 之外的属性；</li>
</ul>
<p>除此之外，Schema 节点还支持一些通用的规则字段，包括：</p>
<ul>
<li><code>enum</code>：枚举数组，属性值必须完全等于(Deep equal)这些值之一，例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// JSON-Schema</span>
{
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>,
  <span class="hljs-string">"enum"</span>: [
    <span class="hljs-string">"fanwenjie"</span>,
    <span class="hljs-string">"tecvan"</span>
  ]
}

<span class="hljs-comment">// 有效值：</span>
<span class="hljs-string">"fanwenjie"</span>/<span class="hljs-string">"tecvan"</span>
<span class="hljs-comment">// 无效值，如：</span>
<span class="hljs-string">"foo bar"</span> 等
</code></pre>
<ul>
<li><code>const</code>：静态数值，属性值必须完全等于 <code>const</code> 定义，单独看 <code>const</code> 似乎作用不大，但配合 <a href="https://ajv.js.org/guide/combining-schemas.html#data-reference" target="_blank" rel="nofollow noopener noreferrer">$data</a> 指令的 <a href="https://datatracker.ietf.org/doc/rfc6901/" target="_blank" rel="nofollow noopener noreferrer">JSON-Pointer</a> 能力，可以实现关联相等的效果，例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// JSON-Schema</span>
{
  <span class="hljs-attr">type</span>: <span class="hljs-string">"object"</span>,
  <span class="hljs-attr">properties</span>: {
    <span class="hljs-attr">foo</span>: {<span class="hljs-attr">type</span>: <span class="hljs-string">"string"</span>},
    <span class="hljs-attr">bar</span>: {<span class="hljs-attr">const</span>: {<span class="hljs-attr">$data</span>: <span class="hljs-string">"1/foo"</span>}}
  }
}

<span class="hljs-comment">// bar 必须等于 foo，如：</span>
{
  <span class="hljs-string">"foo"</span>: <span class="hljs-string">"fanwenjie"</span>,
  <span class="hljs-string">"bar"</span>: <span class="hljs-string">"fanwenjie"</span>
}
<span class="hljs-comment">// 否则无效：</span>
{
  <span class="hljs-string">"foo"</span>: <span class="hljs-string">"fanwenjie"</span>,
  <span class="hljs-string">"bar"</span>: <span class="hljs-string">"tecvan"</span>
}
</code></pre>
<p>这些基础数据类型与校验规则奠定了 <code>ajv</code> 的基础校验能力，我们使用 <code>schema-utils</code> 时大部分时间都需要与之打交道，建议同学们多加学习掌握。</p>
<blockquote>
<p>使用 <code>ajv</code> 复合条件指令</p>
</blockquote>
<p>除上述介绍的基本类型与基础校验规则外，<code>ajv</code> 还提供了若干<a href="https://ajv.js.org/json-schema.html#compound-keywords" target="_blank" rel="nofollow noopener noreferrer">复合校验指令</a>：</p>
<ul>
<li><a href="https://ajv.js.org/json-schema.html#not" target="_blank" rel="nofollow noopener noreferrer">not</a>：数值必须不符合该条件，例如：<code>{type: "number", not: {minimum: 3}}</code> 时，传入数值必须小于 3；</li>
<li><a href="https://ajv.js.org/json-schema.html#anyof" target="_blank" rel="nofollow noopener noreferrer">anyof</a>：数值必须满足 <code>anyof</code> 条件之一，这是一个非常实用的指令，例如在 <code>css-loader</code> 中：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// css-loader/src/options.json</span>
{
  <span class="hljs-string">"additionalProperties"</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-string">"properties"</span>: {
    <span class="hljs-string">"url"</span>: {
      <span class="hljs-string">"description"</span>: <span class="hljs-string">"Enables/Disables 'url'/'image-set' functions handling (https://github.com/webpack-contrib/css-loader#url)."</span>,
      <span class="hljs-string">"anyOf"</span>: [
        {
          <span class="hljs-string">"type"</span>: <span class="hljs-string">"boolean"</span>
        },
        {
          <span class="hljs-string">"instanceof"</span>: <span class="hljs-string">"Function"</span>
        }
      ]
    },
    <span class="hljs-comment">// more properties</span>
  },
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"object"</span>
}
</code></pre>
<p>这意味着 <code>css-loader</code> 的 <code>url</code> 配置项只接受 Bool 或函数值。</p>
<ul>
<li><a href="https://ajv.js.org/json-schema.html#oneof" target="_blank" rel="nofollow noopener noreferrer">oneof</a>：数值必须满足且只能满足 <code>oneof</code> 条件之一，例如：</li>
</ul>
<pre><code class="hljs language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">"number"</span>,
  <span class="hljs-attr">oneOf</span>: [{<span class="hljs-attr">maximum</span>: <span class="hljs-number">3</span>}, {<span class="hljs-attr">type</span>: <span class="hljs-string">"integer"</span>}]
}
<span class="hljs-comment">// 下述数值符合要求：</span>
<span class="hljs-number">1.1</span>、<span class="hljs-number">2.1</span>、<span class="hljs-number">4</span>、<span class="hljs-number">5</span> 等

<span class="hljs-comment">// 下述数值不符合要求：</span>
<span class="hljs-number">3.5</span>、<span class="hljs-number">2</span>、<span class="hljs-number">1</span> 等
</code></pre>
<p>数值要么是小于等于3的浮点数，要么是大于3的整数，不在此区间的数值如“3.5/2” 等均不符合要求。</p>
<ul>
<li><a href="https://ajv.js.org/json-schema.html#allof" target="_blank" rel="nofollow noopener noreferrer">allof</a>：数值必须满足 <code>allof</code> 指定的所有条件，例如：</li>
</ul>
<pre><code class="hljs language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">"number"</span>,
  <span class="hljs-attr">allOf</span>: [{<span class="hljs-attr">maximum</span>: <span class="hljs-number">3</span>}, {<span class="hljs-attr">type</span>: <span class="hljs-string">"integer"</span>}]
}
<span class="hljs-comment">// 下述数值符合要求：</span>
<span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span> 等

<span class="hljs-comment">// 下述数值不符合要求：</span>
<span class="hljs-number">1.1</span>、<span class="hljs-number">4</span>、<span class="hljs-number">5</span> 等
</code></pre>
<p>这要求传入的数值必须小于 3，且必须为整型。</p>
<ul>
<li><code>if/then/else</code>：这是一个稍显复杂的三元组复合条件，大致逻辑为：若传入的数值满足 <code>if</code> 条件，则必须同时满足 <code>then</code> 条件；若不满足 <code>if</code> 则必须同时满足 <code>else</code>，其中 <code>else</code> 可选。例如：</li>
</ul>
<pre><code class="hljs language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">"object"</span>,
  <span class="hljs-attr">if</span>: {<span class="hljs-attr">properties</span>: {<span class="hljs-attr">foo</span>: {<span class="hljs-attr">minimum</span>: <span class="hljs-number">10</span>}}},
  <span class="hljs-attr">then</span>: {<span class="hljs-attr">required</span>: [<span class="hljs-string">"bar"</span>]},
  <span class="hljs-attr">else</span>: {<span class="hljs-attr">required</span>: [<span class="hljs-string">"baz"</span>]}
}
</code></pre>
<p>这意味着，若传入的 <code>foo</code> 属性值大于等于 10 时，则必须同时提供 <code>then</code> 所要求的 <code>bar</code> 属性；否则必须同时提供 <code>else</code> 所要求的 <code>baz</code> 属性。</p>
<p>总结一下，Webpack 官方选择 <code>ajv</code> 作用配置参数的校验工具，并将其二次封装为 <code>schema-utils</code> 库，供 Webpack 生态下的诸多 Loader、Plugin 使用。</p>
<p>而上面介绍的基础类型、类型校验、复合校验规则等内容是 <code>ajv</code> 非常基础且重要的知识点，三者协作组成 <code>ajv</code> 校验 <code>schema</code> 的框架结构，除此之外还有许多增强 Schema 表述能力的增强指令，包括：<code>$data</code>、<code>$ref</code>、<code>definitions</code> 等，篇幅关系这里不一一列举。同学们也可以参考 Webpack 官方编写的 <a href="https://github1s.com/webpack/webpack/blob/HEAD/schemas/WebpackOptions.json" target="_blank" rel="nofollow noopener noreferrer">Schema 文件</a>，学习各种校验规则的写法。</p>
<h2>使用 <code>loader-utils</code></h2>
<p>在 Webpack5 之前，<a href="https://github.com/webpack/loader-utils" target="_blank" rel="nofollow noopener noreferrer">loader-utils</a> 是一个非常重要的 Loader 开发辅助工具，为开发者提供了诸如 <code>getOptions/getCurrentRequest/parseQuery</code> 等核心接口，这些接口被诸多 Loader 广泛使用，到 Webpack5 之后干脆将这部分能力迁移到 Loader Context，致使 <code>loader-utils</code> 被大幅裁减简化。</p>
<p>被裁减后的 <code>loader-utils</code> 仅保留了四个接口：</p>
<ul>
<li><code>urlToRequest</code>：用于将模块路径转换为文件路径的工具函数；</li>
<li><code>isUrlRequest</code>：用于判定字符串是否为模块请求路径；</li>
<li><code>getHashDigest</code>：用于计算内容 Hash 值；</li>
<li><code>interpolateName</code>：用于拼接文件名的模板工具；</li>
</ul>
<p>翻阅大量 Loader 源码后发现，前三个接口使用率极低，实用性不大，因此本文直接跳过，仅侧重介绍 <code>interpolateName</code> 接口。</p>
<blockquote>
<p>使用 <code>interpolateName</code> 拼接文件名</p>
</blockquote>
<p>Webpack 支持以类似 <code>[path]/[name]-[hash].js</code> 方式设定 <code>output.filename</code> 即输出文件的命名，这一层规则通常不需要关注，但在编写类似 <a href="https://github.com/webpack-contrib/file-loader" target="_blank" rel="nofollow noopener noreferrer">webpack-contrib/file-loader</a> 这种自行输出产物文件的 Loader 时，需要由开发者自行处理产物路径逻辑。</p>
<p>此时可以使用 <code>loader-utils</code> 提供的 <code>interpolateName</code> 方法在 Loader 中以类似 Webpack 的 <code>output.filename</code> 规则拼接资源路径及名称，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// file-loader/src/index.js</span>
<span class="hljs-keyword">import</span> { interpolateName } <span class="hljs-keyword">from</span> <span class="hljs-string">'loader-utils'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loader</span>(<span class="hljs-params">content</span>) {
  <span class="hljs-keyword">const</span> context = options.<span class="hljs-property">context</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">rootContext</span>;
  <span class="hljs-keyword">const</span> name = options.<span class="hljs-property">name</span> || <span class="hljs-string">'[contenthash].[ext]'</span>;

  <span class="hljs-comment">// 拼接最终输出的名称</span>
  <span class="hljs-keyword">const</span> url = <span class="hljs-title function_">interpolateName</span>(<span class="hljs-variable language_">this</span>, name, {
    context,
    content,
    <span class="hljs-attr">regExp</span>: options.<span class="hljs-property">regExp</span>,
  });

  <span class="hljs-keyword">let</span> outputPath = url;
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">let</span> publicPath = <span class="hljs-string">`__webpack_public_path__ + <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(outputPath)}</span>`</span>;
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options.<span class="hljs-property">emitFile</span> === <span class="hljs-string">'undefined'</span> || options.<span class="hljs-property">emitFile</span>) {
    <span class="hljs-comment">// ...</span>

    <span class="hljs-comment">// 提交、写出文件</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emitFile</span>(outputPath, content, <span class="hljs-literal">null</span>, assetInfo);
  }
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">const</span> esModule =
    <span class="hljs-keyword">typeof</span> options.<span class="hljs-property">esModule</span> !== <span class="hljs-string">'undefined'</span> ? options.<span class="hljs-property">esModule</span> : <span class="hljs-literal">true</span>;

  <span class="hljs-comment">// 返回模块化内容</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${esModule ? <span class="hljs-string">'export default'</span> : <span class="hljs-string">'module.exports ='</span>}</span> <span class="hljs-subst">${publicPath}</span>;`</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> raw = <span class="hljs-literal">true</span>;
</code></pre>
<p>代码的核心逻辑：</p>
<ol>
<li>根据 Loader 配置，调用 <code>interpolateName</code> 方法拼接目标文件的完整路径；</li>
<li>调用上下文 <code>this.emitFile</code> 接口，写出文件；</li>
<li>返回 <code>module.exports = ${publicPath}</code> ，其它模块可以引用到该文件路径。</li>
</ol>
<blockquote>
<p>提示：除 <code>file-loader</code> 外，<code>css-loader</code>、<code>eslint-loader</code> 都有用到该接口，感兴趣的同学请自行前往查阅源码。</p>
</blockquote>
<p><code>interpolateName</code> 功能稍弱于 Webpack 的 <a href="https://webpack.js.org/configuration/output/#template-strings" target="_blank" rel="nofollow noopener noreferrer">Template String</a> 规则，仅支持如下占位符：</p>
<ul>
<li><code>[ext]</code>：原始资源文件的扩展名，如 <code>.js</code>；</li>
<li><code>[name]</code>：原始文件名；</li>
<li><code>[path]</code>：原始文件相对 <code>context</code> 参数的路径；</li>
<li><code>[hash]</code>：原始文件的内容 Hash 值，与 <code>output.file</code> 类似同样支持 <code>[hash:length]</code> 指定 Hash 字符串的长度；</li>
<li><code>[contenthash]</code>：作用、用法都与上述 <code>[hash]</code> 一模一样。</li>
</ul>
<h2>综合示例：Vue-loader</h2>
<p>接下来，我们再结合 <a href="https://vue-loader.vuejs.org/" target="_blank" rel="nofollow noopener noreferrer">vue-loader</a> 源码进一步学习 Loader 开发的进阶技巧。<code>vue-loader</code> 是一个综合性很强的示例，它借助 Webpack 与组件的一系列特性巧妙地解决了：如何区分 Vue SFC 不同代码块，并复用其它 Loader 处理不同区块的内容？</p>
<p>先从结构说起，<code>vue-loader</code> 内部实际上包含了三个组件：</p>
<ul>
<li><code>lib/index.js</code> 定义的 Normal Loader，负责将 Vue SFC 不同区块转化为 JavaScript <code>import</code> 语句，具体逻辑下面细讲；</li>
<li><code>lib/loaders/pitcher.js</code> 定义的 Pitch Loader，负责遍历的 <code>rules</code> 数组，拼接出完整的行内引用路径；</li>
<li><code>lib/plugin.js</code> 定义的插件，负责初始化编译环境，如复制原始 <code>rules</code> 配置等；</li>
</ul>
<p>三者协作共同完成对 SFC 的处理，使用时需要用户同时注册 Normal Loader 和 Plugin，如：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">VueLoaderPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vue-loader/lib/plugin"</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.vue$/</span>,
        <span class="hljs-attr">use</span>: [{ <span class="hljs-attr">loader</span>: <span class="hljs-string">"vue-loader"</span> }],
      }
    ],
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueLoaderPlugin</span>()
  ],
};
</code></pre>
<p><code>vue-loader</code> 运行过程大致上可以划分为两个阶段：</p>
<ol>
<li>预处理阶段：动态修改 Webpack 配置，注入 <code>vue-loader</code> 专用的一系列 <code>module.rules</code>；</li>
<li>内容处理阶段：Normal Loader 配合 Pitch Loader 完成文件内容转译。</li>
</ol>
<h3>预处理阶段</h3>
<p><code>vue-loader</code> 插件会在 <code>apply</code> 函数中动态修改 Webpack 配置，核心代码如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VueLoaderPlugin</span> {
  apply (compiler) {
    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">const</span> rules = compiler.<span class="hljs-property">options</span>.<span class="hljs-property">module</span>.<span class="hljs-property">rules</span>
    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">const</span> clonedRules = rules
      .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">r</span> =></span> r !== rawVueRules)
      .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">rawRule</span>) =></span> <span class="hljs-title function_">cloneRule</span>(rawRule, refs))

    <span class="hljs-comment">// ...</span>

    <span class="hljs-comment">// global pitcher (responsible for injecting template compiler loader &#x26; CSS</span>
    <span class="hljs-comment">// post loader)</span>
    <span class="hljs-keyword">const</span> pitcher = {
      <span class="hljs-attr">loader</span>: <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'./loaders/pitcher'</span>),
      <span class="hljs-attr">resourceQuery</span>: <span class="hljs-function"><span class="hljs-params">query</span> =></span> {
        <span class="hljs-keyword">if</span> (!query) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> }
        <span class="hljs-keyword">const</span> parsed = qs.<span class="hljs-title function_">parse</span>(query.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>))
        <span class="hljs-keyword">return</span> parsed.<span class="hljs-property">vue</span> != <span class="hljs-literal">null</span>
      }
      <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-comment">// replace original rules</span>
    compiler.<span class="hljs-property">options</span>.<span class="hljs-property">module</span>.<span class="hljs-property">rules</span> = [
      pitcher,
      ...clonedRules,
      ...rules
    ]
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneRule</span> (rawRule, refs) {
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">VueLoaderPlugin</span>
</code></pre>
<p>拆开来看，插件主要完成两个任务：</p>
<ol>
<li>初始化并注册 Pitch Loader：代码第16行，定义pitcher对象，指定loader路径为 <code>require.resolve('./loaders/pitcher')</code> ，并将pitcher注入到 <code>rules</code> 数组首位。</li>
</ol>
<p>这种动态注入的好处是用户不用关注 —— 不去看源码根本不知道还有一个pitcher loader，而且能保证pitcher能在其他rule之前执行，确保运行顺序。</p>
<ol start="2">
<li>复制 <code>rules</code> 配置：代码第8行遍历 <code>compiler.options.module.rules</code> 数组，也就是用户提供的 Webpack 配置中的 <code>module.rules</code> 项，对每个rule执行 <code>cloneRule</code> 方法复制规则对象。</li>
</ol>
<p>之后，将 Webpack 配置修改为 <code>[pitcher, ...clonedRules, ...rules]</code> 。感受一下实际效果，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.vue$/i</span>,
        <span class="hljs-attr">use</span>: [{ <span class="hljs-attr">loader</span>: <span class="hljs-string">"vue-loader"</span> }],
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">"css-loader"</span>],
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/i</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">"babel-loader"</span>,
          <span class="hljs-attr">options</span>: {
            <span class="hljs-attr">presets</span>: [[<span class="hljs-string">"@babel/preset-env"</span>, { <span class="hljs-attr">targets</span>: <span class="hljs-string">"defaults"</span> }]],
          },
        },
      },
    ],
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueLoaderPlugin</span>(),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>({ <span class="hljs-attr">filename</span>: <span class="hljs-string">"[name].css"</span> }),
  ],
};
</code></pre>
<p>这里定义了三个 rule，分别对应 vue、js、css 文件。经过 plugin 转换之后的结果大概为：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">loader</span>: <span class="hljs-string">"/node_modules/vue-loader/lib/loaders/pitcher.js"</span>,
        <span class="hljs-attr">resourceQuery</span>: <span class="hljs-function">() =></span> {},
        <span class="hljs-attr">options</span>: {},
      },
      {
        <span class="hljs-attr">resource</span>: <span class="hljs-function">() =></span> {},
        <span class="hljs-attr">resourceQuery</span>: <span class="hljs-function">() =></span> {},
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">"/node_modules/mini-css-extract-plugin/dist/loader.js"</span>,
          },
          { <span class="hljs-attr">loader</span>: <span class="hljs-string">"css-loader"</span> },
        ],
      },
      {
        <span class="hljs-attr">resource</span>: <span class="hljs-function">() =></span> {},
        <span class="hljs-attr">resourceQuery</span>: <span class="hljs-function">() =></span> {},
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">"babel-loader"</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">presets</span>: [[<span class="hljs-string">"@babel/preset-env"</span>, { <span class="hljs-attr">targets</span>: <span class="hljs-string">"defaults"</span> }]],
            },
            <span class="hljs-attr">ident</span>: <span class="hljs-string">"clonedRuleSet-2[0].rules[0].use"</span>,
          },
        ],
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/i</span>,
        <span class="hljs-attr">use</span>: [
          { <span class="hljs-attr">loader</span>: <span class="hljs-string">"vue-loader"</span>, <span class="hljs-attr">options</span>: {}, <span class="hljs-attr">ident</span>: <span class="hljs-string">"vue-loader-options"</span> },
        ],
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">"/node_modules/mini-css-extract-plugin/dist/loader.js"</span>,
          },
          { <span class="hljs-attr">loader</span>: <span class="hljs-string">"css-loader"</span> },
        ],
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/i</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">"babel-loader"</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">presets</span>: [[<span class="hljs-string">"@babel/preset-env"</span>, { <span class="hljs-attr">targets</span>: <span class="hljs-string">"defaults"</span> }]],
            },
            <span class="hljs-attr">ident</span>: <span class="hljs-string">"clonedRuleSet-2[0].rules[0].use"</span>,
          },
        ],
      },
    ],
  },
};
</code></pre>
<p>转换之后生成6个rule，按定义的顺序分别为：</p>
<ol>
<li>针对 <code>xx.vue&#x26;vue</code> 格式路径生效的规则，只用了 <code>vue-loader</code> 的 Pitch 作为 Loader；</li>
<li>被复制的 CSS 处理规则，<code>use</code> 数组与开发者定义的规则相同；</li>
<li>被复制的 JS 处理规则，<code>use</code> 数组也跟开发者定义的规则相同；</li>
<li>开发者定义的 <code>vue-loader</code> 规则，内容及配置都不变；</li>
<li>开发者定义的css规则，用到 <code>css-loader</code>、<code>mini-css-extract-plugin loader</code>；</li>
<li>开发者定义的js规则，用到 <code>babel-loader</code>。</li>
</ol>
<p>可以看到，第2、3项是从开发者提供的配置中复制过来的，内容相似，只是 <code>cloneRule</code> 在复制过程会给这些规则重新定义 <code>resourceQuery</code> 函数：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneRule</span> (rawRule, refs) {
    <span class="hljs-keyword">const</span> rules = ruleSetCompiler.<span class="hljs-title function_">compileRules</span>(<span class="hljs-string">`clonedRuleSet-<span class="hljs-subst">${++uid}</span>`</span>, [{
      <span class="hljs-attr">rules</span>: [rawRule]
    }], refs)
  
    <span class="hljs-keyword">const</span> conditions = rules[<span class="hljs-number">0</span>].<span class="hljs-property">rules</span>
      .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">rule</span> =></span> rule.<span class="hljs-property">conditions</span>)
      <span class="hljs-comment">// shallow flat</span>
      .<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, next</span>) =></span> prev.<span class="hljs-title function_">concat</span>(next), [])

    <span class="hljs-comment">// ...</span>
  
    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, rawRule, {
      <span class="hljs-attr">resource</span>: <span class="hljs-function"><span class="hljs-params">resources</span> =></span> {
        currentResource = resources
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
      },
      <span class="hljs-attr">resourceQuery</span>: <span class="hljs-function"><span class="hljs-params">query</span> =></span> {
        <span class="hljs-keyword">if</span> (!query) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> }
        <span class="hljs-keyword">const</span> parsed = qs.<span class="hljs-title function_">parse</span>(query.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>))
        <span class="hljs-keyword">if</span> (parsed.<span class="hljs-property">vue</span> == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
        <span class="hljs-keyword">if</span> (!conditions) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
        <span class="hljs-comment">// 用import路径的lang参数测试是否适用于当前rule</span>
        <span class="hljs-keyword">const</span> fakeResourcePath = <span class="hljs-string">`<span class="hljs-subst">${currentResource}</span>.<span class="hljs-subst">${parsed.lang}</span>`</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> condition <span class="hljs-keyword">of</span> conditions) {
          <span class="hljs-comment">// add support for resourceQuery</span>
          <span class="hljs-keyword">const</span> request = condition.<span class="hljs-property">property</span> === <span class="hljs-string">'resourceQuery'</span> ? query : fakeResourcePath
          <span class="hljs-keyword">if</span> (condition &#x26;&#x26; !condition.<span class="hljs-title function_">fn</span>(request)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
          }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
      }
    })
    <span class="hljs-comment">// ...</span>
  
    <span class="hljs-keyword">return</span> res
  }
</code></pre>
<p><code>cloneRule</code> 内部定义的 <code>resourceQuery</code> 函数对应 <a href="https://webpack.js.org/configuration/module/#ruleresourcequery" target="_blank" rel="nofollow noopener noreferrer">module.rules.resourceQuery</a> 配置项，与我们经常用的 <code>test</code> 差不多，都用于判断资源路径是否适用这个rule。这里 <code>resourceQuery</code> 核心逻辑就是取出路径中的lang参数，伪造一个以 <code>lang</code> 结尾的路径，传入rule的condition中测试路径名对该rule是否生效，例如下面这种会命中 <code>/\.js$/i</code> 规则：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> script <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.vue?vue&#x26;type=script&#x26;lang=js&#x26;"</span>
</code></pre>
<p><code>vue-loader</code> 正是基于这一规则，为不同内容块 (css/js/template) 匹配、复用用户所提供的 rule 设置。</p>
<h3>内容处理阶段</h3>
<p>插件处理完配置，webpack 运行起来之后，Vue SFC 文件会被多次传入不同的 Loader，经历多次中间形态变换之后才产出最终的 js 结果，大致上可以分为如下步骤：</p>
<ol>
<li>路径命中 <code>/\.vue$/i</code> 规则，调用 <code>vue-loader</code> 生成中间结果 A；</li>
<li>结果 A 命中 <code>xx.vue?vue</code> 规则，调用 <code>vue-loader</code> Pitch Loader 生成中间结果 B；</li>
<li>结果 B 命中具体 Loader，直接调用 Loader 做处理。</li>
</ol>
<p>过程大致为：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ba22f6bdf754a00997c607117e6c881~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>举个转换过程的例子：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 原始代码</span>
<span class="hljs-keyword">import</span> xx <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.vue'</span>;
<span class="hljs-comment">// 第一步，命中 vue-loader，转换为：</span>
<span class="hljs-keyword">import</span> { render, staticRenderFns } <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.vue?vue&#x26;type=template&#x26;id=2964abc9&#x26;scoped=true&#x26;"</span>
<span class="hljs-keyword">import</span> script <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.vue?vue&#x26;type=script&#x26;lang=js&#x26;"</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.vue?vue&#x26;type=script&#x26;lang=js&#x26;"</span>
<span class="hljs-keyword">import</span> style0 <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.vue?vue&#x26;type=style&#x26;index=0&#x26;id=2964abc9&#x26;scoped=true&#x26;lang=css&#x26;"</span>

<span class="hljs-comment">// 第二步，命中 pitcher，转换为：</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">"-!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&#x26;type=template&#x26;id=2964abc9&#x26;scoped=true&#x26;"</span>
<span class="hljs-keyword">import</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">"-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&#x26;type=script&#x26;lang=js&#x26;"</span>; 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> mod; <span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">"-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&#x26;type=script&#x26;lang=js&#x26;"</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">"-!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&#x26;type=style&#x26;index=0&#x26;id=2964abc9&#x26;scoped=true&#x26;lang=css&#x26;"</span>

<span class="hljs-comment">// 第三步，根据行内路径规则按序调用loader</span>
</code></pre>
<p>每一步的细节，请继续往下看。</p>
<blockquote>
<p>第一次执行 vue-loader</p>
</blockquote>
<p>在运行阶段，根据配置规则， Webpack 首先将原始的 SFC 内容传入 <code>vue-loader</code>，例如对于下面的代码：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> xx <span class="hljs-keyword">from</span> <span class="hljs-string">'index.vue'</span>;

<span class="hljs-comment">// index.vue 代码</span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">template</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"root"</span>></span>hello world<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">template</span>></span></span>

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {},
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"hello world"</span>);
  },
};
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>></span><span class="css">
<span class="hljs-selector-class">.root</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;
}
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">style</span>></span></span>
</code></pre>
<p>此时<strong>第一次</strong>执行 vue-loader ，执行如下逻辑：</p>
<ol>
<li>调用 <code>@vue/component-compiler-utils</code> 包的parse函数，将SFC 文本解析为AST对象；</li>
<li>遍历 AST 对象属性，转换为特殊的引用路径；</li>
<li>返回转换结果。</li>
</ol>
<p>对于上述 <code>index.vue</code> 内容，转换结果为：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { render, staticRenderFns } <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.vue?vue&#x26;type=template&#x26;id=2964abc9&#x26;scoped=true&#x26;"</span>
<span class="hljs-keyword">import</span> script <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.vue?vue&#x26;type=script&#x26;lang=js&#x26;"</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.vue?vue&#x26;type=script&#x26;lang=js&#x26;"</span>
<span class="hljs-keyword">import</span> style0 <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.vue?vue&#x26;type=style&#x26;index=0&#x26;id=2964abc9&#x26;scoped=true&#x26;lang=css&#x26;"</span>


<span class="hljs-comment">/* normalize component */</span>
<span class="hljs-keyword">import</span> normalizer <span class="hljs-keyword">from</span> <span class="hljs-string">"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js"</span>
<span class="hljs-keyword">var</span> component = <span class="hljs-title function_">normalizer</span>(
  script,
  render,
  staticRenderFns,
  <span class="hljs-literal">false</span>,
  <span class="hljs-literal">null</span>,
  <span class="hljs-string">"2964abc9"</span>,
  <span class="hljs-literal">null</span>
  
)

...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> component.<span class="hljs-property">exports</span>
</code></pre>
<p>注意，这里并没有真的处理 block 里面的内容，而是简单地针对不同类型的内容块生成 import 语句：</p>
<ul>
<li>Script：<code>"./index.vue?vue&#x26;type=script&#x26;lang=js&#x26;"</code></li>
<li>Template: <code>"./index.vue?vue&#x26;type=template&#x26;id=2964abc9&#x26;scoped=true&#x26;"</code></li>
<li>Style: <code>"./index.vue?vue&#x26;type=style&#x26;index=0&#x26;id=2964abc9&#x26;scoped=true&#x26;lang=css&#x26;"</code></li>
</ul>
<p>这些路径都对应原始的 <code>.vue</code> 路径基础上增加了 <code>vue</code> 标志符及 type、lang 等参数。</p>
<blockquote>
<p>执行 Pitch Loader</p>
</blockquote>
<p>如前所述，<code>vue-loader</code> 插件会在预处理阶段插入带 <code>resourceQuery</code> 函数的 Pitch Loader：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> pitcher = {
  <span class="hljs-attr">loader</span>: <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'./loaders/pitcher'</span>),
  <span class="hljs-attr">resourceQuery</span>: <span class="hljs-function"><span class="hljs-params">query</span> =></span> {
    <span class="hljs-keyword">if</span> (!query) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> }
    <span class="hljs-keyword">const</span> parsed = qs.<span class="hljs-title function_">parse</span>(query.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>))
    <span class="hljs-keyword">return</span> parsed.<span class="hljs-property">vue</span> != <span class="hljs-literal">null</span>
  }
}
</code></pre>
<p>其中， <code>resourceQuery</code> 函数命中 <code>xx.vue?vue</code> 格式的路径，也就是说上面 <code>vue-loader</code> 转换后的 import 路径会被 Pitch Loader 命中，做进一步处理。Pitch Loader 的逻辑比较简单，做的事情也只是转换 import 路径：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'querystring'</span>)
...

<span class="hljs-keyword">const</span> <span class="hljs-title function_">dedupeESLintLoader</span> = loaders => {...}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">shouldIgnoreCustomBlock</span> = loaders => {...}

<span class="hljs-comment">// 正常的loader阶段，直接返回结果</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function"><span class="hljs-params">code</span> =></span> code

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">pitch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">remainingRequest</span>) {
  <span class="hljs-keyword">const</span> options = loaderUtils.<span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>)
  <span class="hljs-keyword">const</span> { cacheDirectory, cacheIdentifier } = options
  <span class="hljs-comment">// 关注点1： 通过解析 resourceQuery 获取loader参数</span>
  <span class="hljs-keyword">const</span> query = qs.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">resourceQuery</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>))

  <span class="hljs-keyword">let</span> loaders = <span class="hljs-variable language_">this</span>.<span class="hljs-property">loaders</span>

  <span class="hljs-comment">// if this is a language block request, eslint-loader may get matched</span>
  <span class="hljs-comment">// multiple times</span>
  <span class="hljs-keyword">if</span> (query.<span class="hljs-property">type</span>) {
    <span class="hljs-comment">// if this is an inline block, since the whole file itself is being linted,</span>
    <span class="hljs-comment">// remove eslint-loader to avoid duplicate linting.</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\.vue$/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">resourcePath</span>)) {
      loaders = loaders.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">l</span> =></span> !<span class="hljs-title function_">isESLintLoader</span>(l))
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// This is a src import. Just make sure there's not more than 1 instance</span>
      <span class="hljs-comment">// of eslint present.</span>
      loaders = <span class="hljs-title function_">dedupeESLintLoader</span>(loaders)
    }
  }

  <span class="hljs-comment">// remove self</span>
  loaders = loaders.<span class="hljs-title function_">filter</span>(isPitcher)

  <span class="hljs-comment">// do not inject if user uses null-loader to void the type (#1239)</span>
  <span class="hljs-keyword">if</span> (loaders.<span class="hljs-title function_">some</span>(isNullLoader)) {
    <span class="hljs-keyword">return</span>
  }

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">genRequest</span> = loaders => {
    ... 
  }

  <span class="hljs-comment">// Inject style-post-loader before css-loader for scoped CSS and trimming</span>
  <span class="hljs-keyword">if</span> (query.<span class="hljs-property">type</span> === <span class="hljs-string">`style`</span>) {
    <span class="hljs-keyword">const</span> cssLoaderIndex = loaders.<span class="hljs-title function_">findIndex</span>(isCSSLoader)
    <span class="hljs-keyword">if</span> (cssLoaderIndex > -<span class="hljs-number">1</span>) {
      ...
      <span class="hljs-keyword">return</span> query.<span class="hljs-property">module</span>
        ? <span class="hljs-string">`export { default } from  <span class="hljs-subst">${request}</span>; export * from <span class="hljs-subst">${request}</span>`</span>
        : <span class="hljs-string">`export * from <span class="hljs-subst">${request}</span>`</span>
    }
  }

  <span class="hljs-comment">// for templates: inject the template compiler &#x26; optional cache</span>
  <span class="hljs-keyword">if</span> (query.<span class="hljs-property">type</span> === <span class="hljs-string">`template`</span>) {
    .​..
    <span class="hljs-comment">// console.log(request)</span>
    <span class="hljs-comment">// the template compiler uses esm exports</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">`export * from <span class="hljs-subst">${request}</span>`</span>
  }

  <span class="hljs-comment">// if a custom block has no other matching loader other than vue-loader itself</span>
  <span class="hljs-comment">// or cache-loader, we should ignore it</span>
  <span class="hljs-keyword">if</span> (query.<span class="hljs-property">type</span> === <span class="hljs-string">`custom`</span> &#x26;&#x26; <span class="hljs-title function_">shouldIgnoreCustomBlock</span>(loaders)) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">``</span>
  }

  <span class="hljs-keyword">const</span> request = <span class="hljs-title function_">genRequest</span>(loaders)
  <span class="hljs-keyword">return</span> <span class="hljs-string">`import mod from <span class="hljs-subst">${request}</span>; export default mod; export * from <span class="hljs-subst">${request}</span>`</span>
}
</code></pre>
<p>核心功能是遍历用户定义的rule数组，拼接出完整的行内引用路径，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 开发代码：</span>
<span class="hljs-keyword">import</span> xx <span class="hljs-keyword">from</span> <span class="hljs-string">'index.vue'</span>
<span class="hljs-comment">// 第一步，通过vue-loader转换成带参数的路径</span>
<span class="hljs-keyword">import</span> script <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.vue?vue&#x26;type=script&#x26;lang=js&#x26;"</span>
<span class="hljs-comment">// 第二步，在 pitcher 中解读loader数组的配置，并将路径转换成完整的行内路径格式</span>
<span class="hljs-keyword">import</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">"-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&#x26;type=script&#x26;lang=js&#x26;"</span>;
</code></pre>
<blockquote>
<p>第二次执行vue-loader</p>
</blockquote>
<p>通过上面 <code>vue-loader</code> -> Pitch Loader 处理后，会得到一个新的行内路径，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">"-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&#x26;type=script&#x26;lang=js&#x26;"</span>;
</code></pre>
<p>以这个 import 语句为例，之后 Webpack 会按照下述逻辑运行：</p>
<ul>
<li>调用 <code>vue-loader</code> 处理 <code>index.js</code> 文件；</li>
<li>调用 <code>babel-loader</code> 处理上一步返回的内容。</li>
</ul>
<p>这就给了 <code>vue-loader</code> 第二次执行的机会，再回过头来看看 <code>vue-loader</code> 的代码：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) {
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">const</span> {
    target,
    request,
    minimize,
    sourceMap,
    rootContext,
    resourcePath,
    resourceQuery = <span class="hljs-string">""</span>,
  } = loaderContext;
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">const</span> descriptor = <span class="hljs-title function_">parse</span>({
    source,
    <span class="hljs-attr">compiler</span>: options.<span class="hljs-property">compiler</span> || <span class="hljs-title function_">loadTemplateCompiler</span>(loaderContext),
    filename,
    sourceRoot,
    <span class="hljs-attr">needMap</span>: sourceMap,
  });

  <span class="hljs-comment">// if the query has a type field, this is a language block request</span>
  <span class="hljs-comment">// e.g. foo.vue?type=template&#x26;id=xxxxx</span>
  <span class="hljs-comment">// and we will return early</span>
  <span class="hljs-keyword">if</span> (incomingQuery.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">selectBlock</span>(
      descriptor,
      loaderContext,
      incomingQuery,
      !!options.<span class="hljs-property">appendExtension</span>
    );
  }
  <span class="hljs-comment">//...</span>
  <span class="hljs-keyword">return</span> code;
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">VueLoaderPlugin</span> = plugin;
</code></pre>
<p>第二次运行时由于路径已经带上了 <code>type</code> 参数，会命中上面第26行的判断语句，进入 <code>selectBlock</code> 函数，这个函数的逻辑很简单：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">selectBlock</span> (
  descriptor,
  loaderContext,
  query,
  appendExtension
) {
  <span class="hljs-comment">// template</span>
  <span class="hljs-keyword">if</span> (query.<span class="hljs-property">type</span> === <span class="hljs-string">`template`</span>) {
    <span class="hljs-keyword">if</span> (appendExtension) {
      loaderContext.<span class="hljs-property">resourcePath</span> += <span class="hljs-string">'.'</span> + (descriptor.<span class="hljs-property">template</span>.<span class="hljs-property">lang</span> || <span class="hljs-string">'html'</span>)
    }
    loaderContext.<span class="hljs-title function_">callback</span>(
      <span class="hljs-literal">null</span>,
      descriptor.<span class="hljs-property">template</span>.<span class="hljs-property">content</span>,
      descriptor.<span class="hljs-property">template</span>.<span class="hljs-property">map</span>
    )
    <span class="hljs-keyword">return</span>
  }

  <span class="hljs-comment">// script</span>
  <span class="hljs-keyword">if</span> (query.<span class="hljs-property">type</span> === <span class="hljs-string">`script`</span>) {
    <span class="hljs-keyword">if</span> (appendExtension) {
      loaderContext.<span class="hljs-property">resourcePath</span> += <span class="hljs-string">'.'</span> + (descriptor.<span class="hljs-property">script</span>.<span class="hljs-property">lang</span> || <span class="hljs-string">'js'</span>)
    }
    loaderContext.<span class="hljs-title function_">callback</span>(
      <span class="hljs-literal">null</span>,
      descriptor.<span class="hljs-property">script</span>.<span class="hljs-property">content</span>,
      descriptor.<span class="hljs-property">script</span>.<span class="hljs-property">map</span>
    )
    <span class="hljs-keyword">return</span>
  }

  <span class="hljs-comment">// styles</span>
  <span class="hljs-keyword">if</span> (query.<span class="hljs-property">type</span> === <span class="hljs-string">`style`</span> &#x26;&#x26; query.<span class="hljs-property">index</span> != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> style = descriptor.<span class="hljs-property">styles</span>[query.<span class="hljs-property">index</span>]
    <span class="hljs-keyword">if</span> (appendExtension) {
      loaderContext.<span class="hljs-property">resourcePath</span> += <span class="hljs-string">'.'</span> + (style.<span class="hljs-property">lang</span> || <span class="hljs-string">'css'</span>)
    }
    loaderContext.<span class="hljs-title function_">callback</span>(
      <span class="hljs-literal">null</span>,
      style.<span class="hljs-property">content</span>,
      style.<span class="hljs-property">map</span>
    )
    <span class="hljs-keyword">return</span>
  }

  <span class="hljs-comment">// custom</span>
  <span class="hljs-keyword">if</span> (query.<span class="hljs-property">type</span> === <span class="hljs-string">'custom'</span> &#x26;&#x26; query.<span class="hljs-property">index</span> != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> block = descriptor.<span class="hljs-property">customBlocks</span>[query.<span class="hljs-property">index</span>]
    loaderContext.<span class="hljs-title function_">callback</span>(
      <span class="hljs-literal">null</span>,
      block.<span class="hljs-property">content</span>,
      block.<span class="hljs-property">map</span>
    )
    <span class="hljs-keyword">return</span>
  }
}
</code></pre>
<p>至此，就可以完成从 Vue SFC 文件中抽取特定 Block 内容，并复用用户定义的其它 Loader 加载这些 Block。</p>
<h3>小结</h3>
<p>综上，我们可以将 <code>vue-loader</code> 的核心逻辑总结为：</p>
<ol>
<li>首先给原始文件路径增加不同的参数，后续配合 <code>resourceQuery</code> 参数就可以分开处理这些内容，这样的实现相比于一次性处理，逻辑更清晰简洁，更容易理解；</li>
<li>经过 Normal Loader、Pitch Loader 两个阶段后，SFC 内容会被转化为 <code>import xxx from '!-babel-loader!vue-loader?xxx'</code> 格式的引用路径，以此复用用户配置。</li>
</ol>
<h2>总结</h2>
<p>本文主要介绍如何使用 <code>schema-utils</code> 与 <code>loader-utils</code> 工具实现更多 Loader 进阶特性，并进一步剖析 <code>vue-loader</code> 源码，讲解如何构建一个成熟的 Webpack Loader 组件。结合《<a href="https://juejin.cn/book/7115598540721618944/section/7119035404715556879" target="_blank" rel="nofollow noopener noreferrer">Loader 开发基础：从开源项目学到的 Loader 开发技巧</a>》一文，我们可以总结一些常用的开发方法论，包括：</p>
<ul>
<li>Loader 主要负责将资源内容转译为 Webpack 能够理解、处理的标准 JavaScript 形式，所以通常需要做 Loader 内通过 <code>return</code>/<code>this.callback</code> 方式返回翻译结果；</li>
<li>Loader Context 提供了许多实用接口，我们可以借助这些接口读取上下文信息，或改变 Webpack 运行状态(相当于产生 Side Effect，例如通过 <code>emitFile</code> 接口)；</li>
<li>假若我们开发的 Loader 需要对外提供配置选项，建议使用 <code>schema-utils</code> 校验配置参数是否合法；</li>
<li>假若 Loader 需要生成额外的资源文件，建议使用 <code>loader-utils</code> 拼接产物路径；</li>
<li>执行时，Webpack 会按照 <code>use</code> 定义的顺序从前到后执行 Pitch Loader，从后到前执行 Normal Loader，我们可以将一些预处理逻辑放在 Pitch 中(如 <code>vue-loader</code>)；</li>
<li>等等。</li>
</ul>
<p>最后，建议你同步翻阅一些知名 Loader 的源码(如：css-loader/babel-loader/file-loader 等)，结合这两篇文章介绍的知识点与方法论，透彻理解 Webpack Loader 的开发方式。</p>
<h2>思考题</h2>
<p>总结一下，<code>vue-loader</code> 中的 Pitch Loader 与 Normal Loader 分别做了什么事情？两者是怎么串联协作起来的？</p></div>
</body></html>