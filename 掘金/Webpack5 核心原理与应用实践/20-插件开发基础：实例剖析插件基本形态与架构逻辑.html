<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>插件开发基础：实例剖析插件基本形态与架构逻辑</h1>
<p>Webpack 对外提供了 Loader 与 Plugin 两种扩展方式，其中 Loader 职责比较单一，开发方法比较简单容易理解；Plugin 则功能强大，借助 Webpack 数量庞大的 Hook，我们几乎能改写 Webpack 所有特性，但也伴随着巨大的开发复杂度。</p>
<p>学习如何开发 Webpack 插件并不是一件简单的事情，所以我打算用 3 个连续的章节，力求足够全面地剖析如何开发一款成熟、稳定的插件。本文将聚焦在插件代码形态、插件架构、Hook 与上下文参数等内容，同时深入剖析若干常用插件的实现原理，帮你构建起关于 Webpack 插件开发的基本认知。</p>
<h2>插件简介</h2>
<p>从形态上看，插件通常是一个带有 <code>apply</code> 函数的类，如：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePlugin</span> {
    <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    }
}
</code></pre>
<p>Webpack 在启动时会调用插件对象的 <code>apply</code> 函数，并以参数方式传递核心对象 <code>compiler</code> ，以此为起点，插件内可以注册 <code>compiler</code> 对象及其子对象的钩子(<a href="https://webpack.js.org/api/plugins/" target="_blank" rel="nofollow noopener noreferrer">Hook</a>)回调，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePlugin</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">thisCompilation</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"SomePlugin"</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =></span> {
      compilation.<span class="hljs-title function_">addModule</span>(<span class="hljs-comment">/* ... */</span>);
    });
  }
}
</code></pre>
<p>示例中的 <code>compiler</code> 为 Hook 挂载的对象；<code>thisCompilation</code> 为 Hook 名称；后面调用的 <code>tap</code> 为调用方式，支持 <code>tap/tapAsync/tapPromise</code> 等，后面章节会展开细讲。</p>
<p>在 Webpack 运行过程中，随着构建流程的推进会触发各个钩子回调，并传入上下文参数(例如上例回调函数中的 <code>compilation</code> 对象)，插件可以通过调用上下文接口、修改上下文状态等方式「篡改」构建逻辑，从而将扩展代码「勾入」到 Webpack 构建流程中。</p>
<blockquote>
<p>提示：网上不少资料将 Webpack 的插件架构归类为“事件/订阅”模式，我认为这种归纳有失偏颇。订阅模式是一种<strong>松散耦合结构</strong>，发布器只是在特定时机发布事件消息，订阅者并不或者很少与事件源直接发生交互。</p>
</blockquote>
<p>基于 Hook 这一设计，开发插件时我们需要重点关注两个问题：</p>
<ol>
<li>针对插件需求，我们应该使用什么钩子？</li>
<li>选定钩子后，我怎么跟上下文参数交互？</li>
</ol>
<blockquote>
<p>什么时候会触发什么钩子：</p>
</blockquote>
<p>Webpack5 暴露了多达 200+ 个 Hook，基本上覆盖了整个构建流程的所有环节 —— 这也就意味着通过编写插件，我们几乎可以改写 Webpack 的所有执行逻辑。问题是，我们在什么情况下该用什么钩子？这就需要了解 Webpack 内部几个核心对象，以及各对象下 Hook 的触发时机，例如：</p>
<ul>
<li><a href="https://webpack.js.org/api/compiler-hooks/" target="_blank" rel="nofollow noopener noreferrer">Compiler</a>：全局构建管理器，Webpack 启动后会首先创建 <code>compiler</code> 对象，负责管理配置信息、Loader、Plugin 等。从启动构建到结束，<code>compiler</code> 大致上会触发如下钩子：</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/407f8596a5b24203b091a51b5fca6726~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<ul>
<li><a href="https://webpack.js.org/api/compilation-hooks/" target="_blank" rel="nofollow noopener noreferrer">Compilation</a>：单次构建过程的管理器，负责遍历模块，执行编译操作；当 <code>watch = true</code> 时，每次文件变更触发重新编译，都会创建一个新的 <code>compilation</code> 对象；<code>compilation</code> 生命周期中主要触发如下钩子：</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08c337e97f664f3da4d301a3a5404f7d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<ul>
<li>此外，还有 <a href="https://webpack.js.org/api/normalmodulefactory-hooks/" target="_blank" rel="nofollow noopener noreferrer">Module</a>、Resolver、<a href="https://webpack.js.org/api/parser/" target="_blank" rel="nofollow noopener noreferrer">Parser</a>、Generator 等关键类型，也都相应暴露了许多 Hook。</li>
</ul>
<p>由此可见，Webpack Hook 与构建流程强相关，使用时你结合上面流程图分析 Hook 对应的流程环节，以及这个环节主要完成了什么工作，可以借助 Hook 做出哪些修改，等等。</p>
<blockquote>
<p>使用 Hook 上下文接口：</p>
</blockquote>
<p>Webpack Hook 有两个重点，一是上面介绍的触发时机；二是触发时传递的上下文参数。例如：</p>
<ul>
<li><code>compiler.hooks.compilation</code> ：
<ul>
<li>时机：Webpack 刚启动完，创建出 <code>compilation</code> 对象后触发；</li>
<li>参数：当前编译的 <code>compilation</code> 对象。</li>
</ul>
</li>
<li><code>compiler.hooks.make</code>：
<ul>
<li>时机：正式开始构建时触发；</li>
<li>参数：同样是当前编译的 <code>compilation</code> 对象。</li>
</ul>
</li>
<li><code>compilation.hooks.optimizeChunks</code> ：
<ul>
<li>时机： <code>seal</code> 函数中，<code>chunk</code> 集合构建完毕后触发；</li>
<li>参数：<code>chunks</code> 集合与 <code>chunkGroups</code> 集合。</li>
</ul>
</li>
<li><code>compiler.hooks.done</code>：
<ul>
<li>时机：编译完成后触发；</li>
<li>参数： <code>stats</code> 对象，包含编译过程中的各类统计信息。</li>
</ul>
</li>
</ul>
<p>每个钩子传递的上下文参数不同，但主要包含如下几种类型(以 Webpack5 为例)：</p>
<ul>
<li><a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js" target="_blank" rel="nofollow noopener noreferrer">complation</a> 对象：构建管理器，使用率非常高，主要提供了一系列与单次构建相关的接口，包括：
<ul>
<li><code>addModule</code>：用于添加模块，例如 Module 遍历出依赖之后，就会调用该接口将新模块添加到构建需求中；</li>
<li><code>addEntry</code>：添加新的入口模块，效果与直接定义 <code>entry</code> 配置相似；</li>
<li><code>emitAsset</code>：用于添加产物文件，效果与 Loader Context 的 <code>emitAsset</code> 相同；</li>
<li><code>getDependencyReference</code>：从给定模块返回对依赖项的引用，常用于计算模块引用关系；</li>
<li>等等。</li>
</ul>
</li>
<li><a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/Compiler.js" target="_blank" rel="nofollow noopener noreferrer">compiler</a> 对象：全局构建管理器，提供如下接口：
<ul>
<li><code>createChildCompiler</code>：创建子 <code>compiler</code> 对象，子对象将继承原始 Compiler 对象的所有配置数据；</li>
<li><code>createCompilation</code>：创建 <code>compilation</code> 对象，可以借此实现并行编译；</li>
<li><code>close</code>：结束编译；</li>
<li><code>getCache</code>：获取缓存接口，可借此复用 Webpack5 的缓存功能；</li>
<li><code>getInfrastructureLogger</code>：获取<a href="https://webpack.js.org/configuration/other-options/#infrastructurelogging" target="_blank" rel="nofollow noopener noreferrer">日志对象</a>；</li>
<li>等等。</li>
</ul>
</li>
<li><a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/NormalModule.js" target="_blank" rel="nofollow noopener noreferrer">module</a> 对象：资源模块，有诸如 <code>NormalModule/RawModule/ContextModule</code> 等子类型，其中 <code>NormalModule</code> 使用频率较高，提供如下接口：
<ul>
<li><code>identifier</code>：读取模块的唯一标识符；</li>
<li><code>getCurrentLoader</code>：获取当前正在执行的 Loader 对象；</li>
<li><code>originalSource</code>：读取模块原始内容；</li>
<li><code>serialize/deserialize</code>：模块序列化与反序列化函数，用于实现持久化缓存，一般不需要调用；</li>
<li><code>issuer</code>：模块的引用者；</li>
<li><code>isEntryModule</code>：用于判断该模块是否为入口文件；</li>
<li>等等。</li>
</ul>
</li>
<li><a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/Chunk.js" target="_blank" rel="nofollow noopener noreferrer">chunk</a> 对象：模块封装容器，提供如下接口：
<ul>
<li><code>addModule</code>：添加模块，之后该模块会与 Chunk 中其它模块一起打包，生成最终产物；</li>
<li><code>removeModule</code>：删除模块；</li>
<li><code>containsModule</code>：判断是否包含某个特定模块；</li>
<li><code>size</code>：推断最终构建出的产物大小；</li>
<li><code>hasRuntime</code>：判断 Chunk 中是否包含运行时代码；</li>
<li><code>updateHash</code>：计算 Hash 值。</li>
</ul>
</li>
<li><a href="https://webpack.js.org/api/stats/" target="_blank" rel="nofollow noopener noreferrer">stats</a> 对象：构建过程收集到的统计信息，包括模块构建耗时、模块依赖关系、产物文件列表等。</li>
</ul>
<blockquote>
<p>提示：无论官网还是社区，我都没有找到完整介绍这些对象的，足够好、足够完备的文档，且 Webpack 本身还在不断升级迭代，许多内部对象的接口并不稳定，建议读者使用时直接翻阅相关版本源码。</p>
</blockquote>
<p>篇幅关系，我们只对部分重要接口做了简单介绍，后面我还会讲解各种常用插件源码，展开介绍部分常见接口的使用方法。</p>
<blockquote>
<p>小结</p>
</blockquote>
<p>总结一下，Webpack 的插件体系与平常所见的 <code>订阅/发布</code> 模式差别很大，是一种非常强耦合的设计，Hook 回调由 Webpack 决定何时，以何种方式执行；而在 Hook 回调内部可以通过调用上下文 API 、修改上下文状态等方式，对 Webpack 原定流程产生 Side Effect。</p>
<p>所以想熟练编写插件，需要深入理解常见 Hook 调用时机，以及各类上下文参数的用法，这方面没有太多学习资料，我建议直接翻阅相关开源插件源码，下面我会抽几个比较经典、逻辑简单、容易理解的插件，剖析如何灵活使用 Hook。</p>
<h2>实例剖析：<code>imagemin-webpack-plugin</code></h2>
<blockquote>
<p>学习如何遍历、修改最终产物文件</p>
</blockquote>
<p><a href="https://github1s.com/Klathmon/imagemin-webpack-plugin" target="_blank" rel="nofollow noopener noreferrer">imagemin-webpack-plugin</a> 是一个用于实现图像压缩的插件，它会在 Webpack 完成前置的代码分析构建，提交(<a href="https://webpack.js.org/api/compiler-hooks/#emit" target="_blank" rel="nofollow noopener noreferrer">emit</a>)产物时，找出所有图片资源并调用 <a href="https://github.com/imagemin/imagemin" target="_blank" rel="nofollow noopener noreferrer">imagemin</a> 压缩图像。核心逻辑：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageminPlugin</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options = {}</span>) {
    <span class="hljs-comment">// init options</span>
  }

  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onEmit</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">compilation, callback</span>) => {
      <span class="hljs-comment">// ...</span>
      <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
        ...<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">optimizeWebpackImages</span>(throttle, compilation),
        ...<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">optimizeExternalImages</span>(throttle),
      ]);
    };

    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>, onEmit);
  }

  <span class="hljs-title function_">optimizeWebpackImages</span>(<span class="hljs-params">throttle, compilation</span>) {}

  <span class="hljs-title function_">optimizeExternalImages</span>(<span class="hljs-params">throttle</span>) {}
}
</code></pre>
<p>上述代码主要用到 <code>compiler.hooks.emit</code> 钩子，该钩子在 Webpack 完成代码构建与打包操作，准备将产物发送到输出目录之前执行，我们可以在此修改产物内容，如上例 <code>optimizeWebpackImages</code> 函数：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageminPlugin</span> {
  <span class="hljs-title function_">optimizeWebpackImages</span>(<span class="hljs-params">throttle, compilation</span>) {
    <span class="hljs-keyword">const</span> {
        <span class="hljs-comment">// 用于判断是否对特定文件做图像压缩操作</span>
        testFunction,
        <span class="hljs-comment">// 缓存目录</span>
        cacheFolder
      } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>
  
    <span class="hljs-comment">// 遍历 `assets` 产物数组</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">map</span>(compilation.<span class="hljs-property">assets</span>, <span class="hljs-function">(<span class="hljs-params">asset, filename</span>) =></span> <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">async</span> () => {
        <span class="hljs-comment">// 读取产物内容</span>
        <span class="hljs-keyword">const</span> assetSource = asset.<span class="hljs-title function_">source</span>()
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">testFunction</span>(filename, assetSource)) {
          <span class="hljs-comment">// 尝试从缓存中读取</span>
          <span class="hljs-keyword">let</span> optimizedImageBuffer = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getFromCacheIfPossible</span>(cacheFolder, assetSource, <span class="hljs-function">() =></span> {
            <span class="hljs-comment">// 调用 `imagemin` 压缩图片</span>
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">optimizeImage</span>(assetSource, <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>)
          })
  
          <span class="hljs-comment">// 之后，使用优化版本替换原始文件</span>
          compilation.<span class="hljs-property">assets</span>[filename] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RawSource</span>(optimizedImageBuffer)
        }
      }))
  }
}
</code></pre>
<p>这里面的关键逻辑是：</p>
<ol>
<li>遍历 <code>compilation.assets</code> 产物列表，调用 <code>asset.source()</code> 方法读取产物内容；</li>
<li>调用 <code>imagemin</code> 压缩图片；</li>
<li>修改 <code>compilation.assets</code>，使用优化后的图片 <code>RawSource</code> 对象替换原始 <code>asset</code> 对象。</li>
</ol>
<p>至此完成文件压缩操作。</p>
<blockquote>
<p>提示：<code>Source</code> 是 Webpack 内代表资源内容的类，由 <a href="https://github1s.com/webpack/webpack-sources/blob/HEAD/lib/index.js" target="_blank" rel="nofollow noopener noreferrer">webpack-source</a> 库实现，支持 <code>RawSource/ConcatSource</code> 等子类型，用于实现文件读写、合并、修改、Sourcemap 等操作。</p>
</blockquote>
<h2>实例剖析：<code>eslint-webpack-plugin</code></h2>
<blockquote>
<p>学习如何提交错误日志</p>
</blockquote>
<p><a href="https://github1s.com/webpack-contrib/eslint-webpack-plugin" target="_blank" rel="nofollow noopener noreferrer">eslint-webpack-plugin</a> 是一个基于 ESLint 实现的代码风格检查插件，它的实现比较巧妙，一是使用多个 Hook，在不同时间点执行 Lint 检查；二是复用 Webpack 内置的 <code>error/warn</code> 方法提交代码风格问题。核心逻辑：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ESLintWebpackPlugin</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options = {}</span>) {
    <span class="hljs-comment">// ...</span>
  }

  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">run</span>.<span class="hljs-title function_">tapPromise</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span>, <span class="hljs-function">(<span class="hljs-params">c</span>) =></span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">run</span>(c, options, wanted, exclude)
    );
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">compiler, options, wanted, exclude</span>) {
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compilation</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =></span> {
      ({ lint, report, threads } = <span class="hljs-title function_">linter</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span>, options, compilation));

      <span class="hljs-keyword">const</span> files = [];

      <span class="hljs-comment">// 单个模块成功编译后触发</span>
      compilation.<span class="hljs-property">hooks</span>.<span class="hljs-property">succeedModule</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span>, <span class="hljs-function">(<span class="hljs-params">{ resource }</span>) =></span> {
        <span class="hljs-comment">// 判断是否需要检查该文件</span>
        <span class="hljs-keyword">if</span> (
          <span class="hljs-title function_">isMatch</span>(file, wanted, { <span class="hljs-attr">dot</span>: <span class="hljs-literal">true</span> }) &#x26;&#x26;
          !<span class="hljs-title function_">isMatch</span>(file, exclude, { <span class="hljs-attr">dot</span>: <span class="hljs-literal">true</span> })
        ) {
          <span class="hljs-title function_">lint</span>(file);
        }
      });

      <span class="hljs-comment">// 所有模块构建完毕后触发</span>
      compilation.<span class="hljs-property">hooks</span>.<span class="hljs-property">finishModules</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span>, <span class="hljs-function">() =></span> {
        <span class="hljs-keyword">if</span> (files.<span class="hljs-property">length</span> > <span class="hljs-number">0</span> &#x26;&#x26; threads &#x3C;= <span class="hljs-number">1</span>) {
          <span class="hljs-title function_">lint</span>(files);
        }
      });

      <span class="hljs-comment">// 等待检查结果</span>
      compilation.<span class="hljs-property">hooks</span>.<span class="hljs-property">additionalAssets</span>.<span class="hljs-title function_">tapPromise</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span>, processResults);

      <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processResults</span>(<span class="hljs-params"></span>) {}
    });
  }
}
</code></pre>
<p>代码用到如下 Hook：</p>
<ul>
<li><code>compiler.hooks.compilation</code>：Compiler 环境初始化完毕，创建出 <code>compilation</code> 对象，准备开始执行构建前触发；</li>
<li><code>compilation.hooks.succeedModule</code>：Webpack 完成单个「模块」的读入、运行 Loader、AST 分析、依赖分析等操作后触发；</li>
<li><code>compilation.hooks.finishModules</code>：Webpack 完成「所有」模块的读入、运行 Loader、依赖分析等操作后触发；</li>
<li><code>compilation.hooks.additionalAssets</code>：构建、打包完毕后触发，通常用于为编译创建附加资产。</li>
</ul>
<p>其中，比较重要的是借助 <code>compilation.hooks.succeedModule</code> 钩子，在每个模块处理完毕之后立即通过 <code>lint</code> 函数添加非阻塞代码检查任务，相比于过去的 <a href="https://www.npmjs.com/package/eslint-loader" target="_blank" rel="nofollow noopener noreferrer">eslint-loader</a> 的阻塞式执行，这种方式能够提高 ESLint 的并发度，效率更高。</p>
<p>其次，借助 <code>compilation.hooks.additionalAssets</code> 钩子，在所有模块处理完毕后读取检查结果 —— 即 <code>processResults</code> 函数，核心代码：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processResults</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> { errors, warnings } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">report</span>();

  <span class="hljs-keyword">if</span> (warnings &#x26;&#x26; !options.<span class="hljs-property">failOnWarning</span>) {
    compilation.<span class="hljs-property">warnings</span>.<span class="hljs-title function_">push</span>(warnings);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (warnings &#x26;&#x26; options.<span class="hljs-property">failOnWarning</span>) {
    compilation.<span class="hljs-property">errors</span>.<span class="hljs-title function_">push</span>(warnings);
  }

  <span class="hljs-keyword">if</span> (errors &#x26;&#x26; options.<span class="hljs-property">failOnError</span>) {
    compilation.<span class="hljs-property">errors</span>.<span class="hljs-title function_">push</span>(errors);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (errors &#x26;&#x26; !options.<span class="hljs-property">failOnError</span>) {
    compilation.<span class="hljs-property">warnings</span>.<span class="hljs-title function_">push</span>(errors);
  }
}
</code></pre>
<p>代码读取 ESLint 执行结果(<code>report</code> 函数)，并使用 <code>compilation</code> 的 <code>errors</code> 与 <code>warnings</code> 数组提交错误/警告信息，这种方式只会输出错误信息，不会中断编译流程，运行效果如：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ad70295b2214f3ebb77b9024d41ae1f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>实例剖析：<code>DefinePlugin</code></h2>
<blockquote>
<p>学习在插件中如何与 AST 结构交互</p>
</blockquote>
<p><a href="https://github1s.com/webpack/webpack" target="_blank" rel="nofollow noopener noreferrer">DefinePlugin</a> 是 Webpack 官方实现的，用于构建时注入预定义常量的插件，先简单回顾一下<a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="nofollow noopener noreferrer">用法</a>，如：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">DefinePlugin</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"webpack"</span>);

<span class="hljs-keyword">const</span> baseConfig = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefinePlugin</span>({
      <span class="hljs-attr">PROD</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">VERSION</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">"12.13.0"</span>),
    }),
  ],
};
</code></pre>
<p>之后，Webpack 会帮我们替换掉代码中所有 <code>DefinePlugin</code> 声明的属性值，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 源码：</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable constant_">PROD</span>, <span class="hljs-variable constant_">VERSION</span>);

<span class="hljs-comment">// 构建结果：</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">"5fa3b9"</span>);
</code></pre>
<p><code>DefinePlugin</code> 的 <a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/DefinePlugin.js" target="_blank" rel="nofollow noopener noreferrer">底层实现</a> 比较复杂，需要遍历 AST 找出变量名对应的代码位置之后再做替换，插件核心结构：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefinePlugin</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compilation</span>.<span class="hljs-title function_">tap</span>(
      <span class="hljs-string">"DefinePlugin"</span>,
      <span class="hljs-function">(<span class="hljs-params">compilation, { normalModuleFactory }</span>) =></span> {
        <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">parser</span>) => {
          <span class="hljs-comment">// 递归处理 `DefinePlugin` 参数</span>
          <span class="hljs-keyword">const</span> <span class="hljs-title function_">walkDefinitions</span> = (<span class="hljs-params">definitions, prefix</span>) => {
            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(definitions).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =></span> {
              <span class="hljs-keyword">const</span> code = definitions[key];
              <span class="hljs-keyword">if</span> (isObject <span class="hljs-comment">/*...*/</span>) {
                <span class="hljs-comment">// 递归处理对象属性</span>
                <span class="hljs-title function_">walkDefinitions</span>(code, prefix + key + <span class="hljs-string">"."</span>);
                <span class="hljs-title function_">applyObjectDefine</span>(prefix + key, code);
                <span class="hljs-keyword">return</span>;
              }
              <span class="hljs-title function_">applyDefineKey</span>(prefix, key);
              <span class="hljs-title function_">applyDefine</span>(prefix + key, code);
            });
          };

          <span class="hljs-comment">// 替换基本类型的表达式值</span>
          <span class="hljs-keyword">const</span> <span class="hljs-title function_">applyDefine</span> = (<span class="hljs-params">key, code</span>) => {
            <span class="hljs-keyword">if</span> (!isTypeof) {
              <span class="hljs-comment">// 借助 expression 钩子替换内容</span>
              parser.<span class="hljs-property">hooks</span>.<span class="hljs-property">expression</span>.<span class="hljs-title function_">for</span>(key).<span class="hljs-title function_">tap</span>(<span class="hljs-string">"DefinePlugin"</span>, <span class="hljs-function">(<span class="hljs-params">expr</span>) =></span> {
                <span class="hljs-comment">/*...*/</span>
              });
            }
            <span class="hljs-comment">// 处理 `'typeof window': JSON.stringify('object'),` 场景</span>
            parser.<span class="hljs-property">hooks</span>.<span class="hljs-property">typeof</span>.<span class="hljs-title function_">for</span>(key).<span class="hljs-title function_">tap</span>(<span class="hljs-string">"DefinePlugin"</span>, <span class="hljs-function">(<span class="hljs-params">expr</span>) =></span> {
              <span class="hljs-comment">/*...*/</span>
            });
          };

          <span class="hljs-comment">// 替换引用类型的表达式值</span>
          <span class="hljs-keyword">const</span> <span class="hljs-title function_">applyObjectDefine</span> = (<span class="hljs-params">key, obj</span>) => {
            <span class="hljs-comment">// ...</span>
            parser.<span class="hljs-property">hooks</span>.<span class="hljs-property">expression</span>.<span class="hljs-title function_">for</span>(key).<span class="hljs-title function_">tap</span>(<span class="hljs-string">"DefinePlugin"</span>, <span class="hljs-function">(<span class="hljs-params">expr</span>) =></span> {
              <span class="hljs-comment">/*...*/</span>
            });
          };

          <span class="hljs-title function_">walkDefinitions</span>(definitions, <span class="hljs-string">""</span>);
        };

        <span class="hljs-comment">// 监听 `parser` 钩子</span>
        normalModuleFactory.<span class="hljs-property">hooks</span>.<span class="hljs-property">parser</span>
          .<span class="hljs-title function_">for</span>(<span class="hljs-string">"javascript/auto"</span>)
          .<span class="hljs-title function_">tap</span>(<span class="hljs-string">"DefinePlugin"</span>, handler);
        normalModuleFactory.<span class="hljs-property">hooks</span>.<span class="hljs-property">parser</span>
          .<span class="hljs-title function_">for</span>(<span class="hljs-string">"javascript/dynamic"</span>)
          .<span class="hljs-title function_">tap</span>(<span class="hljs-string">"DefinePlugin"</span>, handler);
        normalModuleFactory.<span class="hljs-property">hooks</span>.<span class="hljs-property">parser</span>
          .<span class="hljs-title function_">for</span>(<span class="hljs-string">"javascript/esm"</span>)
          .<span class="hljs-title function_">tap</span>(<span class="hljs-string">"DefinePlugin"</span>, handler);
      }
    );
  }
}
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">DefinePlugin</span>;
</code></pre>
<blockquote>
<p>提示：可能有同学注意到，上例代码中出现 <code>xxx.hooks.xxx.for(condition).tap</code> 形式的调用，这里的 <code>for</code> 函数可以理解为 Hook 的过滤条件，仅在满足 <code>condition</code> 时触发，后面章节会详细讲解。</p>
</blockquote>
<p>核心逻辑：</p>
<ol>
<li>使用 <code>normalModuleFactory.hooks.parser</code> 钩子(上例 48 行)，在 Webpack 创建出代码解析器 <code>Parser</code> 对象后执行 <code>handler</code> 函数。注意，此时还没有执行代码转 AST 操作；</li>
<li><code>walkDefinitions</code> 函数中递归遍历 <code>DefinePlugin</code> 参数对象，为每一个属性注册 <code>parser.hooks.expression</code> 钩子回调，该钩子会在 Webpack 遍历 AST 过程遇到表达式语句时触发；</li>
<li>在 <code>parser.hooks.expression</code> 回调中创建新的 <code>Dependency</code> 对象，调用 <a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/Module.js#L494" target="_blank" rel="nofollow noopener noreferrer">addPresentationalDependency</a> 添加为模块依赖：</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">toConstantDependency</span> = (<span class="hljs-params">parser, value, runtimeRequirements</span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">constDependency</span>(<span class="hljs-params">expr</span>) {
    <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstDependency</span>(value, expr.<span class="hljs-property">range</span>, runtimeRequirements);
    dep.<span class="hljs-property">loc</span> = expr.<span class="hljs-property">loc</span>;
    <span class="hljs-comment">// 创建静态依赖对象，替换 loc 指定位置内容</span>
    parser.<span class="hljs-property">state</span>.<span class="hljs-property">module</span>.<span class="hljs-title function_">addPresentationalDependency</span>(dep);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">applyDefine</span> = (<span class="hljs-params">key, code</span>) => {
  parser.<span class="hljs-property">hooks</span>.<span class="hljs-property">expression</span>.<span class="hljs-title function_">for</span>(key).<span class="hljs-title function_">tap</span>(<span class="hljs-string">"DefinePlugin"</span>, <span class="hljs-function">(<span class="hljs-params">expr</span>) =></span> {
    <span class="hljs-keyword">const</span> strCode = <span class="hljs-title function_">toCode</span>(<span class="hljs-comment">/*...*/</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/*...*/</span>) {
      <span class="hljs-comment">/*...*/</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">toConstantDependency</span>(parser, strCode)(expr);
    }
  });
};
</code></pre>
<p>之后，Webpack 会借助 Template 接口将上述 <code>Dependency</code> 打包进 Chunk 中，替换对应位置(<code>loc</code>)代码：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eaa247a0d034d6dbcc4a5624573311c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>这是一个功能效果看起来简单，但实现特别复杂的例子，底层需要使用 <code>Parser</code> 钩子遍历 AST 结构，之后借助 <code>Dependency</code> 声明代码依赖，最后借助 Template 替换代码内容，过程中已经涉及到许多 Webpack 底层对象。</p>
<p>这正是学习开发 Webpack 插件的难点，有时候你不仅仅需要了解每一个 Hook 的时机与作用、如何与上下文参数交互，还需要了解 Webpack 底层许多类型的实现、作用、接口等等，才能写出符合预期的功能，而 Webpack 是一个极度复杂、庞大的工具，这些具体知识点太多太碎，几乎不可能一一枚举。不过，我们可以换一种方式，从更高更抽象的视角审视 Webpack 插件架构，从“道”的角度加深理解。</p>
<h2>插件架构综述</h2>
<p>前端社区里很多有名的框架都各自有一套插件架构，例如 axios、quill、vscode、webpack、vue、rollup 等等。插件架构灵活性高，扩展性强，但通常架构复杂度更高，学习曲线更陡峭。插件架构至少需要解决三个方面的问题：</p>
<ul>
<li><strong>接口</strong>：需要提供一套逻辑接入方法，让开发者能够将代码插入特定环节，变更原始逻辑；</li>
<li><strong>输入</strong>：如何将上下文信息高效传导给插件；</li>
<li><strong>输出</strong>：插件内部通过何种方式影响整套运行体系。</li>
</ul>
<p>针对这些问题，webpack 基于 <a href="https://github.com/webpack/tapable" target="_blank" rel="nofollow noopener noreferrer">tapable</a> 实现了：</p>
<ol>
<li>编译过程的特定节点以钩子形式，通知插件此刻正在发生什么事情；</li>
<li>通过 tapable 提供的回调机制，以参数方式传递上下文信息；</li>
<li>在上下文参数对象中附带了很多存在 Side Effect 的交互接口，插件可以通过这些接口改变。</li>
</ol>
<p>这一切都离不开 tapable，举例来说：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compiler</span> {
  <span class="hljs-comment">// 在构造函数中，先初始化钩子对象</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span> = {
      <span class="hljs-attr">thisCompilation</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncHook</span>([<span class="hljs-string">"compilation"</span>, <span class="hljs-string">"params"</span>]),
    };
  }

  <span class="hljs-title function_">compile</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 特定时机触发特定钩子</span>
    <span class="hljs-keyword">const</span> compilation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compilation</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">thisCompilation</span>.<span class="hljs-title function_">call</span>(compilation);
  }
}
</code></pre>
<p><code>Compiler</code> 类型内部定义了 <code>thisCompilation</code> 钩子，并在 <code>compilation</code> 创建完毕后发布事件消息，插件开发者就可以基于这个钩子获取到最新创建出的 <code>compilation</code> 对象：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePlugin</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">thisCompilation</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"SomePlugin"</span>, <span class="hljs-function">(<span class="hljs-params">compilation, params</span>) =></span> {
        <span class="hljs-comment">// 上下文信息： compilation、params</span>
    });
  }
}
</code></pre>
<p>钩子回调传递的 <code>compilation/params</code> 参数，就是 Webpack 希望传递给插件的上下文信息，也是插件能拿到的输入。不同钩子会传递不同的上下文对象，这一点在钩子被创建的时候就定下来了，比如：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compiler</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span> = {
            <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">SyncBailHook&#x3C;Compilation></span>} */</span>
            <span class="hljs-attr">shouldEmit</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncBailHook</span>([<span class="hljs-string">"compilation"</span>]),
            <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">AsyncSeriesHook&#x3C;Stats></span>} */</span>
            <span class="hljs-attr">done</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSeriesHook</span>([<span class="hljs-string">"stats"</span>]),
            <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">AsyncSeriesHook&#x3C;></span>} */</span>
            <span class="hljs-attr">additionalPass</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSeriesHook</span>([]),
            <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">AsyncSeriesHook&#x3C;Compiler></span>} */</span>
            <span class="hljs-attr">beforeRun</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSeriesHook</span>([<span class="hljs-string">"compiler"</span>]),
            <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">AsyncSeriesHook&#x3C;Compiler></span>} */</span>
            <span class="hljs-attr">run</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSeriesHook</span>([<span class="hljs-string">"compiler"</span>]),
            <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">AsyncSeriesHook&#x3C;Compilation></span>} */</span>
            <span class="hljs-attr">emit</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSeriesHook</span>([<span class="hljs-string">"compilation"</span>]),
            <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">AsyncSeriesHook&#x3C;string, Buffer></span>} */</span>
            <span class="hljs-attr">assetEmitted</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSeriesHook</span>([<span class="hljs-string">"file"</span>, <span class="hljs-string">"content"</span>]),
            <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">AsyncSeriesHook&#x3C;Compilation></span>} */</span>
            <span class="hljs-attr">afterEmit</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSeriesHook</span>([<span class="hljs-string">"compilation"</span>]),
        };
    }
}
</code></pre>
<ul>
<li><code>shouldEmit</code> 会被传入 <code>compilation</code> 参数；</li>
<li><code>done</code> 会被传入 <code>stats</code> 参数；</li>
<li>……</li>
</ul>
<p>这一设计贯穿 Webpack 整个执行过程，几乎无处不在，我们可以借此介入 Webpack 的运行逻辑。</p>
<p>插件架构的灵魂就在于，框架自身只负责实现最关键的核心流程，其它具体功能都尽量交给具体插件实现，包括 Webpack 仓库内也会内置非常多插件(如 <code>DefinePlugin/EntryPlugin</code> 等)，这就为我们提供了非常充分的学习素材。因此，我的建议是：</p>
<ol>
<li>先透彻理解上述 Webpack 插件架构的设计逻辑，捋清楚 Webpack 主流程与 Hook 之间的关系；</li>
<li>尝试用本文第一节提及的若干常见 Hook 与上下文参数对象编写一些示例，对这些钩子有一个感性认知；</li>
<li>尝试分析一些常用但不是很复杂的插件源码，例如文中提到的 <code>eslint-webpack-plugin</code> 等，或者：<code>terser-webpack-plugin</code>、<code>stylelint-webpack-plugin</code> 等，从中学习一些编写插件的常见方法；</li>
<li>最后，在实际开发时参考相关插件源码实现，带着问题与明确目标，逐行分析插件实现逻辑。</li>
</ol>
<h2>总结</h2>
<p>综上，Webpack 插件在代码形态上是一个带 <code>apply</code> 方法的对象，我们可以在 <code>apply</code> 函数中注册各式各样的 Hook 回调，监听对应事件，之后在回调中修改上下文状态，达到干预 Webpack 构建逻辑的效果。</p>
<p>由此可见，编写插件时大部分工作都围绕 Hook 展开，因此我们需要理解构建过程中的不同环节会触发什么 Hook、对应传递什么上下文参数、如何与上下文参数对象交互等，而学习这些知识最高效的方式，我认为是阅读、分析各种开源插件源码。例如文章中提及的：</p>
<ul>
<li>从 <code>imagemin-webpack-plugin</code> 学习：如何借助 <code>assets</code> 数组修改最终产物内容；</li>
<li>从 <code>eslint-webpack-plugin</code> 学习：如何提交错误信息；</li>
<li>从 <code>DefinePlugin</code> 学习：如何与 AST 结构交互。</li>
</ul>
<p>相信通过阅读这些内容，你已经对 Webpack 插件的形态与开发方式有了一个基本理解，下一章节我会继续抽象一些常见的开发用例，包括：校验插件参数、提交日志、搭建自动化测试环境等，帮助你进一步掌握插件的开发方法。</p>
<h2>思考题</h2>
<p>插件架构设计算是许多优秀软件工程项目的标配，那么作为对比，Rollup 又是怎么实现插件扩展能力的呢？感兴趣的同学可以参考相关源码，交叉学习。</p></div>
</body></html>