<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>插件架构：Hook 体系是如何影响 Webpack 架构的？</h1>
<p>Webpack 之所以能够应对 Web 场景下极度复杂、多样的构建需求，关键就在于其健壮、扩展性极强的插件架构，而插件架构的精髓又在于其灵活多变的 Hook 体系，可以说，只有真正掌握 Hook 底层设计与实现逻辑，深入理解不同 Hook 的运行特性与用法，才能灵活处理各种问题，更快更好地编写出 Webpack 插件。</p>
<p>本文将聚焦在 Webpack Hook 底层的 Tapable 框架，详细枚举了 Tapable 提供的钩子及各类型钩子的特点、运行逻辑、实现原理，并进一步讨论 Tapable 框架在 Webpack 的作用，进而揭示 Webpack 插件架构的核心逻辑。阅读本文，你将：</p>
<ul>
<li>深入了解 Hook 类型，以及不同类型的特点、运行特性；</li>
<li>理解如何识别 Webpack 特定钩子类型，正确调用处理。</li>
</ul>
<h2>Tapable 全解析</h2>
<p>网上不少资料将 Webpack 的插件架构归类为“事件/订阅”模式，我认为这种归纳有失偏颇。订阅模式是一种松耦合架构，发布器只是在特定时机发布事件消息，订阅者并不或者很少与事件直接发生交互，举例来说，我们平常在使用 HTML 事件的时候很多时候只是在这个时机触发业务逻辑，很少调用上下文操作。</p>
<p>而 Webpack 的插件体系是一种基于 <a href="https://github.com/webpack/tapable" target="_blank" rel="nofollow noopener noreferrer">Tapable</a> 实现的强耦合架构，它在特定时机触发钩子时会附带上足够的上下文信息，插件定义的钩子回调中，能也只能与这些上下文背后的数据结构、接口交互产生 side effect，进而影响到编译状态和后续流程。</p>
<p><a href="https://github.com/webpack/tapable" target="_blank" rel="nofollow noopener noreferrer">Tapable</a> 是 Webpack 插件架构的核心支架，但它的代码量其实很少，本质上就是围绕着 <code>订阅/发布</code> 模式叠加各种特化逻辑，适配 Webpack 体系下复杂的事件源-处理器之间交互需求，比如：</p>
<ul>
<li>有些场景需要支持将前一个处理器的结果传入下一个回调处理器；</li>
<li>有些场景需要支持异步并行调用这些回调处理器。</li>
</ul>
<p>先简单看看 Tapable 的用法：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">SyncHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"tapable"</span>);

<span class="hljs-comment">// 1. 创建钩子实例</span>
<span class="hljs-keyword">const</span> sleep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncHook</span>();

<span class="hljs-comment">// 2. 调用订阅接口注册回调</span>
sleep.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback A"</span>);
});

<span class="hljs-comment">// 3. 调用发布接口触发回调</span>
sleep.<span class="hljs-title function_">call</span>();

<span class="hljs-comment">// 运行结果：</span>
<span class="hljs-comment">// callback A</span>
</code></pre>
<p>使用 Tapable 时通常需要经历三个步骤：</p>
<ul>
<li>创建钩子实例，如上例第 4 行；</li>
<li>调用订阅接口注册回调，包括：<code>tap</code>、<code>tapAsync</code>、<code>tapPromise</code>，如上例第 7 行；</li>
<li>调用发布接口触发回调，包括：<code>call</code>、<code>callAsync</code>、<code>promise</code>，如上例第 12 行。</li>
</ul>
<p>Webpack 内部的钩子大体上都遵循上面三个步骤，只是在某些钩子中还可以使用异步风格的 <code>tapAsync/callAsync</code>、promise 风格 <code>tapPromise/promise</code>，具体使用哪一类函数与钩子类型有关。</p>
<h2>Hook 类型汇总</h2>
<p>Tabable 提供如下类型的钩子：</p>
<table class="ace-table author-6857319138482798593"><tbody><tr><td><div>名称</div></td><td><div>简介</div></td><td><div>统计</div></td></tr><tr><td><div><code>SyncHook</code></div></td><td><div>同步钩子</div></td><td><div>Webpack 共出现 71 次，如 <code>Compiler.hooks.compilation</code></div></td></tr><tr><td><div><code>SyncBailHook</code></div></td><td><div>同步熔断钩子</div></td><td><div>Webpack 共出现 66 次，如 <code>Compiler.hooks.shouldEmit</code></div></td></tr><tr><td><div><code>SyncWaterfallHook</code></div></td><td><div>同步瀑布流钩子</div></td><td><div>Webpack 共出现 37 次，如 <code>Compilation.hooks.assetPath</code></div></td></tr><tr><td><div><code>SyncLoopHook</code></div></td><td><div>同步循环钩子</div></td><td><div>Webpack 中未使用</div></td></tr><tr><td><div><code>AsyncParallelHook</code></div></td><td><div>异步并行钩子</div></td><td><div>Webpack 仅出现 1 次：<code>Compiler.hooks.make</code></div></td></tr><tr><td><div><code>AsyncParallelBailHook</code></div></td><td><div>异步并行熔断钩子</div></td><td><div>Webpack 中未使用</div></td></tr><tr><td><div><code>AsyncSeriesHook</code></div></td><td><div>异步串行钩子</div></td><td><div>Webpack 共出现 16 次，如 <code>Compiler.hooks.done</code></div></td></tr><tr><td><div><code>AsyncSeriesBailHook</code></div></td><td><div>异步串行熔断钩子</div></td><td><div>Webpack 中未使用</div></td></tr><tr><td><div><code>AsyncSeriesLoopHook</code></div></td><td><div>异步串行循环钩子</div></td><td><div>Webpack 中未使用</div></td></tr><tr><td><div><code>AsyncSeriesWaterfallHook</code></div></td><td><div>异步串行瀑布流钩子</div></td><td><div>Webpack 共出现 5 次，如 <code>NormalModuleFactory.hooks.beforeResolve</code></div></td></tr></tbody></table>
<p>类型虽多，但整体遵循两种分类规则：</p>
<ul>
<li>按回调逻辑，分为：
<ul>
<li>基本类型，名称不带 <code>Waterfall/Bail/Loop</code> 关键字：与通常 <code>订阅/回调</code> 模式相似，按钩子注册顺序，逐次调用回调；</li>
<li><code>waterfall</code> 类型：前一个回调的返回值会被带入下一个回调；</li>
<li><code>bail</code> 类型：逐次调用回调，若有任何一个回调返回非 <code>undefined</code> 值，则终止后续调用；</li>
<li><code>loop</code> 类型：逐次、循环调用，直到所有回调函数都返回 <code>undefined</code> 。</li>
</ul>
</li>
<li>按执行回调的并行方式，分为：
<ul>
<li><code>sync</code> ：同步执行，启动后会按次序逐个执行回调，支持 <code>call/tap</code> 调用语句；</li>
<li><code>async</code> ：异步执行，支持传入 callback 或 promise 风格的异步回调函数，支持 <code>callAsync/tapAsync</code> 、<code>promise/tapPromise</code> 两种调用语句。</li>
</ul>
</li>
</ul>
<p>所有钩子都可以按名称套进这两条规则里面，对插件开发者来说不同类型的钩子会直接影响到回调函数的写法，以及插件与其他插件的互通关系，但是有一些基本能力、概念是通用的：<code>tap/call</code>、<code>intercept</code>、<code>context</code>、动态编译等。</p>
<p>接下来展开详细介绍每种钩子的特点与执行逻辑。</p>
<h2><code>SyncHook</code> 钩子</h2>
<p><code>SyncHook</code> 算的上是简单的钩子了，触发后会按照注册的顺序逐个调用回调，且不关心这些回调的返回值，底层逻辑大致如下述代码：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">syncCall</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> callbacks = [fn1, fn2, fn3];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; callbacks.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> cb = callbacks[i];
    <span class="hljs-title function_">cb</span>();
  }
}
</code></pre>
<p>举个例子：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">SyncHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"tapable"</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Somebody</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span> = {
      <span class="hljs-attr">sleep</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncHook</span>(),
    };
  }
  <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">//   触发回调</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">call</span>();
  }
}

<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Somebody</span>();

<span class="hljs-comment">// 注册回调</span>
person.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback A"</span>);
});
person.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback B"</span>);
});
person.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback C"</span>);
});

person.<span class="hljs-title function_">sleep</span>();
<span class="hljs-comment">// 输出结果：</span>
<span class="hljs-comment">// callback A</span>
<span class="hljs-comment">// callback B</span>
<span class="hljs-comment">// callback C</span>
</code></pre>
<p>示例中，<code>Somebody</code> 初始化时声明了一个 <code>sleep</code> 钩子，并在后续调用 <code>sleep.tap</code> 函数连续注册三次回调，在调用 <code>person.sleep()</code> 语句触发 <code>sleep.call</code> 之后，tapable 会按照注册的先后按序执行三个回调。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b92ebab230e746caaa7a0ae4b90ae581~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>上述示例中，触发回调时用到了钩子的 <code>call</code> 函数，我们也可以选择异步风格的 <code>callAsync</code> ，选用 <code>call</code> 或 <code>callAsync</code> 并不会影响回调的执行逻辑：按注册顺序依次执行 + 忽略回调执行结果，两者唯一的区别是 <code>callAsync</code> 需要传入 <code>callback</code> 函数，用于处理回调队列可能抛出的异常：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// call 风格</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">call</span>();
} <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">// 错误处理逻辑</span>
}
<span class="hljs-comment">// callAsync 风格</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">callAsync</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-comment">// 错误处理逻辑</span>
  }
});
</code></pre>
<p>由于调用方式不会 Hook 本身的规则，所以对使用者来说，无需关心底层到底用的是 <code>call</code> 还是 <code>callAsync</code>，上面的例子只需要做简单的修改就可以适配 <code>callAsync</code> 场景：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">SyncHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"tapable"</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Somebody</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span> = {
      <span class="hljs-attr">sleep</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncHook</span>(),
    };
  }
  <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">//   触发回调</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">callAsync</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`interrupt with "<span class="hljs-subst">${err.message}</span>"`</span>);
      }
    });
  }
}

<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Somebody</span>();

<span class="hljs-comment">// 注册回调</span>
person.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">(<span class="hljs-params">cb</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback A"</span>);
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"我就是要报错"</span>);
});
<span class="hljs-comment">// 第一个回调出错后，后续回调不会执行</span>
person.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback B"</span>);
});

person.<span class="hljs-title function_">sleep</span>();

<span class="hljs-comment">// 输出结果：</span>
<span class="hljs-comment">// callback A</span>
<span class="hljs-comment">// interrupt with "我就是要报错"</span>
</code></pre>
<h2><code>SyncBailHook</code> 钩子</h2>
<p><code>bail</code> 单词有熔断的意思，而 <code>bail</code> 类型钩子的特点是在回调队列中，若任一回调返回了非 <code>undefined</code> 的值，则中断后续处理，直接返回该值，用一段伪代码来表示：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bailCall</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> callbacks = [fn1, fn2, fn3];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> callbacks) {
    <span class="hljs-keyword">const</span> cb = callbacks[i];
    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">cb</span>(lastResult);
    <span class="hljs-comment">// 如果有任意一个回调返回结果，则停止调用剩下的回调</span>
    <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-comment">// 熔断</span>
      <span class="hljs-keyword">return</span> result;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
}
</code></pre>
<p><code>SyncBailHook</code> 的调用顺序与规则都跟 <code>SyncHook</code> 相似，主要区别一是 <code>SyncBailHook</code> 增加了熔断逻辑，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">SyncBailHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"tapable"</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Somebody</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span> = {
      <span class="hljs-attr">sleep</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncBailHook</span>(),
    };
  }
  <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">call</span>();
  }
}

<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Somebody</span>();

<span class="hljs-comment">// 注册回调</span>
person.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback A"</span>);
  <span class="hljs-comment">// 熔断点</span>
  <span class="hljs-comment">// 返回非 undefined 的任意值都会中断回调队列</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'返回值：tecvan'</span>
});
person.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback B"</span>);
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">sleep</span>());

<span class="hljs-comment">// 运行结果：</span>
<span class="hljs-comment">// callback A</span>
<span class="hljs-comment">// 返回值：tecvan</span>
</code></pre>
<p>其次，相比于 <code>SyncHook</code> ，<code>SyncBailHook</code> 运行结束后，会将熔断值返回给call函数，例如上例第20行， <code>callback A</code> 返回的 <code>返回值：tecvan</code> 会成为 <code>this.hooks.sleep.call</code> 的调用结果。</p>
<blockquote>
<p>在 Webpack 中被如何使用</p>
</blockquote>
<p><code>SyncBailHook</code> 通常用在发布者需要关心订阅回调运行结果的场景， Webpack 内部有接近 100 个地方用到这种钩子，举个例子： <code>compiler.hooks.shouldEmit</code>，对应的 call 语句：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compiler</span> {
  <span class="hljs-title function_">run</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-comment">//   ...</span>

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onCompiled</span> = (<span class="hljs-params">err, compilation</span>) => {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">shouldEmit</span>.<span class="hljs-title function_">call</span>(compilation) === <span class="hljs-literal">false</span>) {
        <span class="hljs-comment">// ...</span>
      }
    };
  }
}
</code></pre>
<p>此处 Webpack 会根据 <code>shouldEmit</code> 钩子的运行结果确定是否执行后续的操作，其它场景也有相似逻辑，如：</p>
<ul>
<li><code>NormalModuleFactory.hooks.createModule</code> ：预期返回新建的 Module 对象；</li>
<li><code>Compilation.hooks.needAdditionalSeal</code> ：预期返回 bool 值，判定是否进入 <code>unseal</code> 状态；</li>
<li><code>Compilation.hooks.optimizeModules</code> ：预期返回 bool 值，用于判定是否继续执行优化操作。</li>
</ul>
<h2><code>SyncWaterfallHook</code> 钩子</h2>
<p><code>waterfall</code> 钩子的执行逻辑跟 lodash 的 <code>flow</code> 函数有点像，大致上就是将前一个函数的返回值作为参数传入下一个函数，逻辑如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">waterfallCall</span>(<span class="hljs-params">arg</span>) {
  <span class="hljs-keyword">const</span> callbacks = [fn1, fn2, fn3];
  <span class="hljs-keyword">let</span> lastResult = arg;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> callbacks) {
    <span class="hljs-keyword">const</span> cb = callbacks[i];
    <span class="hljs-comment">// 上次执行结果作为参数传入下一个函数</span>
    lastResult = <span class="hljs-title function_">cb</span>(lastResult);
  }
  <span class="hljs-keyword">return</span> lastResult;
}
</code></pre>
<p>理解上述逻辑后，<code>SyncWaterfallHook</code> 的特点也就很明确了：</p>
<ol>
<li>上一个函数的结果会被带入下一个函数；</li>
<li>最后一个回调的结果会作为 <code>call</code> 调用的结果返回。</li>
</ol>
<p>例如：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">SyncWaterfallHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"tapable"</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Somebody</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span> = {
      <span class="hljs-attr">sleep</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncWaterfallHook</span>([<span class="hljs-string">"msg"</span>]),
    };
  }
  <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">"hello"</span>);
  }
}

<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Somebody</span>();

<span class="hljs-comment">// 注册回调</span>
person.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`call 调用传入： <span class="hljs-subst">${arg}</span>`</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">"tecvan"</span>;
});

person.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`A 回调返回： <span class="hljs-subst">${arg}</span>`</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">"world"</span>;
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"最终结果："</span> + person.<span class="hljs-title function_">sleep</span>());
<span class="hljs-comment">// 运行结果：</span>
<span class="hljs-comment">// call 调用传入： hello</span>
<span class="hljs-comment">// A 回调返回： tecvan</span>
<span class="hljs-comment">// 最终结果：world</span>
</code></pre>
<p>示例中，<code>sleep</code> 钩子为 <code>SyncWaterfallHook</code> 类型，之后注册了两个回调，从处理结果可以看到，第一个回调收到的 <code>arg = hello</code> ，即第10行 call 调用时传入的参数；第二个回调收到的是第一个回调返回的结果 <code>tecvan</code>；之后 <code>call</code> 调用返回的是第二个回调的结果 <code>world</code> 。</p>
<p>使用时，<code>SyncWaterfallHook</code> 钩子有一些注意事项：</p>
<ul>
<li>初始化时必须提供参数，例如上例 <code>new SyncWaterfallHook(["msg"])</code> 构造函数中，必须传入参数 <code>["msg"]</code> ，用于动态编译 <code>call</code> 的参数依赖，后面我们会讲到 <strong>动态编译</strong> 的细节；</li>
<li>发布调用 <code>call</code> 时，需要传入初始参数。</li>
</ul>
<blockquote>
<p>在 Webpack 中被如何使用</p>
</blockquote>
<p><code>SyncWaterfallHook</code> 在 Webpack 中总共出现了 50+次，其中比较有代表性的例子是 <code>NormalModuleFactory.hooks.factory</code> ，在 Webpack 内部实现中，会在这个钩子内根据资源类型 <code>resolve</code> 出对应的 <code>module</code> 对象：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalModuleFactory</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span> = {
      <span class="hljs-attr">factory</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncWaterfallHook</span>([<span class="hljs-string">"filename"</span>, <span class="hljs-string">"data"</span>]),
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">factory</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"NormalModuleFactory"</span>, <span class="hljs-function">() =></span> <span class="hljs-function">(<span class="hljs-params">result, callback</span>) =></span> {
      <span class="hljs-keyword">let</span> resolver = <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">resolver</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>);

      <span class="hljs-keyword">if</span> (!resolver) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>();

      <span class="hljs-title function_">resolver</span>(result, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =></span> {
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err);

        <span class="hljs-comment">// direct module</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data.<span class="hljs-property">source</span> === <span class="hljs-string">"function"</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, data);

        <span class="hljs-comment">// ...</span>
      });
    });
  }

  <span class="hljs-title function_">create</span>(<span class="hljs-params">data, callback</span>) {
    <span class="hljs-comment">//   ...</span>
    <span class="hljs-keyword">const</span> factory = <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">factory</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>);
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<p>大致上就是在创建模块，通过 <code>factory</code> 钩子将 <code>module</code> 的创建过程外包出去，在钩子回调队列中依据 <code>waterfall</code> 的特性逐步推断出最终的 <code>module</code> 对象。</p>
<h2><code>SyncLoopHook</code> 钩子</h2>
<p><code>loop</code> 型钩子的特点是循环执行，直到所有回调都返回 <code>undefined</code> ，不过这里循环的维度是单个回调函数，例如有回调队列 <code>[fn1, fn2, fn3]</code> ，<code>loop</code> 钩子先执行 <code>fn1</code> ，如果此时 <code>fn1</code> 返回了非 <code>undefined</code> 值，则继续执行 <code>fn1</code> 直到返回 <code>undefined</code> 后，才向前推进执行 <code>fn2</code> 。伪代码：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loopCall</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> callbacks = [fn1, fn2, fn3];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> callbacks) {
    <span class="hljs-keyword">const</span> cb = callbacks[i];
    <span class="hljs-comment">// 重复执行</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-title function_">cb</span>() !== <span class="hljs-literal">undefined</span>) {}
  }
}
</code></pre>
<p>由于 <code>loop</code> 钩子循环执行的特性，使用时务必十分注意，避免陷入死循环。示例：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">SyncLoopHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"tapable"</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Somebody</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span> = {
      <span class="hljs-attr">sleep</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncLoopHook</span>(),
    };
  }
  <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">call</span>();
  }
}

<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Somebody</span>();
<span class="hljs-keyword">let</span> times = <span class="hljs-number">0</span>;

<span class="hljs-comment">// 注册回调</span>
person.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =></span> {
  ++times;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第 <span class="hljs-subst">${times}</span> 次执行回调A`</span>);
  <span class="hljs-keyword">if</span> (times &#x3C; <span class="hljs-number">4</span>) {
    <span class="hljs-keyword">return</span> times;
  }
});

person.<span class="hljs-property">hooks</span>.<span class="hljs-property">sleep</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`执行回调B`</span>);
});

person.<span class="hljs-title function_">sleep</span>();
<span class="hljs-comment">// 运行结果</span>
<span class="hljs-comment">// 第 1 次执行回调A</span>
<span class="hljs-comment">// 第 2 次执行回调A</span>
<span class="hljs-comment">// 第 3 次执行回调A</span>
<span class="hljs-comment">// 第 4 次执行回调A</span>
<span class="hljs-comment">// 执行回调B</span>
</code></pre>
<p>可以看到示例中一直在执行回调 A，直到满足判定条件 <code>times >= 4</code> ，A 返回 <code>undefined</code> 后，才开始执行回调B。</p>
<p>虽然 Tapable 提供了 <code>SyncLoopHook</code> 钩子，但 Webpack 源码中并没有使用到，所以大家理解用法就行，不用深究。</p>
<h2><code>AsyncSeriesHook</code> 钩子</h2>
<p>前面这些以 <code>Sync</code> 开头的都是同步风格的钩子，执行逻辑相对简单，但不支持异步回调，所以 Tapable 还提供了一系列 <code>Async</code> 开头的异步钩子，支持在回调函数中执行异步操作，执行逻辑比较复杂。</p>
<p>例如 <code>AsyncSeriesHook</code>，它有这样一些特点：</p>
<ul>
<li>支持异步回调，可以在回调函数中写 <code>callback</code> 或 <code>promise</code> 风格的异步操作；</li>
<li>回调队列依次执行，前一个执行结束后，才会开始执行下一个；</li>
<li>与 <code>SyncHook</code> 一样，不关心回调的执行结果。</li>
</ul>
<p>用一段伪代码来表示：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncSeriesCall</span>(<span class="hljs-params">callback</span>) {
  <span class="hljs-keyword">const</span> callbacks = [fn1, fn2, fn3];
  <span class="hljs-comment">//   执行回调 1</span>
  <span class="hljs-title function_">fn1</span>(<span class="hljs-function">(<span class="hljs-params">err1</span>) =></span> {
    <span class="hljs-keyword">if</span> (err1) {
      <span class="hljs-title function_">callback</span>(err1);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">//   执行回调 2</span>
      <span class="hljs-title function_">fn2</span>(<span class="hljs-function">(<span class="hljs-params">err2</span>) =></span> {
        <span class="hljs-keyword">if</span> (err2) {
          <span class="hljs-title function_">callback</span>(err2);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">//   执行回调 3</span>
          <span class="hljs-title function_">fn3</span>(<span class="hljs-function">(<span class="hljs-params">err3</span>) =></span> {
            <span class="hljs-keyword">if</span> (err3) {
              <span class="hljs-title function_">callback</span>(err2);
            }
          });
        }
      });
    }
  });
}
</code></pre>
<p>先来看一个 <code>callback</code> 风格的示例：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">AsyncSeriesHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"tapable"</span>);

<span class="hljs-keyword">const</span> hook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSeriesHook</span>();

<span class="hljs-comment">// 注册回调</span>
hook.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">(<span class="hljs-params">cb</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback A"</span>);
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback A 异步操作结束"</span>);
    <span class="hljs-comment">// 回调结束时，调用 cb 通知 tapable 当前回调已结束</span>
    <span class="hljs-title function_">cb</span>();
  }, <span class="hljs-number">100</span>);
});

hook.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback B"</span>);
});

hook.<span class="hljs-title function_">callAsync</span>();
<span class="hljs-comment">// 运行结果：</span>
<span class="hljs-comment">// callback A</span>
<span class="hljs-comment">// callback A 异步操作结束</span>
<span class="hljs-comment">// callback B</span>
</code></pre>
<p>从代码输出结果可以看出，A 回调内部的 <code>setTimeout</code> 执行完毕调用 <code>cb</code> 函数，<code>tapable</code> 才认为当前回调执行完毕，开始执行 B 回调。</p>
<p>除了 <code>callback</code> 风格外，也可以使用 promise 风格调用 <code>tap/call</code> 函数，改造上例：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">AsyncSeriesHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"tapable"</span>);

<span class="hljs-keyword">const</span> hook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSeriesHook</span>();

<span class="hljs-comment">// 注册回调</span>
hook.<span class="hljs-title function_">tapPromise</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback A"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback A 异步操作结束"</span>);
      <span class="hljs-title function_">resolve</span>();
    }, <span class="hljs-number">100</span>);
  });
});

hook.<span class="hljs-title function_">tapPromise</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback B"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();
});

hook.<span class="hljs-title function_">promise</span>();
<span class="hljs-comment">// 运行结果：</span>
<span class="hljs-comment">// callback A</span>
<span class="hljs-comment">// callback A 异步操作结束</span>
<span class="hljs-comment">// callback B</span>
</code></pre>
<p>有三个改动点：</p>
<ul>
<li>将 <code>tapAsync</code> 更改为 <code>tapPromise</code>；</li>
<li>Tap 回调需要返回 promise 对象，如上例第 8 行；</li>
<li><code>callAsync</code> 调用更改为 <code>promise</code>。</li>
</ul>
<blockquote>
<p>在 Webpack 中被如何使用</p>
</blockquote>
<p><code>AsyncSeriesHook</code> 钩子在 Webpack 中总共出现了 30+ 次，相对来说都是一些比较容易理解的时机，比如在构建完毕后触发 <code>compiler.hooks.done</code> 钩子，用于通知单次构建已经结束：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compiler</span> {
  <span class="hljs-title function_">run</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">finalCallback</span>(err);

    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emitAssets</span>(compilation, <span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">finalCallback</span>(err);

      <span class="hljs-keyword">if</span> (compilation.<span class="hljs-property">hooks</span>.<span class="hljs-property">needAdditionalPass</span>.<span class="hljs-title function_">call</span>()) {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">done</span>.<span class="hljs-title function_">callAsync</span>(stats, <span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
          <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">finalCallback</span>(err);

          <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">additionalPass</span>.<span class="hljs-title function_">callAsync</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
            <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">finalCallback</span>(err);
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(onCompiled);
          });
        });
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emitRecords</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">finalCallback</span>(err);

        <span class="hljs-comment">// ...</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">done</span>.<span class="hljs-title function_">callAsync</span>(stats, <span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
          <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">finalCallback</span>(err);
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">finalCallback</span>(<span class="hljs-literal">null</span>, stats);
        });
      });
    });
  }
}
</code></pre>
<h2><code>AsyncParallelHook</code> 钩子</h2>
<p>与 <code>AsyncSeriesHook</code> 类似，<code>AsyncParallelHook</code> 也支持异步风格的回调，不过 <code>AsyncParallelHook</code> 是以并行方式，同时执行回调队列里面的所有回调，逻辑上近似于：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncParallelCall</span>(<span class="hljs-params">callback</span>) {
  <span class="hljs-keyword">const</span> callbacks = [fn1, fn2];
  <span class="hljs-comment">// 内部维护了一个计数器</span>
  <span class="hljs-keyword">var</span> _counter = <span class="hljs-number">2</span>;

  <span class="hljs-keyword">var</span> _done = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">_callback</span>();
  };
  <span class="hljs-keyword">if</span> (_counter &#x3C;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-comment">// 按序执行回调</span>
  <span class="hljs-keyword">var</span> _fn0 = callbacks[<span class="hljs-number">0</span>];
  <span class="hljs-title function_">_fn0</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">_err0</span>) {
    <span class="hljs-keyword">if</span> (_err0) {
      <span class="hljs-keyword">if</span> (_counter > <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 出错时，忽略后续回调，直接退出</span>
        <span class="hljs-title function_">_callback</span>(_err0);
        _counter = <span class="hljs-number">0</span>;
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (--_counter === <span class="hljs-number">0</span>) <span class="hljs-title function_">_done</span>();
    }
  });
  <span class="hljs-keyword">if</span> (_counter &#x3C;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-comment">// 不需要等待前面回调结束，直接开始执行下一个回调</span>
  <span class="hljs-keyword">var</span> _fn1 = callbacks[<span class="hljs-number">1</span>];
  <span class="hljs-title function_">_fn1</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">_err1</span>) {
    <span class="hljs-keyword">if</span> (_err1) {
      <span class="hljs-keyword">if</span> (_counter > <span class="hljs-number">0</span>) {
        <span class="hljs-title function_">_callback</span>(_err1);
        _counter = <span class="hljs-number">0</span>;
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (--_counter === <span class="hljs-number">0</span>) <span class="hljs-title function_">_done</span>();
    }
  });
}
</code></pre>
<p><code>AsyncParallelHook</code> 钩子的特点：</p>
<ul>
<li>支持异步风格；</li>
<li>并行执行回调队列，不需要做任何等待；</li>
<li>与 <code>SyncHook</code> 一样，不关心回调的执行结果。</li>
</ul>
<h2>实践应用</h2>
<p>综上，Tapable 合计提供了 10 种钩子，支持同步、异步、熔断、循环、waterfall 等功能特性，以此支撑起 Webpack 复杂的构建需求。虽然多数情况下我们不需要手动调用 Tapable，但编写插件时可以借助这些知识，识别 Hook 类型与执行特性后，正确地调用，正确地实现交互。</p>
<p>例如：对于 <a href="https://webpack.js.org/api/compiler-hooks/#done" target="_blank" rel="nofollow noopener noreferrer">compiler.hooks.done</a> 钩子，官网介绍：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a27c1a2560c4926aa76f9a8adefa035~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>这是一个 <code>AsyncSeriesHook</code> 钩子，意味着：</p>
<ul>
<li>支持异步语法，我们可以用 <code>tap/tapAsync/tapPromise</code> 方式注册回调；</li>
<li>Webpack 会按照注册顺序串行执行回调；</li>
<li>Webpack 不关心回调的返回值，但可以通过 <code>callback</code> 函数传递 Error 信息。</li>
</ul>
<p>又或者，对于 <a href="https://webpack.js.org/api/compilation-hooks/#optimizemodules" target="_blank" rel="nofollow noopener noreferrer">compilation.hooks.optimizeChunkModules</a> 钩子，官网介绍：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba180e097d804216800ec285758b9a44~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>这是一个 <code>SyncBailHook</code> 钩子，因此：</p>
<ul>
<li>不支持异步语法，我们只能用 <code>tap</code> 注册回调；</li>
<li>若任意回调有返回值，则中断 Hook 流程，后面回调不再执行，所以使用时需要谨慎。</li>
</ul>
<p>其它 Hook 也能用类似方法，参照分析出钩子的应用技巧。</p>
<blockquote>
<p>提示：Webpack 官方文档并没有覆盖介绍所有钩子，必要时建议读者直接翻阅 Webpack 源码，分析钩子类型。</p>
</blockquote>
<h2>Hook 动态编译</h2>
<p>至此，Webpack 中用到的 Hook 子类都已介绍完毕，不同 Hook 适用于不同场景，解决不同问题，而它们底层都基于 Tapable 的“动态编译”实现，可以说，理解了动态编译，也就掌握了 Tapable 的核心实现逻辑。</p>
<p>动态编译是一个非常大胆的设计，不同 Hook 所谓的同步、异步、bail、waterfall、loop 等回调规则都是 Tapable 根据 Hook 类型、参数、回调队列等参数，调用 <code>new Function</code> 语句动态拼装出一段控制执行流程的 JavaScript 代码实现控制的。例如：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">SyncHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"tapable"</span>);

<span class="hljs-keyword">const</span> sleep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncHook</span>();

sleep.<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback A"</span>);
});
sleep.<span class="hljs-title function_">call</span>();
</code></pre>
<p>调用 <code>sleep.call</code> 时，Tapable 内部处理流程大致为：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1353e6ffa8794086b3dadb91a1de8b04~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>编译过程主要涉及三个实体：</p>
<ul>
<li><code>tapable/lib/SyncHook.js</code> ：定义 <code>SyncHook</code> 的入口文件；</li>
<li><code>tapable/lib/Hook.js</code> ：<code>SyncHook</code> 只是一个代理接口，内部实际上调用了 <code>Hook</code> 类，由 <code>Hook</code> 负责实现钩子的逻辑（其它钩子也是一样的套路）；</li>
<li><code>tapable/lib/HookCodeFactory.js</code> ：动态编译出 <code>call</code>、<code>callAsync</code>、<code>promise</code> 函数内容的工厂类，注意，其他钩子也都会用到 <code>HookCodeFactory</code> 工厂函数。</li>
</ul>
<p><code>SyncHook</code> （其他钩子类似)）调用 <code>call</code> 后，<code>Hook</code> 基类收集上下文信息并调用 <code>createCall</code> 及子类传入的 <code>compiler</code> 函数；<code>compiler</code> 调用 <code>HookCodeFactory</code> 进而使用 <code>new Function</code> 方法动态拼接出回调执行函数。上面例子对应的生成函数：</p>
<pre><code class="hljs language-js">(<span class="hljs-keyword">function</span> <span class="hljs-title function_">anonymous</span>(<span class="hljs-params">
</span>) {
<span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">var</span> _context;
<span class="hljs-keyword">var</span> _x = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_x</span>;
<span class="hljs-keyword">var</span> _fn0 = _x[<span class="hljs-number">0</span>];
<span class="hljs-title function_">_fn0</span>();

})
</code></pre>
<p>那么问题来了，通过 <code>new Function</code>、<code>eval</code> 等方式实现的动态编译，存在诸如性能、安全性等方面的问题，所以社区很少见到类似的设计，真的有必要用这种方式实现 Hook 吗？</p>
<p>这放在 <code>SyncHook</code> 这种简单场景确实大可不必，但若是更复杂的 Hook，如 <code>AsyncSeriesWaterfallHook</code>：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">AsyncSeriesWaterfallHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"tapable"</span>);

<span class="hljs-keyword">const</span> sleep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSeriesWaterfallHook</span>([<span class="hljs-string">"name"</span>]);

sleep.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">"test1"</span>, <span class="hljs-function">(<span class="hljs-params">name, cb</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`执行 A 回调： 参数 name=<span class="hljs-subst">${name}</span>`</span>);
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">cb</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"tecvan2"</span>);
  }, <span class="hljs-number">100</span>);
});

sleep.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">(<span class="hljs-params">name, cb</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`执行 B 回调： 参数 name=<span class="hljs-subst">${name}</span>`</span>);
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">cb</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"tecvan3"</span>);
  }, <span class="hljs-number">100</span>);
});

sleep.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">(<span class="hljs-params">name, cb</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`执行 C 回调： 参数 name=<span class="hljs-subst">${name}</span>`</span>);
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">cb</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"tecvan4"</span>);
  }, <span class="hljs-number">100</span>);
});

sleep.<span class="hljs-title function_">callAsync</span>(<span class="hljs-string">"tecvan"</span>, <span class="hljs-function">(<span class="hljs-params">err, name</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`回调结束， name=<span class="hljs-subst">${name}</span>`</span>);
});

<span class="hljs-comment">// 运行结果：</span>
<span class="hljs-comment">// 执行 A 回调： 参数 name=tecvan</span>
<span class="hljs-comment">// 执行 B 回调： 参数 name=tecvan2</span>
<span class="hljs-comment">// 执行 C 回调： 参数 name=tecvan3</span>
<span class="hljs-comment">// 回调结束， name=tecvan4</span>
</code></pre>
<p><code>AsyncSeriesWaterfallHook</code> 的特点是异步 + 串行 + 前一个回调的返回值会传入下一个回调，对应生成函数：</p>
<pre><code class="hljs language-js">(<span class="hljs-keyword">function</span> <span class="hljs-title function_">anonymous</span>(<span class="hljs-params">name, _callback</span>) {
  <span class="hljs-string">"use strict"</span>;
  <span class="hljs-keyword">var</span> _context;
  <span class="hljs-keyword">var</span> _x = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_x</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">_next1</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> _fn2 = _x[<span class="hljs-number">2</span>];
    <span class="hljs-title function_">_fn2</span>(name, <span class="hljs-keyword">function</span>(<span class="hljs-params">_err2, _result2</span>) {
      <span class="hljs-keyword">if</span> (_err2) {
        <span class="hljs-title function_">_callback</span>(_err2);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (_result2 !== <span class="hljs-literal">undefined</span>) {
          name = _result2;
        }
        <span class="hljs-title function_">_callback</span>(<span class="hljs-literal">null</span>, name);
      }
    });
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">_next0</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> _fn1 = _x[<span class="hljs-number">1</span>];
    <span class="hljs-title function_">_fn1</span>(name, <span class="hljs-keyword">function</span>(<span class="hljs-params">_err1, _result1</span>) {
      <span class="hljs-keyword">if</span> (_err1) {
        <span class="hljs-title function_">_callback</span>(_err1);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (_result1 !== <span class="hljs-literal">undefined</span>) {
          name = _result1;
        }
        <span class="hljs-title function_">_next1</span>();
      }
    });
  }
  <span class="hljs-keyword">var</span> _fn0 = _x[<span class="hljs-number">0</span>];
  <span class="hljs-title function_">_fn0</span>(name, <span class="hljs-keyword">function</span>(<span class="hljs-params">_err0, _result0</span>) {
    <span class="hljs-keyword">if</span> (_err0) {
      <span class="hljs-title function_">_callback</span>(_err0);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (_result0 !== <span class="hljs-literal">undefined</span>) {
        name = _result0;
      }
      <span class="hljs-title function_">_next0</span>();
    }
  });
});
</code></pre>
<p>核心逻辑：</p>
<ul>
<li>生成函数将回调队列各个项封装为 <code>_next0/_next1</code> 函数，这些 <code>next</code> 函数内在逻辑高度相似；</li>
<li>按回调定义的顺序，逐次执行，上一个回调结束后，才调用下一个回调，例如生成代码中的第39行、27行。</li>
</ul>
<p>相比于用递归、循环之类的手段实现 <code>AsyncSeriesWaterfallHook</code>，这段动态生成的函数逻辑确实会更清晰，更容易理解，这种场景下用动态编译，确实是一个不错的选择。</p>
<p>Tapable 提供的大多数特性都是基于 <code>Hook + HookCodeFactory</code> 实现的，如果大家对此有兴趣，可以在 <a href="https://github1s.com/webpack/tapable/blob/master/lib/Hook.js#L12" target="_blank" rel="nofollow noopener noreferrer">tapable/lib/Hook.js</a> 的 <code>CALL_DELEGATE/CALL_ASYNC_DELEGATE/PROMISE_DELEGATE</code> 几个函数打断点：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b5b6274428f46649a9fd71ffa3d7834~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>之后，使用 <a href="https://github.com/GoogleChromeLabs/ndb" target="_blank" rel="nofollow noopener noreferrer">ndb</a> 命令断点调试，查看动态编译出的代码：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/472e9bca1ddf442a9d44970ae700f59c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>高级特性：Intercept</h2>
<p>除了通常的 <code>tap/call</code> 之外，tapable 还提供了简易的中间件机制 —— <code>intercept</code> 接口，例如</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> sleep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncHook</span>();

sleep.<span class="hljs-title function_">intercept</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">"test"</span>,
  <span class="hljs-attr">context</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-title function_">call</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"before call"</span>);
  },
  <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"before loop"</span>);
  },
  <span class="hljs-title function_">tap</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"before each callback"</span>);
  },
  <span class="hljs-title function_">register</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"every time call tap"</span>);
  },
});
</code></pre>
<p><code>intercept</code> 支持注册如下类型的中间件：</p>
<table class="ace-table author-6857319138482798593"><tbody><tr><td><div></div></td><td><div>签名</div></td><td><div>解释</div></td></tr><tr><td><div><code>call</code></div></td><td><div><code>(...args) => void</code></div></td><td><div>调用 <code>call/callAsync/promise</code> 时触发</div></td></tr><tr><td><div><code>tap</code></div></td><td><div><code>(tap: Tap) => void</code></div></td><td><div>调用 <code>call</code> 类函数后，每次调用回调之前触发</div></td></tr><tr><td><div><code>loop</code></div></td><td><div><code>(...args) => void</code></div></td><td><div>仅 <code>loop</code> 型的钩子有效，在循环开始之前触发</div></td></tr><tr><td><div><code>register</code></div></td><td><div><code>(tap: Tap) => Tap | undefined</code></div></td><td><div>调用 <code>tap/tapAsync/tapPromise</code> 时触发</div></td></tr></tbody></table>
<p>其中 <code>register</code> 在每次调用 <code>tap</code> 时被调用；其他三种中间件的触发时机大致如下：</p>
<pre><code class="hljs language-js">  <span class="hljs-keyword">var</span> _context;
  <span class="hljs-keyword">const</span> callbacks = [fn1, fn2];
  <span class="hljs-keyword">var</span> _interceptors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>;
  <span class="hljs-comment">// 调用 call 函数，立即触发</span>
  _interceptors.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">intercept</span>) =></span> intercept.<span class="hljs-title function_">call</span>(_context));
  <span class="hljs-keyword">var</span> _loop;
  <span class="hljs-keyword">var</span> cursor = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">do</span> {
    _loop = <span class="hljs-literal">false</span>;
    <span class="hljs-comment">// 每次循环开始时触发 `loop`</span>
    _interceptors.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">intercept</span>) =></span> intercept.<span class="hljs-title function_">loop</span>(_context));
    <span class="hljs-comment">// 触发 `tap`</span>
    <span class="hljs-keyword">var</span> _fn0 = callbacks[<span class="hljs-number">0</span>];
    _interceptors.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">intercept</span>) =></span> intercept.<span class="hljs-title function_">tap</span>(_context, _fn0));
    <span class="hljs-keyword">var</span> _result0 = <span class="hljs-title function_">_fn0</span>();
    <span class="hljs-keyword">if</span> (_result0 !== <span class="hljs-literal">undefined</span>) {
      _loop = <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> _fn1 = callbacks[<span class="hljs-number">1</span>];
      <span class="hljs-comment">// 再次触发 `tap`</span>
      _interceptors.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">intercept</span>) =></span> intercept.<span class="hljs-title function_">tap</span>(_context, _fn1));
      <span class="hljs-keyword">var</span> _result1 = <span class="hljs-title function_">_fn1</span>();
      <span class="hljs-keyword">if</span> (_result1 !== <span class="hljs-literal">undefined</span>) {
        _loop = <span class="hljs-literal">true</span>;
      }
    }
  } <span class="hljs-keyword">while</span> (_loop);
</code></pre>
<p><code>intercept</code> 特性在 Webpack 内主要被用作进度提示，如 <code>Webpack/lib/ProgressPlugin.js</code> 插件中，分别对 <code>compiler.hooks.emit</code> 、<code>compiler.hooks.afterEmit</code> 钩子应用了记录进度的中间件函数。其他类型的插件应用较少。</p>
<h2>高级特性：HookMap</h2>
<p>Tapable 还有一个值得注意的特性 —— <code>HookMap</code>，它提供了一种集合操作能力，能够降低创建与使用的复杂度，用法比较简单：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">SyncHook</span>, <span class="hljs-title class_">HookMap</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"tapable"</span>);

<span class="hljs-keyword">const</span> sleep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HookMap</span>(<span class="hljs-function">() =></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncHook</span>());

<span class="hljs-comment">// 通过 for 函数过滤集合中的特定钩子</span>
sleep.<span class="hljs-title function_">for</span>(<span class="hljs-string">"statement"</span>).<span class="hljs-title function_">tap</span>(<span class="hljs-string">"test"</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"callback for statement"</span>);
});

<span class="hljs-comment">// 触发 statement 类型的钩子</span>
sleep.<span class="hljs-title function_">get</span>(<span class="hljs-string">"statement"</span>).<span class="hljs-title function_">call</span>();
</code></pre>
<p><code>HookMap</code> 能够用于实现的动态获取钩子功能，例如在 Webpack 的 <code>lib/parser.js</code> 文件中，<code>parser</code> 文件主要完成将资源内容解析为 AST 集合，之后遍历 AST 并以 <code>HookMap</code> 方式对外通知遍历到的内容。</p>
<p>例如，遇到表达式的时候触发 <code>Parser.hooks.expression</code> 钩子，问题是 AST 结构和内容都很复杂，如果所有情景都以独立的钩子实现，那代码量会急剧膨胀。这种场景就很适合用 <code>HookMap</code> 解决，以 <code>expression</code> 为例：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parser</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span> = {
      <span class="hljs-comment">// 定义钩子</span>
      <span class="hljs-comment">// 这里用到 HookMap ，所以不需要提前遍历枚举所有 expression 场景</span>
      <span class="hljs-attr">expression</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">HookMap</span>(<span class="hljs-function">() =></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncBailHook</span>([<span class="hljs-string">"expression"</span>])),
    };
  }

  <span class="hljs-comment">//   不同场景下触发钩子</span>
  <span class="hljs-title function_">walkMemberExpression</span>(<span class="hljs-params">expression</span>) {
    <span class="hljs-keyword">const</span> exprName = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getNameForExpression</span>(expression);
    <span class="hljs-keyword">if</span> (exprName &#x26;&#x26; exprName.<span class="hljs-property">free</span>) {
      <span class="hljs-comment">// 触发特定类型的钩子</span>
      <span class="hljs-keyword">const</span> expressionHook = <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">expression</span>.<span class="hljs-title function_">get</span>(exprName.<span class="hljs-property">name</span>);
      <span class="hljs-keyword">if</span> (expressionHook !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">const</span> result = expressionHook.<span class="hljs-title function_">call</span>(expression);
        <span class="hljs-keyword">if</span> (result === <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span>;
      }
    }
    <span class="hljs-comment">// ...</span>
  }

  <span class="hljs-title function_">walkThisExpression</span>(<span class="hljs-params">expression</span>) {
    <span class="hljs-keyword">const</span> expressionHook = <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">expression</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"this"</span>);
    <span class="hljs-keyword">if</span> (expressionHook !== <span class="hljs-literal">undefined</span>) {
      expressionHook.<span class="hljs-title function_">call</span>(expression);
    }
  }
}
</code></pre>
<p>上例代码第 15、25 行都通过 <code>this.hooks.expression.get(xxx)</code> 语句动态获取对应钩子实例，之后再调用 <code>call</code> 触发。HookMap 的消费逻辑与普通 Hook 类似，只需要增加 <code>for</code> 函数过滤出你实际监听的 Hook 实例即可，如：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 钩子消费逻辑</span>
<span class="hljs-comment">// 选取 CommonJsStuffPlugin 仅起示例作用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonJsStuffPlugin</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compilation</span>.<span class="hljs-title function_">tap</span>(
      <span class="hljs-string">"CommonJsStuffPlugin"</span>,
      <span class="hljs-function">(<span class="hljs-params">compilation, { normalModuleFactory }</span>) =></span> {
        <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">parser, parserOptions</span>) => {
          <span class="hljs-comment">// 通过 for 精确消费钩子</span>
          parser.<span class="hljs-property">hooks</span>.<span class="hljs-property">expression</span>
            .<span class="hljs-title function_">for</span>(<span class="hljs-string">"require.main.require"</span>)
            .<span class="hljs-title function_">tap</span>(
              <span class="hljs-string">"CommonJsStuffPlugin"</span>,
              <span class="hljs-title class_">ParserHelpers</span>.<span class="hljs-title function_">expressionIsUnsupported</span>(
                parser,
                <span class="hljs-string">"require.main.require is not supported by Webpack."</span>
              )
            );
          parser.<span class="hljs-property">hooks</span>.<span class="hljs-property">expression</span>
            .<span class="hljs-title function_">for</span>(<span class="hljs-string">"module.parent.require"</span>)
            .<span class="hljs-title function_">tap</span>(
              <span class="hljs-string">"CommonJsStuffPlugin"</span>,
              <span class="hljs-title class_">ParserHelpers</span>.<span class="hljs-title function_">expressionIsUnsupported</span>(
                parser,
                <span class="hljs-string">"module.parent.require is not supported by Webpack."</span>
              )
            );
          parser.<span class="hljs-property">hooks</span>.<span class="hljs-property">expression</span>
            .<span class="hljs-title function_">for</span>(<span class="hljs-string">"require.main"</span>)
            .<span class="hljs-title function_">tap</span>(
              <span class="hljs-string">"CommonJsStuffPlugin"</span>,
              <span class="hljs-title class_">ParserHelpers</span>.<span class="hljs-title function_">toConstantDependencyWithWebpackRequire</span>(
                parser,
                <span class="hljs-string">"__Webpack_require__.c[__Webpack_require__.s]"</span>
              )
            );
          <span class="hljs-comment">// ...</span>
        };
      }
    );
  }
}
</code></pre>
<p>借助这种能力我们就不需要为每一种情况都单独创建 Hook，只需要在使用时动态创建、获取对应实例即可，能有效降低开发与维护成本。</p>
<h2>总结</h2>
<p>为了应对构建场景下各种复杂需求，Webpack 内部使用了多种类型的 Hook，分别用于实现同步、异步、熔断、串行、并行的流程逻辑，开发插件时需要注意识别 Hook 类型，据此做出正确的调用与交互逻辑。</p>
<h2>思考题</h2>
<p>为什么 Webpack 内部需要这些不同类型的流程逻辑？比如，为什么需要 <code>SyncBailHook</code> 这种具有熔断特性的钩子？适用于怎么样的场景？在我们日常业务开发中，能否复用这一类流程控制能力？</p></div>
</body></html>