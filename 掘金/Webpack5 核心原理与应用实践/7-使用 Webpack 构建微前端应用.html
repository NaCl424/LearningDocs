<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>使用 Webpack 构建微前端应用</h1>
<blockquote>
<p>Module Federation 通常译作“<strong>模块联邦</strong>”，是 Webpack 5 新引入的一种远程模块动态加载、运行技术。MF 允许我们将原本单个巨大应用按我们理想的方式拆分成多个体积更小、职责更内聚的小应用形式，理想情况下各个应用能够实现独立部署、独立开发(不同应用甚至允许使用不同技术栈)、团队自治，从而降低系统与团队协作的复杂度 —— 没错，这正是所谓的微前端架构。</p>
<p><em>An architectural style where independently deliverable frontend applications are composed into a greater whole —— 摘自《<strong><a href="https://martinfowler.com/articles/micro-frontends.html" target="_blank" rel="nofollow noopener noreferrer">Micro Frontends</a></strong>》。</em></p>
</blockquote>
<p>英文社区对 Webpack Module Federation 的响应非常热烈，甚至被誉为“<a href="https://medium.com/swlh/webpack-5-module-federation-a-game-changer-to-javascript-architecture-bcdd30e02669" target="_blank" rel="nofollow noopener noreferrer">A game-changer in JavaScript architecture</a>”，相对而言国内对此热度并不高，这一方面是因为 MF 强依赖于 Webpack5，升级成本有点高；另一方面是国内已经有一些成熟微前端框架，例如 <a href="https://qiankun.umijs.org/zh/guide" target="_blank" rel="nofollow noopener noreferrer">qiankun</a>。不过我个人觉得 MF 有不少实用性强，非常值得学习、使用的特性，包括：</p>
<ul>
<li>应用可按需导出若干模块，这些模块最终会被单独打成模块包，功能上有点像 NPM 模块；</li>
<li>应用可在运行时基于 HTTP(S) 协议动态加载其它应用暴露的模块，且用法与动态加载普通 NPM 模块一样简单；</li>
<li>与其它微前端方案不同，MF 的应用之间关系平等，没有主应用/子应用之分，每个应用都能导出/导入任意模块；</li>
<li>等等。</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbb78e89b39941818ab0c323d4873c1f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<blockquote>
<p>图片摘自：《<a href="https://www.lumin.tech/articles/webpack-module-federation/#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9D%97" target="_blank" rel="nofollow noopener noreferrer">Webpack 5 之 模块联合（Module Federation）</a>》</p>
</blockquote>
<h2>简单示例</h2>
<p>Module Federation 的基本逻辑是一端导出模块，另一端导入、使用模块，实现上两端都依赖于 Webpack 5 内置的 <code>ModuleFederationPlugin</code> 插件：</p>
<ol>
<li>对于模块生成方，需要使用 <code>ModuleFederationPlugin</code> 插件的 <code>expose</code> 参数声明需要导出的模块列表；</li>
<li>对于模块使用方，需要使用 <code>ModuleFederationPlugin</code> 插件的 <code>remotes</code> 参数声明需要从哪些地方导入远程模块。</li>
</ol>
<p>接下来，我们按这个流程一步步搭建一个简单的 Webpack Module Federation 示例，相关代码已上传到 <a href="https://github1s.com/Tecvan-fe/webpack-book-samples/blob/HEAD/MF-basic" target="_blank" rel="nofollow noopener noreferrer">小册仓库</a>。首先介绍一下示例文件结构：</p>
<pre><code class="hljs language-lua">MF-basic
├─ app<span class="hljs-number">-1</span>
│  ├─ dist
│  │  ├─ ...
│  ├─ <span class="hljs-built_in">package</span>.json
│  ├─ src
│  │  ├─ main.js
│  │  ├─ foo.js
│  │  └─ utils.js
│  └─ webpack.<span class="hljs-built_in">config</span>.js
├─ app<span class="hljs-number">-2</span>
│  ├─ dist
│  │  ├─ ...
│  ├─ <span class="hljs-built_in">package</span>.json
│  ├─ src
│  │  ├─ bootstrap.js
│  │  └─ main.js
│  ├─ webpack.<span class="hljs-built_in">config</span>.js
├─ lerna.json
└─ <span class="hljs-built_in">package</span>.json
</code></pre>
<blockquote>
<p>提示：为简化依赖管理，示例引入 <a href="https://github.com/lerna/lerna" target="_blank" rel="nofollow noopener noreferrer">lerna</a> 实现 Monorepo 策略，不过这与文章主题无关，这里不做过多介绍。</p>
</blockquote>
<p>其中，<code>app-1</code>、<code>app-2</code> 是两个独立应用，分别有一套独立的 Webpack 构建配置，类似于微前端场景下的“微应用”概念。在本示例中，<code>app-1</code> 负责导出模块 —— 类似于子应用；<code>app-2</code> 负责使用这些模块 —— 类似于主应用。</p>
<p>我们先看看模块导出方 —— 也就是 <code>app-1</code> 的构建配置：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">ModuleFederationPlugin</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"webpack"</span>).<span class="hljs-property">container</span>;

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">"development"</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">entry</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./src/main.js"</span>),
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./dist"</span>),
    <span class="hljs-comment">// 必须指定产物的完整路径，否则使用方无法正确加载产物资源</span>
    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">`http://localhost:8081/dist/`</span>,
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-comment">// MF 应用名称</span>
      <span class="hljs-attr">name</span>: <span class="hljs-string">"app1"</span>,
      <span class="hljs-comment">// MF 模块入口，可以理解为该应用的资源清单</span>
      <span class="hljs-attr">filename</span>: <span class="hljs-string">`remoteEntry.js`</span>,
      <span class="hljs-comment">// 定义应用导出哪些模块</span>
      <span class="hljs-attr">exposes</span>: {
        <span class="hljs-string">"./utils"</span>: <span class="hljs-string">"./src/utils"</span>,
        <span class="hljs-string">"./foo"</span>: <span class="hljs-string">"./src/foo"</span>,
      },
    }),
  ],
  <span class="hljs-comment">// MF 应用资源提供方必须以 http(s) 形式提供服务</span>
  <span class="hljs-comment">// 所以这里需要使用 devServer 提供 http(s) server 能力</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">port</span>: <span class="hljs-number">8081</span>,
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,
  },
};
</code></pre>
<blockquote>
<p>提示：Module Federation 依赖于 Webpack5 内置的 <a href="https://webpack.js.org/plugins/module-federation-plugin/" target="_blank" rel="nofollow noopener noreferrer">ModuleFederationPlugin</a> 实现模块导入导出功能。</p>
</blockquote>
<p>作用模块导出方，<code>app-1</code> 的配置逻辑可以总结为：</p>
<ol>
<li>需要使用 <code>ModuleFederationPlugin</code> 的 <code>exposes</code> 项声明哪些模块需要被导出；使用 <code>filename</code> 项定义入口文件名称；</li>
<li>需要使用 <code>devServer</code> 启动开发服务器能力。</li>
</ol>
<p>使用 <code>ModuleFederationPlugin</code> 插件后，Webpack 会将 <code>exposes</code> 声明的模块分别编译为独立产物，并将产物清单、MF 运行时等代码打包进 <code>filename</code> 定义的<strong>应用入口文件</strong>(Remote Entry File)中。例如 <code>app-1</code> 经过 Webpack 编译后，将生成如下产物：</p>
<pre><code class="hljs language-css">MF-basic
├─ app-<span class="hljs-number">1</span>
│  ├─ dist
│  │  ├─ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>
│  │  ├─ remoteEntry<span class="hljs-selector-class">.js</span>
│  │  ├─ src_foo_js<span class="hljs-selector-class">.js</span>
│  │  └─ src_utils_js<span class="hljs-selector-class">.js</span>
│  ├─ <span class="hljs-attribute">src</span>
│  │  ├─ ...
</code></pre>
<ul>
<li><code>main.js</code> 为整个应用的编译结果，此处可忽略；</li>
<li><code>src_utils_js.js</code> 与 <code>src_foo_js.js</code> 分别为 <code>exposes</code> 声明的模块的编译产物；</li>
<li><code>remoteEntry.js</code> 是 <code>ModuleFederationPlugin</code> 插件生成的应用入口文件，包含模块清单、MF 运行时代码。</li>
</ul>
<p>接下来继续看看模块导入方 —— 也就是 <code>app-2</code> 的配置方法：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">"html-webpack-plugin"</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">ModuleFederationPlugin</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"webpack"</span>).<span class="hljs-property">container</span>;

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">"development"</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">entry</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./src/main.js"</span>),
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./dist"</span>),
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 模块使用方也依然使用 ModuleFederationPlugin 插件搭建 MF 环境</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-comment">// 使用 remotes 属性声明远程模块列表</span>
      <span class="hljs-attr">remotes</span>: {
        <span class="hljs-comment">// 地址需要指向导出方生成的应用入口文件</span>
        <span class="hljs-title class_">RemoteApp</span>: <span class="hljs-string">"app1@http://localhost:8081/dist/remoteEntry.js"</span>,
      },
    }),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(),
  ],
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">port</span>: <span class="hljs-number">8082</span>,
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,
  },
};
</code></pre>
<p>作用远程模块使用方，<code>app-2</code> 需要使用 <code>ModuleFederationPlugin</code> 声明远程模块的 HTTP(S) 地址与模块名称(示例中的 <code>RemoteApp</code>)，之后在 <code>app-2</code> 中就可以使用模块名称异步导入 <code>app-1</code> 暴露出来的模块，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// app-2/src/main.js</span>
(<span class="hljs-keyword">async</span> () => {
  <span class="hljs-keyword">const</span> { sayHello } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">"RemoteApp/utils"</span>);
  <span class="hljs-title function_">sayHello</span>();
})();
</code></pre>
<p>到这里，简单示例就算是搭建完毕了，之后运行页面，打开开发者工具的 Network 面板，可以看到：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a52bfa6daf0e4c0fb181a6bdfb6698e2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>其中：</p>
<ul>
<li><code>remoteEntry.js</code> 即 <code>app-1</code> 构建的应用入口文件；</li>
<li><code>src_utils_js.js</code> 则是 <code>import("RemoteApp/utils")</code> 语句导入的远程模块。</li>
</ul>
<p>总结一下，MF 中的模块导出/导入方都依赖于 <code>ModuleFederationPlugin</code> 插件，其中导出方需要使用插件的 <code>exposes</code> 项声明导出哪些模块，使用 <code>filename</code> 指定生成的入口文件；导入方需要使用 <code>remotes</code> 声明远程模块地址，之后在代码中使用异步导入语法 <code>import("module")</code> 引入模块。</p>
<p>这种模块远程加载、运行的能力，搭配适当的 DevOps 手段，已经足以满足微前端的独立部署、独立维护、开发隔离的要求，在此基础上 MF 还提供了一套简单的依赖共享功能，用于解决多应用间基础库管理问题。</p>
<h2>依赖共享</h2>
<p>上例应用相互独立，各自管理、打包基础依赖包，但实际项目中应用之间通常存在一部分公共依赖 —— 例如 Vue、React、Lodash 等，如果简单沿用上例这种分开打包的方式势必会出现依赖被重复打包，造成产物冗余的问题，为此 <code>ModuleFederationPlugin</code> 提供了 <code>shared</code> 配置用于声明该应用可被共享的依赖模块。</p>
<p>例如，改造上例模块导出方 <code>app-1</code> ，添加 <code>shared</code> 配置：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">"app1"</span>,
      <span class="hljs-attr">filename</span>: <span class="hljs-string">`remoteEntry.js`</span>,
      <span class="hljs-attr">exposes</span>: {
        <span class="hljs-string">"./utils"</span>: <span class="hljs-string">"./src/utils"</span>,
        <span class="hljs-string">"./foo"</span>: <span class="hljs-string">"./src/foo"</span>,
      }, 
      <span class="hljs-comment">// 可被共享的依赖模块</span>
+     <span class="hljs-attr">shared</span>: [<span class="hljs-string">'lodash'</span>]
    }),
  ],
  <span class="hljs-comment">// ...</span>
};
</code></pre>
<p>接下来，还需要修改模块导入方 <code>app-2</code>，添加相同的 <code>shared</code> 配置：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 模块使用方也依然使用 ModuleFederationPlugin 插件搭建 MF 环境</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-comment">// 使用 remotes 属性声明远程模块列表</span>
      <span class="hljs-attr">remotes</span>: {
        <span class="hljs-comment">// 地址需要指向导出方生成的应用入口文件</span>
        <span class="hljs-title class_">RemoteApp</span>: <span class="hljs-string">"app1@http://localhost:8081/dist/remoteEntry.js"</span>,
      },
+     <span class="hljs-attr">shared</span>: [<span class="hljs-string">'lodash'</span>]
    }),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(),
  ],
  <span class="hljs-comment">// ...</span>
};
</code></pre>
<blockquote>
<p>提示：示例代码已上传到 <a href="https://github1s.com/Tecvan-fe/webpack-book-samples/blob/HEAD/MF-shared/package.json" target="_blank" rel="nofollow noopener noreferrer">小册仓库</a>。</p>
</blockquote>
<p>之后，运行页面可以看到最终只加载了一次 <code>lodash</code> 产物(下表左图)，而改动前则需要分别从导入/导出方各加载一次 <code>lodash</code>(下表右图)：</p>
<table class="ace-table author-6857319138482798593"><tbody><tr><td><div>添加 <code>shared</code> 后</div></td><td><div>改动前</div></td></tr><tr><td><div><div class="image-uploaded gallery"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55d6c1597e6743a29067aa5ab64c3544~tplv-k3u1fbpfcp-zoom-1.image"></div></div><div></div></td><td><div><div class="image-uploaded gallery"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d216a327b16d414eaa4f7cba93d16476~tplv-k3u1fbpfcp-zoom-1.image"></div></div><div></div></td></tr></tbody></table>
<p>注意，这里要求两个应用使用 <strong>版本号完全相同</strong> 的依赖才能被复用，假设上例应用 <code>app-1</code> 用了 <code>lodash@4.17.0</code> ，而 <code>app-2</code> 用的是 <code>lodash@4.17.1</code>，Webpack 还是会同时加载两份 lodash 代码，我们可以通过 <code>shared.[lib].requiredVersion</code> 配置项显式声明应用需要的依赖库版本来解决这个问题：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-comment">// ...</span>
      <span class="hljs-comment">// 共享依赖及版本要求声明</span>
+     <span class="hljs-attr">shared</span>: {
+       <span class="hljs-attr">lodash</span>: {
+         <span class="hljs-attr">requiredVersion</span>: <span class="hljs-string">"^4.17.0"</span>,
+       },
+     },
    }),
  ],
  <span class="hljs-comment">// ...</span>
};
</code></pre>
<p>上例 <code>requiredVersion: "^4.17.0"</code> 表示该应用支持共享版本大于等于 <code>4.17.0</code> 小于等于 <code>4.18.0</code> 的 lodash，其它应用所使用的 lodash 版本号只要在这一范围内即可复用。<code>requiredVersion</code> 支持 <a href="https://semver.org/" target="_blank" rel="nofollow noopener noreferrer">Semantic Versioning 2.0</a> 标准，这意味着我们可以复用 <code>package.json</code> 中声明版本依赖的方法。</p>
<p><code>requiredVersion</code> 的作用在于限制依赖版本的上下限，实用性极高。除此之外，我们还可以通过 <code>shared.[lib].shareScope</code> 属性更精细地控制依赖的共享范围，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-comment">// ...</span>
      <span class="hljs-comment">// 共享依赖及版本要求声明</span>
+     <span class="hljs-attr">shared</span>: {
+       <span class="hljs-attr">lodash</span>: {
+         <span class="hljs-comment">// 任意字符串</span>
+         <span class="hljs-attr">shareScope</span>: <span class="hljs-string">'foo'</span>
+       },
+     },
    }),
  ],
  <span class="hljs-comment">// ...</span>
};
</code></pre>
<p>在这种配置下，其它应用所共享的 lodash 库必须同样声明为 <code>foo</code> 空间才能复用。<code>shareScope</code> 在多团队协作时能够切分出多个资源共享空间，降低依赖冲突的概率。</p>
<p>除 <code>requiredVersion</code>/<code>shareScope</code> 外，<code>shared</code> 还提供了一些不太常用的 <a href="https://webpack.js.org/plugins/module-federation-plugin/" target="_blank" rel="nofollow noopener noreferrer">配置</a>，简单介绍：</p>
<ul>
<li><code>singletong</code>：强制约束多个版本之间共用同一个依赖包，如果依赖包不满足版本 <code>requiredVersion</code> 版本要求则报警告：</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bbdf553eb2b4c8e9d38ffb2e1695948~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<ul>
<li><code>version</code>：声明依赖包版本，缺省默认会从包体的 <code>package.json</code> 的 <code>version</code> 字段解析；</li>
<li><code>packageName</code>：用于从描述文件中确定所需版本的包名称，仅当无法从请求中自动确定包名称时才需要这样做；</li>
<li><code>eager</code>：允许 webpack 直接打包该依赖库 —— 而不是通过异步请求获取库；</li>
<li><code>import</code>：声明如何导入该模块，默认为 shared 属性名，实用性不高，可忽略。</li>
</ul>
<h2>示例：微前端</h2>
<p>Module Federation 是一种非常新的技术，社区资料还比较少，接下来我们来编写一个完整的微前端应用，帮助你更好理解 MF 的功能与用法。微前端架构通常包含一个作为容器的主应用及若干负责渲染具体页面的子应用，分别对标到下面示例的 <code>packages/host</code> 与 <code>packages/order</code> 应用：</p>
<pre><code class="hljs language-lua">MF-micro-fe
├─ packages
│  ├─ host
│  │  ├─ public
│  │  │  └─ index.html
│  │  ├─ src
│  │  │  ├─ App.js
│  │  │  ├─ HomePage.js
│  │  │  ├─ Navigation.js
│  │  │  ├─ bootstrap.js
│  │  │  ├─ index.js
│  │  │  └─ routes.js
│  │  ├─ <span class="hljs-built_in">package</span>.json
│  │  └─ webpack.<span class="hljs-built_in">config</span>.js
│  └─ order
│     ├─ src
│     │  ├─ OrderDetail.js
│     │  ├─ OrderList.js
│     │  ├─ main.js
│     │  └─ routes.js
│     ├─ <span class="hljs-built_in">package</span>.json
│     └─ webpack.<span class="hljs-built_in">config</span>.js
├─ lerna.json
└─ <span class="hljs-built_in">package</span>.json
</code></pre>
<blockquote>
<p>提示：示例代码已上传到：<a href="https://github1s.com/Tecvan-fe/webpack-book-samples/blob/HEAD/MF-micro-fe/package.json" target="_blank" rel="nofollow noopener noreferrer">MF-micro-fe</a>，务必 Clone 下来辅助阅读。</p>
</blockquote>
<p>先看看 <code>order</code> 对应的 MF 配置：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">"order"</span>,
      <span class="hljs-attr">filename</span>: <span class="hljs-string">"remoteEntry.js"</span>,
      <span class="hljs-comment">// 导入路由配置</span>
      <span class="hljs-attr">exposes</span>: {
        <span class="hljs-string">"./routes"</span>: <span class="hljs-string">"./src/routes"</span>,
      },
    }),
  ],
};
</code></pre>
<p>注意，<code>order</code> 应用实际导出的是路由配置文件 <code>routes.js</code>。而 <code>host</code> 则通过 MF 插件导入并消费 <code>order</code> 应用的组件，对应配置：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 模块使用方也依然使用 ModuleFederationPlugin 插件搭建 MF 环境</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-comment">// 使用 remotes 属性声明远程模块列表</span>
      <span class="hljs-attr">remotes</span>: {
        <span class="hljs-comment">// 地址需要指向导出方生成的应用入口文件</span>
        <span class="hljs-title class_">RemoteOrder</span>: <span class="hljs-string">"order@http://localhost:8081/dist/remoteEntry.js"</span>,
      },
    })
  ],
  <span class="hljs-comment">// ...</span>
};
</code></pre>
<p>之后，在 <code>host</code> 应用中引入 <code>order</code> 的路由配置并应用到页面中：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> localRoutes <span class="hljs-keyword">from</span> <span class="hljs-string">"./routes"</span>;
<span class="hljs-comment">// 引入远程 order 模块</span>
<span class="hljs-keyword">import</span> orderRoutes <span class="hljs-keyword">from</span> <span class="hljs-string">"RemoteOrder/routes"</span>;

<span class="hljs-keyword">const</span> routes = [...localRoutes, ...orderRoutes];

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) => (
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">React.StrictMode</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">HashRouter</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>Micro Frontend Example<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Navigation</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Routes</span>></span>
        {routes.map((route) => (
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Route</span>
            <span class="hljs-attr">key</span>=<span class="hljs-string">{route.path}</span>
            <span class="hljs-attr">path</span>=<span class="hljs-string">{route.path}</span>
            <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>
              &#x3C;<span class="hljs-attr">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&#x3C;></span>...<span class="hljs-tag">&#x3C;/></span>}>
                <span class="hljs-tag">&#x3C;<span class="hljs-name">route.component</span> /></span>
              <span class="hljs-tag">&#x3C;/<span class="hljs-name">React.Suspense</span>></span>
            }
            exact={route.exact}
          />
        ))}
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">Routes</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">HashRouter</span>></span></span>
  &#x3C;/<span class="hljs-title class_">React</span>.<span class="hljs-property">StrictMode</span>>
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>通过这种方式，一是可以将业务代码分解为更细粒度的应用形态；二是应用可以各自管理路由逻辑，降低应用间耦合性。最终能降低系统组件间耦合度，更有利于多团队协作。除此之外，MF 技术还有非常大想象空间，国外有大神专门整理了一系列实用 MF 示例：<a href="https://github.com/module-federation/module-federation-examples/" target="_blank" rel="nofollow noopener noreferrer">Module Federation Examples</a>，感兴趣的读者务必仔细阅读这些示例代码。</p>
<h2>总结</h2>
<p>Module Federation 是 Webpack 5 新引入的一种远程模块动态加载、运行技术，虽然国内讨论热度较低，但使用简单，功能强大，非常适用于微前端或代码重构迁移场景。</p>
<p>使用上，只需引入 <code>ModuleFederationPlugin</code> 插件，按要求组织、分割好各个微应用的代码，并正确配置 <code>expose/remotes</code> 配置项即可实现基于 HTTP(S) 的模块共享功能。此外，我们还可以通过插件的 <code>shared</code> 配置项实现在应用间共享基础依赖库，还可以通过 <code>shared.requireVersion</code> 等一系列配置，精细控制依赖的共享版本与范围。</p>
<h2>思考题</h2>
<p>Module Federation 实现的微前端架构并未提供沙箱能力，会不会导致一些安全问题？</p></div>
</body></html>