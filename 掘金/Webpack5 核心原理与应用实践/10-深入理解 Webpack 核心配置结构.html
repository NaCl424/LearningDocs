<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>深入理解 Webpack 核心配置结构</h1>
<p>Webpack 是一种 <strong>「配置」</strong> 驱动的构建工具，所以站在应用的角度，必须深入学习 Webpack 的各项配置规则，才能灵活应对各种构建需求。本文将作为小册应用系列的一个总结，汇总与应用配置相关的各项知识点，包括：</p>
<ol>
<li>剖析配置结构规则，解释对象、数组、函数三种形态的写法，以及各自应对的场景；</li>
<li>详细讲解环境治理的意义，以及如何借助多文件实现环境治理；</li>
<li>完整、清晰地介绍若干核心配置项：<code>entry/output/target/mode</code>，帮助你更深入理解配置规则。</li>
</ol>
<h2>配置结构详解</h2>
<p>在前面章节中，我们已经编写了许多 Webpack 配置示例，其大多数都以单文件导出单个配置对象方式实现，类似：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-comment">// 其它配置...</span>
};
</code></pre>
<p>实际上，Webpack 还支持以数组、函数方式配置运行参数，以适配不同场景应用需求，它们之间大致上区别：</p>
<ul>
<li><strong>单个配置对象</strong>：比较常用的一种方式，逻辑简单，适合大多数业务项目；</li>
<li><strong>配置对象数组</strong>：每个数组项都是一个完整的配置对象，每个对象都会触发一次单独的构建，通常用于需要为同一份代码构建多种产物的场景，如 Library；</li>
<li><strong>函数</strong>：Webpack 启动时会执行该函数获取配置，我们可以在函数中根据环境参数(如 <code>NODE_ENV</code>)动态调整配置对象。</li>
</ul>
<p>下面我们着重介绍数组、函数两种方式。</p>
<blockquote>
<p><strong>使用配置数组：</strong></p>
</blockquote>
<p>导出数组的方式很简单，如：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = [{
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-comment">// 其它配置...</span>
}, {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-comment">// 其它配置...</span>
}];
</code></pre>
<p>使用数组方式时，Webpack 会在启动后创建多个 <code>Compilation</code> 实例，并行执行构建工作，但需要注意，<code>Compilation</code> 实例间基本上不作通讯，这意味着这种并行构建对运行性能并没有任何正向收益，例如某个 Module 在 <code>Compilation</code> 实例 A 中完成解析、构建后，在其它 <code>Compilation</code> 中依然需要完整经历构建流程，无法直接复用结果。</p>
<p>数组方式主要用于应对“同一份代码打包出多种产物”的场景，例如在构建 Library 时，我们通常需要同时构建出 ESM/CMD/UMD 等模块方案的产物，如：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = [
  {
    <span class="hljs-attr">output</span>: {
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'./dist-amd.js'</span>,
      <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">'amd'</span>,
    },
    <span class="hljs-attr">name</span>: <span class="hljs-string">'amd'</span>,
    <span class="hljs-attr">entry</span>: <span class="hljs-string">'./app.js'</span>,
    <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span>,
  },
  {
    <span class="hljs-attr">output</span>: {
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'./dist-commonjs.js'</span>,
      <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">'commonjs'</span>,
    },
    <span class="hljs-attr">name</span>: <span class="hljs-string">'commonjs'</span>,
    <span class="hljs-attr">entry</span>: <span class="hljs-string">'./app.js'</span>,
    <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span>,
  },
];
</code></pre>
<blockquote>
<p>提示：使用配置数组时，还可以通过 <code>--config-name</code> 参数指定需要构建的配置对象，例如上例配置中若执行 <code>npx webpack --config-name='amd'</code>，则仅使用数组中 <code>name='amd'</code> 的项做构建。</p>
</blockquote>
<p>此时适合使用配置数组方式解决；若是“多份代码打包多份产物”的场景，则建议使用 <code>entry</code> 配置多个应用入口。</p>
<p>使用数组方式时，我们还可以借助 <a href="https://www.npmjs.com/package/webpack-merge" target="_blank" rel="nofollow noopener noreferrer">webpack-merge</a> 工具简化配置逻辑，如：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { merge } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"webpack-merge"</span>);

<span class="hljs-keyword">const</span> baseConfig = {
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: <span class="hljs-string">"./dist"</span>
  },
  <span class="hljs-attr">name</span>: <span class="hljs-string">"amd"</span>,
  <span class="hljs-attr">entry</span>: <span class="hljs-string">"./app.js"</span>,
  <span class="hljs-attr">mode</span>: <span class="hljs-string">"production"</span>,
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = [
  <span class="hljs-title function_">merge</span>(baseConfig, {
    <span class="hljs-attr">output</span>: {
      <span class="hljs-attr">filename</span>: <span class="hljs-string">"[name]-amd.js"</span>,
      <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">"amd"</span>,
    },
  }),
  <span class="hljs-title function_">merge</span>(baseConfig, {
    <span class="hljs-attr">output</span>: {
      <span class="hljs-attr">filename</span>: <span class="hljs-string">"./[name]-commonjs.js"</span>,
      <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">"commonjs"</span>,
    },
  }),
];
</code></pre>
<blockquote>
<p>提示：<code>webpack-merge</code> 是 Webpack 生态内专门用于合并配置对象的工具，后面我们还会展开讲解使用方法。</p>
</blockquote>
<p>示例中将公共配置抽取为 <code>baseConfig</code> 对象，之后配合 <code>webpack-merge</code> 创建不同目标数组项，这种方式可有效减少重复的配置代码，非常推荐使用。</p>
<blockquote>
<p><strong>使用配置函数：</strong></p>
</blockquote>
<p>配置函数方式要求在配置文件中导出一个函数，并在函数中返回 Webpack 配置对象，或配置数组，或 <code>Promise</code> 对象，如：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">env, argv</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
    <span class="hljs-comment">// 其它配置...</span>
  }
}
</code></pre>
<p>运行时，Webpack 会传入两个环境参数对象：</p>
<ul>
<li><code>env</code>：通过 <code>--env</code> 传递的命令行参数，适用于自定义参数，例如：</li>
</ul>
<p>​</p>





























<table><thead><tr><th>命令：</th><th><code>env</code> 参数值：</th></tr></thead><tbody><tr><td>npx webpack --env prod</td><td>{ prod: true }</td></tr><tr><td>npx webpack --env prod --env min</td><td>{ prod: true, min: true }</td></tr><tr><td>npx webpack --env platform=app --env production</td><td>{ platform: "app", production: true }</td></tr><tr><td>npx webpack --env foo=bar=app</td><td>{ foo: "bar=app"}</td></tr><tr><td>npx webpack --env app.platform="staging" --env app.name="test"</td><td>{ app: { platform: "staging", name: "test" }</td></tr></tbody></table>
<ul>
<li><code>argv</code>：命令行 <a href="https://webpack.js.org/api/cli/#flags" target="_blank" rel="nofollow noopener noreferrer">Flags</a> 参数，支持 <code>entry</code>/<code>output-path</code>/<code>mode</code>/<code>merge</code> 等。</li>
</ul>
<p>“<strong>配置函数</strong>”这种方式的意义在于，允许用户根据命令行参数动态创建配置对象，可用于实现简单的多环境治理策略，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// npx webpack --env app.type=miniapp --mode=production</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">env, argv</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">mode</span>: argv.<span class="hljs-property">mode</span> ? <span class="hljs-string">"production"</span> : <span class="hljs-string">"development"</span>,
    <span class="hljs-attr">devtool</span>: argv.<span class="hljs-property">mode</span> ? <span class="hljs-string">"source-map"</span> : <span class="hljs-string">"eval"</span>,
    <span class="hljs-attr">output</span>: {
      <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">`./dist/<span class="hljs-subst">${env.app.type}</span>`</span>,
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].js'</span>
    },
    <span class="hljs-attr">plugins</span>: [
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>({
        <span class="hljs-attr">terserOptions</span>: {
          <span class="hljs-attr">compress</span>: argv.<span class="hljs-property">mode</span> === <span class="hljs-string">"production"</span>, 
        },
      }),
    ],
  };
};
</code></pre>
<p>示例支持通过命令行传入 <code>env.app.type</code> 与 <code>argv.mode</code> 值，决定最终配置结构，我们可以为不同场景传入不同命令行参数，从而实现环境隔离效果。</p>
<p>不过这种方式并不常用，一是因为需要在配置函数内做许多逻辑判断，复杂场景下可能可读性会很低，维护成本高；二是强依赖于命令行参数，可能最终需要写出一串很长的运行命令，应用体验较差。目前社区比较流行通过不同配置文件区分不同环境的运行配置，配合 <code>--config</code> 参数实现环境治理，下面我们会展开讲解这种方案。</p>
<p>最后简单总结下，Webpack 支持三种配置方式：对象、数组、函数，其中对象方式最简单，且能够应对大多数业务开发场景，所以使用率最高；数组方式主要用于构建 Library 场景；函数方式灵活性较高，可用于实现一些简单的环境治理策略。同学们可根据实际场景，择优选用。</p>
<h2>环境治理策略</h2>
<p>在现代前端工程化实践中，通常需要将同一个应用项目部署在不同环境(如生产环境、开发环境、测试环境)中，以满足项目参与各方的不同需求。这就要求我们能根据部署环境需求，对同一份代码执行各有侧重的打包策略，例如：</p>
<ul>
<li>开发环境需要使用 <code>webpack-dev-server</code> 实现 Hot Module Replacement；</li>
<li>测试环境需要带上完整的 Soucemap 内容，以帮助更好地定位问题；</li>
<li>生产环境需要尽可能打包出更快、更小、更好的应用代码，确保用户体验。</li>
</ul>
<p>Webpack 中有许多实现环境治理的方案，比如上面介绍过的，使用“配置函数”配合命令行参数动态计算配置对象。除此之外，业界比较流行将不同环境配置分别维护在单独的配置文件中，如：</p>
<pre><code class="hljs language-arduino">.
└── config
  ├── webpack.common.js
  ├── webpack.development.js
  ├── webpack.testing.js
  └── webpack.production.js
</code></pre>
<p>之后配合 <code>--config</code> 选项指定配置目标，如：</p>
<pre><code class="hljs language-arduino">npx webpack --config webpack.development.js
</code></pre>
<p>这种模式下通常会将部分通用配置放在基础文件中，如上例的 <code>webpack.common.js</code>，之后在其它文件中引入该模块并使用 <a href="https://www.npmjs.org/package/webpack-merge" target="_blank" rel="nofollow noopener noreferrer">webpack-merge</a> 合并配置对象。</p>
<p><code>webpack-merge</code> 是一个专为 Webpack 设计的数据合并(<code>merge</code>)的工具，功能逻辑与 Lodash 的 <a href="https://devdocs.io/lodash~4/index#merge" target="_blank" rel="nofollow noopener noreferrer">merge</a> 函数、 <a href="https://devdocs.io/javascript/global_objects/object/assign" target="_blank" rel="nofollow noopener noreferrer">Object.assign</a> 等相似，但支持更多特性，如：</p>
<ul>
<li>支持数组属性合并，例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title function_">merge</span>({ <span class="hljs-attr">arr</span>: [<span class="hljs-number">1</span>] }, { <span class="hljs-attr">arr</span>: [<span class="hljs-number">2</span>] }) === { <span class="hljs-attr">arr</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] }
</code></pre>
<ul>
<li>支持函数属性合并，例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> res = <span class="hljs-title function_">merge</span>(
  { <span class="hljs-attr">func</span>: <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>) },
  { <span class="hljs-attr">func</span>: <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>) }
);
res.<span class="hljs-title function_">func</span>();
<span class="hljs-comment">// => 1,2 </span>
</code></pre>
<ul>
<li>支持设定对象合并策略，支持 <code>match/append/prepend/replace/merge</code> 规则；</li>
<li>支持传入自定义对象合并函数；</li>
<li>等等。</li>
</ul>
<p>这些特性能更好地支持 Webpack 这种高度复杂的数据合并场景，例如对于 <code>module.rules</code> 数组，若只是使用 <code>Object.assign</code> 做合并，则只会导致后面对象属性替换了前面对象属性；而使用 <code>webpack-merge</code> 能够实现两个数组项合并，更符合预期。</p>
<p>接下来，我们用一个 <a href="https://github.com/Tecvan-fe/webpack-book-samples/blob/main/env-manage/webpack.common.js" target="_blank" rel="nofollow noopener noreferrer">示例</a> 简单串一下与 <code>webpack-merge</code> 实现环境管理的过程。首先我们需要将通用配置放在公共文件中，如：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// webpack.common.js</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">HTMLWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">"html-webpack-plugin"</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: { <span class="hljs-attr">main</span>: <span class="hljs-string">"./src/index.js"</span> },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">"[name].js"</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"dist"</span>),
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">"babel-loader"</span>],
      },
    ],
  },
  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLWebpackPlugin</span>()],
};
</code></pre>
<p>其次，需要安装 <code>webpack-merge</code> 做配置合并操作：</p>
<pre><code class="hljs language-sql">yarn <span class="hljs-keyword">add</span> <span class="hljs-operator">-</span>D webpack<span class="hljs-operator">-</span><span class="hljs-keyword">merge</span>
</code></pre>
<p>之后，创建对应环境配置文件，如 <code>webpack.development.js</code>，并输入开发环境专用配置代码，如：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// webpack.development.js</span>
<span class="hljs-keyword">const</span> { merge } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"webpack-merge"</span>);
<span class="hljs-keyword">const</span> baseConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./webpack.common"</span>);

<span class="hljs-comment">// 使用 webpack-merge 合并配置对象</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">merge</span>(baseConfig, {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">"development"</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">"source-map"</span>,
  <span class="hljs-attr">devServer</span>: { <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span> },
});
</code></pre>
<p>最后，执行构建命令并通过 <code>--config</code> 参数传入配置文件路径，如：</p>
<pre><code class="hljs language-ini">npx webpack <span class="hljs-attr">--config</span>=webpack.development.js
</code></pre>
<p>至此，样例大致搭建完毕，接下来我们还可以继续为更多构建环境配备特定的配置文件，流程同上，此处不再赘述。</p>
<h2>核心配置项汇总</h2>
<p>在前面章节中，我们已经基于各种应用场景综合讲解了 Webpack 方方面面的应用方法，其中涉及多达上百种配置项，不太可能一一详细讲解，但大致上可以划分下图中展示的几种分类：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b0350016e9e4d92868ecbdcbbded33d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>包括：流程配置、性能优化类配置、日志类配置、开发效率类配置等，这里面较常用，需要着重学习的配置有：</p>
<ul>
<li><code>entry</code>：声明项目入口文件，Webpack 会从这个文件开始递归找出所有文件依赖；</li>
<li><code>output</code>：声明构建结果的存放位置；</li>
<li><code>target</code>：用于配置编译产物的目标运行环境，支持 <code>web</code>、<code>node</code>、<code>electron</code> 等值，不同值最终产物会有所差异；</li>
<li><code>mode</code>：编译模式短语，支持 <code>development</code>、<code>production</code> 等值，Webpack 会根据该属性推断默认配置；</li>
<li><code>optimization</code>：用于控制如何优化产物包体积，内置 Dead Code Elimination、Scope Hoisting、代码混淆、代码压缩等功能；</li>
<li><code>module</code>：用于声明模块加载规则，例如针对什么类型的资源需要使用哪些 Loader 进行处理；</li>
<li><code>plugin</code>：Webpack 插件列表。</li>
</ul>
<p>其中，<code>optimization/module/plugin</code> 属性将在后续章节做专门介绍，此处先不展开。接下来我们将集中讲解 <code>entry/output/target/mode</code> 属性，帮你更全面、立体、透彻地理解 Webpack 配置项逻辑。</p>
<h2><code>entry</code> 配置详解</h2>
<p>Webpack 的基本运行逻辑是从 <strong>「入口文件」</strong> 开始，递归加载、构建所有项目资源，所以几乎所有项目都必须使用 <a href="https://webpack.js.org/configuration/entry-context/" target="_blank" rel="nofollow noopener noreferrer">entry</a> 配置项明确声明项目入口。<code>entry</code> 配置规则比较复杂，支持如下形态：</p>
<ul>
<li>字符串：指定入口文件路径；</li>
<li>对象：对象形态功能比较完备，除了可以指定入口文件列表外，还可以指定入口依赖、Runtime 打包方式等；</li>
<li>函数：动态生成 Entry 配置信息，函数中可返回字符串、对象或数组；</li>
<li>数组：指明多个入口文件，数组项可以为上述介绍的文件路径字符串、对象、函数形式，Webpack 会将数组指明的入口全部打包成一个 Bundle。</li>
</ul>
<p>例如：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">//...</span>
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-comment">// 字符串形态</span>
    <span class="hljs-attr">home</span>: <span class="hljs-string">'./home.js'</span>,
    <span class="hljs-comment">// 数组形态</span>
    <span class="hljs-attr">shared</span>: [<span class="hljs-string">'react'</span>, <span class="hljs-string">'react-dom'</span>, <span class="hljs-string">'redux'</span>, <span class="hljs-string">'react-redux'</span>],
    <span class="hljs-comment">// 对象形态</span>
    <span class="hljs-attr">personal</span>: {
      <span class="hljs-attr">import</span>: <span class="hljs-string">'./personal.js'</span>,
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'pages/personal.js'</span>,
      <span class="hljs-attr">dependOn</span>: <span class="hljs-string">'shared'</span>,
      <span class="hljs-attr">chunkLoading</span>: <span class="hljs-string">'jsonp'</span>,
      <span class="hljs-attr">asyncChunks</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-comment">// 函数形态</span>
    <span class="hljs-attr">admin</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'./admin.js'</span>;
    }
  },
};
</code></pre>
<p>这其中，<strong>「对象」</strong> 形态的配置逻辑最为复杂，支持如下配置属性：</p>
<ul>
<li><code>import</code>：声明入口文件，支持路径字符串或路径数组(多入口)；</li>
<li><code>dependOn</code>：声明该入口的前置依赖 Bundle；</li>
<li><code>runtime</code>：设置该入口的 Runtime Chunk，若该属性不为空，Webpack 会将该入口的运行时代码抽离成单独的 Bundle；</li>
<li><code>filename</code>：效果与 <a href="https://webpack.js.org/configuration/output/#outputfilename" target="_blank" rel="nofollow noopener noreferrer">output.filename</a> 类同，用于声明该模块构建产物路径；</li>
<li><code>library</code>：声明该入口的 <a href="https://webpack.js.org/configuration/output/#outputlibrary" target="_blank" rel="nofollow noopener noreferrer">output.library</a> 配置，一般在构建 NPM Library 时使用；</li>
<li><code>publicPath</code>：效果与 <a href="https://webpack.js.org/configuration/output/#outputpublicpath" target="_blank" rel="nofollow noopener noreferrer">output.publicPath</a> 相同，用于声明该入口文件的发布 URL；</li>
<li><code>chunkLoading</code>：效果与 <a href="https://webpack.js.org/configuration/output/#outputchunkloading" target="_blank" rel="nofollow noopener noreferrer">output.chunkLoading</a> 相同，用于声明异步模块加载的技术方案，支持 <code>false/jsonp/require/import</code> 等值；</li>
<li><code>asyncChunks</code>：效果与 <a href="https://webpack.js.org/configuration/output/#outputasyncchunks" target="_blank" rel="nofollow noopener noreferrer">output.asyncChunks</a> 相同，用于声明是否支持异步模块加载，默认值为 <code>true</code>。</li>
</ul>
<p>而这些属性中，<code>dependOn</code> 与 <code>runtime</code> 最为晦涩难懂，有必要构造实例，展开讲解。</p>
<blockquote>
<p>使用 <code>entry.dependOn</code> 声明入口依赖：</p>
</blockquote>
<p><code>dependOn</code> 属性用于声明前置 Bundle 依赖，从效果上看能够减少重复代码，优化构建产物质量。例如：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">main</span>: <span class="hljs-string">"./src/index.js"</span>,
    <span class="hljs-attr">foo</span>: { <span class="hljs-attr">import</span>: <span class="hljs-string">"./src/foo.js"</span>, <span class="hljs-attr">dependOn</span>: <span class="hljs-string">"main"</span> },
  },
};
</code></pre>
<blockquote>
<p>提示：示例代码已上传到 <a href="https://github1s.com/Tecvan-fe/webpack-book-samples/blob/main/entry-obj/webpack.config.js" target="_blank" rel="nofollow noopener noreferrer">小册仓库</a>。</p>
</blockquote>
<p>示例中，<code>foo</code> 入口的 <code>dependOn</code> 属性指向 <code>main</code> 入口，此时 Webpack 认为：客户端在加载 <code>foo</code> 产物之前必然会加载 <code>main</code>，因此可以将重复的模块代码、运行时代码等都放到 <code>main</code> 产物，减少不必要的重复，最终打包结果：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1558bef8b4cf42f5994750000e1b3725~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>左边为 <code>main</code> 产物，包含所有模块、运行时代码，与普通 Bundle 无异；右边为 <code>foo</code> 产物，代码结构非常清爽。作为对比，若不指定 <code>dependOn</code> 属性，则构建结果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5271c309cfb54c26a3d7d32ec1558001~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>可以看出两边内容并无差异。</p>
<p><code>dependOn</code> 适用于哪些有明确入口依赖的场景，例如我们构建了一个主框架 Bundle，其中包含了项目基本框架(如 React)，之后还需要为每个页面单独构建 Bundle，这些页面代码也都依赖于主框架代码，此时可用 <code>dependOn</code> 属性优化产物内容，减少代码重复。</p>
<blockquote>
<p>使用 <code>entry.runtime</code> 管理运行时代码：</p>
</blockquote>
<p>为支持产物代码在各种环境中正常运行，Webpack 会在产物文件中注入一系列运行时代码，用以支撑起整个应用框架。运行时代码的多寡取决于我们用到多少特性，例如：</p>
<ul>
<li>需要导入导出文件时，将注入 <code>__webpack_require__.r</code> 等；</li>
<li>使用异步加载时，将注入 <code>__webpack_require__.l</code> 等；</li>
<li>等等。</li>
</ul>
<p>不要小看运行时代码量，极端情况下甚至有可能超过业务代码总量！为此，必要时我们可以尝试使用 <a href="https://webpack.js.org/concepts/entry-points/#entrydescription-object" target="_blank" rel="nofollow noopener noreferrer">runtime</a> 配置将运行时抽离为独立 Bundle，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">"development"</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">main</span>: { <span class="hljs-attr">import</span>: <span class="hljs-string">"./src/index.js"</span>, <span class="hljs-attr">runtime</span>: <span class="hljs-string">"common-runtime"</span> },
    <span class="hljs-attr">foo</span>: { <span class="hljs-attr">import</span>: <span class="hljs-string">"./src/foo.js"</span>, <span class="hljs-attr">runtime</span>: <span class="hljs-string">"common-runtime"</span> },
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">filename</span>: <span class="hljs-string">"[name].js"</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"dist"</span>),
  },
};
</code></pre>
<blockquote>
<p>提示：示例代码已上传到 <a href="https://github1s.com/Tecvan-fe/webpack-book-samples/blob/main/entry-runtime/webpack.config.js" target="_blank" rel="nofollow noopener noreferrer">小册仓库</a>。</p>
</blockquote>
<p>示例中，<code>main</code> 与 <code>foo</code> 入口均将 <code>runtime</code> 声明为 <code>common-runtime</code>，此时 Webpack 会将这两个入口的运行时代码都抽取出来，放在 <code>common-runtime</code> Bundle 中，效果：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44051543ac17436abab8dd1844500435~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p><code>entry.runtime</code> 是一种常用的应用性能优化手段，建议大家多做尝试、使用。</p>
<h2>使用 <code>output</code> 声明输出方式</h2>
<p>Webpack 的 <a href="https://webpack.js.org/configuration/output/" target="_blank" rel="nofollow noopener noreferrer">output</a> 配置项用于声明：如何输出构建结果，比如产物放在什么地方、文件名是什么、文件编码等。<code>output</code> 支持许多子配置项，包括：</p>
<ul>
<li><a href="https://webpack.js.org/configuration/output/#outputpath" target="_blank" rel="nofollow noopener noreferrer">output.path</a>：声明产物放在什么文件目录下；</li>
<li><a href="https://webpack.js.org/configuration/output/#outputfilename" target="_blank" rel="nofollow noopener noreferrer">output.filename</a>：声明产物文件名规则，支持 <code>[name]/[hash]</code> 等占位符；</li>
<li><a href="https://webpack.js.org/configuration/output/#outputpublicpath" target="_blank" rel="nofollow noopener noreferrer">output.publicPath</a>：文件发布路径，在 Web 应用中使用率较高；</li>
<li><a href="https://webpack.js.org/configuration/output/#outputclean" target="_blank" rel="nofollow noopener noreferrer">output.clean</a>：是否自动清除 <code>path</code> 目录下的内容，调试时特别好用；</li>
<li><a href="https://webpack.js.org/configuration/output/#outputlibrary" target="_blank" rel="nofollow noopener noreferrer">output.library</a>：NPM Library 形态下的一些产物特性，例如：Library 名称、模块化(UMD/CMD 等)规范；</li>
<li><a href="https://webpack.js.org/configuration/output/#outputchunkloading" target="_blank" rel="nofollow noopener noreferrer">output.chunkLoading</a>：声明加载异步模块的技术方案，支持 <code>false/jsonp/require</code> 等方式。</li>
<li>等等。</li>
</ul>
<p>对于 Web 应用场景，多数情况下我们只需要使用 <code>path/filename/publicPath</code> 即可满足需求，其它属性使用率不高，篇幅关系，此处不再赘述。</p>
<h2>使用 <code>target</code> 设置构建目标</h2>
<p>虽然多数时候 Webpack 都被用于打包 Web 应用，但实际上 Webpack 还支持构建 Node、Electron、NW.js、WebWorker 等应用形态，这一特性主要通过 <a href="https://webpack.js.org/configuration/target/" target="_blank" rel="nofollow noopener noreferrer">target</a> 配置控制，支持如下数值：</p>
<ul>
<li><code>node[[X].Y]</code>：编译为 Node 应用，此时将使用 Node 的 <code>require</code> 方法加载其它 Chunk，支持指定 Node 版本，如：<code>node12.13</code>；</li>
<li><code>async-node[[X].Y]</code>：编译为 Node 应用，与 <code>node</code> 相比主要差异在于：<code>async-node</code> 方式将以异步(Promise)方式加载异步模块(<code>node</code> 时直接使用 <code>require</code>)。支持指定 Node 版本，如：<code>async-node12.13</code>；</li>
<li><code>nwjs[[X].Y]</code>：编译为 NW.js 应用；</li>
<li><code>node-webkit[[X].Y]</code>：同 <code>nwjs</code>；</li>
<li><code>electron[[X].Y]-main</code>：构建为 Electron <a href="https://www.electronjs.org/zh/docs/latest/tutorial/process-model#%E4%B8%BB%E8%BF%9B%E7%A8%8B" target="_blank" rel="nofollow noopener noreferrer">主进程</a>；</li>
<li><code>electron[[X].Y]-renderer</code>：构建为 Electron <a href="https://www.electronjs.org/zh/docs/latest/tutorial/process-model#%E6%B8%B2%E6%9F%93%E5%99%A8%E8%BF%9B%E7%A8%8B" target="_blank" rel="nofollow noopener noreferrer">渲染进程</a>；</li>
<li><code>electron[[X].Y]-preload</code>：构建为 Electron Preload <a href="https://www.electronjs.org/zh/docs/latest/tutorial/process-model#preload-%E8%84%9A%E6%9C%AC" target="_blank" rel="nofollow noopener noreferrer">脚本</a>；</li>
<li><code>web</code>：构建为 Web 应用；</li>
<li><code>esX</code>：构建为特定版本 ECMAScript 兼容的代码，支持 <code>es5</code>、<code>es2020</code> 等；</li>
<li><code>browserslist</code>：根据浏览器平台与版本，推断需要兼容的 ES 特性，数据来源于 <a href="https://github.com/browserslist/browserslist#queries" target="_blank" rel="nofollow noopener noreferrer">Browserslist</a> 项目，用法如：<code>browserslist: 'last 2 major versions'</code>。</li>
</ul>
<p>不同构建目标会根据平台特性打包出略有差异的结果(主要体现在运行时与 NPM Library)，例如对于下面这种使用了异步导入的代码：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// foo.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">"foo"</span>;

<span class="hljs-comment">// index.js </span>
<span class="hljs-title function_">import</span>(<span class="hljs-string">"./foo"</span>).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);
</code></pre>
<p>使用如下配置，同时构建 <code>node</code> 与 <code>web</code> 版本：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">const</span> { merge } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"webpack-merge"</span>);

<span class="hljs-keyword">const</span> baseConfig = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">"development"</span>,
  <span class="hljs-attr">target</span>: <span class="hljs-string">"web"</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">main</span>: { <span class="hljs-attr">import</span>: <span class="hljs-string">"./src/index.js"</span> },
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"dist"</span>),
  },
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = [
  <span class="hljs-title function_">merge</span>(baseConfig, { <span class="hljs-attr">target</span>: <span class="hljs-string">"web"</span>, <span class="hljs-attr">output</span>: { <span class="hljs-attr">filename</span>: <span class="hljs-string">"web-[name].js"</span> } }),
  <span class="hljs-title function_">merge</span>(baseConfig, { <span class="hljs-attr">target</span>: <span class="hljs-string">"node"</span>, <span class="hljs-attr">output</span>: { <span class="hljs-attr">filename</span>: <span class="hljs-string">"node-[name].js"</span> } }),
];
</code></pre>
<blockquote>
<p>提示：相关示例已上传到小册<a href="https://github1s.com/Tecvan-fe/webpack-book-samples/blob/main/target-node-web/webpack.config.js" target="_blank" rel="nofollow noopener noreferrer">仓库</a>，强烈建议你拉下来，对比两种目标下构建产物的差异。</p>
</blockquote>
<p>之后，执行构建命令，结果：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/000c2d30c12940018df57f172d33c3b0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>可以看到左边 <code>web</code> 版本中需要注入使用 JSONP 异步加载 JS 文件的运行时代码；而右边 <code>node</code> 版本则可以直接使用 Node 环境下的 <code>require</code> 实现异步加载，因此不需要注入相关运行时。</p>
<h2>使用 <code>mode</code> 短语</h2>
<p>Webpack <a href="https://github.com/webpack/webpack/blob/main/lib/config/defaults.js" target="_blank" rel="nofollow noopener noreferrer">内置</a> 了许多构建优化策略，我们可以通过 <a href="https://webpack.js.org/configuration/mode/" target="_blank" rel="nofollow noopener noreferrer">mode</a> 配置项切换默认优化规则，支持如下值：</p>
<ul>
<li><code>production</code>：默认值，生产模式，使用该值时 Webpack 会自动帮我们开启一系列优化措施：Three-Shaking、Terser 压缩代码、SplitChunk 提起公共代码，通常用于生产环境构建；</li>
<li><code>development</code>：开发模式，使用该值时 Webpack 会保留更语义化的 Module 与 Chunk 名称，更有助于调试，通常用于开发环境构建；</li>
<li><code>none</code>：关闭所有内置优化规则。</li>
</ul>
<p><code>mode</code> 规则比较简单，一般在开发模式使用 <code>mode = 'development'</code>，生产模式使用 <code>mode = 'production'</code> 即可。</p>
<h2>总结</h2>
<p>至此，关于 Webpack 配置规则的重要知识点就补充完毕了，我们主要需要理解：</p>
<ul>
<li>Webpack 配置文件支持导出对象、数组、函数三种形态，其中对象形式最为常用，足够应对多数业务项目场景；数组形式适用于需要为同一份代码同时构建多种产物的场景，如 NPM Library；函数形态适用于需要动态生成配置规则的场景；</li>
<li>为方便管理配置逻辑，我们通常需要引入一些环境治理策略，目前业界比较常用单独配置文件管理单个构建环境；</li>
<li><code>entry</code> 配置项支持字符串、对象、函数、数组等方式，其中对象形式下的 <code>dependOn/runtime</code> 规则比较复杂，建议深入学习；</li>
<li><code>output</code> 用于声明构建产物的输出规则；</li>
<li><code>target</code> 用于设置构建目标，不同目标会导致产物内容有轻微差异，支持 Node、Web、Electron、WebWorker 等场景；</li>
<li><code>mode</code> 构建模式，支持 <code>development/production/none</code> 三种值。</li>
</ul>
<p>结合前面若干应用介绍的章节，相信已经帮你搭建起一套体系化的应用方法论，已经足以应付大多数业务场景。后续章节我们将转入更高阶的内容，包括：如何开发 Loader、Plugin；如何优化构建与应用性能；Webpack 构建原理等。</p>
<h2>思考题</h2>
<p>假设在配置文件中需要通过远程接口动态获取配置片段，如何实现比较优雅？请试试。</p></div>
</body></html>