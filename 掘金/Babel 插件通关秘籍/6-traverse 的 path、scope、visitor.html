<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第 01 讲：设计一份吸引面试官的简历</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
<div id="content"><h1>traverse 的 path、scope、visitor</h1>
<p>源码 parse 成 AST 之后，需要进行 AST 的遍历和增删改（transform）。那么 transform 的流程是什么样的？</p>
<p>babel 会递归遍历 AST，遍历过程中处理到不同的 AST 会调用不同的 visitor 函数来实现 transform。这其实是一种设计模式，叫做访问者模式：</p>
<h2>visitor 模式</h2>
<p>visitor 模式（访问者模式）是 23 种经典设计模式中的一种。visitor 模式的思想是：当被操作的对象结构比较稳定，而操作对象的逻辑经常变化的时候，通过分离逻辑和对象结构，使得他们能独立扩展。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a89899432b549d198a98f404e791a97~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>如图，Element 和 Visitor 分别代表对象结构和操作逻辑，两者可以独立扩展，在 Client 里面来组合两者，使用 visitor 操作 element。这就是 visitor 模式。</p>
<p>对应到 babel traverse 的实现，就是 AST 和 visitor 分离，在 traverse（遍历）AST 的时候，调用注册的 visitor 来对其进行处理。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c592dedef6ff429ebbcb350e0afa404d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>这样 AST 是独立的扩展的，visitor 是独立的扩展的，两者可以各自独立扩展单还能轻易地结合在一起。</p>
<h2>path 和 scope</h2>
<p>path 是记录遍历路径的 api，它记录了父子节点的引用，还有很多增删改查 AST 的 api：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/293327a616cc4c90b7fa40c7e28761a0~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>那 path 大概有哪些属性和方法呢？</p>
<h3>path</h3>
<p>path 大概有这些属性和方法，不需要记，后面案例用到的时候知道是啥就行。</p>
<pre><code class="hljs language-javascript">path {
    <span class="hljs-comment">// 属性：</span>
    node 
    parent
    parentPath
    scope
    hub
    container
    key
    listKey
    
    <span class="hljs-comment">// 方法</span>
    <span class="hljs-title function_">get</span>(key) 
    <span class="hljs-title function_">set</span>(key, node)
    <span class="hljs-title function_">inList</span>()
    <span class="hljs-title function_">getSibling</span>(key) 
    <span class="hljs-title function_">getNextSibling</span>()
    <span class="hljs-title function_">getPrevSibling</span>()
    <span class="hljs-title function_">getAllPrevSiblings</span>()
    <span class="hljs-title function_">getAllNextSiblings</span>()
    <span class="hljs-title function_">isXxx</span>(opts)
    <span class="hljs-title function_">assertXxx</span>(opts)
    <span class="hljs-title function_">find</span>(callback)
    <span class="hljs-title function_">findParent</span>(callback)
    
    <span class="hljs-title function_">insertBefore</span>(nodes)
    <span class="hljs-title function_">insertAfter</span>(nodes)
    <span class="hljs-title function_">replaceWith</span>(replacement)
    <span class="hljs-title function_">replaceWithMultiple</span>(nodes)
    <span class="hljs-title function_">replaceWithSourceString</span>(replacement)
    <span class="hljs-title function_">remove</span>()
    
    <span class="hljs-title function_">traverse</span>(visitor, state)
    <span class="hljs-title function_">skip</span>()
    <span class="hljs-title function_">stop</span>()
}
</code></pre>
<p>它们各自的含义：</p>
<ul>
<li>path.node 当前 AST 节点</li>
<li>path.parent 父 AST 节点</li>
<li>path.parentPath 父 AST 节点的 path</li>
<li>path.scope 作用域</li>
<li>path.hub 可以通过 path.hub.file 拿到最外层 File 对象， path.hub.getScope 拿到最外层作用域，path.hub.getCode 拿到源码字符串</li>
<li>path.container 当前 AST 节点所在的父节点属性的属性值</li>
<li>path.key 当前 AST 节点所在父节点属性的属性名或所在数组的下标</li>
<li>path.listkey 当前 AST 节点所在父节点属性的属性值为数组时 listkey 为该属性名，否则为 undefined</li>
</ul>
<h4>container、listkey、key</h4>
<p>这几个属性不太常用，简单介绍一下。</p>
<p>因为 AST 节点要挂在父 AST 节点的某个属性上，那个属性的属性值就是这个 AST 节点的 container。</p>
<p>比如 CallExpression 有 callee 和 arguments 属性，那么对于 callee 的 AST 节点来说，callee 的属性值就是它的 container，而 callee 就是它的 key。</p>
<p>因为不是一个列表，所以 listkey 是 undefined。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce55f6c749d4e35ad6460de6f5be71a~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>而 BlockStatement 有 body 属性，是一个数组，对于数组中的每一个 AST 来说，这个数组就是它们的 container，而 listKey 是 body，key 则是下标。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b48a0cdddb4344d1b9343e04818460ad~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h3>path 的方法</h3>
<p>path 有如下方法，同样也不需要记：</p>
<ul>
<li>get(key) 获取某个属性的 path</li>
<li>set(key, node) 设置某个属性的值</li>
<li>getSibling(key) 获取某个下标的兄弟节点</li>
<li>getNextSibling() 获取下一个兄弟节点</li>
<li>getPrevSibling() 获取上一个兄弟节点</li>
<li>getAllPrevSiblings() 获取之前的所有兄弟节点</li>
<li>getAllNextSiblings() 获取之后的所有兄弟节点</li>
<li>find(callback) 从当前节点到根节点来查找节点（包括当前节点），调用 callback（传入 path）来决定是否终止查找</li>
<li>findParent(callback) 从当前节点到根节点来查找节点（不包括当前节点），调用 callback（传入 path）来决定是否终止查找</li>
<li>inList() 判断节点是否在数组中，如果 container 为数组，也就是有 listkey 的时候，返回 true</li>
<li>isXxx(opts) 判断当前节点是否是某个类型，可以传入属性和属性值进一步判断，比如path.isIdentifier({name: 'a'})</li>
<li>assertXxx(opts) 同 isXxx，但是不返回布尔值，而是抛出异常</li>
<li>insertBefore(nodes) 在之前插入节点，可以是单个节点或者节点数组</li>
<li>insertAfter(nodes) 在之后插入节点，可以是单个节点或者节点数组</li>
<li>replaceWith(replacement) 用某个节点替换当前节点</li>
<li>replaceWithMultiple(nodes) 用多个节点替换当前节点</li>
<li>replaceWithSourceString(replacement) 解析源码成 AST，然后替换当前节点</li>
<li>remove() 删除当前节点</li>
<li>traverse(visitor, state) 遍历当前节点的子节点，传入 visitor 和 state（state 是不同节点间传递数据的方式）</li>
<li>skip() 跳过当前节点的子节点的遍历</li>
<li>stop() 结束所有遍历</li>
</ul>
<h3>作用域 path.scope</h3>
<p>scope 是作用域信息，javascript 中能生成作用域的就是模块、函数、块等，而且作用域之间会形成嵌套关系，也就是作用域链。babel 在遍历的过程中会生成作用域链保存在 path.scope 中。</p>
<p>属性和方法大概有这些</p>
<pre><code class="hljs language-scss">path<span class="hljs-selector-class">.scope</span> {
    bindings
    block
    parent
    parentBlock
    path
    references
 
    <span class="hljs-built_in">dump</span>()
    <span class="hljs-built_in">parentBlock</span>()
    <span class="hljs-built_in">getAllBindings</span>()
    <span class="hljs-built_in">getBinding</span>(name)
    <span class="hljs-built_in">hasBinding</span>(name)
    <span class="hljs-built_in">getOwnBinding</span>(name)
    <span class="hljs-built_in">parentHasBinding</span>(name)
    <span class="hljs-built_in">removeBinding</span>(name)
    <span class="hljs-built_in">moveBindingTo</span>(name, scope)
    <span class="hljs-built_in">generateUid</span>(name)
}
</code></pre>
<p>各自的含义：</p>
<ul>
<li>scope.bindings 当前作用域内声明的所有变量</li>
<li>scope.block 生成作用域的 block，详见下文</li>
<li>scope.path 生成作用域的节点对应的 path</li>
<li>scope.references 所有 binding 的引用对应的 path，详见下文</li>
<li>scope.dump() 打印作用域链的所有 binding 到控制台</li>
<li>scope.parentBlock() 父级作用域的 block</li>
<li>getAllBindings() 从当前作用域到根作用域的所有 binding 的合并</li>
<li>getBinding(name) 查找某个 binding，从当前作用域一直查找到根作用域</li>
<li>getOwnBinding(name) 从当前作用域查找 binding</li>
<li>parentHasBinding(name, noGlobals) 查找某个 binding，从父作用域查到根作用域，不包括当前作用域。可以通过 noGlobals 参数指定是否算上全局变量（比如console，不需要声明就可用），默认是 false</li>
<li>removeBinding(name)  删除某个 binding</li>
<li>hasBinding(name, noGlobals) 从当前作用域查找 binding，可以指定是否算上全局变量，默认是 false</li>
<li>moveBindingTo(name, scope) 把当前作用域中的某个 binding 移动到其他作用域</li>
<li>generateUid(name) 生成作用域内唯一的名字，根据 name 添加下划线，比如 name 为 a，会尝试生成 _a，如果被占用就会生成 __a，直到生成没有被使用的名字。</li>
</ul>
<h4>scope.block</h4>
<p>能形成 scope 的有这些节点，这些节点也叫 block 节点。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">export</span> type <span class="hljs-title class_">Scopable</span> =
  | <span class="hljs-title class_">BlockStatement</span>
  | <span class="hljs-title class_">CatchClause</span>
  | <span class="hljs-title class_">DoWhileStatement</span>
  | <span class="hljs-title class_">ForInStatement</span>
  | <span class="hljs-title class_">ForStatement</span>
  | <span class="hljs-title class_">FunctionDeclaration</span>
  | <span class="hljs-title class_">FunctionExpression</span>
  | <span class="hljs-title class_">Program</span>
  | <span class="hljs-title class_">ObjectMethod</span>
  | <span class="hljs-title class_">SwitchStatement</span>
  | <span class="hljs-title class_">WhileStatement</span>
  | <span class="hljs-title class_">ArrowFunctionExpression</span>
  | <span class="hljs-title class_">ClassExpression</span>
  | <span class="hljs-title class_">ClassDeclaration</span>
  | <span class="hljs-title class_">ForOfStatement</span>
  | <span class="hljs-title class_">ClassMethod</span>
  | <span class="hljs-title class_">ClassPrivateMethod</span>
  | <span class="hljs-title class_">StaticBlock</span>
  | <span class="hljs-title class_">TSModuleBlock</span>;
</code></pre>
<p>我们可以通过 path.scope.block 来拿到所在的块对应的节点，通过 path.scope.parentBlock 拿到父作用域对应的块节点。</p>
<p>一般情况下我们不需要拿到生成作用域的块节点，只需要通过 path.scope 拿到作用域的信息，通过 path.scope.parent 拿到父作用域的信息。</p>
<h4>scope.bindings、scope.references（重点）</h4>
<p>作用域中保存的是声明的变量和对应的值，<strong>每一个声明叫做一个binding</strong>。</p>
<p>比如这样一段代码</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;
</code></pre>
<p>它的 path.scope.bindings 是这样的</p>
<pre><code class="hljs language-javascript"><span class="hljs-attr">bindings</span>: {
    <span class="hljs-attr">a</span>: {
        <span class="hljs-attr">constant</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">constantViolations</span>: [],
        <span class="hljs-attr">identifier</span>: {<span class="hljs-attr">type</span>: <span class="hljs-string">'Identifier'</span>, ...}
        <span class="hljs-attr">kind</span>:<span class="hljs-string">'const'</span>,
        <span class="hljs-attr">path</span>: {node,...}
        <span class="hljs-attr">referenced</span>: <span class="hljs-literal">false</span>
        <span class="hljs-attr">referencePaths</span>: [],
        <span class="hljs-attr">references</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">scope</span>: ...
    }
}
</code></pre>
<p>因为我们在当前 scope 中声明了 a 这个变量，所以 bindings 中有 a 的 binding，每一个 binding 都有 kind，这代表绑定的类型：</p>
<ul>
<li>var、let、const 分别代表 var、let、const 形式声明的变量</li>
<li>param 代表参数的声明</li>
<li>module 代表 import 的变量的声明</li>
</ul>
<p>binding 有多种 kind，代表变量是用不同的方式声明的。</p>
<p>binding.identifier 和 binding.path，分别代表标识符、整个声明语句。</p>
<p>声明之后的变量会被引用和修改，binding.referenced 代表声明的变量是否被引用，binding.constant 代表变量是否被修改过。如果被引用了，就可以通过 binding.referencePaths 拿到所有引用的语句的 path。如果被修改了，可以通过 binding.constViolations 拿到所有修改的语句的 path。</p>
<p>path 的 api 还是比较多的，这也是 babel 最强大的地方。主要是操作当前节点、当前节点的父节点、兄弟节点，作用域，以及增删改的方法。</p>
<h2>state</h2>
<p>state 是遍历过程中 AST 节点之间传递数据的方式。插件的 visitor 中，第一个参数是 path，第二个参数就是 state。</p>
<p>插件可以从 state 中拿到 opts，也就是插件的配置项，也可以拿到 file 对象，file 中有一些文件级别的信息，这个也可以从 path.hub.file 中拿。</p>
<pre><code class="hljs language-markdown">state {
<span class="hljs-code">    file
    opts
}
</span></code></pre>
<p>可以在遍历的过程中在 state 中存一些状态信息，用于后续的 AST 处理。</p>
<h2>AST 的别名</h2>
<p>遍历的时候要指定 visitor 处理的 AST，有的时候需要对多个节点做同样的处理，babel 支持指定多个 AST 类型，也可以通过别名指定一系列类型。</p>
<pre><code class="hljs language-javascript">  <span class="hljs-comment">// 单个 AST 类型</span>
  <span class="hljs-title class_">FunctionDeclaration</span>(path, state) {},
  <span class="hljs-comment">// 多个 AST 类型</span>
  <span class="hljs-string">'FunctionDeclaration|VariableDeclaration'</span>(path, state) {}
  <span class="hljs-comment">// AST 类型别名</span>
  <span class="hljs-title class_">Declaration</span>(){}
</code></pre>
<p>可以在<a href="https://babeljs.io/docs/en/babel-types" target="_blank" rel="nofollow noopener noreferrer">文档中</a>查到某个 AST 类型的别名是啥，某个别名都包含哪些 AST 类型可以在<a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/ast-types/generated/index.ts#L2489-L2535" target="_blank" rel="nofollow noopener noreferrer">babel-types的类型定义</a>处查。</p>
<p>可以把 @babel/types 源码下载下来看，类型定义在 src/ast-types/generated 目录下，这样可以利用 ide 的功能方便的查看每种 alias 的具体 AST 类型。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7ce124c18bd4e5c95760212e5e16078~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>所有的 AST 相关的信息都可以在<a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/definitions/core.ts" target="_blank" rel="nofollow noopener noreferrer">babel-types</a>里查看，每一个 AST 节点怎么创建、怎么校验、怎么遍历，其实都与 AST 的结构有关系，这些都在 babel-types 里面定义。</p>
<p>比如 if 就定义了有哪些属性可以遍历、别名是什么，每一个属性怎么校验，然后会根据这些规则生成xxx，isXxx，assertXxx等api用于创建、判断AST节点。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/004cb659aeaa4c749cfff6b2187383a4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2>总结</h2>
<p>这一节我们学习了 visitor 模式，通过对象和操作分离的方式使得 AST 和 visitor 可以独立扩展，还可以轻易的结合在一起。</p>
<p>然后学习了 babel 强大的 path，包括它的属性和操作 AST 的 api，以及作用域 scope 的一些概念和 api。</p>
<p>path 的 api 比较多，马上消化不太现实，不用着急，后面实战会大量用到。</p></div>
</body></html>