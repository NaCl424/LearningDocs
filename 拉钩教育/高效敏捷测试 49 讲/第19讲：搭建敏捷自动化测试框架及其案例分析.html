<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第19讲：搭建敏捷自动化测试框架及其案例分析</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>第19讲：搭建敏捷自动化测试框架及其案例分析</h1><p style="text-align: justify; line-height: 1.75em;"></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">在前几讲已经介绍了虚拟化技术、CI/CD 环境、DevOps 下的基础设施及自动部署、BVT 等，而上一讲介绍了静态测试技术和工具，这一讲将侧重介绍动态测试工具，从而形成一个完整的测试基础设施的体系。</span><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">如果只是讨论工具，感觉不够恰当，所以会提升到自动化测试框架这个层次上。因为工具很多，变化也很快，而且换工具是比较容易的，今天喜欢这个工具，就用这个，明天有更好的工具，就可能想换了。经常望着这山比那山高、频繁换工具，也是不合适的，因为团队已经熟练使用工具并积累了良好的经验，与工具联系在一起的脚本值得继承，这些无形资产都值得保护。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">自动化测试框架是测试基础设施的核心部分，不仅提供了各种测试服务，比如测试脚本的开发、执行、调试和管理，测试过程的管理、测试资源的管理，以及支持不同类型的测试（比如性能测试、安全性测试、易用性测试等）执行与分析，而且也希望基于这个框架，让测试与开发平台、CI/CD 环境更加融合，构建更高效的研发平台。 </span></p>
<h3><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 14pt;">自动化测试框架的构成</strong></span></p></h3>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">可以设想一下自动化测试开发与执行的场景：首先，研发人员根据测试任务的要求，开发和调试自动化测试脚本，并能基于脚本和测试环境组合成测试任务，在下班前预先安排好测试任务，比如在某个 Web 页面上提交测试任务，而这些任务能够在当晚自动执行，第二天我们一上班就可以查看测试结果或浏览测试报告。如果晚上执行不顺利，系统则会发消息或邮件给相关人员，让我们检查并处理存在的问题，使得测试能够继续跑下去。当然，如果测试都在半夜执行，不适合人工干预，那就增加一些异常处理机制、重试机制来自动处理这类问题。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">这种测试任务能够按某种机制（比如定时机制、版本构建成功后消息触发机制等）自动启动执行，而且需要自动发现可用的测试资源来执行测试任务，这依赖于资源监控和调度工具 或 平台来完成，并借助代理获得机器状态、运行测试工具和将测试日志发送到特定服务器上以供分析。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">为此，我们需要构建一个自己的自动化测试框架，能够集成测试脚本开发环境、测试执行引擎、测试资源管理、测试报告生产器、函数库、测试数据源和其他可复用模块等为一体，而且还可以灵活地集成其他各种测试工具，包括单元测试工具、API 测试工具和 UI 测试工具等。不同于工具，框架只是实现一个架构，用户可以根据自己的需求进行填充，比如进行二次开发增加具体、特定的功能，还可以集成其他不同的测试工具。图1就展示了自动化测试框架的逻辑结构，由多个组件构成。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<p style="margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: center; text-indent: 29.3333px;">&nbsp; &nbsp;</span></p>
<p style="text-align:center"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><img src="https://s0.lgstatic.com/i/image3/M01/7F/F1/Cgq2xl6DS7GAVWDJAAJ0ZLP_iKQ797.png"></span></p>
<p style="text-align: center; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">图1 &nbsp;自动化测试框架的基本构成</span></p>
<p style="margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<ol>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 11pt;">Harness/IDE</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">：TA 框架的核心，相当于“夹具”，框架的其它组成部分都能与之集成，而且具有脚本的创建、编辑、调试和管理等功能。</span></span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 11pt;">TA 脚本的管理</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">，包括公共脚本库、项目归类的脚本库，这部分可以与 GitHub 这类（代码库）配置管理工具集成。</span></span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 11pt;">测试资源管理</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">：增加、删除和配置相应的测试设备（软硬件资源），并根据它们的使用状态来分配测试资源，这部分可以和容器管理工具集成。</span></span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 11pt;">测试数据管理</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">：测试数据的自动生成、存储、备份和恢复等，也可以演化成一个数据平台，甚至是数据中台。</span></span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 11pt;">开放的接口</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">：提供给其他 CI 环境或其他测试环境的集成接口，这种接口以 API 形式提供，类似之前提到的“基础设施即代码”的概念。</span></span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 11pt;">代理（Agents）</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">：负责 Harness 与工具的通信，控制测试工具的运行。</span></span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 11pt;">任务安排（Scheduler）</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">：安排和提交定时任务、事件触发任务等，以便实现无人值守的自动化测试执行。</span></span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 11pt;">数据统计分析</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">：针对测试结果（含测试工具运行产生的日志），生成可读性良好的测试报告（如 HTML 格式的测试结果），如上一讲提到的 SonarQube、Allure2 等。</span></span></p></li>
</ol>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">自动化测试框架能够与 CI 环境、配置管理系统和缺陷管理系统等集成起来，持续构建后直接触发 BVT、后续的深度自动化测试。这种集成，不仅发生在单元测试、接口层次上，而且还可以在系统层面、业务层面的测试。下面我们就介绍不同层次的自动化测试框架。</span></p>
<h3><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 14pt;">自动化测试框架的分类</strong></span></p></h3>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">结合前面分层自动化测试策略——金字塔模型来划分自动化测试框架更合适一些，从单元测试、接口测试再到 UI 层、ATDD/BDD 的自动化测试框架。</span></p>
<ul>
 <li><p style="line-height: 1.75em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">单元测试框架</span></strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">，由 JUnit 演化成单元测试框架家族 xUnit 最具代表性，形成了单元测试的基本规则，包含了面向各种编程语言的框架，比如 JUnit、CppUnit、NUnit、PyUnit、JsUnit、QUnit、DBUnit、HttpUnit 等。JavaScript 语言，也有一些其他的测试框架，比如 Jasmine、Mocha、Buster.js、DaleJS、PhantomJS、TestSwarm、JsTestDriver 等。</span></span></p></li>
 <li><p style="line-height: 1.75em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">接口测试框架</span></strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">，比如 HttpRunner、Karate、APIfortress、Swagger 等。从框架的角度看，JMeter、SoapUI、Postman、PyTest、APIAutoTest 等算接口测试工具，还不能算框架，而 REST Assured 通常也算 API 框架，它更是为了简化基于 REST 服务的测试而建立的 Java 领域特定语言（DSL），但将它和 JUnit 集成起来，如同 APIAutoTest +TestNG + HttpClient、Unittest + Request + HTMLRunner 等集成，也可形成接口测试框架。Robot Framework 和 Requests 库集成起来，也能执行 API 的测试。</span></p></li>
 <li><p style="line-height: 1.75em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">UI 自动化测试框架</span></strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">，比如面向 Web 的 Selenium + WebDriver、TestCafe 和 Cypress，面向移动 App 的 Appium，面向 Windows 客户端软件的 AutoIT 等。移动 App 还有更多的自动化测试框架，比如基于 Android 的 TA 框架 Robotium、Selendroid、ATAF 等，基于 iOS 的 TA 框架 KIF、Kiwi 等，以及跨平台的 Ranorex Studio、Calabash 等。</span></span></p></li>
 <li><p style="line-height: 1.75em;"><strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">ATDD/BDD 自动化测试框架</span></strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">：Robot Framework、Ginkgo、Cucumber、JBehave/ NBehave / CBehave、SpecFlow、RSpec、JDave、Chakram（REST API）、Concordion、Fitnesse、Guage 等。</span></span></p></li>
</ul>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">在敏捷测试中，更推荐单元测试和基于接口的自动化测试，如果再进一步，ATDD 和 BDD 也是敏捷测试中所推荐的，是更为彻底的自动化，即让需求可执行，将需求变成真正的活文档。而基于 UI 的自动化测试框架更适合传统的开发，或者说不是为敏捷测试而生，所以我们重点会关注单元测试和基于接口的测试、支持 ATDD/BDD 的验收测试等三类自动化测试框架。下面将从这三类框架中各拿出一个工具，做进一步的案例分析。</span></p>
<h3><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 14pt;">单元测试框架 JUnit 5</strong></span></p></h3>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">先说单元测试框架。谈起单元测试框架，不得不介绍 JUnit，它是最为经典的自动化测试框架，也成为了事实上的单元测试框架的业界标准。JUnit 最新版本是 JUnit 5，它不再是一个单一的 jar 包，而是由 JUnit platform（平台）、Jupiter（木星）、Vintage 等三部分组成，如图 2 所示，其显著的新特性有扩展模型、嵌套测试、条件测试、参数化测试等。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: center; text-indent: 29.3333px;">&nbsp; &nbsp;</span></p>
<p style="text-align:center"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><img src="https://s0.lgstatic.com/i/image3/M01/7F/F1/Cgq2xl6DS7KAaMCgAAOhMU05WX4203.png"></span></p>
<p style="text-align: center; text-indent: 29.3333px; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">图2 &nbsp;JUnit 5 架构示意图</span></p>
<ul>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 11pt;">JUnit platform</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">，其主要作用是在 JVM 上启动测试框架，包含一个内部的 JUnit 公共库以及用于测试引擎、配置和启动测试计划、配置测试套件的注释等公共 API，同时还支持通过控制台（Console Launcher）命令、IDE 或构建工具 Gradle、Maven（即借助 surefire-provider、gradle-plugin）等来启动测试。</span></span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 11pt;">JUnit Jupiter</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">，包含了 JUnit5 最新的编程模型（注释、类、方法）和扩展机制的组合（Jupiter API）和一个测试引擎（Test Engine），用于编写和执行 JUnit 5 的新测试，其中 junit-jupiter-params 为参数化测试提供支持。</span></span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 11pt;">JUnit Vintage</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63); font-size: 11pt;">，一个测试引擎，允许在平台上运行老的 JUnit 3 和 JUnit 4 测试用例，从而确保必要的向后兼容性。</span></span></p></li>
</ul>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><img src="https://s0.lgstatic.com/i/image3/M01/06/DB/Ciqah16DS7OAByspAATY-yR0P7s026.png"></span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">通过上面这张注释列表，能感受到 JUnit 5 更强大的功能。例如，扩展机制通过 @ExtendWith 定义，简单明了。</span></p>
<p style="text-align: center; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><img src="https://s0.lgstatic.com/i/image3/M01/7F/F1/Cgq2xl6DS7SALitAAAC-g88oR88747.png" style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: left;"><br></p>
<p style="margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">可以通过 @ParameterizedTest 来定义参数化测试方法，而且还可以和其他注释组合使用，指定多个来源，包括 @ValueSource、@MethodSource、@CsvSource、@ArgumentSource 等。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><img src="https://s0.lgstatic.com/i/image3/M01/7F/F1/Cgq2xl6DS7SACmmzAAELY0rfXsQ913.png" style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: center;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: center;">&nbsp; &nbsp; &nbsp;&nbsp;</span><br></p>
<h3><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 14pt;">API 层的 TA 测试框架 Karate</strong></span></p></h3>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">API 层的自动化测试框架，如上所列，也有很多，要选择适合自己的框架，也不是容易的事情，可以选择自己熟悉的工具，比如 HttpRunner、JMeter、Postman 等。这里介绍一个由 Intuit 公司开发并开源的 API 测试框架 Karate，它不仅提供了源代码，而且还提供了比较完整的文档和演示实例，值得关注。这个框架，官方列出了 30 多个优点（特性），这里从中选出十大优点，供参考。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">（1）纯文本脚本，可以调用其他脚本，能调用 JDK 类、Java 库，并具有嵌入式 JavaScript 引擎，可构建适合特定环境的、可重复使用的功能库，具有良好的可扩展性。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">（2）标准的 Java / Maven 项目结构，以及与 CI / CD 管道的无缝集成，并支持 JUnit 5。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">（3）优雅的 DSL 语法原生地支持 JSON 和 XML，包括 JsonPath 和 XPath 表达式，覆盖数据的输入和结果的输出。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">（4）基于流行的 Cucumber / Gherkin 标准，支持 BDD（Cucumber 场景 Scenario Outline 表），并内置与 Cucumber 兼容的测试报告。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">（5）内置对数据驱动测试的支持，原生支持读取 YAML 甚至 CSV 文件，并能够标记或分组测试，其场景数据支持友好的 JSON、XML 或其独有的 payload 生成器方法。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">（6）全面的断言功能，容易定位故障，清楚地报告哪个数据元素（和路径）与预期不符。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">（7）多线程并行执行，内置分布式测试功能，可用于 API 测试而无需任何复杂的“网格”基础架构，从而显著节省测试时间，简化测试环境准备工作。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">（8）API mocks&nbsp;or test-doubles 甚至可以在多个调用之间维持 CRUD 的“状态”，从而支持微服务和消费者驱动的契约测试。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">（9）模拟 HTTP Servlet，可以测试任何控制器 Servlet，例如，Spring Boot / MVC 或 Jersey / JAX-RS- 无需启动应用程序服务器，可以使用未更改的 HTTP 集成测试。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">（10）全面支持不同类型的 HTTP 调用：</span></p>
<ul>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">SOAP / XML 请求</span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">HTTPS / SSL，不需要证书、密钥库等</span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">HTTP 代理服务器</span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">URL 编码的 HTML 表单数据</span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">Multi-part&nbsp;文件上传、Cookie 处理的支持</span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">HTTP &nbsp;head、路径和查询参数的完全控制</span></p></li>
 <li><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">WebSocket 支持</span></p></li>
</ul>
<p style="margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">这里展示了一个简单的 WebSocket 测试示例，用到了 Given-When-Then 这种 BDD 的场景描述方式。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: center;">&nbsp;&nbsp;</span><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><img src="https://s0.lgstatic.com/i/image3/M01/06/DB/Ciqah16DS7SAGHabAAI2mQSVPr0618.png"></span></p>
<h3><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><strong style="font-size: 14pt;">验收测试框架 Ginkgo</strong></span></p></h3>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">最后来分析一个验收测试的自动化测试框架，比较著名的有前面提到的 Cucumber 和 Robot Framework，今天介绍一个用 Go 语言开发的框架 Ginkgo（银杏），它对 BDD&nbsp;有很好地支持，拥有自己的 DSL，包括嵌套的 Describe、Context 和 When 容器模块，BeforeEach / AfterEach、BeforeSuite / AfterSuite、It / Specify 等也一应俱全，这样就能帮助我们组织和编排测试用例了。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">先上一个例子，让你感受一下，测试用例的业务场景是多么清晰、脚本的可读性多么良好，这会大大降低脚本后期的维护成本。&nbsp;</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><img src="https://s0.lgstatic.com/i/image3/M01/7F/F1/Cgq2xl6DS7SAcGZqAALGj2LPtOI090.png"></span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><img src="https://s0.lgstatic.com/i/image3/M01/06/DB/Ciqah16DS7WAe7w8AAJAcD6Gwnw799.png"></span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">Go 语言擅长并行处理，Ginkgo 并行执行能力也就是原生的能力，实现了进程级并行执行测试的能力，既节省时间，稳定性也大大提高，也特别适合现在流行的容器环境，一个容器跑一个进程，可以直接在每个容器上运行命令 ginkgo -p 来执行测试。而且，ginkgo CLI 工具在并行执行测试时，会起一个监听随机端口的服务来实现不同进程之间的消息同步、日志和报告的聚合工作，从而输出整齐漂亮的日志和测试报告。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">下面给出 ginkgo 几个命令，可以看出：非常方便地实现并行执行、代码覆盖率度量和 XUnit 测试包的转换。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<pre><p>ginkgo -nodes = N 在N个并行进程中运行测试，并实时打印出一致的输出<br>ginkgo -cover 使用Go的代码覆盖率工具运行测试<br>ginkgo -coverprofile=FILENAME 指定覆盖率文件名称<br>ginkgo -outputdir=DIRECTORY 指定覆盖率文件存放目录<br>ginkgo convert将XUnit样式的测试包转换为Ginkgo样式的包</p></pre>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">通过 ginkgo build、ginkgo -notify 等命令，还能进行测试服务分发、执行工作流时实现消息通知，这样很容易和 CI/CD（如 Jinkins）集成起来，实现全流程的自动化测试。通过 ginkgo bootstrap、ginkgo generate 可以创建测试集、测试用例模板，从而更好地实现测试复用。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<pre><p>ginkgo build PACKAGE_PATH编译测试集成.test文件，可部署到其他地方执行<br>ginkgo -notify 执行完成后触发通知，需要按照对应插件<br>ginkgo -r &nbsp;递归执行文件夹内的所有测试用例<br>ginkgo bootstrap 创建测试集模板文件，会生成xxx_suite_test.go文件<br>ginkgo generate xxx 创建测试用例模板文件</p></pre>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">Ginkgo 也支持第三方测试库：Gomock 和 Testify，还能和 Google Go 的 Agouti（基于浏览器的验收测试测试库）集成。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">Ginkgo 借助 Gomega（匹配器 / 断言库，是 Ginkgo BDD 测试框架的最佳搭档）的 Eventually 和 Consistently 两大功能提供了原生的异步支持，能大大降低死锁或者未设置超时而异常卡住等问题的风险，提升执行的稳定性，而且能够减少没必要的等待时间。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<pre><p>Eventually(func() []int {<br> &nbsp; &nbsp;return thing.SliceImMonitoring<br>}, TIMEOUT, POLLING_INTERVAL).Should(HaveLen(2))</p></pre>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<pre><p>Consistently(func() []int {<br> &nbsp; &nbsp;return thing.MemoryUsage()<br>}, DURATION, POLLING_INTERVAL).Should(BeNumerically("&lt;", 10))</p></pre>
<p style="margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">针对分布式系统进行集成测试时，这个功能也很有用。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<pre><p>externalProcess.DoSomethingAmazing()<br>Eventually(func() bool {<br> &nbsp; &nbsp;return somethingAmazingHappened()<br>}).Should(BeTrue())</p></pre>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">至此，完成了本讲要讨论的内容，主要讨论了自动化测试框架的构成与分类，并从中选了三个具有代表性的框架进行了分析与展示，它们分别是单元测试框架 JUnit 5、API 层的 TA 测试框架Karate 和验收测试框架 Ginkgo。</span></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p>
<p style="text-align: left; margin-bottom: 0pt; margin-top: 0pt; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">最后留一个思考题，如果让你在 Ginkgo 和 Robot Framework 中选择一个框架，你会选择哪一个？为什么？欢迎留言参与讨论。</span></p></div>

</body></html>