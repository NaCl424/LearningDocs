<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lagou DOC</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>08 | 深入 React-Hooks 工作机制：“原则”的背后，是“原理”</h1><p data-nodeid="8633" class="">React 团队面向开发者给出了两条 React-Hooks 的使用原则，原则的内容如下：</p>
<ol data-nodeid="8634">
<li data-nodeid="8635">
<p data-nodeid="8636">只在 React 函数中调用 Hook；</p>
</li>
<li data-nodeid="8637">
<p data-nodeid="8638">不要在循环、条件或嵌套函数中调用 Hook。</p>
</li>
</ol>
<p data-nodeid="8639">原则 1 无须多言，React-Hooks 本身就是 React 组件的“钩子”，在普通函数里引入意义不大。我相信更多的人在原则 2 上栽过跟头，或者说至今仍然对它半信半疑。其实，原则 2 中强调的所有“<strong data-nodeid="8722">不要</strong>”，都是在指向同一个目的，那就是<strong data-nodeid="8723">要确保 Hooks 在每次渲染时都保持同样的执行顺序</strong>。</p>
<p data-nodeid="8640">为什么顺序如此重要？这就要从 Hooks 的实现机制说起了。这里我就以 useState 为例，带你从现象入手，深度探索一番 React-Hooks 的工作原理。</p>
<p data-nodeid="8641">注：本讲 Demo 基于 React 16.8.x 版本进行演示。</p>
<h3 data-nodeid="8642">从现象看问题：若不保证 Hooks 执行顺序，会带来什么麻烦？</h3>
<p data-nodeid="8643">先来看一个小 Demo：</p>
<pre class="lang-javascript" data-nodeid="8644"><code data-language="javascript"><span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonalInfoComponent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 集中定义变量</span>
  <span class="hljs-keyword">let</span> name, age, career, setName, setCareer;

  <span class="hljs-comment">// 获取姓名状态</span>
  [name, setName] = useState(<span class="hljs-string">"修言"</span>);

  <span class="hljs-comment">// 获取年龄状态</span>
  [age] = useState(<span class="hljs-string">"99"</span>);

  <span class="hljs-comment">// 获取职业状态</span>
  [career, setCareer] = useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>);

  <span class="hljs-comment">// 输出职业信息</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"career"</span>, career);

  <span class="hljs-comment">// 编写 UI 逻辑</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"personalInfo"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：{name}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>职业：{career}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
          setName("秀妍");
        }}
      &gt;
        修改姓名
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PersonalInfoComponent;
</code></pre>
<p data-nodeid="8645">这个 PersonalInfoComponent 组件渲染出来的界面长这样：</p>
<p data-nodeid="8646"><img src="https://s0.lgstatic.com/i/image/M00/89/5F/Ciqc1F_YT0uAT1kZAACw9EfbQe8557.png" alt="1.png" data-nodeid="8731"></p>
<p data-nodeid="10684" class="te-preview-highlight">PersonalInfoComponent 用于对个人信息进行展示，这里展示的内容包括姓名、年龄、职业。出于测试效果需要，PersonalInfoComponent 还允许你点击“修改姓名”按钮修改姓名信息。点击一次后，“修言”会被修改为“秀妍”，如下图所示：</p>





<p data-nodeid="8648"><img src="https://s0.lgstatic.com/i/image/M00/89/6A/CgqCHl_YT1qAUSuVAAC-xZcsk54138.png" alt="2.png" data-nodeid="8735"></p>
<p data-nodeid="8649">到目前为止，组件的行为都是符合我们的预期的，一切看上去都是那么的和谐。但倘若我对代码做一丝小小的改变，把一部分的 useState 操作放进 if 语句里，事情就会变得大不一样。改动后的代码如下：</p>
<pre class="lang-js" data-nodeid="8650"><code data-language="js"><span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-comment">// isMounted 用于记录是否已挂载（是否是首次渲染）</span>
<span class="hljs-keyword">let</span> isMounted = <span class="hljs-literal">false</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonalInfoComponent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 定义变量的逻辑不变</span>
  <span class="hljs-keyword">let</span> name, age, career, setName, setCareer;

  <span class="hljs-comment">// 这里追加对 isMounted 的输出，这是一个 debug 性质的操作</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"isMounted is"</span>, isMounted);
  <span class="hljs-comment">// 这里追加 if 逻辑：只有在首次渲染（组件还未挂载）时，才获取 name、age 两个状态</span>
  <span class="hljs-keyword">if</span> (!isMounted) {
    <span class="hljs-comment">// eslint-disable-next-line</span>
    [name, setName] = useState(<span class="hljs-string">"修言"</span>);
    <span class="hljs-comment">// eslint-disable-next-line</span>
    [age] = useState(<span class="hljs-string">"99"</span>);

    <span class="hljs-comment">// if 内部的逻辑执行一次后，就将 isMounted 置为 true（说明已挂载，后续都不再是首次渲染了）</span>
    isMounted = <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// 对职业信息的获取逻辑不变</span>
  [career, setCareer] = useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>);
  <span class="hljs-comment">// 这里追加对 career 的输出，这也是一个 debug 性质的操作</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"career"</span>, career);
  <span class="hljs-comment">// UI 逻辑的改动在于，name和age成了可选的展示项，若值为空，则不展示</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"personalInfo"</span>&gt;</span>
      {name ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：{name}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : null}
      {age ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : null}
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>职业：{career}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
          setName("秀妍");
        }}
      &gt;
        修改姓名
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PersonalInfoComponent;
</code></pre>
<p data-nodeid="8651">修改后的组件在初始渲染的时候，界面与上个版本无异：</p>
<p data-nodeid="8652"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJDaAC6-qAACIdJOIg3E041.png" alt="Drawing 5.png" data-nodeid="8740"></p>
<p data-nodeid="8653">注意，你在自己电脑上模仿这段代码的时候，千万不要漏掉 if 语句里面<code data-backticks="1" data-nodeid="8742">// eslint-disable-next-line</code>这个注释——因为目前大部分的 React 项目都在内部预置了对 React-Hooks-Rule（React-Hooks 使用规则）的强校验，而示例代码中把 Hooks 放进 if 语句的操作作为一种不合规操作，会被直接识别为 Error 级别的错误，进而导致程序报错。这里我们只有将相关代码的 eslint 校验给禁用掉，才能够避免校验性质的报错，从而更直观地看到错误的效果到底是什么样的，进而理解错误的原因。</p>
<p data-nodeid="8654">修改后的组件在初始挂载的时候，实际执行的逻辑内容和上个版本是没有区别的，都涉及对 name、age、career 三个状态的获取和渲染。理论上来说，<strong data-nodeid="8749">变化应该发生在我单击“修改姓名”之后触发的二次渲染里</strong>：二次渲染时，isMounted 已经被置为 true，if 内部的逻辑会被直接跳过。此时按照代码注释中给出的设计意图，这里我希望在二次渲染时，只获取并展示 career 这一个状态。那么事情是否会如我所愿呢？我们一起来看看单击“修改姓名”按钮后会发生什么：</p>
<p data-nodeid="8655"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJEOAMfdIAAJ8aDhIGdA549.png" alt="Drawing 7.png" data-nodeid="8752"></p>
<p data-nodeid="8656">组件不仅没有像预期中一样发生界面变化，甚至直接报错了。报错信息提醒我们，这是因为“<strong data-nodeid="8758">组件渲染的 Hooks 比期望中更少</strong>”。</p>
<p data-nodeid="8657">确实，按照现有的逻辑，初始渲染调用了三次 useState，而二次渲染时只会调用一次。但仅仅因为这个，就要报错吗？</p>
<p data-nodeid="8658">按道理来说，二次渲染的时候，只要我获取到的 career 值没有问题，那么渲染就应该是没有问题的（因为二次渲染实际只会渲染 career 这一个状态），React 就没有理由阻止我的渲染动作。啊这……难道是 career 出问题了吗？还好我们预先留了一手 Debug 逻辑，每次渲染的时候都会尝试去输出一次 isMounted 和 career 这两个变量的值。现在我们就赶紧来看看，这两个变量到底是什么情况。</p>
<p data-nodeid="8659">首先我将界面重置回初次挂载的状态，观察控制台的输出，如下图所示：</p>
<p data-nodeid="8660"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJHSAL8SuAAHP-0rTPKY784.png" alt="Drawing 9.png" data-nodeid="8764"></p>
<p data-nodeid="8661">这里我把关键的 isMounted 和 career 两个变量用红色框框圈了出来：isMounted 值为 false，说明是初次渲染；career 值为“我是一个前端，爱吃小熊饼干”，这也是没有问题的。</p>
<p data-nodeid="8662">接下来单击“修改姓名”按钮后，我们再来看一眼两个变量的内容，如下图所示：</p>
<p data-nodeid="8663"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJRiAP2doAAKt-ZhwxQ0744.png" alt="图片11.png" data-nodeid="8769"></p>
<p data-nodeid="8664">二次渲染时，isMounted 为 true，这个没毛病。但是 career 竟然被修改为了“秀妍”，这也太诡异了？代码里面可不是这么写的。赶紧回头确认一下按钮单击事件的回调内容，代码如下所示：</p>
<pre class="lang-js" data-nodeid="8665"><code data-language="js"> &lt;button
   onClick={() =&gt; {
    setName(<span class="hljs-string">"秀妍"</span>);
  }}
   &gt;
  修改姓名
&lt;/button&gt;
</code></pre>
<p data-nodeid="8666">确实，代码是没错的，我们调用的是 setName，那么它修改的状态也应该是 name，而不是 career。</p>
<p data-nodeid="8667">那为什么最后发生变化的竟然是 career 呢？年轻人，不如我们一起来看一看 Hooks 的实现机制吧！</p>
<h3 data-nodeid="8668">从源码调用流程看原理：Hooks 的正常运作，在底层依赖于顺序链表</h3>
<p data-nodeid="8669">这里强调“源码流程”而非“源码”，主要有两方面的考虑：</p>
<ol data-nodeid="8670">
<li data-nodeid="8671">
<p data-nodeid="8672">React-Hooks 在源码层面和 Fiber 关联十分密切，我们目前仍然处于基础夯实阶段，对 Fiber 机制相关的底层实现暂时没有讨论，盲目啃源码在这个阶段来说没有意义；</p>
</li>
<li data-nodeid="8673">
<p data-nodeid="8674">原理 !== 源码，阅读源码只是掌握原理的一种手段，在某些场景下，阅读源码确实能够迅速帮我们定位到问题的本质（比如 React.createElement 的源码就可以快速帮我们理解 JSX 转换出来的到底是什么东西）；而 React-Hooks 的源码链路相对来说比较长，涉及的关键函数 renderWithHooks 中“脏逻辑”也比较多，整体来说，学习成本比较高，学习效果也难以保证。</p>
</li>
</ol>
<p data-nodeid="8675">综上所述，这里我不会精细地贴出每一行具体的源码，而是针对关键方法做重点分析。同时我也<strong data-nodeid="8788">不建议你在对 Fiber 底层实现没有认知的前提下去和 Hooks 源码死磕</strong>。对于搞清楚“Hooks 的执行顺序为什么必须一样”这个问题来说，重要的并不是去细抠每一行代码到底都做了什么，而是要搞清楚整个<strong data-nodeid="8789">调用链路</strong>是什么样的。如果我们能够理解 Hooks 在每个关键环节都做了哪些事情，同时也能理解这些关键环节是如何对最终的渲染结果产生影响的，那么理解 Hooks 的工作机制对于你来说就不在话下了。</p>
<h4 data-nodeid="8676">以 useState 为例，分析 React-Hooks 的调用链路</h4>
<p data-nodeid="8677">首先要说明的是，React-Hooks 的调用链路在首次渲染和更新阶段是不同的，这里我将两个阶段的链路各总结进了两张大图里，我们依次来看。首先是首次渲染的过程，请看下图：</p>
<p data-nodeid="8678"><img src="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJYCAWVjCAAEtNT9pGHA170.png" alt="图片12.png" data-nodeid="8794"></p>
<p data-nodeid="8679">在这个流程中，useState 触发的一系列操作最后会落到 mountState 里面去，所以我们重点需要关注的就是 mountState 做了什么事情。以下我为你提取了 mountState 的源码：</p>
<pre class="lang-java" data-nodeid="8680"><code data-language="java"><span class="hljs-comment">// 进入 mounState 逻辑</span>
<span class="hljs-function">function <span class="hljs-title">mountState</span><span class="hljs-params">(initialState)</span> </span>{

  <span class="hljs-comment">// 将新的 hook 对象追加进链表尾部</span>
  <span class="hljs-keyword">var</span> hook = mountWorkInProgressHook();

  <span class="hljs-comment">// initialState 可以是一个回调，若是回调，则取回调执行后的值</span>
  <span class="hljs-keyword">if</span> (typeof initialState === <span class="hljs-string">'function'</span>) {
    <span class="hljs-comment">// $FlowFixMe: Flow doesn't like mixed types</span>
    initialState = initialState();
  }

  <span class="hljs-comment">// 创建当前 hook 对象的更新队列，这一步主要是为了能够依序保留 dispatch</span>
  <span class="hljs-keyword">const</span> queue = hook.queue = {
    last: <span class="hljs-keyword">null</span>,
    dispatch: <span class="hljs-keyword">null</span>,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: (initialState: any),
  };

  <span class="hljs-comment">// 将 initialState 作为一个“记忆值”存下来</span>
  hook.memoizedState = hook.baseState = initialState;

  <span class="hljs-comment">// dispatch 是由上下文中一个叫 dispatchAction 的方法创建的，这里不必纠结这个方法具体做了什么</span>
  <span class="hljs-keyword">var</span> dispatch = queue.dispatch = dispatchAction.bind(<span class="hljs-keyword">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, queue);
  <span class="hljs-comment">// 返回目标数组，dispatch 其实就是示例中常常见到的 setXXX 这个函数，想不到吧？哈哈</span>
  <span class="hljs-keyword">return</span> [hook.memoizedState, dispatch];
}
</code></pre>
<p data-nodeid="8681">从这段源码中我们可以看出，<strong data-nodeid="8801">mounState 的主要工作是初始化 Hooks</strong>。在整段源码中，最需要关注的是 mountWorkInProgressHook 方法，它为我们道出了 Hooks 背后的数据结构组织形式。以下是 mountWorkInProgressHook 方法的源码：</p>
<pre class="lang-java" data-nodeid="8682"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">mountWorkInProgressHook</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// 注意，单个 hook 是以对象的形式存在的</span>
  <span class="hljs-keyword">var</span> hook = {
    memoizedState: <span class="hljs-keyword">null</span>,
    baseState: <span class="hljs-keyword">null</span>,
    baseQueue: <span class="hljs-keyword">null</span>,
    queue: <span class="hljs-keyword">null</span>,
    next: <span class="hljs-keyword">null</span>
  };
  <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-keyword">null</span>) {
    <span class="hljs-comment">// 这行代码每个 React 版本不太一样，但做的都是同一件事：将 hook 作为链表的头节点处理</span>
    firstWorkInProgressHook = workInProgressHook = hook;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 若链表不为空，则将 hook 追加到链表尾部</span>
    workInProgressHook = workInProgressHook.next = hook;
  }
  <span class="hljs-comment">// 返回当前的 hook</span>
  <span class="hljs-keyword">return</span> workInProgressHook;
}
</code></pre>
<p data-nodeid="8683">到这里可以看出，<strong data-nodeid="8807">hook 相关的所有信息收敛在一个 hook 对象里，而 hook 对象之间以单向链表的形式相互串联</strong>。</p>
<p data-nodeid="8684">接下来我们再看更新过程的大图：</p>
<p data-nodeid="8685"><img src="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJTGANs5yAAD4e6ACv8Q643.png" alt="图片13.png" data-nodeid="8811"></p>
<p data-nodeid="8686">根据图中高亮部分的提示不难看出，首次渲染和更新渲染的区别，在于调用的是 mountState，还是 updateState。mountState 做了什么，你已经非常清楚了；而 updateState 之后的操作链路，虽然涉及的代码有很多，但其实做的事情很容易理解：<strong data-nodeid="8817">按顺序去遍历之前构建好的链表，取出对应的数据信息进行渲染</strong>。</p>
<p data-nodeid="8687">我们把 mountState 和 updateState 做的事情放在一起来看：mountState（首次渲染）构建链表并渲染；updateState 依次遍历链表并渲染。</p>
<p data-nodeid="8688">看到这里，你是不是已经大概知道怎么回事儿了？没错，<strong data-nodeid="8824">hooks 的渲染是通过“依次遍历”来定位每个 hooks 内容的。如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然是不可控的</strong>。</p>
<p data-nodeid="8689">这个现象有点像我们构建了一个长度确定的数组，数组中的每个坑位都对应着一块确切的信息，后续每次从数组里取值的时候，只能够通过索引（也就是位置）来定位数据。也正因为如此，在许多文章里，都会直截了当地下这样的定义：Hooks 的本质就是数组。但读完这一课时的内容你就会知道，<strong data-nodeid="8830">Hooks 的本质其实是链表</strong>。</p>
<p data-nodeid="8690">接下来我们把这个已知的结论还原到 PersonalInfoComponent 里去，看看实际项目中，变量到底是怎么发生变化的。</p>
<h3 data-nodeid="8691">站在底层视角，重现 PersonalInfoComponent 组件的执行过程</h3>
<p data-nodeid="8692">我们先来复习一下修改过后的 PersonalInfoComponent 组件代码：</p>
<pre class="lang-js" data-nodeid="8693"><code data-language="js"><span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-comment">// isMounted 用于记录是否已挂载（是否是首次渲染）</span>
<span class="hljs-keyword">let</span> isMounted = <span class="hljs-literal">false</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonalInfoComponent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 定义变量的逻辑不变</span>
  <span class="hljs-keyword">let</span> name, age, career, setName, setCareer;

  <span class="hljs-comment">// 这里追加对 isMounted 的输出，这是一个 debug 性质的操作</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"isMounted is"</span>, isMounted);
  <span class="hljs-comment">// 这里追加 if 逻辑：只有在首次渲染（组件还未挂载）时，才获取 name、age 两个状态</span>
  <span class="hljs-keyword">if</span> (!isMounted) {
    <span class="hljs-comment">// eslint-disable-next-line</span>
    [name, setName] = useState(<span class="hljs-string">"修言"</span>);
    <span class="hljs-comment">// eslint-disable-next-line</span>
    [age] = useState(<span class="hljs-string">"99"</span>);

    <span class="hljs-comment">// if 内部的逻辑执行一次后，就将 isMounted 置为 true（说明已挂载，后续都不再是首次渲染了）</span>
    isMounted = <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// 对职业信息的获取逻辑不变</span>
  [career, setCareer] = useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>);
  <span class="hljs-comment">// 这里追加对 career 的输出，这也是一个 debug 性质的操作</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"career"</span>, career);
  <span class="hljs-comment">// UI 逻辑的改动在于，name 和 age 成了可选的展示项，若值为空，则不展示</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"personalInfo"</span>&gt;</span>
      {name ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：{name}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : null}
      {age ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : null}
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>职业：{career}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
          setName("秀妍");
        }}
      &gt;
        修改姓名
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PersonalInfoComponent;
</code></pre>
<p data-nodeid="8694">从代码里面，我们可以提取出来的 useState 调用有三个：</p>
<pre class="lang-java" data-nodeid="8695"><code data-language="java">[name, setName] = useState(<span class="hljs-string">"修言"</span>);
[age] = useState(<span class="hljs-string">"99"</span>);
[career, setCareer] = useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>);
</code></pre>
<p data-nodeid="8696">这三个调用在首次渲染的时候都会发生，伴随而来的链表结构如图所示：</p>
<p data-nodeid="8697"><img src="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJUWAe27kAAC_6mxli_Q918.png" alt="图片14.png" data-nodeid="8838"></p>
<p data-nodeid="8698">当首次渲染结束，进行二次渲染的时候，实际发生的 useState 调用只有一个：</p>
<pre class="lang-java" data-nodeid="8699"><code data-language="java">useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>)
</code></pre>
<p data-nodeid="8700">而此时的链表情况如下图所示：</p>
<p data-nodeid="8701"><img src="https://s0.lgstatic.com/i/image/M00/67/65/CgqCHl-hJeCAY_aoAAF7Tt5bK8k880.png" alt="图片15.png" data-nodeid="8843"></p>
<p data-nodeid="8702">我们再复习一遍更新（二次渲染）的时候会发生什么事情：updateState 会依次遍历链表、读取数据并渲染。注意这个过程就像从数组中依次取值一样，是完全按照顺序（或者说索引）来的。因此 React 不会看你命名的变量名是 career 还是别的什么，它只认你这一次 useState 调用，于是它难免会认为：<strong data-nodeid="8849">喔，原来你想要的是第一个位置的 hook 啊</strong>。</p>
<p data-nodeid="8703">然后就会有下面这样的效果：</p>
<p data-nodeid="8704"><img src="https://s0.lgstatic.com/i/image/M00/67/65/CgqCHl-hJe2ATIhGAAHpze3gFHg893.png" alt="图片16.png" data-nodeid="8853"></p>
<p data-nodeid="8705">如此一来，career 就自然而然地取到了链表头节点 hook 对象中的“秀妍”这个值。</p>
<h3 data-nodeid="8706">总结</h3>
<p data-nodeid="8707">三个课时学完了，到这里，我们对 React-Hooks 的学习，才终于算是告一段落。</p>
<p data-nodeid="8708">在过去的三个课时里，我们摸排了“动机”，认知了“工作模式”，最后更是结合源码、深挖了一把 React-Hooks 的底层原理。我们所做的这所有的努力，都是为了能够真正吃透 React-Hooks，不仅要确保实践中不出错，还要做到面试时有底气。</p>
<p data-nodeid="8709" class="">接下来，我们就将进入整个专栏真正的“深水区”，逐步切入“虚拟 DOM → Diff 算法 → Fiber 架构”这个知识链路里来。在后续的学习中，我们将延续并且强化这种“刨根问底”的风格，紧贴源码、原理和面试题来向 React 最为核心的部分发起挑战。真正的战斗，才刚刚开始，大家加油~</p></div>

</body></html>