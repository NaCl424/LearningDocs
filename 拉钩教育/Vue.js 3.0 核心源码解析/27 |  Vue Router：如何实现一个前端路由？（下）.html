<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lagou DOC</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>27 |  Vue Router：如何实现一个前端路由？（下）</h1><p data-nodeid="391">上节课我们学习了 Vue Router 的基本用法，并且开始探究它的实现原理，今天我们继续未完的原理，一起来看路径是如何和路由组件映射的。</p>



<h3 data-nodeid="4">路径和路由组件的渲染的映射</h3>
<p data-nodeid="5">通过前面的示例我们了解到，路由组件就是通过 RouterView 组件渲染的，那么 RouterView 是怎么渲染的呢，我们来看它的实现：</p>
<pre class="lang-java" data-nodeid="6"><code data-language="java"><span class="hljs-keyword">const</span> RouterView = defineComponent({
  name: <span class="hljs-string">'RouterView'</span>,
  props: {
    name: {
      type: String,
      <span class="hljs-keyword">default</span>: <span class="hljs-string">'default'</span>,
    },
    route: Object,
  },
  setup(props, { attrs, slots }) {
    warnDeprecatedUsage()
    <span class="hljs-keyword">const</span> injectedRoute = inject(routeLocationKey)
    <span class="hljs-keyword">const</span> depth = inject(viewDepthKey, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> matchedRouteRef = computed(() =&gt; (props.route || injectedRoute).matched[depth])
    provide(viewDepthKey, depth + <span class="hljs-number">1</span>)
    provide(matchedRouteKey, matchedRouteRef)
    <span class="hljs-keyword">const</span> viewRef = ref()
    watch(() =&gt; [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) =&gt; {
      <span class="hljs-keyword">if</span> (to) {
        to.instances[name] = <span class="hljs-function">instance
        <span class="hljs-title">if</span> <span class="hljs-params">(from &amp;&amp; instance === oldInstance)</span> </span>{
          to.leaveGuards = from.leaveGuards
          to.updateGuards = from.updateGuards
        }
      }
      <span class="hljs-keyword">if</span> (instance &amp;&amp;
        to &amp;&amp;
        (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach(callback =&gt; callback(instance))
      }
    })
    <span class="hljs-keyword">return</span> () =&gt; {
      <span class="hljs-keyword">const</span> route = props.route || injectedRoute
      <span class="hljs-keyword">const</span> matchedRoute = matchedRouteRef.value
      <span class="hljs-keyword">const</span> ViewComponent = matchedRoute &amp;&amp; matchedRoute.components[props.name]
      <span class="hljs-keyword">const</span> currentName = props.<span class="hljs-function">name
      <span class="hljs-title">if</span> <span class="hljs-params">(!ViewComponent)</span> </span>{
        <span class="hljs-keyword">return</span> slots.<span class="hljs-keyword">default</span>
          ? slots.<span class="hljs-keyword">default</span>({ Component: ViewComponent, route })
          : <span class="hljs-keyword">null</span>
      }
      <span class="hljs-keyword">const</span> routePropsOption = matchedRoute.props[props.name]
      <span class="hljs-keyword">const</span> routeProps = routePropsOption
        ? routePropsOption === <span class="hljs-keyword">true</span>
          ? route.params
          : typeof routePropsOption === <span class="hljs-string">'function'</span>
            ? routePropsOption(route)
            : routePropsOption
        : <span class="hljs-keyword">null</span>
      <span class="hljs-keyword">const</span> onVnodeUnmounted = vnode =&gt; {
        <span class="hljs-keyword">if</span> (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = <span class="hljs-keyword">null</span>
        }
      }
      <span class="hljs-keyword">const</span> component = h(ViewComponent, assign({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef,
      }))
      <span class="hljs-keyword">return</span> (
        slots.<span class="hljs-keyword">default</span>
          ? slots.<span class="hljs-keyword">default</span>({ Component: component, route })
          : component)
    }
  },
})
</code></pre>
<p data-nodeid="7">RouterView 组件也是基于 composition API 实现的，我们重点看它的渲染部分，由于 setup 函数的返回值是一个函数，那这个函数就是它的渲染函数。</p>
<p data-nodeid="8">我们从后往前看，通常不带插槽的情况下，会返回 component 变量，它是根据 ViewComponent 渲染出来的，而ViewComponent 是根据matchedRoute.components[props.name] 求得的，而matchedRoute 是 matchedRouteRef对应的 value。</p>
<p data-nodeid="9">matchedRouteRef 一个计算属性，在不考虑 prop 传入 route 的情况下，它的 getter 是由 injectedRoute.matched[depth] 求得的，而 injectedRoute，就是我们在前面在安装路由时候，注入的响应式 currentRoute 对象，而 depth 就是表示这个 RouterView 的嵌套层级。</p>
<p data-nodeid="10">所以我们可以看到，RouterView 的渲染的路由组件和当前路径 currentRoute 的 matched 对象相关，也和 RouterView 自身的嵌套层级相关。</p>
<p data-nodeid="11">那么接下来，我们就来看路径对象中的 matched 的值是怎么在路径切换的情况下更新的。</p>
<p data-nodeid="12">我们还是通过示例的方式来说明，我们对前面的示例稍做修改，加上嵌套路由的场景：</p>
<pre class="lang-js" data-nodeid="645"><code data-language="js"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> { createRouter, createWebHashHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">const</span> Home = { <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;Home&lt;/div&gt;'</span> }
<span class="hljs-keyword">const</span> About = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">\`&lt;div&gt;About
  &lt;router-link to="/about/user"&gt;Go User&lt;/router-link&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;\`</span>
}
<span class="hljs-keyword">const</span> User = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;User&lt;/div&gt;,'</span>
}
<span class="hljs-keyword">const</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">component</span>: Home },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>,
    <span class="hljs-attr">component</span>: About,
    <span class="hljs-attr">children</span>: [
      {
        <span class="hljs-attr">path</span>: <span class="hljs-string">'user'</span>,
        <span class="hljs-attr">component</span>: User
      }
    ]
  }
]
<span class="hljs-keyword">const</span> router = createRouter({
  <span class="hljs-attr">history</span>: createWebHashHistory(),
  routes
})
<span class="hljs-keyword">const</span> app = createApp({})
app.use(router)
app.mount(<span class="hljs-string">'#app'</span>)
</code></pre>
<p data-nodeid="646">它和前面示例的区别在于，我们在 About 路由组件中又嵌套了一个 RouterView 组件，然后对 routes 数组中 path 为 /about 的路径配置扩展了 children 属性，对应的就是 About 组件嵌套路由的配置。</p>
<p data-nodeid="647">当我们执行 createRouter 函数创建路由的时候，内部会执行如下代码来创建一个 matcher 对象：</p>
<pre class="lang-java" data-nodeid="648"><code data-language="java"><span class="hljs-keyword">const</span> matcher = createRouterMatcher(options.routes, options)
</code></pre>
<p data-nodeid="649">执行了createRouterMatcher 函数，并传入 routes 路径配置数组，它的目的就是根据路径配置对象创建一个路由的匹配对象，再来看它的实现：</p>
<pre class="lang-java" data-nodeid="650"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createRouterMatcher</span><span class="hljs-params">(routes, globalOptions)</span> </span>{
  <span class="hljs-keyword">const</span> matchers = []
  <span class="hljs-keyword">const</span> matcherMap = <span class="hljs-keyword">new</span> Map()
  globalOptions = mergeOptions({ strict: <span class="hljs-keyword">false</span>, end: <span class="hljs-keyword">true</span>, sensitive: <span class="hljs-keyword">false</span> }, globalOptions)
  
  <span class="hljs-function">function <span class="hljs-title">addRoute</span><span class="hljs-params">(record, parent, originalRecord)</span> </span>{
    let isRootAdd = !originalRecord
    let mainNormalizedRecord = normalizeRouteRecord(record)
    mainNormalizedRecord.aliasOf = originalRecord &amp;&amp; originalRecord.record
    <span class="hljs-keyword">const</span> options = mergeOptions(globalOptions, record)
    <span class="hljs-keyword">const</span> normalizedRecords = [
      mainNormalizedRecord,
    ]
    <span class="hljs-function">let matcher
    let originalMatcher
    <span class="hljs-title">for</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> normalizedRecord of normalizedRecords)</span> </span>{
      let { path } = <span class="hljs-function">normalizedRecord
      <span class="hljs-title">if</span> <span class="hljs-params">(parent &amp;&amp; path[<span class="hljs-number">0</span>] !== <span class="hljs-string">'/'</span>)</span> </span>{
        let parentPath = parent.record.path
        let connectingSlash = parentPath[parentPath.length - <span class="hljs-number">1</span>] === <span class="hljs-string">'/'</span> ? <span class="hljs-string">''</span> : <span class="hljs-string">'/'</span>
        normalizedRecord.path =
          parent.record.path + (path &amp;&amp; connectingSlash + path)
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options)
      <span class="hljs-keyword">if</span> ( parent &amp;&amp; path[<span class="hljs-number">0</span>] === <span class="hljs-string">'/'</span>)
        checkMissingParamsInAbsolutePath(matcher, parent)
      <span class="hljs-keyword">if</span> (originalRecord) {
        originalRecord.alias.push(matcher)
        {
          checkSameParams(originalRecord, matcher)
        }
      }
      <span class="hljs-keyword">else</span> {
        originalMatcher = originalMatcher || <span class="hljs-function">matcher
        <span class="hljs-title">if</span> <span class="hljs-params">(originalMatcher !== matcher)</span>
          originalMatcher.alias.<span class="hljs-title">push</span><span class="hljs-params">(matcher)</span>
        <span class="hljs-title">if</span> <span class="hljs-params">(isRootAdd &amp;&amp; record.name &amp;&amp; !isAliasRecord(matcher)</span>)
          <span class="hljs-title">removeRoute</span><span class="hljs-params">(record.name)</span>
      }
      <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-string">'children'</span> in mainNormalizedRecord)</span> </span>{
        let children = mainNormalizedRecord.<span class="hljs-function">children
        <span class="hljs-title">for</span> <span class="hljs-params">(let i = <span class="hljs-number">0</span>; i &lt; children.length; i++)</span> </span>{
          addRoute(children[i], matcher, originalRecord &amp;&amp; originalRecord.children[i])
        }
      }
      originalRecord = originalRecord || <span class="hljs-function">matcher
      <span class="hljs-title">insertMatcher</span><span class="hljs-params">(matcher)</span>
    }
    return originalMatcher
      ? <span class="hljs-params">()</span> </span>=&gt; {
        removeRoute(originalMatcher)
      }
      : noop
  }
  
  <span class="hljs-function">function <span class="hljs-title">insertMatcher</span><span class="hljs-params">(matcher)</span> </span>{
    let i = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> (i &lt; matchers.length &amp;&amp;
    comparePathParserScore(matcher, matchers[i]) &gt;= <span class="hljs-number">0</span>)
      i++
    matchers.splice(i, <span class="hljs-number">0</span>, matcher)
    <span class="hljs-keyword">if</span> (matcher.record.name &amp;&amp; !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher)
  }
 
  <span class="hljs-comment">// 定义其它一些辅助函数</span>
  
  <span class="hljs-comment">// 添加初始路径</span>
  routes.forEach(route =&gt; addRoute(route))
  <span class="hljs-keyword">return</span> { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher }
}
</code></pre>
<p data-nodeid="651">createRouterMatcher 函数内部定义了一个 matchers 数组和一些辅助函数，我们先重点关注 addRoute 函数的实现，我们只关注核心流程。</p>
<p data-nodeid="652">在 createRouterMatcher 函数的最后，会遍历 routes 路径数组调用 addRoute 方法添加初始路径。</p>
<p data-nodeid="653">在 addRoute 函数内部，首先会把 route 对象标准化成一个 record，其实就是给路径对象添加更丰富的属性。</p>
<p data-nodeid="654">然后再执行createRouteRecordMatcher 函数，传入标准化的 record 对象，我们再来看它的实现：</p>
<pre class="lang-java" data-nodeid="655"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createRouteRecordMatcher</span><span class="hljs-params">(record, parent, options)</span> </span>{
  <span class="hljs-keyword">const</span> parser = tokensToParser(tokenizePath(record.path), options)
  {
    <span class="hljs-keyword">const</span> existingKeys = <span class="hljs-keyword">new</span> Set()
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key of parser.keys) {
      <span class="hljs-keyword">if</span> (existingKeys.has(key.name))
        warn(\`Found duplicated params with name <span class="hljs-string">"\${key.name}"</span> <span class="hljs-keyword">for</span> path <span class="hljs-string">"\${record.path}"</span>. Only the last one will be available on <span class="hljs-string">"$route.params"</span>.\`)
      existingKeys.add(key.name)
    }
  }
  <span class="hljs-keyword">const</span> matcher = assign(parser, {
    record,
    parent,
    children: [],
    alias: []
  })
  <span class="hljs-keyword">if</span> (parent) {
    <span class="hljs-keyword">if</span> (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher)
  }
  <span class="hljs-keyword">return</span> matcher
}
</code></pre>
<p data-nodeid="656">其实 createRouteRecordMatcher 创建的 matcher 对象不仅仅拥有 record 属性来存储 record，还扩展了一些其他属性，需要注意，如果存在 parent matcher，那么会把当前 matcher 添加到 parent.children 中去，这样就维护了父子关系，构造了树形结构。</p>
<p data-nodeid="657">那么什么情况下会有 parent matcher 呢？让我们先回到 addRoute 函数，在创建了 matcher 对象后，接着判断 record 中是否有 children 属性，如果有则遍历 children，递归执行 addRoute 方法添加路径，并把创建 matcher 作为第二个参数 parent 传入，这也就是 parent matcher 存在的原因。</p>
<p data-nodeid="658">所有 children 处理完毕后，再执行 insertMatcher 函数，把创建的 matcher 存入到 matchers 数组中。</p>
<p data-nodeid="659">至此，我们就根据用户配置的 routes 路径数组，初始化好了 matchers 数组。</p>
<p data-nodeid="660">那么再回到我们前面的问题，分析路径对象中的 matched 的值是怎么在路径切换的情况下更新的。</p>
<p data-nodeid="661">之前我们提到过，切换路径会执行 pushWithRedirect 方法，内部会执行一段代码：</p>
<pre class="lang-java" data-nodeid="662"><code data-language="java"><span class="hljs-keyword">const</span> targetLocation = (pendingLocation = resolve(to))
</code></pre>
<p data-nodeid="663">这里会执行 resolve 函数解析生成 targetLocation，这个 targetLocation 最后也会在 finalizeNavigation 的时候赋值 currentRoute 更新当前路径。我们来看 resolve 函数的实现：</p>
<pre class="lang-java" data-nodeid="664"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">resolve</span><span class="hljs-params">(location, currentLocation)</span> </span>{
  let matcher
  let params = {}
  <span class="hljs-function">let path
  let name
  <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-string">'name'</span> in location &amp;&amp; location.name)</span> </span>{
    matcher = matcherMap.get(location.name)
    <span class="hljs-keyword">if</span> (!matcher)
      <span class="hljs-keyword">throw</span> createRouterError(<span class="hljs-number">1</span> <span class="hljs-comment">/* MATCHER_NOT_FOUND */</span>, {
        location,
      })
    name = matcher.record.name
    params = assign(
      paramsFromLocation(currentLocation.params,
        matcher.keys.filter(k =&gt; !k.optional).map(k =&gt; k.name)), location.params)
    path = matcher.stringify(params)
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">'path'</span> in location) {
    path = location.<span class="hljs-function">path
    <span class="hljs-title">if</span> <span class="hljs-params">( !path.startsWith(<span class="hljs-string">'/'</span>)</span>) </span>{
      warn(\`The Matcher cannot resolve relative paths but received <span class="hljs-string">"\${path}"</span>. Unless you directly called \\`matcher.resolve(<span class="hljs-string">"\${path}"</span>)\\`, <span class="hljs-keyword">this</span> is probably a bug in vue-router. Please open an issue at https:<span class="hljs-comment">//new-issue.vuejs.org/?repo=vuejs/vue-router-next.\`)</span>
    }
    matcher = matchers.find(m =&gt; m.re.test(path))
  
    <span class="hljs-keyword">if</span> (matcher) {
      params = matcher.parse(path)
      name = matcher.record.name
    }
  }
  <span class="hljs-keyword">else</span> {
    matcher = currentLocation.name
      ? matcherMap.get(currentLocation.name)
      : matchers.find(m =&gt; m.re.test(currentLocation.path))
    <span class="hljs-keyword">if</span> (!matcher)
      <span class="hljs-keyword">throw</span> createRouterError(<span class="hljs-number">1</span> <span class="hljs-comment">/* MATCHER_NOT_FOUND */</span>, {
        location,
        currentLocation,
      })
    name = matcher.record.name
    params = assign({}, currentLocation.params, location.params)
    path = matcher.stringify(params)
  }
  <span class="hljs-keyword">const</span> matched = []
  let parentMatcher = <span class="hljs-function">matcher
  <span class="hljs-title">while</span> <span class="hljs-params">(parentMatcher)</span> </span>{
    matched.unshift(parentMatcher.record)
    parentMatcher = parentMatcher.parent
  }
  <span class="hljs-keyword">return</span> {
    name,
    path,
    params,
    matched,
    meta: mergeMetaFields(matched),
  }
}
</code></pre>
<p data-nodeid="665">resolve 函数主要做的事情就是根据 location 的 name 或者 path 从我们前面创建的 matchers 数组中找到对应的 matcher，然后再顺着 matcher 的 parent 一直找到链路上所有匹配的 matcher，然后获取其中的 record 属性构造成一个 matched 数组，最终返回包含 matched 属性的新的路径对象。</p>
<p data-nodeid="666">这么做的目的就是让 matched 数组完整记录 record 路径，它的顺序和嵌套的 RouterView 组件顺序一致，也就是 matched 数组中的第 n 个元素就代表着 RouterView 嵌套的第 n 层。</p>
<p data-nodeid="667">因此 targetLocation 和 to 相比，其实就是多了一个 matched 对象，这样再回到我们的 RouterView 组件，就可以从<code data-backticks="1" data-nodeid="714">injectedRoute.matched[depth] [props.name]</code>中拿到对应的组件对象定义，去渲染对应的组件了。</p>
<p data-nodeid="668">至此，我们就搞清楚路径和路由组件的渲染是如何映射的了。</p>
<p data-nodeid="669">前面的分析过程中，我们提到过在路径切换过程中，会执行 navigate 方法，它包含了一系列的导航守卫钩子函数的执行，接下来我们就来分析这部分的实现原理。</p>
<h3 data-nodeid="670">导航守卫的实现</h3>
<p data-nodeid="671">导航守卫主要是让用户在路径切换的生命周期中可以注入钩子函数，执行一些自己的逻辑，也可以取消和重定向导航，举个应用的例子：</p>
<pre class="lang-java" data-nodeid="672"><code data-language="java">router.beforeEach((to, from, next) =&gt; {
  <span class="hljs-keyword">if</span> (to.name !== <span class="hljs-string">'Login'</span> &amp;&amp; !isAuthenticated) next({ name: <span class="hljs-string">'Login'</span> }) <span class="hljs-keyword">else</span> {
    next()
  }
})
</code></pre>
<p data-nodeid="673">这里大致含义就是进入路由前检查用户是否登录，如果没有则跳转到登录的视图组件，否则继续。</p>
<p data-nodeid="674">router.beforeEach 传入的参数是一个函数，我们把这类函数就称为导航守卫。</p>
<p data-nodeid="675">那么这些导航守卫是怎么执行的呢？这里我并不打算去详细讲 navigate 实现的完整流程，而是讲清楚它的执行原理，关于导航守卫的执行顺序建议你去对照<a href="https://next.router.vuejs.org/guide/advanced/navigation-guards.html" data-nodeid="725">官网文档</a>，然后再来看实现细节。</p>
<p data-nodeid="676">接下来，我们来看 navigate 函数的实现：</p>
<pre class="lang-java" data-nodeid="677"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">navigate</span><span class="hljs-params">(to, from)</span> </span>{
  let guards
  <span class="hljs-keyword">const</span> [leavingRecords, updatingRecords, enteringRecords,] = extractChangingRecords(to, from)
  guards = extractComponentsGuards(leavingRecords.reverse(), <span class="hljs-string">'beforeRouteLeave'</span>, to, from)
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> record of leavingRecords) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> guard of record.leaveGuards) {
      guards.push(guardToPromiseFn(guard, to, from))
    }
  }
  <span class="hljs-keyword">const</span> canceledNavigationCheck = checkCanceledNavigationAndReject.bind(<span class="hljs-keyword">null</span>, to, from)
  guards.push(canceledNavigationCheck)
  <span class="hljs-keyword">return</span> (runGuardQueue(guards)
    .then(() =&gt; {
      guards = []
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from))
      }
      guards.push(canceledNavigationCheck)
      <span class="hljs-keyword">return</span> runGuardQueue(guards)
    })
    .then(() =&gt; {
      guards = extractComponentsGuards(updatingRecords, <span class="hljs-string">'beforeRouteUpdate'</span>, to, from)
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> record of updatingRecords) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> guard of record.updateGuards) {
          guards.push(guardToPromiseFn(guard, to, from))
        }
      }
      guards.push(canceledNavigationCheck)
      <span class="hljs-keyword">return</span> runGuardQueue(guards)
    })
    .then(() =&gt; {
      guards = []
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> record of to.matched) {
        <span class="hljs-keyword">if</span> (record.beforeEnter &amp;&amp; from.matched.indexOf(record) &lt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">if</span> (Array.isArray(record.beforeEnter)) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from))
          }
          <span class="hljs-keyword">else</span> {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from))
          }
        }
      }
      guards.push(canceledNavigationCheck)
      <span class="hljs-keyword">return</span> runGuardQueue(guards)
    })
    .then(() =&gt; {
      to.matched.forEach(record =&gt; (record.enterCallbacks = {}))
      guards = extractComponentsGuards(enteringRecords, <span class="hljs-string">'beforeRouteEnter'</span>, to, from)
      guards.push(canceledNavigationCheck)
      <span class="hljs-keyword">return</span> runGuardQueue(guards)
    })
    .then(() =&gt; {
      guards = []
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from))
      }
      guards.push(canceledNavigationCheck)
      <span class="hljs-keyword">return</span> runGuardQueue(guards)
    })
    .<span class="hljs-keyword">catch</span>(err =&gt; isNavigationFailure(err, <span class="hljs-number">8</span> <span class="hljs-comment">/* NAVIGATION_CANCELLED */</span>)
      ? err
      : Promise.reject(err)))
}
</code></pre>
<p data-nodeid="678">可以看到 navigate 执行导航守卫的方式是先构造 guards 数组，数组中每个元素都是一个返回 Promise 对象的函数。</p>
<p data-nodeid="679">然后通过 runGuardQueue 去执行这些 guards，来看它的实现：</p>
<pre class="lang-java" data-nodeid="680"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">runGuardQueue</span><span class="hljs-params">(guards)</span> </span>{
  <span class="hljs-keyword">return</span> guards.reduce((promise, guard) =&gt; promise.then(() =&gt; guard()), Promise.resolve())
}
</code></pre>
<p data-nodeid="681">其实就是通过数组的 reduce 方法，链式执行 guard 函数，每个 guard 函数都会返回一个 Promise对象。</p>
<p data-nodeid="682">但是从我们的例子看，我们添加的是一个普通函数，并不是一个返回 Promise对象的函数，那是怎么做的呢？</p>
<p data-nodeid="683">原来在把 guard 添加到 guards 数组前，都会执行 guardToPromiseFn 函数把普通函数 Promise化，来看它的实现：</p>
<pre class="lang-java" data-nodeid="684"><code data-language="java"><span class="hljs-keyword">import</span> { warn as warn$<span class="hljs-number">1</span> } from <span class="hljs-string">"vue/dist/vue"</span>
<span class="hljs-function">function <span class="hljs-title">guardToPromiseFn</span><span class="hljs-params">(guard, to, from, record, name)</span> </span>{
  <span class="hljs-keyword">const</span> enterCallbackArray = record &amp;&amp;
    (record.enterCallbacks[name] = record.enterCallbacks[name] || [])
  <span class="hljs-keyword">return</span> () =&gt; <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt; {
    <span class="hljs-keyword">const</span> next = (valid) =&gt; {
      <span class="hljs-keyword">if</span> (valid === <span class="hljs-keyword">false</span>)
        reject(createRouterError(<span class="hljs-number">4</span> <span class="hljs-comment">/* NAVIGATION_ABORTED */</span>, {
          from,
          to,
        }))
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valid <span class="hljs-keyword">instanceof</span> Error) {
        reject(valid)
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isRouteLocation(valid)) {
        reject(createRouterError(<span class="hljs-number">2</span> <span class="hljs-comment">/* NAVIGATION_GUARD_REDIRECT */</span>, {
          from: to,
          to: valid
        }))
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (enterCallbackArray &amp;&amp;
          record.enterCallbacks[name] === enterCallbackArray &amp;&amp;
          typeof valid === <span class="hljs-string">'function'</span>)
          enterCallbackArray.push(valid)
        resolve()
      }
    }
    <span class="hljs-keyword">const</span> guardReturn = guard.call(record &amp;&amp; record.instances[name], to, from, next )
    let guardCall = Promise.resolve(guardReturn)
    <span class="hljs-keyword">if</span> (guard.length &lt; <span class="hljs-number">3</span>)
      guardCall = guardCall.then(next)
    <span class="hljs-keyword">if</span> (guard.length &gt; <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">const</span> message = \`The <span class="hljs-string">"next"</span> callback was never called inside of \${guard.name ? <span class="hljs-string">'"'</span> + guard.name + <span class="hljs-string">'"'</span> : <span class="hljs-string">''</span>}:\n\${guard.toString()}\n. If you are returning a value instead of calling <span class="hljs-string">"next"</span>, make sure to remove the <span class="hljs-string">"next"</span> parameter from your function.\`
      <span class="hljs-keyword">if</span> (typeof guardReturn === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-string">'then'</span> in guardReturn) {
        guardCall = guardCall.then(resolvedValue =&gt; {
          <span class="hljs-comment">// @ts-ignore: _called is added at canOnlyBeCalledOnce</span>
          <span class="hljs-keyword">if</span> (!next._called) {
            warn$<span class="hljs-number">1</span>(message)
            <span class="hljs-keyword">return</span> Promise.reject(<span class="hljs-keyword">new</span> Error(<span class="hljs-string">'Invalid navigation guard'</span>))
          }
          <span class="hljs-keyword">return</span> resolvedValue
        })
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (guardReturn !== undefined) {
        <span class="hljs-keyword">if</span> (!next._called) {
          warn$<span class="hljs-number">1</span>(message)
          reject(<span class="hljs-keyword">new</span> Error(<span class="hljs-string">'Invalid navigation guard'</span>))
          <span class="hljs-keyword">return</span>
        }
      }
    }
    guardCall.<span class="hljs-keyword">catch</span>(err =&gt; reject(err))
  })
}
</code></pre>
<p data-nodeid="685">guardToPromiseFn 函数返回一个新的函数，这个函数内部会执行 guard 函数。</p>
<p data-nodeid="686">这里我们要注意 next 方法的设计，当我们在导航守卫中执行 next 时，实际上就是执行这里定义的 next 函数。</p>
<p data-nodeid="687">在执行 next 函数时，如果不传参数，那么则直接 resolve，执行下一个导航守卫；如果参数是 false，则创建一个导航取消的错误 reject 出去；如果参数是一个 Error 实例，则直接执行 reject，并把错误传递出去；如果参数是一个路径对象，则创建一个导航重定向的错误传递出去。</p>
<p data-nodeid="688">有些时候我们写导航守卫不使用 next 函数，而是直接返回 true 或 false，这种情况则先执行如下代码：</p>
<pre class="lang-js" data-nodeid="996"><code data-language="js">guardCall = <span class="hljs-built_in">Promise</span>.resolve(guardReturn)
</code></pre>
<p data-nodeid="997">把导航守卫的返回值 Promise化，然后再执行 guardCall.then(next)，把导航守卫的返回值传给 next 函数。</p>
<p data-nodeid="998">当然，如果你在导航守卫中定义了第三个参数 next，但是你没有在函数中调用它，这种情况也会报警告。</p>
<p data-nodeid="999">所以，对于导航守卫而言，经过 Promise化后添加到 guards 数组中，然后再通过 runGuards 以及 Promise 的方式链式调用，最终依次顺序执行这些导航守卫。</p>
<h3 data-nodeid="1000">总结</h3>
<p data-nodeid="1001">好的，到这里我们这一节的学习也要结束啦，通过这节课的学习，你应该要了解 Vue Router 的基本实现原理，知道路径是如何管理的，路径和路由组件的渲染是如何映射的，导航守卫是如何执行的。</p>
<p data-nodeid="1002">当然，路由实现的细节是非常多的，我希望你学完之后，可以对照着官网的文档的 feature，自行去分析它们的实现原理。</p>
<p data-nodeid="1003">最后，给你留一道思考题目，如果我们想给路由组件传递数据，有几种方式，分别都怎么做呢？欢迎你在留言区与我分享。</p></div>

</body></html>