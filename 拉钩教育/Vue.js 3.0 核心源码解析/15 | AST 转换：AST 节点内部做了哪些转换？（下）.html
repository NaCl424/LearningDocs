<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lagou DOC</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>15 | AST 转换：AST 节点内部做了哪些转换？（下）</h1><p data-nodeid="24415">上一节课，我们已经知道了 transform 的核心流程主要有四步：创建 transform 上下文、遍历 AST 节点、静态提升以及创建根代码生成节点。这节课我们接着分析遍历 AST 节点中的 Text 节点的转换函数。</p>



<h3 data-nodeid="23713">遍历 AST 节点</h3>
<h4 data-nodeid="23714">Text 节点转换函数</h4>
<p data-nodeid="23715">接下来，我们来看一下 Text 节点转换函数的实现：</p>
<pre class="lang-java" data-nodeid="26268"><code data-language="java"><span class="hljs-keyword">const</span> transformText = (node, context) =&gt; {
  <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">0</span> <span class="hljs-comment">/* ROOT */</span> ||
    node.type === <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span> ||
    node.type === <span class="hljs-number">11</span> <span class="hljs-comment">/* FOR */</span> ||
    node.type === <span class="hljs-number">10</span> <span class="hljs-comment">/* IF_BRANCH */</span>) {
    <span class="hljs-comment">// 在节点退出时执行转换，保证所有表达式都已经被处理</span>
    <span class="hljs-keyword">return</span> () =&gt; {
      <span class="hljs-keyword">const</span> children = node.children
      let currentContainer = undefined
      let hasText = <span class="hljs-keyword">false</span>
      <span class="hljs-comment">// 将相邻文本节点合并</span>
      <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
        <span class="hljs-keyword">const</span> child = children[i]
        <span class="hljs-keyword">if</span> (isText(child)) {
          hasText = <span class="hljs-function"><span class="hljs-keyword">true</span>
          <span class="hljs-title">for</span> <span class="hljs-params">(let j = i + <span class="hljs-number">1</span>; j &lt; children.length; j++)</span> </span>{
            <span class="hljs-keyword">const</span> next = children[j]
            <span class="hljs-keyword">if</span> (isText(next)) {
              <span class="hljs-keyword">if</span> (!currentContainer) {
                <span class="hljs-comment">// 创建复合表达式节点</span>
                currentContainer = children[i] = {
                  type: <span class="hljs-number">8</span> <span class="hljs-comment">/* COMPOUND_EXPRESSION */</span>,
                  loc: child.loc,
                  children: [child]
                }
              }
              currentContainer.children.push(\` + \`, next)
              children.splice(j, <span class="hljs-number">1</span>)
              j--
            }
            <span class="hljs-keyword">else</span> {
              currentContainer = undefined
              <span class="hljs-keyword">break</span>
            }
          }
        }
      }
      <span class="hljs-keyword">if</span> (!hasText ||
        <span class="hljs-comment">// 如果是一个带有单个文本子元素的纯元素节点，什么都不需要转换，因为这种情况在运行时可以直接设置元素的 textContent 来更新文本。</span>
        (children.length === <span class="hljs-number">1</span> &amp;&amp;
          (node.type === <span class="hljs-number">0</span> <span class="hljs-comment">/* ROOT */</span> ||
            (node.type === <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span> &amp;&amp;
              node.tagType === <span class="hljs-number">0</span> <span class="hljs-comment">/* ELEMENT */</span>)))) {
        <span class="hljs-keyword">return</span>
      }
      <span class="hljs-comment">// 为子文本节点创建一个调用函数表达式的代码生成节点</span>
      <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
        <span class="hljs-keyword">const</span> child = children[i]
        <span class="hljs-keyword">if</span> (isText(child) || child.type === <span class="hljs-number">8</span> <span class="hljs-comment">/* COMPOUND_EXPRESSION */</span>) {
          <span class="hljs-keyword">const</span> callArgs = []
          <span class="hljs-comment">// 为 createTextVNode 添加执行参数</span>
          <span class="hljs-keyword">if</span> (child.type !== <span class="hljs-number">2</span> <span class="hljs-comment">/* TEXT */</span> || child.content !== <span class="hljs-string">' '</span>) {
            callArgs.push(child)
          }
          <span class="hljs-comment">// 标记动态文本</span>
          <span class="hljs-keyword">if</span> (!context.ssr &amp;&amp; child.type !== <span class="hljs-number">2</span> <span class="hljs-comment">/* TEXT */</span>) {
            callArgs.push(\`\${<span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>} <span class="hljs-comment">/* \${PatchFlagNames[1 /* TEXT */</span>]} */\`)
          }
          children[i] = {
            type: <span class="hljs-number">12</span> <span class="hljs-comment">/* TEXT_CALL */</span>,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
          }
        }
      }
    }
  }
}
</code></pre>




<p data-nodeid="23717">transformText 函数只处理根节点、元素节点、 v-for 以及 v-if 分支相关的节点，它也会返回一个退出函数，因为 transformText 要保证所有表达式节点都已经被处理才执行转换逻辑。</p>
<p data-nodeid="23718">transformText 主要的目的就是合并一些相邻的文本节点，然后为内部每一个文本节点创建一个代码生成节点。</p>
<p data-nodeid="23719">在内部，静态文本节点和动态插值节点都被看作是一个文本节点，所以函数首先遍历节点的子节点，然后把子节点中的相邻文本节点合并成一个。</p>
<p data-nodeid="23720">比如示例中的文本节点：<code data-backticks="1" data-nodeid="23820">&lt;p&gt;hello {{ msg + test }}&lt;/p&gt;</code>。</p>
<p data-nodeid="23721">在转换之前，p 节点对应的 children 数组有两个元素，第一个是纯文本节点，第二个是一个插值节点，这个数组也是前面提到的表达式节点转换后的结果：</p>
<pre class="lang-java" data-nodeid="26731"><code data-language="java">[
  {
    <span class="hljs-string">"type"</span>: <span class="hljs-number">2</span>,
    <span class="hljs-string">"content"</span>: <span class="hljs-string">"hello "</span>,
  },
  {
    <span class="hljs-string">"type"</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">"content"</span>: {
      <span class="hljs-string">"type"</span>: <span class="hljs-number">8</span>,
      <span class="hljs-string">"children"</span>: [
        {
          <span class="hljs-string">"type"</span>: <span class="hljs-number">4</span>,
          <span class="hljs-string">"isConstant"</span>: <span class="hljs-keyword">false</span>,
          <span class="hljs-string">"content"</span>: <span class="hljs-string">"_ctx.msg"</span>,
          <span class="hljs-string">"isStatic"</span>: <span class="hljs-keyword">false</span>
        },
        <span class="hljs-string">" + "</span>,
        {
          <span class="hljs-string">"type"</span>: <span class="hljs-number">4</span>,
          <span class="hljs-string">"isConstant"</span>: <span class="hljs-keyword">false</span>,
          <span class="hljs-string">"content"</span>: <span class="hljs-string">"_ctx.test"</span>,
          <span class="hljs-string">"isStatic"</span>: <span class="hljs-keyword">false</span>
        }
      ],
      <span class="hljs-string">"identifiers"</span>: []
    }
  }
]
</code></pre>

<p data-nodeid="23723">转换后，这两个文本节点被合并成一个复合表达式节点，结果如下：</p>
<pre class="lang-java" data-nodeid="27194"><code data-language="java">[
  {
    <span class="hljs-string">"type"</span>: <span class="hljs-number">8</span>,
    <span class="hljs-string">"children"</span>: [
      {
        <span class="hljs-string">"type"</span>: <span class="hljs-number">2</span>,
        <span class="hljs-string">"content"</span>: <span class="hljs-string">"hello "</span>,
      },
      <span class="hljs-string">" + "</span>,
      {
        <span class="hljs-string">"type"</span>: <span class="hljs-number">5</span>,
        <span class="hljs-string">"content"</span>: {
          <span class="hljs-string">"type"</span>: <span class="hljs-number">8</span>,
          <span class="hljs-string">"children"</span>: [
            {
              <span class="hljs-string">"type"</span>: <span class="hljs-number">4</span>,
              <span class="hljs-string">"isConstant"</span>: <span class="hljs-keyword">false</span>,
              <span class="hljs-string">"content"</span>: <span class="hljs-string">"_ctx.msg"</span>,
              <span class="hljs-string">"isStatic"</span>: <span class="hljs-keyword">false</span>
            },
            <span class="hljs-string">" + "</span>,
            {
              <span class="hljs-string">"type"</span>: <span class="hljs-number">4</span>,
              <span class="hljs-string">"isConstant"</span>: <span class="hljs-keyword">false</span>,
              <span class="hljs-string">"content"</span>: <span class="hljs-string">"_ctx.test"</span>,
              <span class="hljs-string">"isStatic"</span>: <span class="hljs-keyword">false</span>
            }
          ],
          <span class="hljs-string">"identifiers"</span>: []
        }
      }
    ]
  }
]
</code></pre>

<p data-nodeid="23725">合并完子文本节点后，接着判断如果是一个只带有单个文本子元素的纯元素节点，则什么都不需要转换，因为这种情况在运行时可以直接设置元素的 textContent 来更新文本。</p>
<p data-nodeid="23726">最后就是去处理节点包含文本子节点且多个子节点的情况，举个例子：</p>
<pre class="lang-js" data-nodeid="28120"><code data-language="js">&lt;p&gt;
  hello {{ msg + test }}
  &lt;a href=<span class="hljs-string">"foo"</span>/&gt;
  hi
&lt;/p&gt;
</code></pre>


<p data-nodeid="23728">上述 p 标签的子节点经过前面的文本合并流程后，还有 3 个子节点。针对这种情况，我们可以遍历子节点，找到所有的文本节点或者是复合表达式节点，然后为这些子节点通过 createCallExpression 创建一个调用函数表达式的代码生成节点。</p>
<p data-nodeid="23729">我们来看 createCallExpression 的实现：</p>
<pre class="lang-java" data-nodeid="28583"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createCallExpression</span><span class="hljs-params">(callee, args = [], loc = locStub)</span> </span>{
  <span class="hljs-keyword">return</span> {
    type: <span class="hljs-number">14</span> <span class="hljs-comment">/* JS_CALL_EXPRESSION */</span>,
    loc,
    callee,
    arguments: args
  }
}
</code></pre>

<p data-nodeid="23731">createCallExpression 的实现很简单，就是返回一个类型为 JS_CALL_EXPRESSION 的对象，它包含了执行的函数名和参数。</p>
<p data-nodeid="23732">这里，针对我们创建的函数表达式所生成的节点，它对应的函数名是 createTextVNode，参数 callArgs 是子节点本身 child，如果是动态插值节点，那么参数还会多一个 TEXT 的 patchFlag。</p>
<h4 data-nodeid="23733">v-if 节点转换函数</h4>
<p data-nodeid="23734">接下来，我们来看一下 v-if 节点转换函数的实现：</p>
<pre class="lang-java" data-nodeid="29046"><code data-language="java"><span class="hljs-keyword">const</span> transformIf = createStructuralDirectiveTransform(/^(<span class="hljs-keyword">if</span>|<span class="hljs-keyword">else</span>|<span class="hljs-keyword">else</span>-<span class="hljs-keyword">if</span>)$/, (node, dir, context) =&gt; {
  <span class="hljs-keyword">return</span> processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; {
    <span class="hljs-keyword">return</span> () =&gt; {
      <span class="hljs-comment">// 退出回调函数，当所有子节点转换完成执行</span>
    }
  })
})
</code></pre>

<p data-nodeid="23736">在分析函数的实现前，我们先来看一下 v-if 节点转换的目的，为了方便你的理解，我还是通过示例来说明：</p>
<pre class="lang-js" data-nodeid="30898"><code data-language="js">&lt;hello v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"flag"</span>&gt;&lt;/hello&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello {{ msg + test }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>static<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>static<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre>


<p data-nodeid="23738">在 parse 阶段，这个模板解析生成的 AST 节点如下：</p>
<pre class="lang-js" data-nodeid="29972"><code data-language="js">[
  {
    <span class="hljs-string">"children"</span>: [],
    <span class="hljs-string">"codegenNode"</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-string">"isSelfClosing"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-string">"ns"</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">"props"</span>: [{
      <span class="hljs-string">"type"</span>: <span class="hljs-number">7</span>,
      <span class="hljs-string">"name"</span>: <span class="hljs-string">"if"</span>,
      <span class="hljs-string">"exp"</span>: {
        <span class="hljs-string">"type"</span>: <span class="hljs-number">4</span>,
        <span class="hljs-string">"content"</span>: <span class="hljs-string">"flag"</span>,
        <span class="hljs-string">"isConstant"</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-string">"isStatic"</span>: <span class="hljs-literal">false</span>
      },
      <span class="hljs-string">"arg"</span>: <span class="hljs-literal">undefined</span>,
      <span class="hljs-string">"modifiers"</span>: []
    }],
    <span class="hljs-string">"tag"</span>: <span class="hljs-string">"hello"</span>,
    <span class="hljs-string">"tagType"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">"type"</span>: <span class="hljs-number">1</span>
  },
  {
    <span class="hljs-string">"children"</span>: [
      <span class="hljs-comment">// 子节点</span>
    ],
    <span class="hljs-string">"codegenNode"</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-string">"isSelfClosing"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-string">"ns"</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">"props"</span>: [{ 
      <span class="hljs-string">"type"</span>: <span class="hljs-number">7</span>,
      <span class="hljs-string">"name"</span>: <span class="hljs-string">"else"</span>,
      <span class="hljs-string">"exp"</span>: <span class="hljs-literal">undefined</span>,
      <span class="hljs-string">"arg"</span>: <span class="hljs-literal">undefined</span>,
      <span class="hljs-string">"modifiers"</span>: []
    }],
    <span class="hljs-string">"tag"</span>: <span class="hljs-string">"div"</span>,
    <span class="hljs-string">"tagType"</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">"type"</span>: <span class="hljs-number">1</span>
  }
]
</code></pre>


<p data-nodeid="23740">v-if 指令用于条件性地渲染一块内容，显然上述 AST 节点对于最终去生成条件的代码而言，是不够语义化的，于是我们需要对它们做一层转换，使其成为语义化强的代码生成节点。</p>
<p data-nodeid="23741">现在我们回过头看 transformIf 的实现，它是通过 createStructuralDirectiveTransform 函数创建的一个结构化指令的转换函数，在 Vue.js 中，v-if、v-else-if、v-else 和 v-for 这些都属于结构化指令，因为它们能影响代码的组织结构。</p>
<p data-nodeid="23742">我们来看一下 createStructuralDirectiveTransform 的实现：</p>
<pre class="lang-java" data-nodeid="31361"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createStructuralDirectiveTransform</span><span class="hljs-params">(name, fn)</span> </span>{
  <span class="hljs-keyword">const</span> matches = isString(name)
    ? (n) =&gt; n === name
    : (n) =&gt; name.test(n)
  <span class="hljs-keyword">return</span> (node, context) =&gt; {
    <span class="hljs-comment">// 只处理元素节点</span>
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span>) {
      <span class="hljs-keyword">const</span> { props } = node
      <span class="hljs-comment">// 结构化指令的转换与插槽无关，插槽相关处理逻辑在 vSlot.ts 中</span>
      <span class="hljs-keyword">if</span> (node.tagType === <span class="hljs-number">3</span> <span class="hljs-comment">/* TEMPLATE */</span> &amp;&amp; props.some(isVSlot)) {
        <span class="hljs-keyword">return</span>
      }
      <span class="hljs-keyword">const</span> exitFns = []
      <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; props.length; i++) {
        <span class="hljs-keyword">const</span> prop = props[i]
        <span class="hljs-keyword">if</span> (prop.type === <span class="hljs-number">7</span> <span class="hljs-comment">/* DIRECTIVE */</span> &amp;&amp; matches(prop.name)) {
          <span class="hljs-comment">// 删除结构指令以避免无限递归</span>
          props.splice(i, <span class="hljs-number">1</span>)
          i--
          <span class="hljs-keyword">const</span> onExit = fn(node, prop, context)
          <span class="hljs-keyword">if</span> (onExit)
            exitFns.push(onExit)
        }
      }
      <span class="hljs-keyword">return</span> exitFns
    }
  }
}
</code></pre>

<p data-nodeid="23744">可以看到，createStructuralDirectiveTransform 接受 2 个参数，第一个 name 是指令的名称，第二个 fn 是构造转换退出函数的方法。</p>
<p data-nodeid="23745">createStructuralDirectiveTransform 最后会返回一个函数，在我们的场景下，这个函数就是 transformIf 转换函数。</p>
<p data-nodeid="23746">我们进一步看这个函数的实现，它只处理元素节点，这个很好理解，因为只有元素节点才会有 v-if 指令，接着会解析这个节点的 props 属性，如果发现 props 包含 if 属性，也就是节点拥有 v-if 指令，那么先从 props 删除这个结构化指令防止无限递归，然后执行 fn 获取对应的退出函数，最后将这个退出函数返回。</p>
<p data-nodeid="23747">接着我们来看 fn 的实现，在我们这个场景下 fn 对应的是前面传入的匿名函数：</p>
<pre class="lang-java" data-nodeid="31824"><code data-language="java">(node, dir, context) =&gt; {
  <span class="hljs-keyword">return</span> processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; {
    <span class="hljs-keyword">return</span> () =&gt; {
       <span class="hljs-comment">// 退出回调函数，当所有子节点转换完成执行</span>
    }
  })
}
</code></pre>

<p data-nodeid="23749">可以看出，这个匿名函数内部执行了 processIf 函数，它会先对 v-if 和它的相邻节点做转换，然后返回一个退出函数，在它们的子节点都转换完毕后执行。</p>
<p data-nodeid="23750">我们来看 processIf 函数的实现：</p>
<pre class="lang-java" data-nodeid="32287"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">processIf</span><span class="hljs-params">(node, dir, context, processCodegen)</span> </span>{
  <span class="hljs-keyword">if</span> (dir.name === <span class="hljs-string">'if'</span>) {
    <span class="hljs-comment">// 创建分支节点</span>
    <span class="hljs-keyword">const</span> branch = createIfBranch(node, dir)
    <span class="hljs-comment">// 创建 IF 节点，替换当前节点</span>
    <span class="hljs-keyword">const</span> ifNode = {
      type: <span class="hljs-number">9</span> <span class="hljs-comment">/* IF */</span>,
      loc: node.loc,
      branches: [branch]
    }
    context.replaceNode(ifNode)
    <span class="hljs-keyword">if</span> (processCodegen) {
      <span class="hljs-keyword">return</span> processCodegen(ifNode, branch, <span class="hljs-keyword">true</span>)
    }
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 处理 v-if 相邻节点，比如 v-else-if 和 v-else</span>
  }
}
</code></pre>

<p data-nodeid="23752">processIf 主要就是用来处理 v-if 节点以及 v-if 的相邻节点，比如 v-else-if 和 v-else，并且它们会走不同的处理逻辑。</p>
<p data-nodeid="23753">我们先来看 v-if 的处理逻辑。首先，它会执行 createIfBranch 去创建一个分支节点：</p>
<pre class="lang-java" data-nodeid="32750"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createIfBranch</span><span class="hljs-params">(node, dir)</span> </span>{
  <span class="hljs-keyword">return</span> {
    type: <span class="hljs-number">10</span> <span class="hljs-comment">/* IF_BRANCH */</span>,
    loc: node.loc,
    condition: dir.name === <span class="hljs-string">'else'</span> ? undefined : dir.exp,
    children: node.tagType === <span class="hljs-number">3</span> <span class="hljs-comment">/* TEMPLATE */</span> ? node.children : [node]
  }
}
</code></pre>

<p data-nodeid="23755">这个分支节点很好理解，因为 v-if 节点内部的子节点可以属于一个分支，v-else-if 和 v-else 节点内部的子节点也都可以属于一个分支，而最终页面渲染执行哪个分支，这取决于哪个分支节点的 condition 为 true。</p>
<p data-nodeid="23756">所以分支节点返回的对象，就包含了 condition 条件，以及它的子节点 children。注意，<strong data-nodeid="23859">如果节点 node 不是 template</strong>，<strong data-nodeid="23860">那么 children 指向的就是这个单个 node 构造的数组</strong>。</p>
<p data-nodeid="23757">接下来它会创建 IF 节点替换当前节点，IF 节点拥有 branches 属性，包含我们前面创建的分支节点，显然，相对于原节点，IF 节点的语义化更强，更利于后续生成条件表达式代码。</p>
<p data-nodeid="23758">最后它会执行 processCodegen 创建退出函数。我们先不着急去分析退出函数的创建过程，先把 v-if 相邻节点的处理逻辑分析完：</p>
<pre class="lang-java" data-nodeid="33213"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">processIf</span><span class="hljs-params">(node, dir, context, processCodegen)</span> </span>{
  <span class="hljs-keyword">if</span> (dir.name === <span class="hljs-string">'if'</span>) {
    <span class="hljs-comment">// 处理 v-if 节点</span>
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 处理 v-if 相邻节点，比如 v-else-if 和 v-else</span>
    <span class="hljs-keyword">const</span> siblings = context.parent.children
    let i = siblings.indexOf(node)
    <span class="hljs-keyword">while</span> (i-- &gt;= -<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">const</span> sibling = siblings[i]
      <span class="hljs-keyword">if</span> (sibling &amp;&amp; sibling.type === <span class="hljs-number">9</span> <span class="hljs-comment">/* IF */</span>) {
        <span class="hljs-comment">// 把节点移动到 IF 节点的 branches 中</span>
        context.removeNode()
        <span class="hljs-keyword">const</span> branch = createIfBranch(node, dir)
        sibling.branches.push(branch)
        <span class="hljs-keyword">const</span> onExit = processCodegen &amp;&amp; processCodegen(sibling, branch, <span class="hljs-keyword">false</span>)
        <span class="hljs-comment">// 因为分支已被删除，所以它的子节点需要在这里遍历</span>
        traverseNode(branch, context)
        <span class="hljs-comment">// 执行退出函数</span>
        <span class="hljs-keyword">if</span> (onExit)
          onExit()
        <span class="hljs-comment">// 恢复 currentNode 为 null，因为它已经被移除</span>
        context.currentNode = <span class="hljs-keyword">null</span>
      }
      <span class="hljs-keyword">else</span> {
        context.onError(createCompilerError(<span class="hljs-number">28</span> <span class="hljs-comment">/* X_V_ELSE_NO_ADJACENT_IF */</span>, node.loc))
      }
      <span class="hljs-keyword">break</span>
    }
  }
}
</code></pre>

<p data-nodeid="23760">这段处理逻辑就是从当前节点往前面的兄弟节点遍历，找到 v-if 节点后，把当前节点删除，然后根据当前节点创建一个分支节点，把这个分支节点添加到前面创建的 IF 节点的 branches 中。此外，由于这个节点已经删除，那么需要在这里把这个节点的子节点通过 traverseNode 遍历一遍。</p>
<p data-nodeid="23761">这么处理下来，就相当于完善了 IF 节点的信息了，IF 节点的 branches 就包含了所有分支节点了。</p>
<p data-nodeid="23762">那么至此，进入 v-if、v-else-if、v-else 这些节点的转换逻辑我们就分析完毕了，即最终创建了一个 IF 节点，它包含了所有的分支节点。</p>
<p data-nodeid="23763">接下来，我们再来分析这个退出函数的逻辑：</p>
<pre class="lang-java" data-nodeid="33676"><code data-language="java">(node, dir, context) =&gt; {
  <span class="hljs-keyword">return</span> processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; {
    <span class="hljs-comment">// 退出回调函数，当所有子节点转换完成执行</span>
    <span class="hljs-keyword">return</span> () =&gt; {
      <span class="hljs-keyword">if</span> (isRoot) {
        <span class="hljs-comment">// v-if 节点的退出函数</span>
        <span class="hljs-comment">// 创建 IF 节点的 codegenNode</span>
        ifNode.codegenNode = createCodegenNodeForBranch(branch, <span class="hljs-number">0</span>, context)
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// v-else-if、v-else 节点的退出函数</span>
        <span class="hljs-comment">// 将此分支的 codegenNode 附加到 上一个条件节点的 codegenNode 的 alternate 中</span>
        let parentCondition = ifNode.<span class="hljs-function">codegenNode
        <span class="hljs-title">while</span> <span class="hljs-params">(parentCondition.alternate.type ===
        <span class="hljs-number">19</span> <span class="hljs-comment">/* JS_CONDITIONAL_EXPRESSION */</span>)</span> </span>{
          parentCondition = parentCondition.alternate
        }
        <span class="hljs-comment">// 更新候选节点</span>
        parentCondition.alternate = createCodegenNodeForBranch(branch, ifNode.branches.length - <span class="hljs-number">1</span>, context)
      }
    }
  })
}
</code></pre>

<p data-nodeid="23765">可以看到，当 v-if 节点执行退出函数时，会通过 createCodegenNodeForBranch 创建 IF 分支节点的 codegenNode，我们来看一下它的实现：</p>
<pre class="lang-java" data-nodeid="34139"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createCodegenNodeForBranch</span><span class="hljs-params">(branch, index, context)</span> </span>{
  <span class="hljs-keyword">if</span> (branch.condition) {
    <span class="hljs-keyword">return</span> createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, index, context),
      createCallExpression(context.helper(CREATE_COMMENT), [
        (process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) ? <span class="hljs-string">'"v-if"'</span> : <span class="hljs-string">'""'</span>,
        <span class="hljs-string">'true'</span>
      ]))
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> createChildrenCodegenNode(branch, index, context)
  }
}
</code></pre>

<p data-nodeid="23767">当分支节点存在 condition 的时候，比如 v-if、和 v-else-if，它通过 createConditionalExpression 返回一个条件表达式节点：</p>
<pre class="lang-java" data-nodeid="34602"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createConditionalExpression</span><span class="hljs-params">(test, consequent, alternate, newline = <span class="hljs-keyword">true</span>)</span> </span>{
  <span class="hljs-keyword">return</span> {
    type: <span class="hljs-number">19</span> <span class="hljs-comment">/* JS_CONDITIONAL_EXPRESSION */</span>,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  }
}
</code></pre>

<p data-nodeid="23769">其中 consequent 在这里是 IF 主 branch 的子节点对应的代码生成节点，alternate 是后补 branch 子节点对应的代码生成节点。</p>
<p data-nodeid="23770">接着，我们来看一下 createChildrenCodegenNode 的实现：</p>
<pre class="lang-java" data-nodeid="35065"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createChildrenCodegenNode</span><span class="hljs-params">(branch, index, context)</span> </span>{
  <span class="hljs-keyword">const</span> { helper } = context
  <span class="hljs-comment">// 根据 index 创建 key 属性</span>
  <span class="hljs-keyword">const</span> keyProperty = createObjectProperty(\`key\`, createSimpleExpression(index + <span class="hljs-string">''</span>, <span class="hljs-keyword">false</span>))
  <span class="hljs-keyword">const</span> { children } = branch
  <span class="hljs-keyword">const</span> firstChild = children[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">const</span> needFragmentWrapper = children.length !== <span class="hljs-number">1</span> || firstChild.type !== <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span>
  <span class="hljs-keyword">if</span> (needFragmentWrapper) {
    <span class="hljs-keyword">if</span> (children.length === <span class="hljs-number">1</span> &amp;&amp; firstChild.type === <span class="hljs-number">11</span> <span class="hljs-comment">/* FOR */</span>) {
      <span class="hljs-keyword">const</span> vnodeCall = firstChild.<span class="hljs-function">codegenNode
      <span class="hljs-title">injectProp</span><span class="hljs-params">(vnodeCall, keyProperty, context)</span>
      return vnodeCall
    }
    <span class="hljs-keyword">else</span> </span>{
      <span class="hljs-keyword">return</span> createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, \`\${<span class="hljs-number">64</span> <span class="hljs-comment">/* STABLE_FRAGMENT */</span>} <span class="hljs-comment">/* \${PatchFlagNames[64 /* STABLE_FRAGMENT */</span>]} */\`, undefined, undefined, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, branch.loc)
    }
  } 
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">const</span> vnodeCall = firstChild
      .codegenNode;
    <span class="hljs-comment">// 把 createVNode 改变为 createBlock</span>
    <span class="hljs-keyword">if</span> (vnodeCall.type === <span class="hljs-number">13</span> <span class="hljs-comment">/* VNODE_CALL */</span> &amp;&amp;
      <span class="hljs-comment">// 组件节点的 children 会被视为插槽，不需要添加 block</span>
      (firstChild.tagType !== <span class="hljs-number">1</span> <span class="hljs-comment">/* COMPONENT */</span> ||
        vnodeCall.tag === TELEPORT)) {
      vnodeCall.isBlock = <span class="hljs-keyword">true</span>
      <span class="hljs-comment">// 创建 block 的辅助代码</span>
      helper(OPEN_BLOCK)
      helper(CREATE_BLOCK)
    }
    <span class="hljs-comment">// 给 branch 注入 key 属性</span>
    injectProp(vnodeCall, keyProperty, context)
    <span class="hljs-keyword">return</span> vnodeCall
  }
}
</code></pre>

<p data-nodeid="23772">createChildrenCodegenNode 主要就是判断每个分支子节点是不是一个 vnodeCall，如果这个子节点不是组件节点的话，则把它转变成一个 BlockCall，也就是让 v-if 的每一个分支都可以创建一个 Block。</p>
<p data-nodeid="23773">这个行为是很好理解的，因为 v-if 是条件渲染的，我们知道在某些条件下某些分支是不会渲染的，那么它内部的动态节点就不能添加到外部的 Block 中的，所以它就需要单独创建一个 Block 来维护分支内部的动态节点，这样也就构成了 Block tree。</p>
<p data-nodeid="23774">为了直观让你感受 v-if 节点最终转换的结果，我们来看前面示例转换后的结果，最终转换生成的 IF 节点对象大致如下：</p>
<pre class="lang-json" data-nodeid="23775"><code data-language="json">{
  <span class="hljs-attr">"type"</span>: <span class="hljs-number">9</span>,
  <span class="hljs-attr">"branches"</span>: [{
     <span class="hljs-attr">"type"</span>: <span class="hljs-number">10</span>,
     <span class="hljs-attr">"children"</span>: [{
        <span class="hljs-attr">"type"</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">"tagType"</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"hello"</span>
     }],
     <span class="hljs-attr">"condition"</span>: {
       <span class="hljs-attr">"type"</span>: <span class="hljs-number">4</span>,
       <span class="hljs-attr">"content"</span>: <span class="hljs-string">"_ctx.flag"</span>
     }
  },{
     <span class="hljs-attr">"type"</span>: <span class="hljs-number">10</span>,
     <span class="hljs-attr">"children"</span>: [{
        <span class="hljs-attr">"type"</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">"tagType"</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"hello"</span>
     }],
     <span class="hljs-attr">"condition"</span>: {
       <span class="hljs-attr">"type"</span>: <span class="hljs-number">4</span>,
       <span class="hljs-attr">"content"</span>: <span class="hljs-string">"_ctx.flag"</span>
     }
  }],
  <span class="hljs-attr">"codegenNode"</span>: {
    <span class="hljs-attr">"type"</span>: <span class="hljs-number">19</span>,
    <span class="hljs-attr">"consequent"</span>: {
      <span class="hljs-attr">"type"</span>: <span class="hljs-number">13</span>,
      <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"_component_hello"</span>,
      <span class="hljs-attr">"children"</span>: undefined,
      <span class="hljs-attr">"directives"</span>: undefined,
      <span class="hljs-attr">"dynamicProps"</span>: undefined,
      <span class="hljs-attr">"isBlock"</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">"patchFlag"</span>: undefined
    },
    <span class="hljs-attr">"alternate"</span>: {
      <span class="hljs-attr">"type"</span>: <span class="hljs-number">13</span>,
      <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"_component_hello"</span>,
      <span class="hljs-attr">"children"</span>: [
        <span class="hljs-comment">// 子节点</span>
      ],
      <span class="hljs-attr">"directives"</span>: undefined,
      <span class="hljs-attr">"dynamicProps"</span>: undefined,
      <span class="hljs-attr">"isBlock"</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">"patchFlag"</span>: undefined
    }
  }
}
</code></pre>
<p data-nodeid="23776">可以看到，相比原节点，转换后的 IF 节点无论是在语义化还是在信息上，都更加丰富，我们可以依据它在代码生成阶段生成所需的代码。</p>
<h3 data-nodeid="23777">静态提升</h3>
<p data-nodeid="23778">节点转换完毕后，接下来会判断编译配置中是否配置了 hoistStatic，如果是就会执行 hoistStatic 做静态提升：</p>
<pre class="lang-java" data-nodeid="35528"><code data-language="java"><span class="hljs-keyword">if</span> (options.hoistStatic) {
  hoistStatic(root, context)
}
</code></pre>

<p data-nodeid="23780">静态提升也是 Vue.js 3.0 在编译阶段设计了一个优化策略，为了便于你理解，我先举个简单的例子：</p>
<pre class="lang-js" data-nodeid="36454"><code data-language="js">&lt;p&gt;&gt;hello {{ msg + test }}&lt;/p&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>static<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>static<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
</code></pre>


<p data-nodeid="23782">我们为它配置了 hoistStatic，经过编译后，它的代码就变成了这样：</p>
<pre class="lang-java" data-nodeid="36917"><code data-language="java"><span class="hljs-keyword">import</span> { toDisplayString as _toDisplayString, createVNode as _createVNode, Fragment as _Fragment, openBlock as _openBlock, createBlock as _createBlock } from <span class="hljs-string">"vue"</span>
<span class="hljs-keyword">const</span> _hoisted_1 = <span class="hljs-comment">/*#__PURE__*/</span>_createVNode(<span class="hljs-string">"p"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">"static"</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)
<span class="hljs-keyword">const</span> _hoisted_2 = <span class="hljs-comment">/*#__PURE__*/</span>_createVNode(<span class="hljs-string">"p"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">"static"</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)
<span class="hljs-function">export function <span class="hljs-title">render</span><span class="hljs-params">(_ctx, _cache)</span> </span>{
  <span class="hljs-keyword">return</span> (_openBlock(), _createBlock(_Fragment, <span class="hljs-keyword">null</span>, [
    _createVNode(<span class="hljs-string">"p"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">"hello "</span> + _toDisplayString(_ctx.msg + _ctx.test), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>),
    _hoisted_1,
    _hoisted_2
  ], <span class="hljs-number">64</span> <span class="hljs-comment">/* STABLE_FRAGMENT */</span>))
}
</code></pre>

<p data-nodeid="23784">这里，我们先忽略 openBlock、Fragment ，我会在代码生成章节详细说明，重点看一下 _hoisted_1 和 _hoisted_2 这两个变量，它们分别对应模板中两个静态 p 标签生成的 vnode，可以发现它的创建是在 render 函数外部执行的。<br>
这样做的好处是，不用每次在 render 阶段都执行一次 createVNode 创建 vnode 对象，直接用之前在内存中创建好的 vnode 即可。</p>
<p data-nodeid="23785">那么为什么叫静态提升呢？</p>
<p data-nodeid="23786">因为这些静态节点不依赖动态数据，一旦创建了就不会改变，所以只有静态节点才能被提升到外部创建。</p>
<p data-nodeid="23787">了解以上背景知识后，我们接下来看一下静态提升的实现：</p>
<pre class="lang-java" data-nodeid="37380"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">hoistStatic</span><span class="hljs-params">(root, context)</span> </span>{
  walk(root, context, <span class="hljs-keyword">new</span> Map(),
    <span class="hljs-comment">// Root node is unfortunately non-hoistable due to potential parent fallthrough attributes.</span>
    isSingleElementRoot(root, root.children[<span class="hljs-number">0</span>]));
}
<span class="hljs-function">function <span class="hljs-title">walk</span><span class="hljs-params">(node, context, resultCache, doNotHoistNode = <span class="hljs-keyword">false</span>)</span> </span>{
  let hasHoistedNode = <span class="hljs-keyword">false</span>
  <span class="hljs-comment">// 是否包含运行时常量</span>
  let hasRuntimeConstant = <span class="hljs-keyword">false</span>
  <span class="hljs-keyword">const</span> { children } = <span class="hljs-function">node
  <span class="hljs-title">for</span> <span class="hljs-params">(let i = <span class="hljs-number">0</span>; i &lt; children.length; i++)</span> </span>{
    <span class="hljs-keyword">const</span> child = children[i]
    <span class="hljs-comment">// 只有普通元素和文本节点才能被静态提升</span>
    <span class="hljs-keyword">if</span> (child.type === <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span> &amp;&amp;
      child.tagType === <span class="hljs-number">0</span> <span class="hljs-comment">/* ELEMENT */</span>) {
      <span class="hljs-function">let staticType
      <span class="hljs-title">if</span> <span class="hljs-params">(!doNotHoistNode &amp;&amp;
        // 获取静态节点的类型，如果是元素，则递归检查它的子节点
        (staticType = getStaticType(child, resultCache)</span>) &gt; 0) </span>{
        <span class="hljs-keyword">if</span> (staticType === <span class="hljs-number">2</span> <span class="hljs-comment">/* HAS_RUNTIME_CONSTANT */</span>) {
          hasRuntimeConstant = <span class="hljs-keyword">true</span>
        }
        <span class="hljs-comment">// 更新 patchFlag</span>
        child.codegenNode.patchFlag =
          -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span> + ((process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) ? \` <span class="hljs-comment">/* HOISTED */</span>\` : \`\`)
        <span class="hljs-comment">// 更新节点的 codegenNode</span>
        child.codegenNode = context.hoist(child.codegenNode)
        hasHoistedNode = <span class="hljs-keyword">true</span>
        <span class="hljs-keyword">continue</span>
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 节点可能会包含一些动态子节点，但它的静态属性还是可以被静态提升</span>
        <span class="hljs-keyword">const</span> codegenNode = child.<span class="hljs-function">codegenNode
        <span class="hljs-title">if</span> <span class="hljs-params">(codegenNode.type === <span class="hljs-number">13</span> <span class="hljs-comment">/* VNODE_CALL */</span>)</span> </span>{
          <span class="hljs-keyword">const</span> flag = getPatchFlag(codegenNode)
          <span class="hljs-keyword">if</span> ((!flag ||
            flag === <span class="hljs-number">512</span> <span class="hljs-comment">/* NEED_PATCH */</span> ||
            flag === <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>) &amp;&amp;
            !hasDynamicKeyOrRef(child) &amp;&amp;
            !hasCachedProps()) {
            <span class="hljs-keyword">const</span> props = getNodeProps(child)
            <span class="hljs-keyword">if</span> (props) {
              codegenNode.props = context.hoist(props)
            }
          }
        }
      }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.type === <span class="hljs-number">12</span> <span class="hljs-comment">/* TEXT_CALL */</span>) {
      <span class="hljs-comment">// 文本节点也可以静态提升</span>
      <span class="hljs-keyword">const</span> staticType = getStaticType(child.content, resultCache)
      <span class="hljs-keyword">if</span> (staticType &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (staticType === <span class="hljs-number">2</span> <span class="hljs-comment">/* HAS_RUNTIME_CONSTANT */</span>) {
          hasRuntimeConstant = <span class="hljs-keyword">true</span>
        }
        child.codegenNode = context.hoist(child.codegenNode)
        hasHoistedNode = <span class="hljs-keyword">true</span>
      }
    }
    <span class="hljs-keyword">if</span> (child.type === <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span>) {
      <span class="hljs-comment">// 递归遍历子节点</span>
      walk(child, context, resultCache)
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.type === <span class="hljs-number">11</span> <span class="hljs-comment">/* FOR */</span>) {
      walk(child, context, resultCache, child.children.length === <span class="hljs-number">1</span>)
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.type === <span class="hljs-number">9</span> <span class="hljs-comment">/* IF */</span>) {
      <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; child.branches.length; i++) {
        walk(child.branches[i], context, resultCache, child.branches[i].children.length === <span class="hljs-number">1</span>)
      }
    }
  }
  <span class="hljs-keyword">if</span> (!hasRuntimeConstant &amp;&amp; hasHoistedNode &amp;&amp; context.transformHoist) {
    <span class="hljs-comment">// 如果编译配置了 transformHoist，则执行</span>
    context.transformHoist(children, context, node)
  }
}
</code></pre>

<p data-nodeid="23789">可以看到，hoistStatic 主要就是从根节点开始，通过递归的方式去遍历节点，只有普通元素和文本节点才能被静态提升，所以针对这些节点，这里通过 getStaticType 去获取静态类型，如果节点是一个元素类型，getStaticType 内部还会递归判断它的子节点的静态类型。</p>
<p data-nodeid="23790">虽然有的节点包含一些动态子节点，但它本身的静态属性还是可以被静态提升的。</p>
<p data-nodeid="23791">注意，<strong data-nodeid="23912">如果 getStaticType 返回的 staticType 的值是 2</strong>，<strong data-nodeid="23913">则表明它是一个运行时常量</strong>，<strong data-nodeid="23914">由于它的值在运行时才能被确定</strong>，<strong data-nodeid="23915">所以是不能静态提升的</strong>。</p>
<p data-nodeid="23792">如果节点满足可以被静态提升的条件，节点对应的 codegenNode 会通过执行 context.hoist 修改为一个简单表达式节点：</p>
<pre class="lang-java" data-nodeid="37843"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">hoist</span><span class="hljs-params">(exp)</span> </span>{
  context.hoists.push(exp);
  <span class="hljs-keyword">const</span> identifier = createSimpleExpression(\`_hoisted_\${context.hoists.length}\`, <span class="hljs-keyword">false</span>, exp.loc, <span class="hljs-keyword">true</span>)
  identifier.hoisted = exp
  <span class="hljs-keyword">return</span> identifier
}
child.codegenNode = context.hoist(child.codegenNode)
</code></pre>

<p data-nodeid="23794">改动后的 codegenNode 会在生成代码阶段帮助我们生成静态提升的相关代码。</p>
<h3 data-nodeid="23795">createRootCodegen</h3>
<p data-nodeid="23796">完成静态提升后，我们来到了 AST 转换的最后一步，即<strong data-nodeid="23924">创建根节点的代码生成节点</strong>。我们先来看一下 createRootCodegen 的实现：</p>
<pre class="lang-java" data-nodeid="38306"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createRootCodegen</span><span class="hljs-params">(root, context)</span> </span>{
  <span class="hljs-keyword">const</span> { helper } = context;
  <span class="hljs-keyword">const</span> { children } = root;
  <span class="hljs-keyword">const</span> child = children[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">if</span> (children.length === <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// 如果子节点是单个元素节点，则将其转换成一个 block</span>
    <span class="hljs-keyword">if</span> (isSingleElementRoot(root, child) &amp;&amp; child.codegenNode) {
      <span class="hljs-keyword">const</span> codegenNode = child.codegenNode;
      <span class="hljs-keyword">if</span> (codegenNode.type === <span class="hljs-number">13</span> <span class="hljs-comment">/* VNODE_CALL */</span>) {
        codegenNode.isBlock = <span class="hljs-keyword">true</span>;
        helper(OPEN_BLOCK);
        helper(CREATE_BLOCK);
      }
      root.codegenNode = codegenNode;
    }
    <span class="hljs-keyword">else</span> {
      root.codegenNode = child;
    }
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (children.length &gt; <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// 如果子节点是多个节点，则返回一个 fragement 的代码生成节点</span>
    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, \`\${<span class="hljs-number">64</span> <span class="hljs-comment">/* STABLE_FRAGMENT */</span>} <span class="hljs-comment">/* \${PatchFlagNames[64 /* STABLE_FRAGMENT */</span>]} */\`, undefined, undefined, <span class="hljs-keyword">true</span>);
  }
}
</code></pre>

<p data-nodeid="23798">createRootCodegen 做的事情很简单，就是为 root 这个虚拟的 AST 根节点创建一个代码生成节点，如果 root 的子节点 children 是单个元素节点，则将其转换成一个 Block，把这个 child 的 codegenNode 赋值给 root 的 codegenNode。</p>
<p data-nodeid="39721" class="">如果 root 的子节点 children 是多个节点，则返回一个 fragement 的代码生成节点，并赋值给 root 的 codegenNode。</p>
<p data-nodeid="39722">这里，创建 codegenNode 就是为了后续生成代码时使用。</p>
<p data-nodeid="39723">createRootCodegen 完成之后，接着把 transform 上下文在转换 AST 节点过程中创建的一些变量赋值给 root 节点对应的属性，在这里可以看一下这些属性：</p>
<pre class="lang-yaml" data-nodeid="50376"><code data-language="yaml"><span class="hljs-string">root.helpers</span> <span class="hljs-string">=</span> [<span class="hljs-string">...context.helpers</span>]
<span class="hljs-string">root.components</span> <span class="hljs-string">=</span> [<span class="hljs-string">...context.components</span>]
<span class="hljs-string">root.directives</span> <span class="hljs-string">=</span> [<span class="hljs-string">...context.directives</span>]
<span class="hljs-string">root.imports</span> <span class="hljs-string">=</span> [<span class="hljs-string">...context.imports</span>]
<span class="hljs-string">root.hoists</span> <span class="hljs-string">=</span> <span class="hljs-string">context.hoists</span>
<span class="hljs-string">root.temps</span> <span class="hljs-string">=</span> <span class="hljs-string">context.temps</span>
<span class="hljs-string">root.cached</span> <span class="hljs-string">=</span> <span class="hljs-string">context.cached</span>
</code></pre>
























<pre data-nodeid="39233"><code></code></pre>





<p data-nodeid="23803">这样后续在代码生成节点时，就可以通过 root 这个根节点访问到这些变量了。</p>
<h3 data-nodeid="23804">总结</h3>
<p data-nodeid="23805">好的，到这里我们这一节的学习就结束啦，通过这节课的学习，你应该对 AST 节点内部做了哪些转换有所了解。</p>
<p data-nodeid="23806">如果说 parse 阶段是一个词法分析过程，构造基础的 AST 节点对象，那么 transform 节点就是语法分析阶段，把 AST 节点做一层转换，构造出语义化更强，信息更加丰富的 codegenCode，它在后续的代码生成阶段起着非常重要的作用。</p>
<p data-nodeid="23807">最后，给你留一道思考题目，我们已经知道静态提升的好处是，针对静态节点不用每次在 render 阶段都执行一次 createVNode 创建 vnode 对象，但它有没有成本呢？为什么？欢迎你在留言区与我分享。</p>
<blockquote data-nodeid="23808">
<p data-nodeid="23809">本节课的相关代码在源代码中的位置如下：<br>
packages/compiler-core/src/ast.ts<br>
packages/compiler-core/src/transform.ts<br>
packages/compiler-core/src/transforms/transformText.ts<br>
packages/compiler-core/src/transforms/vIf.ts<br>
packages/compiler-core/src/transforms/hoistStatic.ts</p>
</blockquote></div>

</body></html>