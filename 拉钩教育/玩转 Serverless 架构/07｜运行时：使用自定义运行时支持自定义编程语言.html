<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lagou DOC</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>07｜运行时：使用自定义运行时支持自定义编程语言</h1><p data-nodeid="62907" class="">这一讲我将带你了解如何自定义函数运行时。</p>
<p data-nodeid="62908">我们知道 Serverless 应用的函数代码是在 FaaS 中运行的，到目前为止，你也只能选择 FaaS 平台支持的编程语言开发应用，而 FaaS 平台支持的编程语言不但有限，还只支持极少数的特定版本，比如函数计算只支持 Node.js 12、Node.js 8、Java、Python 等 。这样一来，当你想用 FaaS 平台不支持的编程语言（比如 TypeScrip、Golang、Ruby ）或各种编程语言的小版本（比如最新的 Node.js）时，该怎么办呢？<strong data-nodeid="63002">这就需要使用自定义运行时了。</strong></p>
<p data-nodeid="62909">主流的 FaaS 平台都支持自定义运行时，实现原理也都大致相同。为了让你弄清楚自定义运行时的原理，并学会开发一个自定义运行时，这一讲我将分为原理和实现两部分。</p>
<ul data-nodeid="62910">
<li data-nodeid="62911">
<p data-nodeid="62912"><strong data-nodeid="63008">自定义运行时的原理：</strong> 首先我会带你了解一个通用的 FaaS 自定义运行时原理，这样你使用任何 FaaS 平台都可以触类旁通了。</p>
</li>
<li data-nodeid="62913">
<p data-nodeid="62914"><strong data-nodeid="63013">自定义运行时的实现：</strong> 我会带你分别实现一个 TypeScript 运行时，和 Golang 的运行时，从易到难让你彻底掌握自定义运行时的实现。</p>
</li>
</ul>
<p data-nodeid="62915">话不多说，我们进行今天的学习。</p>
<h3 data-nodeid="62916">自定义运行时的原理</h3>
<p data-nodeid="62917">运行时（Runtime）是程序运行时所依赖的环境（环境包括任何库、框架或平台）。FaaS 中的运行时，就是你创建函数时指定的运行环境，比如函数计算的 Node.js 运行时，就包括 Node.js 运行环境以及一些内置的模块，如 ali-oss、tablestore，此外还有 Java 运行时、Python 运行时等。那自定义运行时就是你可以在 FaaS 自定义一个运行环境，如 TypeScript，然后你就可以使用 TypeScript 来编写代码并部署到 FaaS 平台上运行。</p>
<p data-nodeid="62918">在了解自定义运行时的原理前，咱们先来回顾 FaaS 的运行原理（我在“04 | 运行原理：Serverless 应用是怎么运行的？”讲中提到过）。在 FaaS 中，运行时被预先定义，比如在创建函数时可以指定 runtime:nodejs12 ，接下来，用户通过触发器驱动函数执行后，FaaS 就会以 Node.js 12 作为运行时来创建函数实例，函数代码也就在 Node.js 12 这个运行环境中执行。</p>
<p data-nodeid="62919"><img src="https://s0.lgstatic.com/i/image2/M01/05/12/Cip5yF_7uYKAQkbBAAJKyufn9-8829.png" alt="Drawing 0.png" data-nodeid="63026"></p>
<div data-nodeid="62920"><p style="text-align:center">FaaS 运行原理</p></div>
<p data-nodeid="62921"><strong data-nodeid="63033">那怎么才能让函数在自己定义的运行环境中执行呢？</strong> 这就涉及“06 | 依赖管理：Serverless 应用怎么安装依赖？”的内容了。在这一讲中我讲了：安装依赖的本质就是要把函数运行所需要的依赖都打包上传到 FaaS 中，这些依赖既可以是代码依赖包，还可以是系统依赖库。那你能不能把函数的运行时也打包上传到 FaaS 中，让 FaaS 利用你上传的运行时来执行你的代码呢？</p>
<p data-nodeid="62922">当然可以，并且 FaaS 平台的自定义运行时也是这样实现的。</p>
<p data-nodeid="62923">比如你可以用 TypeScript 编写代码，然后将代码和 TypeScript 运行时都上传到 FaaS 中，然后通过特定的配置，让 FaaS 通过自定义的 TypeScript 运行时来运行你的代码。比如通过 <code data-backticks="1" data-nodeid="63036">runtime:custom</code>配置告诉 FaaS 你使用的时自定义运行时，然后用 <code data-backticks="1" data-nodeid="63038">bootstrap: ts-node index.ts</code>配置来告诉 FaaS 函数启动时，使用 ts-node 来运行 index.ts。</p>
<p data-nodeid="62924">这样一来，我们就解决了使用自定义运行时运行自定义编程语言的代码问题。**但还存在一个问题：**FaaS 平台在运行函数时会有很多参数（比如事件信息、函数上下文等），这些参数怎么传递给自定义运行时呢？这本质上是远程数据通信问题，最简单的就是 HTTP 协议来实现：在自定义运行时中实现一个 HTTP 服务，FaaS 平台通过 HTTP 请求把数据传递给自定义运行时。</p>
<p data-nodeid="62925">讲到这儿，一个自定义运行时的原理图就可以总结出来了：</p>
<p data-nodeid="62926"><img src="https://s0.lgstatic.com/i/image2/M01/05/14/CgpVE1_7uY6AJB5xAAF4dxbQVU0166.png" alt="Drawing 1.png" data-nodeid="63050"></p>
<div data-nodeid="62927"><p style="text-align:center">自定义运行时原理</p></div>
<p data-nodeid="62928">简单来讲，自定义运行时就是一个使用自定义编程语言实现的 HTTP 服务。然后你需要为你的 HTTP 服务指定一个启动命令，通用的做法是将启动命令保存在名为 bootstrap 的文件中。bootstrap 文件示例：</p>
<pre class="lang-shell" data-nodeid="62929"><code data-language="shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>
./node_modules/ts-node/dist/bin.js server.ts
</code></pre>
<p data-nodeid="62930">FaaS 平台在创建函数实例时，会执行 bootstrap 文件启动 HTTP 服务，然后将所有请求及参数都转发到你的 HTTP 服务中，由 HTTP 服务处理所有请求。<br>
讲完自定义运行时的原理之后，我们接着来实现一个自定义运行时。</p>
<h3 data-nodeid="62931">自定义运行时的实现</h3>
<p data-nodeid="62932">我会从易到难，先讲解如何实现一个 TypeScript 运行时，然后再介绍如何实现 Golang 运行时，这是两个很典型的例子，并且你掌握了如何自定义 Golang 运行时之后，就可以轻松自定义其他编程语言的运行时了。为了方便你进行实践，我选择了用得比较多的函数计算进行演示，同时我也为你提供了<a href="https://github.com/nodejh/serverless-class/tree/master/07" data-nodeid="63059">示例程序</a>，你可以直接下载使用。</p>
<h4 data-nodeid="62933">实现一个 TypeScript 运行时</h4>
<p data-nodeid="62934">TypeScript 为 JS 代码增加了类型系统，可以大大提升代码的可读性和可维护性。然而现在大多数 FaaS 平台都不直接支持 TypeScript，要想使用 TypeScript 编写 Serverless 应用，通常需要把代码编译为 JavaScript 再运行。显然这没有直接使用部署并执行 TypeScript 代码高效。我们如果想要直接运行 TypeScript 代码，可以通过 ts-node 来实现。所以你可以基于 ts-node 实现一个 TypeScript 运行时，这样就可以直接使用 TypeScript 编写 Serverless 应用了。</p>
<p data-nodeid="62935">那怎么实现呢？</p>
<p data-nodeid="62936">首先在本地创建一个 TypeScript 项目，然后安装必要的依赖，为了将依赖都上传到 FaaS，我们需要将 ts-node 等相关依赖（ts-node、typescript 和 @types/node）都安装在项目的 node_modules 中，如下所示：</p>
<pre class="lang-shell" data-nodeid="62937"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> npm i -S ts-node</span>
<span class="hljs-meta">$</span><span class="bash"> npm i -S typescript</span>
<span class="hljs-meta">$</span><span class="bash"> npm i -D @types/node</span>
</code></pre>
<p data-nodeid="62938">前面我们已经学习了自定义运行时需要实现一个 HTTP 服务来接收 FaaS 平台的请求，所以接下来我们就使用 TypeScript 编写一个 HTTP 服务：</p>
<pre class="lang-typescript" data-nodeid="62939"><code data-language="typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'http'</span>;
<span class="hljs-comment">/**
 * 你可以在这里实现具体的业务逻辑
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">\`Hello, <span class="hljs-subst">\${name}</span>\`</span>;
}
<span class="hljs-comment">// 创建一个 HTTP 服务</span>
<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req: http.IncomingMessage, res: http.ServerResponse</span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-comment">// 获取 RequestId</span>
  <span class="hljs-keyword">const</span> requestId = req.headers[<span class="hljs-string">"x-fc-request-id"</span>];
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\`FC Invoke Start RequestId: <span class="hljs-subst">\${requestId}</span>\`</span>);
  <span class="hljs-comment">// 拼接请求参数</span>
  <span class="hljs-keyword">let</span> rawData = <span class="hljs-string">""</span>;
  req.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>{
    rawData += chunk;
  });
  req.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-comment">// 处理业务逻辑，比如这里是输出欢迎语</span>
    <span class="hljs-keyword">const</span> body = sayHello(rawData);
    <span class="hljs-comment">// 设置 HTTP 响应</span>
    res.writeHead(<span class="hljs-number">200</span>);
    res.end(body);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\`FC Invoke End RequestId: <span class="hljs-subst">\${requestId}</span>\`</span>);
  });
});
server.timeout = <span class="hljs-number">0</span>;
server.keepAliveTimeout = <span class="hljs-number">0</span>;
<span class="hljs-comment">// 启动 HTTP 服务并监听 9000 端口</span>
server.listen(<span class="hljs-number">9000</span>, <span class="hljs-string">'0.0.0.0'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'FunctionCompute typescript runtime initialized.'</span>);
});
</code></pre>
<p data-nodeid="62940">这段代码启动了一个 HTTP 服务，监听 0.0.0.0:9000 端口（这也是函数计算要求的）。然后我们可以先在本地测试，通过安装在项目中的 ts-node &nbsp;命令来运行上述代码：</p>
<pre class="lang-shell" data-nodeid="62941"><code data-language="shell"><span class="hljs-meta">#</span><span class="bash"> 启动 HTTP 服务</span>
<span class="hljs-meta">$</span><span class="bash"> ./node_modules/ts-node/dist/bin.js server.ts</span>
</code></pre>
<p data-nodeid="62942">然后在另一个终端中使用 curl 命令进行测试：</p>
<pre class="lang-shell" data-nodeid="62943"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> curl 0.0.0.0:9000 -X POST -d <span class="hljs-string">"Serverless"</span> -H <span class="hljs-string">"x-fc-request-id:abcde"</span></span>
Hello, Serverless
</code></pre>
<p data-nodeid="62944">HTTP 服务测试正常后，我们的自定义运行时就完成了。你可以在接收 HTTP 请求后处理业务逻辑，然后将处理结果再以 HTTP 响应返回给 FaaS 平台。</p>
<p data-nodeid="62945">当然了，在将自定义运行时部署到 FaaS 之前还需要创建一个名为 bootstrap 的文件，在文件中添加启动命令，这样 FaaS 才知道如何启动你的自定义运行时，如下所示：</p>
<pre class="lang-java" data-nodeid="62946"><code data-language="java">#!/bin/bash
./node_modules/ts-node/dist/bin.js server.ts
</code></pre>
<p data-nodeid="62947">接下来我们还需要添加函数计算的 template.yaml 配置，定义函数信息：</p>
<pre class="lang-yaml" data-nodeid="62948"><code data-language="yaml"><span class="hljs-attr">ROSTemplateFormatVersion:</span> <span class="hljs-string">'2015-09-01'</span>
<span class="hljs-attr">Transform:</span> <span class="hljs-string">'Aliyun::Serverless-2018-04-03'</span>
<span class="hljs-attr">Resources:</span>
  <span class="hljs-attr">custom-typescript-demo:</span>
    <span class="hljs-attr">Type:</span> <span class="hljs-string">'Aliyun::Serverless::Service'</span>
    <span class="hljs-attr">Properties:</span>
      <span class="hljs-attr">Description:</span> <span class="hljs-string">'helloworld'</span>
    <span class="hljs-attr">typescript-demo:</span>
      <span class="hljs-attr">Type:</span> <span class="hljs-string">'Aliyun::Serverless::Function'</span>
      <span class="hljs-attr">Properties:</span>
        <span class="hljs-attr">Runtime:</span> <span class="hljs-string">custom</span>
        <span class="hljs-attr">MemorySize:</span> <span class="hljs-number">512</span>
        <span class="hljs-attr">Handler:</span> <span class="hljs-string">index.handler</span>
        <span class="hljs-attr">CodeUri:</span> <span class="hljs-string">'./'</span>
</code></pre>
<p data-nodeid="62949">你要注意一下，在这份 YAML 配置中，Runtime 的值必须为 custom，Handler 属性在这里没有实际意义但是必须填写。</p>
<p data-nodeid="62950">接下来就可以使用&nbsp;fun deploy 将自定义运行时部署到函数计算了。部署后可以使用 fun invoke 进行测试：</p>
<pre class="lang-shell" data-nodeid="62951"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> fun deploy -y</span>
...
Waiting for service custom-typescript-demo to be deployed...
    Waiting for function typescript-demo to be deployed...
        Waiting for packaging function typescript-demo code...
        The function typescript-demo has been packaged. A total of 363 files were compressed and the final size was 10.4 MB
        function typescript-demo deploy success
service custom-typescript-demo deploy success
</code></pre>
<pre class="lang-shell" data-nodeid="62952"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> fun invoke -e <span class="hljs-string">"Serverless"</span></span>
...
FC Invoke Result:
Hello Serverless
</code></pre>
<p data-nodeid="62953">这时函数计算就是使用自定义的 TypeScript 运行环境直接运行我们的 TypeScript 代码。</p>
<p data-nodeid="62954">TypeScript 的运行时比较简单，因为 ts-node 可以直接安装在 node_modules 中，那么其他无法直接安装在依赖目录中的编程语言，比如 Golang 或最新版 Node.js 的自定义运行时应该怎么实现呢？</p>
<h4 data-nodeid="62955">实现一个 Golang 的运行时</h4>
<p data-nodeid="62956">如果要沿用 TypeScript 这种自定义启动命令的方案，就需要将 Golang 和代码打包，但 Golang 是直接安装在操作系统上的，依赖系统环境，好像无从下手。</p>
<p data-nodeid="62957"><strong data-nodeid="63085">但你思考一下，将运行环境和代码打包，这种思想是不是和容器技术很像？</strong> 容器技术就是将应用和运行所依赖环境打包为镜像，这样应用可以轻松迁移、部署。那能不能把 Golang 运行环境构建为 Docker 镜像，然后让 FaaS 平台使用你的 Docker 镜像去执行代码呢？这样只要 FaaS 平台能支持自定义容器，就能实现任意编程语言的运行时了。答案是肯定的，很多 FaaS 平台（比如 Lambda 和函数计算）也都提供了自定义容器的能力。</p>
<p data-nodeid="62958">使用容器自定义运行时，你需要先构建一个容器镜像，然后通过函数的配置告诉 FaaS 平台使用你的容器镜像。在函数执行时，FaaS 平台就会拉取容器镜像并启动容器执行代码。与前面 TypeScript 运行时一样，在自定义容器镜像中你也需要实现一个 HTTP 服务，接收 FaaS 平台的所有请求。</p>
<p data-nodeid="62959"><img src="https://s0.lgstatic.com/i/image2/M01/05/14/CgpVE1_7uayAMv-5AATwsp__Ojw457.png" alt="Drawing 2.png" data-nodeid="63089"></p>
<div data-nodeid="62960"><p style="text-align:center">自定义运行时使用流程</p></div>
<p data-nodeid="62961">那我们就一起来实现一下吧！</p>
<p data-nodeid="62962">还是以函数计算为例，首先你需要准备一个镜像仓库，用来存放你的镜像，函数计算目前只支持<a href="https://cr.console.aliyun.com/cn-beijing/instances/repositories" data-nodeid="63094">容器镜像服务</a>中的镜像（大部分 FaaS 也都只支持自家的镜像仓库），所以你需要构建自定义运行时镜像然后上传到容器镜像服务中。你可以提前在容器服务中创建一个命名空间和镜像仓库，创建完毕后记住你的仓库地址，格式为registry.&lt;地域&gt;.aliyuncs.com/&lt;命名空间&gt;/&lt;仓库名&gt; ，例如 registry.cn-hangzhou.aliyuncs.com/serverless-image/nodejs15 。</p>
<p data-nodeid="62963">接下来进入开发步骤。</p>
<p data-nodeid="62964">首先我们使用 Golang 实现一个 HTTP 服务，代码如下：</p>
<pre class="lang-go" data-nodeid="62965"><code data-language="go"><span class="hljs-keyword">package</span> main
<span class="hljs-keyword">import</span> (
   <span class="hljs-string">"fmt"</span>
   <span class="hljs-string">"net/http"</span>
   <span class="hljs-string">"runtime"</span>
)
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
   fmt.Fprintf(w, <span class="hljs-string">"Hello Serverless! This is Golang runtime, version: %s"</span>, runtime.Version())
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span> {
   http.HandleFunc(<span class="hljs-string">"/"</span>, HelloHandler)
   http.ListenAndServe(<span class="hljs-string">":8080"</span>, <span class="hljs-literal">nil</span>)
}
</code></pre>
<p data-nodeid="62966">在这个 HTTP 服务中我们定义了 / 这个路由，逻辑就是返回当前 Golang 的版本。当基于容器实现自定义运行时，函数计算会将 HTTP 触发器的请求转发到 &nbsp;/ 路由，将事件触发器的请求转发到 /invoke 路由。</p>
<p data-nodeid="62967">然后我们也可以先在本地测试，为了简单，可以直接通过 go run main.go 的命令启动 HTTP 服务，然后使用 curl 命令测试：</p>
<pre class="lang-java" data-nodeid="62968"><code data-language="java"># 启动 HTTP 服务
$ go run main.go
</code></pre>
<pre class="lang-java" data-nodeid="62969"><code data-language="java"># 新开一个终端，通过 curl 命令测试
$ curl localhost:8080
Hello Serverless! This is Golang runtime, version: go1.13.5
</code></pre>
<p data-nodeid="62970">（这里返回的 golang 版本是 1.3.15，这是因为我的电脑上安装的是该版本）。</p>
<p data-nodeid="62971">接下来我们需要编写一个 Dockerfile，用来构建包含 Golang 运行时及代码的镜像：</p>
<pre class="lang-java" data-nodeid="62972"><code data-language="java"># Dockerfile
FROM golang:1.15.6-alpine3.12
WORKDIR /go/src/app
# 将代码复制到工作目录
COPY . .
# 编译
RUN go build main.go
# 暴露 8080 端口
EXPOSE 8080
# 启动应用
ENTRYPOINT [ "./main" ]
</code></pre>
<p data-nodeid="62973">在这个 Dockerfile 中，我们使用了 golang:1.15.6-alpine3.12 作为基础镜像，其中 alpine 是最小体积的 golang 运行环境。然后我们使用 go build 来编译代码，最后启动应用。</p>
<p data-nodeid="62974">接下来就可以构建并上传镜像了，如果是第一次使用容器镜像服务，则需要先使用 docker login 登录。</p>
<pre class="lang-java" data-nodeid="62975"><code data-language="java"># 指定镜像名称，例如 registry.cn-hangzhou.aliyuncs.com/serverless-image/golang:v0.1
$ export IMAGE_NAME="你的镜像仓库:版本"
$ docker build -t $IMAGE_NAME .
$ docker push $IMAGE_NAME
</code></pre>
<p data-nodeid="62976">镜像上传后，就可以创建一个 template.yaml 来定义函数配置了：</p>
<pre class="lang-yaml" data-nodeid="62977"><code data-language="yaml"><span class="hljs-attr">ROSTemplateFormatVersion:</span> <span class="hljs-string">'2015-09-01'</span>
<span class="hljs-attr">Transform:</span> <span class="hljs-string">'Aliyun::Serverless-2018-04-03'</span>
<span class="hljs-attr">Resources:</span>
  <span class="hljs-attr">serverless:</span>
    <span class="hljs-attr">Type:</span> <span class="hljs-string">'Aliyun::Serverless::Service'</span>
    <span class="hljs-attr">Properties:</span>
      <span class="hljs-attr">Policies:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">AliyunContainerRegistryReadOnlyAccess</span>
      <span class="hljs-attr">InternetAccess:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">golang-runtime:</span>
      <span class="hljs-attr">Type:</span> <span class="hljs-string">'Aliyun::Serverless::Function'</span>
      <span class="hljs-attr">Properties:</span>
        <span class="hljs-attr">Description:</span> <span class="hljs-string">'Golang Runtime'</span>
        <span class="hljs-attr">Runtime:</span> <span class="hljs-string">custom-container</span>
        <span class="hljs-attr">Timeout:</span> <span class="hljs-number">60</span>
        <span class="hljs-attr">CAPort:</span> <span class="hljs-number">8080</span>
        <span class="hljs-attr">Handler:</span> <span class="hljs-string">not-used</span>
        <span class="hljs-attr">MemorySize:</span> <span class="hljs-number">1024</span>
        <span class="hljs-attr">CodeUri:</span> <span class="hljs-string">./</span>
        <span class="hljs-attr">CustomContainerConfig:</span>
          <span class="hljs-attr">Image:</span> <span class="hljs-string">'registry.cn-hangzhou.aliyuncs.com/serverless-image/golang:v0.1'</span>
</code></pre>
<p data-nodeid="62978">这份 YAML 配置中，Runtime 值为custom-container ，表示该函数是自定义容器，然后通过 CustomContainerConfig 配置容器镜像。示例中我直接使用的 registry.cn-hangzhou.aliyuncs.com 这个 endpoint，但通常为了更快拉取镜像，一般会使用 VPC 地址，如registry-vpc.cn-beijing.aliyuncs.com/serverless-image/golang:v0.1。</p>
<p data-nodeid="62979">接下来就可以通过 fun deploy 进行部署，fun invoke &nbsp;进行测试：</p>
<pre class="lang-java" data-nodeid="62980"><code data-language="java">$ fun deploy
$ fun invoke
Hello Serverless! This is Golang runtime, version: go1<span class="hljs-number">.15</span><span class="hljs-number">.6</span>
</code></pre>
<p data-nodeid="62981">可以看到，执行结果中 Golang 版本是 1.15.6，说明自定义运行时正常工作了。</p>
<h3 data-nodeid="62982">总结</h3>
<p data-nodeid="62983">这一讲我首先为你讲解了自定义运行时的基本原理，然后以 TypeScript 运行时和 Golang 运行时为例，为你详细介绍了如何创建一个自定义运行时。关于这一讲的内容，我想要强调以下几点：</p>
<ul data-nodeid="63837">
<li data-nodeid="63838">
<p data-nodeid="63839">FaaS 平台提供了有限的编程语言及版本的支持，使用自定义运行时，你可以自定义编程语言进行开发；</p>
</li>
<li data-nodeid="63840">
<p data-nodeid="63841">自定义运行时的原理是在函数中实现一个 HTTP 服务，FaaS 平台将触发器事件转发到你的 HTTP 服务；</p>
</li>
<li data-nodeid="63842">
<p data-nodeid="63843">你可以通过将运行时上传到 FaaS，在 bootstrap 中定义启动命令来实现自定义运行时，比如 TypeScript；</p>
</li>
<li data-nodeid="63844">
<p data-nodeid="63845">你也可以通过自定义容器镜像来实现任意编程语言的自定义运行时。</p>
</li>
</ul>
<p data-nodeid="63846"><strong data-nodeid="63856">自定义运行时是 Serverless 应用开中非常重要的一个功能，</strong> 它可以让你突破 FaaS 平台运行环境的限制，可以让你使用 FaaS 平台不支持的编程语言进行开发。你应该也能发现，基于容器实现自定义运行时你可以很方便地安装依赖，因为依赖都打包到了镜像中。除此之外，基于自定义运行时，你还可以平滑地将原有系统或传统应用平滑迁移到 Serverless 架构。</p>
<p data-nodeid="63847" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/8D/40/CgqCHl_8BQmAJmTXAAEfdIEkDno978.png" alt="Lark20210111-155706.png" data-nodeid="63859"></p>






<p data-nodeid="62994">最后我留给你的作业就是：根据我所讲的内容，举一反三地实现一个最新版 Node.js 运行时。我们下一讲见。</p>
<blockquote data-nodeid="62995">
<p data-nodeid="62996" class="">本讲的代码地址：<a href="https://github.com/nodejh/serverless-class/tree/master/07" data-nodeid="63129">https://github.com/nodejh/serverless-class/tree/master/07</a></p>
</blockquote></div>

</body></html>