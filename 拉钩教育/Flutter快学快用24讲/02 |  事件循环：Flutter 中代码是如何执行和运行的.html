<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>02 |  事件循环：Flutter 中代码是如何执行和运行的</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>02 |  事件循环：Flutter 中代码是如何执行和运行的</h1><p data-nodeid="10386" class="">上节课介绍了 Dart 基础数据类型、基础运算符、类以及库与调用。本课时着重通过实践带你掌握 Dart 的运行原理。</p>
<h3 data-nodeid="10387">Dart 单线程</h3>
<p data-nodeid="10388">单线程在流畅性方面有一定安全保障，这点在 JavaScript 中存在类似的机制原理，其核心是分为主线程、微任务和宏任务。主线程执行主业务逻辑，网络 I/O 、本地文件 I/O 、异步事件等相关任务事件，应用事件驱动方式来执行。在 Dart 中同样是单线程执行，其次也包含了两个事件队列，一个是微任务事件队列，一个是事件队列。</p>
<ul data-nodeid="10389">
<li data-nodeid="10390">
<p data-nodeid="10391">微任务队列</p>
</li>
</ul>
<p data-nodeid="10392">微任务队列包含有 Dart 内部的微任务，主要是通过 scheduleMicrotask 来调度。</p>
<ul data-nodeid="10393">
<li data-nodeid="10394">
<p data-nodeid="10395">事件队列</p>
</li>
</ul>
<p data-nodeid="10396">事件队列包含外部事件，例如 I/O 、 Timer ，绘制事件等等。</p>
<h4 data-nodeid="10397">事件循环</h4>
<p data-nodeid="10398">既然 Dart 包含了微任务和事件任务，那么这两个任务之间是如何进行循环执行的呢？我们可以先看下 Dart 执行的逻辑过程（如图 1）：</p>
<ol data-nodeid="10399">
<li data-nodeid="10400">
<p data-nodeid="10401">首先是执行 main 函数，并生产两个相应的微任务和事件任务队列；</p>
</li>
<li data-nodeid="10402">
<p data-nodeid="10403">判断是否存在微任务，有则执行，执行完成后再继续判断是否还存在微任务，无则判断是否存在事件任务；</p>
</li>
<li data-nodeid="10404">
<p data-nodeid="10405">如果没有可执行的微任务，则判断是否存在事件任务，有则执行，无则继续返回判断是否还存在微任务；</p>
</li>
<li data-nodeid="10406">
<p data-nodeid="10407">在微任务和事件任务执行过程中，同样会产生微任务和事件任务，因此需要再次判断是否需要插入微任务队列和事件任务队列。</p>
</li>
</ol>
<p data-nodeid="10408"><img src="https://s0.lgstatic.com/i/image/M00/1D/7D/Ciqc1F7h_D2ARi2aAAJ2G36y8Ng725.png" alt="Drawing 0.png" data-nodeid="10566"></p>
<p data-nodeid="10409">图 1 Dart 事件循环机制</p>
<p data-nodeid="10410">为了验证上面的运行原理，我实现了下面的示例代码，首先 import async 库，然后在 main 函数中首先打印 flow start ，接下来执行一个微任务事件，再执行一个事件任务，最后再打印 flow end 。</p>
<pre class="lang-dart" data-nodeid="10411"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:async'</span>;
<span class="hljs-keyword">void</span> main() {
	<span class="hljs-built_in">print</span>(<span class="hljs-string">'flow start'</span>); <span class="hljs-comment">// 执行打印开始&nbsp;</span>
	<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>
	Timer.run((){&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">print</span>(<span class="hljs-string">'event'</span>); <span class="hljs-comment">// 执行事件任务，打印标记</span>
&nbsp; &nbsp;	});
&nbsp; &nbsp;	<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列&nbsp;</span>
	scheduleMicrotask((){&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">'microtask'</span>); <span class="hljs-comment">// 执行微任务，打印标记</span>
&nbsp; &nbsp; });
	<span class="hljs-built_in">print</span>(<span class="hljs-string">'flow end'</span>); <span class="hljs-comment">// 打印结束标记</span>
}
</code></pre>
<p data-nodeid="10412">使用 Dart 运行如上命令。</p>
<pre class="lang-shell" data-nodeid="10413"><code data-language="shell">dart flow.dart
</code></pre>
<p data-nodeid="10414">代码的实际运行过程如下：</p>
<ul data-nodeid="10415">
<li data-nodeid="10416">
<p data-nodeid="10417">首先主线程逻辑，执行打印 start ；</p>
</li>
<li data-nodeid="10418">
<p data-nodeid="10419">执行 Timer，为事件任务，将其增加到事件任务队列中；</p>
</li>
<li data-nodeid="10420">
<p data-nodeid="10421">执行 scheduleMicrotask，为微任务队列，将其增加到微任务队列中；</p>
</li>
<li data-nodeid="10422">
<p data-nodeid="10423">执行打印 flow end；</p>
</li>
<li data-nodeid="10424">
<p data-nodeid="10425">判断是否存在微任务队列，存在则执行微任务队列，打印 mcrotask；</p>
</li>
<li data-nodeid="10426">
<p data-nodeid="10427">判断是否还存在微任务队列，无则判断是否存在事件任务队列，存在执行事件任务队列，打印 event。</p>
</li>
</ul>
<pre class="lang-sql" data-nodeid="10428"><code data-language="sql">flow <span class="hljs-keyword">start</span>
flow <span class="hljs-keyword">end</span>
microtask
<span class="hljs-keyword">event</span>
</code></pre>
<p data-nodeid="10429">为了更清晰描述，可以我们使用图 2 动画来演示。</p>
<p data-nodeid="10430"><img src="https://s0.lgstatic.com/i/image/M00/1D/8A/CgqCHl7h_RmAFXa9AAnXFc-CvdQ552.gif" alt="flutter-flow-new.gif" data-nodeid="10580"></p>
<p data-nodeid="10431">图 2 Dart 主线程运行逻辑</p>
<p data-nodeid="10432">介绍完 Dart 的运行原理，你可能会产生以下疑问。</p>
<p data-nodeid="10433"><strong data-nodeid="10586">疑问1，为什么事件任务都执行完成了，还需要继续再循环判断是否有微任务？</strong></p>
<p data-nodeid="10434">核心解释是：微任务在执行过程中，也会产生新的事件任务，事件任务在执行过程中也会产生新的微任务。产生的新微任务，按照执行流程，需要根据队列方式插入到任务队列最后。</p>
<p data-nodeid="10435">我们通过代码来看下该过程。下面一段代码， import async 库，第一步打印 start ， 然后执行一个事件任务，在事件任务中打印 event 。接下来增加了一个微任务事件，在微任务事件中打印 microtask in event 。第二步执行微任务事件，在微任务事件中打印 microtask ，并且在其中增加事件任务队列，事件任务队列中打印 event in microtask ，最后再打印 flow end 。</p>
<pre class="lang-dart" data-nodeid="10436"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:async'</span>;
<span class="hljs-keyword">void</span> main() {
	<span class="hljs-built_in">print</span>(<span class="hljs-string">'flow start'</span>); <span class="hljs-comment">// 执行打印开始</span>
&nbsp;   <span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>
	Timer.run((){&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;	<span class="hljs-built_in">print</span>(<span class="hljs-string">'event'</span>); <span class="hljs-comment">// 执行事件任务，打印事件任务标记</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 执行判断为微任务，添加到微任务队列&nbsp;</span>
&nbsp; &nbsp; &nbsp; &nbsp;	scheduleMicrotask((){&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; 	<span class="hljs-built_in">print</span>(<span class="hljs-string">'microtask in event'</span>); <span class="hljs-comment">// 执行微任务，打印微任务标记</span>
&nbsp; &nbsp; 	});
&nbsp; &nbsp;	});
&nbsp; <span class="hljs-comment">// 执行判断为微任务，添加到微任务队列&nbsp;</span>
	scheduleMicrotask((){&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">'microtask'</span>); <span class="hljs-comment">// 执行微任务，打印微任务执行标记</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列&nbsp;</span>
&nbsp; &nbsp; &nbsp; &nbsp; Timer.run((){&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; 	<span class="hljs-built_in">print</span>(<span class="hljs-string">'event in microtask'</span>); <span class="hljs-comment">// 执行事件任务，打印事件任务标记</span>
&nbsp; &nbsp; &nbsp; &nbsp; });
&nbsp; &nbsp; });
	<span class="hljs-built_in">print</span>(<span class="hljs-string">'flow end'</span>); <span class="hljs-comment">// 打印结束标记</span>
}
</code></pre>
<p data-nodeid="10437">使用 Dart 运行如上命令。</p>
<pre class="lang-java" data-nodeid="10438"><code data-language="java">dart event_with_microtask.dart
</code></pre>
<p data-nodeid="10439">代码的实际运行过程如下：</p>
<ul data-nodeid="10440">
<li data-nodeid="10441">
<p data-nodeid="10442">首先还是依次执行打印 flow start ；</p>
</li>
<li data-nodeid="10443">
<p data-nodeid="10444">执行 Timer 为事件任务，添加事件任务队列中；</p>
</li>
<li data-nodeid="10445">
<p data-nodeid="10446">执行 scheduleMicrotask 为微任务，添加到微任务队列中；</p>
</li>
<li data-nodeid="10447">
<p data-nodeid="10448">打印 end ；</p>
</li>
<li data-nodeid="10449">
<p data-nodeid="10450">执行微任务队列，打印 microtask ，其中包括了事件任务，将事件任务插入到事件任务中；</p>
</li>
<li data-nodeid="10451">
<p data-nodeid="10452">执行事件任务队列，打印 event ，其中包括了微任务，将微任务插入到微任务队列中；</p>
</li>
<li data-nodeid="10453">
<p data-nodeid="10454">微任务队列存在微任务，执行微任务队列，打印 microtask in event；</p>
</li>
<li data-nodeid="10455">
<p data-nodeid="10456">微任务队列为空，存在事件任务队列，执行事件任务队列，打印 event in microtask；</p>
</li>
</ul>
<p data-nodeid="10457">根据如上的运行过程，我们可以得出以下的一个运行结果，这点可以通过运行 Dart 命令得到实际的验证。</p>
<pre class="lang-sql" data-nodeid="10458"><code data-language="sql">flow <span class="hljs-keyword">start</span>
flow <span class="hljs-keyword">end</span>
microtask
<span class="hljs-keyword">event</span>
microtask <span class="hljs-keyword">in</span> <span class="hljs-keyword">event</span>
<span class="hljs-keyword">event</span> <span class="hljs-keyword">in</span> microtask
</code></pre>
<p data-nodeid="12184">为了更形象来描述，我使用图 3 动画来演示。</p>
<p data-nodeid="12185" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/21/33/Ciqc1F7p3BCAAutpABeCx2dZvOo916.gif" alt="image" data-nodeid="12189"></p>


<p data-nodeid="10461">图 3 多微任务和事件任务执行流程</p>
<p data-nodeid="10462">一句话概括上面的实践运行结果：每次运行完一个事件后，都会判断微任务和事件任务，在两者都存在时，优先执行完微任务，只有微任务队列没有其他的任务了才会执行事件任务。</p>
<p data-nodeid="10463"><strong data-nodeid="10609">疑问2，Dart 运行过程中是否会被事件运行卡住？</strong></p>
<p data-nodeid="10464">答案是会，比如在运行某个微任务，该微任务非常的耗时，会导致其他微任务和事件任务卡住，从而影响到一些实际运行，这里我们可以看如下例子：</p>
<pre class="lang-dart" data-nodeid="10465"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:async'</span>;
<span class="hljs-keyword">void</span> main() {
	<span class="hljs-built_in">print</span>(<span class="hljs-string">'flow start'</span>);&nbsp; <span class="hljs-comment">// 执行打印开始</span>
&nbsp; <span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>
	Timer.run((){&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000000000</span>; i++){ <span class="hljs-comment">// 大循环，为了卡住事件任务执行时间，检查是否会卡住其他任务执行</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1000000</span>){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scheduleMicrotask((){&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">'microtask in event'</span>); <span class="hljs-comment">// 执行微任务，打印微任务标记</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">'event'</span>); <span class="hljs-comment">// 执行完事件任务，打印执行完事件任务标记</span>
&nbsp; &nbsp;	});
&nbsp; <span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>
	scheduleMicrotask((){&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">'microtask'</span>); <span class="hljs-comment">// 执行微任务，打印微任务标记</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>
&nbsp; &nbsp; &nbsp; &nbsp; Timer.run((){
&nbsp; &nbsp; &nbsp; &nbsp; 	<span class="hljs-built_in">print</span>(<span class="hljs-string">'event in microtask'</span>); <span class="hljs-comment">// 执行事件任务，打印事件任务标记</span>
&nbsp; &nbsp; &nbsp; &nbsp; });
&nbsp; &nbsp; });
	<span class="hljs-built_in">print</span>(<span class="hljs-string">'flow end'</span>); <span class="hljs-comment">// 打印结束标记</span>
}
</code></pre>
<p data-nodeid="10466">上面这段代码和之前的唯一不同点是在执行第一个事件任务的时候，使用了一个大的 for 循环，从运行结果会看到 event in microtask 和 microtask in event 打印的时间会被 event 的执行所 block 住。从结果分析来看 Dart 中事件运行是会被卡住的，因此在日常编程的时候要特别注意，避免因为某个事件任务密集计算，导致较差的用户操作体验。</p>
<h3 data-nodeid="10467">Isolate 多线程</h3>
<p data-nodeid="10468">上面我们介绍了 Dart 是单线程的，这里说的 Dart 的单线程，其实和操作系统的线程概念是存在一定区别的， Dart 的单线程叫作 isolate 线程，<strong data-nodeid="10617">每个 isolate 线程之间是不共享内存的，通过消息机制通信。</strong></p>
<p data-nodeid="10469">我们看个例子，例子是利用 Dart 的 isolate 实现多线程的方式。</p>
<pre class="lang-dart" data-nodeid="10470"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:async'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'dart:isolate'</span>;
Isolate isolate;
<span class="hljs-built_in">String</span> name = <span class="hljs-string">'dart'</span>;
<span class="hljs-keyword">void</span> main() {
	<span class="hljs-comment">// 执行新线程创建函数</span>
&nbsp;	isolateServer();
}
<span class="hljs-comment">/// <span class="markdown">多线程函数</span></span>
<span class="hljs-keyword">void</span> isolateServer()<span class="hljs-keyword">async</span>{
	<span class="hljs-comment">// 创建新的线程，并且执行回调 changName&nbsp;</span>
	<span class="hljs-keyword">final</span> receive = ReceivePort();
	isolate = <span class="hljs-keyword">await</span> Isolate.spawn(changName, receive.sendPort);
	<span class="hljs-comment">// 监听线程返回信息&nbsp;</span>
	receive.listen((data){
		<span class="hljs-built_in">print</span>(<span class="hljs-string">"Myname is <span class="hljs-subst">$data</span>"</span>); <span class="hljs-comment">// 打印线程返回的数据</span>
		<span class="hljs-built_in">print</span>(<span class="hljs-string">"Myname is <span class="hljs-subst">$name</span>"</span>); <span class="hljs-comment">// 打印全局 name 的数据</span>
	});
}
<span class="hljs-comment">/// <span class="markdown">线程回调处理函数</span></span>
<span class="hljs-keyword">void</span> changName(SendPort port){
	name = <span class="hljs-string">'dart isloate'</span>; <span class="hljs-comment">// 修改当前全局 name 属性</span>
	port.send(name); <span class="hljs-comment">// 将当前name发送给监听方</span>
	<span class="hljs-built_in">print</span>(<span class="hljs-string">"Myname is <span class="hljs-subst">$name</span> in isloate"</span>); <span class="hljs-comment">// 打印当前线程中的 name</span>
}
</code></pre>
<p data-nodeid="10471">使用 Dart 运行如上命令。</p>
<pre class="lang-dart" data-nodeid="10472"><code data-language="dart">dart isolate.dart
</code></pre>
<p data-nodeid="10473">以上代码的执行运行流程如下：</p>
<ul data-nodeid="10474">
<li data-nodeid="10475">
<p data-nodeid="10476">import 对应的库；</p>
</li>
<li data-nodeid="10477">
<p data-nodeid="10478">声明两个变量，一个是 isolate 对象，一个是字符串类型的 name；</p>
</li>
<li data-nodeid="10479">
<p data-nodeid="10480">执行 main 函数，main 函数中执行 isolateServer 异步函数；</p>
</li>
<li data-nodeid="10481">
<p data-nodeid="10482">isolateServer 中创建了一个 isolate 线程，创建线程时候，可以传递接受回调的函数 changName；</p>
</li>
<li data-nodeid="10483">
<p data-nodeid="10484">在 changName 中修改当前的全局变量 name ，并且发送消息给到接收的端口，并且打印该线程中的 name 属性；</p>
</li>
<li data-nodeid="10485">
<p data-nodeid="10486">isolateServer 接收消息，接收消息后打印返回的数据和当前 name 变量。</p>
</li>
</ul>
<p data-nodeid="10487">根据如上执行过程，可以得出如下的运行结果。</p>
<pre class="lang-dart" data-nodeid="10488"><code data-language="dart">Myname <span class="hljs-keyword">is</span> dart isolate <span class="hljs-keyword">in</span> isolate
Myname <span class="hljs-keyword">is</span> dart isolate
Myname <span class="hljs-keyword">is</span> dart
</code></pre>
<p data-nodeid="10489">从运行结果中，可以看到新的线程修改了全局的 name，并且通过消息发送返回到主线程中。而主线程的 name 属性并没有因为创建的新线程中的 name 属性的修改而发生改变，这也印证了内存隔离这点。</p>
<h3 data-nodeid="10490">综合示例</h3>
<p data-nodeid="10491">了解完以上知识点后，我再从一个实际的例子进行综合的分析，让你进一步巩固对 Dart 运行原理的掌握。</p>
<p data-nodeid="10492">假设一个项目，需要 2 个团队去完成，团队中包含多项任务。可以分为 2 个高优先级任务（高优先级的其中，会产生 2 个任务，一个是紧急一个是不紧急），和 2 个非高优先级任务（非高优先级的其中，会产生有 2 个任务，一个是紧急一个是不紧急）。其中还有一个是必须依赖其他团队去做的，因为本团队没有那方面的资源，第三方也会产生一个高优先级任务和一个低优先级任务。</p>
<p data-nodeid="10493">根据以上假设，我们可以用表 1 任务划分来表示：</p>
<table data-nodeid="10495">
<thead data-nodeid="10496">
<tr data-nodeid="10497">
<th data-org-content="**主任务**" data-nodeid="10499"><strong data-nodeid="10636">主任务</strong></th>
<th data-org-content="**高优先级任务（微任务）**" data-nodeid="10500"><strong data-nodeid="10640">高优先级任务（微任务）</strong></th>
<th data-org-content="**低优先级任务（事件任务）**" data-nodeid="10501"><strong data-nodeid="10644">低优先级任务（事件任务）</strong></th>
<th data-org-content="**第三方任务（isolate）**" data-nodeid="10502"><strong data-nodeid="10648">第三方任务（isolate）</strong></th>
</tr>
</thead>
<tbody data-nodeid="10507">
<tr data-nodeid="10508">
<td data-org-content="H1" data-nodeid="10509">H1</td>
<td data-org-content="h1-1" data-nodeid="10510">h1-1</td>
<td data-org-content="l1-1" data-nodeid="10511">l1-1</td>
<td data-org-content="否" data-nodeid="10512">否</td>
</tr>
<tr data-nodeid="10513">
<td data-org-content="H2" data-nodeid="10514">H2</td>
<td data-org-content="h2-1" data-nodeid="10515">h2-1</td>
<td data-org-content="l2-1" data-nodeid="10516">l2-1</td>
<td data-org-content="否" data-nodeid="10517">否</td>
</tr>
<tr data-nodeid="10518">
<td data-org-content="L3" data-nodeid="10519">L3</td>
<td data-org-content="h3-1" data-nodeid="10520">h3-1</td>
<td data-org-content="l3-1" data-nodeid="10521">l3-1</td>
<td data-org-content="否" data-nodeid="10522">否</td>
</tr>
<tr data-nodeid="10523">
<td data-org-content="L4" data-nodeid="10524">L4</td>
<td data-org-content="h4-1" data-nodeid="10525">h4-1</td>
<td data-org-content="l4-1" data-nodeid="10526">l4-1</td>
<td data-org-content="否" data-nodeid="10527">否</td>
</tr>
<tr data-nodeid="10528">
<td data-org-content="C5" data-nodeid="10529">C5</td>
<td data-org-content="ch5-1" data-nodeid="10530">ch5-1</td>
<td data-org-content="cl5-1" data-nodeid="10531">cl5-1</td>
<td data-org-content="是" data-nodeid="10532">是</td>
</tr>
</tbody>
</table>
<p data-nodeid="10533">表1 项目任务划分详情</p>
<p data-nodeid="10534">然后我们按照 Dart 语言执行方式去安排这个项目的开发工作，我们看看安排的工作到底会是怎么样执行流程，代码实现方式如下。</p>
<pre class="lang-dart" data-nodeid="10535"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:async'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'dart:isolate'</span>;
Isolate isolate;
<span class="hljs-keyword">void</span> main() {
	<span class="hljs-built_in">print</span>(<span class="hljs-string">'project start'</span>); <span class="hljs-comment">// 打印项目启动标记</span>
	ctask(); <span class="hljs-comment">// 分配并执行 C 任务</span>
	<span class="hljs-comment">// 大循环，等待</span>
	<span class="hljs-comment">//for(int i=0; i&lt;1000000000; i++){</span>
	<span class="hljs-comment">//}</span>
	<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>
	scheduleMicrotask((){
		<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>
		scheduleMicrotask((){
			<span class="hljs-built_in">print</span>(<span class="hljs-string">'h1-1 task complete'</span>); <span class="hljs-comment">// 执行微任务，并打印微任务优先级h1-1</span>
		});
		<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>
		Timer.run((){
&nbsp; &nbsp; &nbsp; &nbsp; 	<span class="hljs-built_in">print</span>(<span class="hljs-string">'l1-1 task complete'</span>); <span class="hljs-comment">// 执行事件任务，并打印事件任务优先级l1-1</span>
&nbsp; &nbsp; &nbsp; &nbsp; });
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">'H1 task complete'</span>); <span class="hljs-comment">// 打印H1微任务执行标记</span>
	});
	<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>
	scheduleMicrotask((){
		<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>
		scheduleMicrotask((){
			<span class="hljs-built_in">print</span>(<span class="hljs-string">'h2-1 task complete'</span>); <span class="hljs-comment">// 执行微任务，并打印微任务优先级h2-1</span>
		});
		<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>
		Timer.run((){
&nbsp; &nbsp; &nbsp; &nbsp; 	<span class="hljs-built_in">print</span>(<span class="hljs-string">'l2-1 task complete'</span>); <span class="hljs-comment">// 执行事件任务，并打印事件任务优先级l2-1</span>
&nbsp; &nbsp; &nbsp; &nbsp; });
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">'H2 task complete'</span>); <span class="hljs-comment">// 打印H2微任务执行标记</span>
	});
	<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>
	Timer.run((){
		<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>
		scheduleMicrotask((){
			<span class="hljs-built_in">print</span>(<span class="hljs-string">'h3-1 task complete'</span>); <span class="hljs-comment">// 执行微任务，并打印微任务优先级h3-1</span>
		});
		<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>
		Timer.run((){
&nbsp; &nbsp; &nbsp; &nbsp; 	<span class="hljs-built_in">print</span>(<span class="hljs-string">'l3-1 task complete'</span>); <span class="hljs-comment">// 执行事件任务，并打印事件任务优先级l3-1</span>
&nbsp; &nbsp; &nbsp; &nbsp; });
		<span class="hljs-built_in">print</span>(<span class="hljs-string">'L3 task complete'</span>); <span class="hljs-comment">// 打印L3事件任务执行标记</span>
&nbsp; &nbsp; });
	
	<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>
	Timer.run((){
		<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>
		scheduleMicrotask((){
			<span class="hljs-built_in">print</span>(<span class="hljs-string">'h4-1 task complete'</span>); <span class="hljs-comment">// 执行微任务，并打印微任务优先级h4-1</span>
		});
		<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>
		Timer.run((){
&nbsp; &nbsp; &nbsp; &nbsp; 	<span class="hljs-built_in">print</span>(<span class="hljs-string">'l4-1 task complete'</span>); <span class="hljs-comment">// 执行事件任务，并打印事件任务优先级l4-1</span>
&nbsp; &nbsp; &nbsp; &nbsp; });
		<span class="hljs-built_in">print</span>(<span class="hljs-string">'L4 task complete'</span>); <span class="hljs-comment">// 打印L4事件任务执行标记</span>
&nbsp; &nbsp; });
}
<span class="hljs-comment">/// <span class="markdown">C 任务具体代码，创建新的线程，并监听线程返回数据&nbsp;</span></span>
<span class="hljs-keyword">void</span> ctask()<span class="hljs-keyword">async</span>{
	<span class="hljs-keyword">final</span> receive = ReceivePort();
	isolate = <span class="hljs-keyword">await</span> Isolate.spawn(doCtask, receive.sendPort);
	receive.listen((data){
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(data);
	});
}
<span class="hljs-comment">/// <span class="markdown">创建的新线程，具体执行的任务代码</span></span>
<span class="hljs-keyword">void</span> doCtask(SendPort port){
	<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>
	scheduleMicrotask((){
		<span class="hljs-built_in">print</span>(<span class="hljs-string">'ch5-1 task complete'</span>); <span class="hljs-comment">// 执行微任务，并打印微任务优先级ch5-1&nbsp;</span>
	});
	<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>
	Timer.run((){
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">'cl5-1 task complete'</span>); <span class="hljs-comment">// 打印cl5-1事件任务执行标记</span>
&nbsp; &nbsp; });
	port.send(<span class="hljs-string">'C1 task complete'</span>); <span class="hljs-comment">// 打印 C 任务执行标记</span>
}
</code></pre>
<p data-nodeid="10536">使用 Dart 运行如上命令。</p>
<pre class="lang-plain" data-nodeid="10537"><code data-language="plain">dart isolate.dart
</code></pre>
<p data-nodeid="10538">我们先来看下，上面代码的运行结果。</p>
<pre class="lang-sql" data-nodeid="10539"><code data-language="sql">project <span class="hljs-keyword">start</span>
H1 task <span class="hljs-keyword">complete</span>
H2 task <span class="hljs-keyword">complete</span>
h1<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
h2<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
L3 task <span class="hljs-keyword">complete</span>
h3<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
L4 task <span class="hljs-keyword">complete</span>
h4<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
l1<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
l2<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
l3<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
l4<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
ch5<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
cl5<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
C1 task <span class="hljs-keyword">complete</span>
</code></pre>
<p data-nodeid="10540">H 和 L 的运行原理，希望你用上面我所讲到的知识点，去一步步分析，可以像我们图 2 或者图 3 的方法，画两个队列，然后逐步去分析。<br>
上面的运行结果中，非 C 任务的运行原理留给你自己去分析，这里我着重介绍下为什么 C 的任务一直在最后才完成。</p>
<p data-nodeid="10541">由于 C 任务是由其他线程执行，因此这里存在一定的时间去创建线程。创建线程完成后，才会进行回调，回调后才会将相应的回调事件插入到事件任务队列中。因此 C1 task complete 会在最后的一个事件任务中执行。而 ch5-1 task complete 和 cl5-1 task complete 由于需要等线程创建完成才能执行，因此执行也在后面。为了验证上面的结论，我们在 ctask() 后面增加一段耗 CPU 计算的代码，让新的线程执行快于当前的主线程。</p>
<pre class="lang-dart" data-nodeid="10542"><code data-language="dart">    <span class="hljs-built_in">print</span>(<span class="hljs-string">'project start'</span>);
	ctask();
	<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000000000</span>; i++){
	}
</code></pre>
<p data-nodeid="10543">在运行代码后，你将看到这样的结果：</p>
<pre class="lang-sql" data-nodeid="10544"><code data-language="sql">project <span class="hljs-keyword">start</span>
ch5<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
cl5<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
H1 task <span class="hljs-keyword">complete</span>
H2 task <span class="hljs-keyword">complete</span>
h1<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
h2<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
C1 task <span class="hljs-keyword">complete</span>
L3 task <span class="hljs-keyword">complete</span>
h3<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
L4 task <span class="hljs-keyword">complete</span>
h4<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
l1<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
l2<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
l3<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
l4<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>
</code></pre>
<p data-nodeid="10545">首先就输出了 C 线程中的微任务和事件任务，C 任务完成后，向主线程的事件任务中插入事件任务。由于主线程还没有运行结束，接下来运行后会产生微任务和事件任务，由于 C 回调的事件任务最先插入，因此在事件任务中最先执行，但是会慢于微任务事件的执行。</p>
<h3 data-nodeid="10546">总结</h3>
<p data-nodeid="10547">本课时首先介绍了 Dart 中单线程两个概念微任务事件队列和事件任务队列，并通过实践代码运行来介绍 Dart 事件循环方式。其次介绍了在 Dart 中应用 isolate 实现多线程的方式。最后使用一个实际的例子，来练习掌握 Dart 运行原理。在综合例子里还涉及了多线程中微任务和事件任务的调度方式。</p>
<p data-nodeid="10548">学完本课时，你需要掌握其单线程中微任务队列和事件任务队列的调度方式，其次知道线程创建需要处理时间，以及线程事件执行完成后的回调是一个事件任务，这样就可以掌握其整体的运行原理了。如果你还有其他困惑，可以在下方留言或加入学习交流群。</p>
<p data-nodeid="10549">以上就是本课时的主要内容，下一课时，我将用“三步法”带你掌握 Flutter ，并开始你的第一个应用，这也是我们即将开始实际的代码编程的第一步。</p>
<p data-nodeid="10550">点击这里下载本课时源码，Flutter 专栏，源码地址：<a href="https://github.com/love-flutter/flutter-column" data-nodeid="10686">https://github.com/love-flutter/flutter-column</a></p></div>

</body></html>