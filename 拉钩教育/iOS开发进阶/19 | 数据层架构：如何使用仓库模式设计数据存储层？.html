<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>19 | 数据层架构：如何使用仓库模式设计数据存储层？</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>19 | 数据层架构：如何使用仓库模式设计数据存储层？</h1><p data-nodeid="1321" class="">数据是 App 的血液，没有了数据，App 就没办法工作了。但是要保持数据的一致性，并不是一件简单的事情。因为在 App 中多个页面共享同一份数据的情况经常出现。比如，朋友圈时间轴列表页面和朋友圈详情页都共享了朋友圈数据，当我们在详情页点了赞，怎样让时间轴页面同步状态数据呢？如果有多于两个页面，它们之间又怎样保持同步呢？</p>
<p data-nodeid="1322">目前比较流行的方案是使用<strong data-nodeid="1418">Repository（数据仓库）模式</strong>。 例如 Android Architecture Components 就推荐使用该模式。在 Moments App 中，我也使用 Repository 模式维护唯一数据源，通过<strong data-nodeid="1419">RxSwift 的 Subject</strong>保证数据的自动更新。为了与具体的数据库进行解耦并提高程序的灵活性，我还使用了<strong data-nodeid="1420">DataStore 模块</strong>来抽象本地数据存储与访问。这一讲我就和你介绍下我是怎么做的。</p>
<h3 data-nodeid="1323">Repository 模式的架构</h3>
<p data-nodeid="1324">所谓 Repository 模式，就是为数据访问提供抽象的接口，数据使用者在读写数据时，只调用相关的接口函数，并不关心数据到底存放在网络还是本地，也不用关心本地数据库的具体实现。使用 Repository 模式有以下几大优势：</p>
<ol data-nodeid="1325">
<li data-nodeid="1326">
<p data-nodeid="1327">Repository 模块作为唯一数据源统一管理所有数据，能有效保证整个 App 数据的一致性；</p>
</li>
<li data-nodeid="1328">
<p data-nodeid="1329">Repository 模块封装了所有数据访问的细节，可提高程序的可扩展性和灵活性，例如，在不改变接口的情况下，把本地存储替换成其他的数据库；</p>
</li>
<li data-nodeid="1330">
<p data-nodeid="1331">结合 RxSwift 的 Subject， Repository 模块能自动更新 App 的数据与状态。</p>
</li>
</ol>
<p data-nodeid="2633">我们以朋友圈功能为例，看看如何使用 Repository 模式。下面是 Repository 模块的架构图。</p>
<p data-nodeid="2634" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/C1/CioPOWCGgkOAFlCeAANesZhJjDM002.png" alt="图片2.png" data-nodeid="2638"></p>


<p data-nodeid="1334"><strong data-nodeid="1442">ViewModel 模块</strong>是 Repository 模块的上层数据使用者，在朋友圈功能里面,<code data-backticks="1" data-nodeid="1434">MomentsTimelineViewModel</code>和<code data-backticks="1" data-nodeid="1436">MomentListItemViewModel</code>都通过<code data-backticks="1" data-nodeid="1438">MomentsRepoType</code>的<code data-backticks="1" data-nodeid="1440">momentsDetails</code>Subject 来订阅数据的更新。</p>
<p data-nodeid="1335"><strong data-nodeid="1447">Repository 模块分成两大部分： Repo 和 DataStore</strong>。其中 Repo 负责统一管理数据（如访问网络的数据、读写本地数据），并通过 Subject 来为订阅者分发新的数据。</p>
<p data-nodeid="1336">Repo 由<code data-backticks="1" data-nodeid="1449">MomentsRepoType</code>协议和遵循该协议的<code data-backticks="1" data-nodeid="1451">MomentsRepo</code>结构体所组成。<code data-backticks="1" data-nodeid="1453">MomentsRepoType</code>协议用于定义接口，而<code data-backticks="1" data-nodeid="1455">MomentsRepo</code>封装具体的实现，当<code data-backticks="1" data-nodeid="1457">MomentsRepo</code>需要读取和更新 BFF 的数据时，会调用 Networking 模块的组件，这方面我在上一讲已经详细介绍过了。而当<code data-backticks="1" data-nodeid="1459">MomentsRepo</code>需要读取和更新本地数据时，会使用到 DataStore。</p>
<p data-nodeid="1337">DataStore 负责本地数据的存储，它由<code data-backticks="1" data-nodeid="1462">PersistentDataStoreType</code>协议和<code data-backticks="1" data-nodeid="1464">UserDefaultsPersistentDataStore</code>结构体所组成。其中，<code data-backticks="1" data-nodeid="1466">PersistentDataStoreType</code>协议用于定义本地数据读写的接口。而<code data-backticks="1" data-nodeid="1468">UserDefaultsPersistentDataStore</code>结构体是其中一种实现。从名字可以看到，该实现使用了 iOS 系统所提供的 UserDefaults 来存储数据。</p>
<p data-nodeid="1338">假如我们需要支持 Core Data，那么可以提供另外一个结构体来遵循<code data-backticks="1" data-nodeid="1471">PersistentDataStoreType</code>协议，比如把该结构体命名为<code data-backticks="1" data-nodeid="1473">CoreDataPersistentDataStore</code>，并使用它来封装所有 Core Data 的访问细节。有了 DataStore 的接口，我们可以很方便地替换不同的本地数据库。</p>
<h3 data-nodeid="1339">Repository 模式的实现</h3>
<p data-nodeid="1340">看完 Repository 模式的架构设计，我们一起了解下 Repo 和 DataStore 的具体实现。</p>
<p data-nodeid="1341">首先我们看一下 DataStore 模块，下面是<code data-backticks="1" data-nodeid="1478">PersistentDataStoreType</code>协议的定义。</p>
<pre class="lang-swift" data-nodeid="1342"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">PersistentDataStoreType</span> </span>{
    <span class="hljs-keyword">var</span> momentsDetails: <span class="hljs-type">ReplaySubject</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; { <span class="hljs-keyword">get</span> }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">save</span><span class="hljs-params">(momentsDetails: MomentsDetails)</span></span>
}
</code></pre>
<p data-nodeid="1343">该协议提供了<code data-backticks="1" data-nodeid="1481">momentsDetails</code>属性来给数据使用者读取朋友圈数据，并提供了<code data-backticks="1" data-nodeid="1483">save(momentsDetails: MomentsDetails)</code>方法来保存朋友圈信息。</p>
<p data-nodeid="1344">在 Moments App 里面，我们为<code data-backticks="1" data-nodeid="1486">PersistentDataStoreType</code>协议提供一个封装了 UserDefaults 的实现，其具体代码如下。</p>
<pre class="lang-swift" data-nodeid="1345"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UserDefaultsPersistentDataStore</span>: <span class="hljs-title">PersistentDataStoreType</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared: <span class="hljs-type">UserDefaultsPersistentDataStore</span> = .<span class="hljs-keyword">init</span>()
    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> momentsDetails: <span class="hljs-type">ReplaySubject</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; = .create(bufferSize: <span class="hljs-number">1</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> disposeBage: <span class="hljs-type">DisposeBag</span> = .<span class="hljs-keyword">init</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> defaults = <span class="hljs-type">UserDefaults</span>.standard
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> momentsDetailsKey = <span class="hljs-type">String</span>(describing: <span class="hljs-type">MomentsDetails</span>.<span class="hljs-keyword">self</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() {
        defaults.rx
            .observe(<span class="hljs-type">Data</span>.<span class="hljs-keyword">self</span>, momentsDetailsKey)
            .<span class="hljs-built_in">compactMap</span> { $<span class="hljs-number">0</span> }
            .<span class="hljs-built_in">compactMap</span> { <span class="hljs-keyword">try</span>? <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">MomentsDetails</span>.<span class="hljs-keyword">self</span>, from: $<span class="hljs-number">0</span>) }
            .subscribe(momentsDetails)
            .disposed(by: disposeBage)
    }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">save</span><span class="hljs-params">(momentsDetails: MomentsDetails)</span></span> {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> encodedData = <span class="hljs-keyword">try</span>? <span class="hljs-type">JSONEncoder</span>().encode(momentsDetails) {
            defaults.<span class="hljs-keyword">set</span>(encodedData, forKey: momentsDetailsKey)
        }
    }
}
</code></pre>
<p data-nodeid="1346">因为<code data-backticks="1" data-nodeid="1489">UserDefaultsPersistentDataStore</code>遵循了<code data-backticks="1" data-nodeid="1491">PersistentDataStoreType</code>协议，因此需要实现<code data-backticks="1" data-nodeid="1493">momentsDetails</code>属性和<code data-backticks="1" data-nodeid="1495">save()</code>方法。<br>
其中<code data-backticks="1" data-nodeid="1499">momentsDetails</code>属性为 RxSwfit 的<code data-backticks="1" data-nodeid="1501">ReplaySubject</code>类型。它负责把数据的更新事件发送给订阅者。在<code data-backticks="1" data-nodeid="1503">init()</code>方法中，我们通过了 Key 来订阅 UserDefaults 里的数据更新，一旦与该 Key 相关联的数据发生了变化，我们就使用<code data-backticks="1" data-nodeid="1505">JSONDecoder</code>来把更新的数据解码成<code data-backticks="1" data-nodeid="1507">MomentsDetails</code>类型，然后发送给<code data-backticks="1" data-nodeid="1509">momentsDetails</code>Subject 属性。这样<code data-backticks="1" data-nodeid="1511">momentsDetails</code>属性就可以把数据事件中转给外部的订阅者了。</p>
<p data-nodeid="1347"><code data-backticks="1" data-nodeid="1513">save(momentsDetails: MomentsDetails)</code>方法用于保存数据，首先把传递进来的<code data-backticks="1" data-nodeid="1515">momentsDetails</code>对象通过<code data-backticks="1" data-nodeid="1517">JSONEncoder</code>来编码，并把编码后的数据写入 UserDefaults 中。这里需要注意，我们在读写 UserDefaults 时，提供的 Key 必须保持一致。为了保证这一点，我们使用了同一个私有属性<code data-backticks="1" data-nodeid="1519">momentsDetailsKey</code>来进行读写。</p>
<p data-nodeid="1348">接着来看 Repo 模块，下面是<code data-backticks="1" data-nodeid="1522">MomentsRepoType</code>协议的定义。</p>
<pre class="lang-swift" data-nodeid="1349"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">MomentsRepoType</span> </span>{
    <span class="hljs-keyword">var</span> momentsDetails: <span class="hljs-type">ReplaySubject</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; { <span class="hljs-keyword">get</span> }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt;
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateLike</span><span class="hljs-params">(isLiked: Bool, momentID: String, fromUserID userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt;
}
</code></pre>
<p data-nodeid="1350">在该协议中，<code data-backticks="1" data-nodeid="1525">momentsDetails</code>属性用来为订阅者发送朋友圈数据的更新事件。<code data-backticks="1" data-nodeid="1527">getMoments(userID: String) -&gt; Observable&lt;Void&gt;</code>方法用于获取朋友圈信息数据，而<code data-backticks="1" data-nodeid="1529">updateLike(isLiked: Bool, momentID: String, fromUserID userID: String) -&gt; Observable&lt;Void&gt;</code>方法用于更新点赞信息。</p>
<p data-nodeid="1351">因为<code data-backticks="1" data-nodeid="1532">MomentsRepo</code>结构体遵循了<code data-backticks="1" data-nodeid="1534">MomentsRepoType</code>协议，它也实现了<code data-backticks="1" data-nodeid="1536">momentsDetails</code>属性以及<code data-backticks="1" data-nodeid="1538">getMoments()</code>和<code data-backticks="1" data-nodeid="1540">updateLike()</code>方法。</p>
<p data-nodeid="1352"><code data-backticks="1" data-nodeid="1542">momentsDetails</code>属性是一个<code data-backticks="1" data-nodeid="1544">ReplaySubject</code>的对象，用于转发朋友圈数据的更新事件，我们可以从<code data-backticks="1" data-nodeid="1546">init()</code>方法里面看到它是怎样转发数据的。</p>
<pre class="lang-swift" data-nodeid="1353"><code data-language="swift"><span class="hljs-keyword">init</span>(persistentDataStore: <span class="hljs-type">PersistentDataStoreType</span>,
             getMomentsByUserIDSession: <span class="hljs-type">GetMomentsByUserIDSessionType</span>,
             updateMomentLikeSession: <span class="hljs-type">UpdateMomentLikeSessionType</span>) {
    <span class="hljs-keyword">self</span>.persistentDataStore = persistentDataStore
    <span class="hljs-keyword">self</span>.getMomentsByUserIDSession = getMomentsByUserIDSession
    <span class="hljs-keyword">self</span>.updateMomentLikeSession = updateMomentLikeSession
    persistentDataStore
        .momentsDetails
        .subscribe(momentsDetails)
        .disposed(by: disposeBag)
}
</code></pre>
<p data-nodeid="1354">其核心代码是订阅<code data-backticks="1" data-nodeid="1549">persistentDataStore</code>的<code data-backticks="1" data-nodeid="1551">momentsDetails</code>属性，然后把接收到所有事件都转发到自己的<code data-backticks="1" data-nodeid="1553">momentsDetails</code>属性。</p>
<p data-nodeid="1355">然后我们来看<code data-backticks="1" data-nodeid="1556">getMoments()</code>和<code data-backticks="1" data-nodeid="1558">updateLike()</code>方法。 其代码如下。</p>
<pre class="lang-swift" data-nodeid="1356"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt; {
&nbsp; &nbsp; <span class="hljs-keyword">return</span> getMomentsByUserIDSession
&nbsp; &nbsp; &nbsp; &nbsp; .getMoments(userID: userID)
&nbsp; &nbsp; &nbsp; &nbsp; .<span class="hljs-keyword">do</span>(onNext: { persistentDataStore.save(momentsDetails: $<span class="hljs-number">0</span>) })
&nbsp; &nbsp; &nbsp; &nbsp; .<span class="hljs-built_in">map</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> () }
&nbsp; &nbsp; &nbsp; &nbsp; .catchErrorJustReturn(())
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateLike</span><span class="hljs-params">(isLiked: Bool, momentID: String, fromUserID userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt; {
&nbsp; &nbsp; <span class="hljs-keyword">return</span> updateMomentLikeSession
&nbsp; &nbsp; &nbsp; &nbsp; .updateLike(isLiked, momentID: momentID, fromUserID: userID)
&nbsp; &nbsp; &nbsp; &nbsp; .<span class="hljs-keyword">do</span>(onNext: { persistentDataStore.save(momentsDetails: $<span class="hljs-number">0</span>) })
&nbsp; &nbsp; &nbsp; &nbsp; .<span class="hljs-built_in">map</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> () }
&nbsp; &nbsp; &nbsp; &nbsp; .catchErrorJustReturn(())
}
</code></pre>
<p data-nodeid="1357"><code data-backticks="1" data-nodeid="1560">getMoments()</code>方法通过请求 BFF 来获取朋友圈信息，因为 Repository 模块所有的网络请求操作都通过调用 Networking 模块来完成。在这个方法里面，我们调用了<code data-backticks="1" data-nodeid="1562">getMomentsByUserIDSession</code>的<code data-backticks="1" data-nodeid="1564">getMoments()</code>方法来发起 BFF 的网络请求。当我们得到朋友圈数据时，就会调用<code data-backticks="1" data-nodeid="1566">persistentDataStore</code>的<code data-backticks="1" data-nodeid="1568">save()</code>方法，把返回数据保存到本地。<br>
<code data-backticks="1" data-nodeid="1571">updateLike()</code>方法通过访问 BFF 来更新点赞信息。在这个方法里面，我们调用了<code data-backticks="1" data-nodeid="1573">updateMomentLikeSession</code>的<code data-backticks="1" data-nodeid="1575">updateLike()</code>方法来发起更新请求。当我们得到更新后的朋友圈数据时，也会调用<code data-backticks="1" data-nodeid="1577">persistentDataStore</code>的<code data-backticks="1" data-nodeid="1579">save()</code>方法把数据保存到本地。</p>
<p data-nodeid="1358">当其他模块，例如 ViewModel 模块想得到自动更新的朋友圈数据时，只需要订阅<code data-backticks="1" data-nodeid="1582">MomentsRepoType</code>的<code data-backticks="1" data-nodeid="1584">momentsDetails</code>Subject 属性即可。下面是<code data-backticks="1" data-nodeid="1586">MomentsTimelineViewModel</code>中的例子代码。</p>
<pre class="lang-swift" data-nodeid="1359"><code data-language="swift">momentsRepo.momentsDetails.subscribe(onNext: {
    <span class="hljs-comment">// 接收并处理朋友圈数据更新</span>
}).disposed(by: disposeBag)
</code></pre>
<h3 data-nodeid="1360">RxSwift Subject</h3>
<p data-nodeid="1361">你可以看到，在 Repository 模块里面，我大量使用了 RxSwift 的 Subject 来中转数据事件。 在 RxSwift 里面，常见的 Subject 有<strong data-nodeid="1594">PublishSubject、BehaviorSubject 和 ReplaySubject</strong>。它们的区别在于订阅者能否收到订阅前的事件。那么，在程序代码中它们是如何工作的呢？接下来我就为你一一介绍下。</p>
<h4 data-nodeid="1362">PublishSubject</h4>
<p data-nodeid="1363">首先看一下 PublishSuject。顾名思义，PublishSuject 用于发布（Publish）事件，它的特点是订阅者只能接收订阅后的事件。下面是 PublishSuject 的例子代码。</p>
<pre class="lang-swift" data-nodeid="1364"><code data-language="swift"><span class="hljs-keyword">let</span> publishSubject = <span class="hljs-type">PublishSubject</span>&lt;<span class="hljs-type">Int</span>&gt;()
publishSubject.onNext(<span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> observer1 = publishSubject.subscribe { event <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer1: \(event)"</span>)
}
observer1.disposed(by: disposeBag)
publishSubject.onNext(<span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> observer2 = publishSubject.subscribe { event <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer2: \(event)"</span>)
}
observer2.disposed(by: disposeBag)
publishSubject.onNext(<span class="hljs-number">3</span>)
publishSubject.onCompleted()
publishSubject.onNext(<span class="hljs-number">4</span>)
</code></pre>
<p data-nodeid="1365">首先，我们生成一个名叫<code data-backticks="1" data-nodeid="1598">publishSubject</code>的对象，并发出<code data-backticks="1" data-nodeid="1600">onNext(1)</code>事件，接着通过<code data-backticks="1" data-nodeid="1602">subscribe</code>方法来生成一个名叫<code data-backticks="1" data-nodeid="1604">observer1</code>的订阅者。由于<code data-backticks="1" data-nodeid="1606">publishSubject</code>的订阅者只能收到订阅以后的事件，因此<code data-backticks="1" data-nodeid="1608">observer1</code>无法收到之前的<code data-backticks="1" data-nodeid="1610">onNext(1)</code>的事件。</p>
<p data-nodeid="1366">当<code data-backticks="1" data-nodeid="1613">publishSubject</code>发出<code data-backticks="1" data-nodeid="1615">onNext(2)</code>事件时，<code data-backticks="1" data-nodeid="1617">observer1</code>就会收到该事件。在此之后，我们又生成了第二个订阅者<code data-backticks="1" data-nodeid="1619">observer2</code>，该订阅者也没法接收到以前的事件。当<code data-backticks="1" data-nodeid="1621">publishSubject</code>发出<code data-backticks="1" data-nodeid="1623">onNext(3)</code>和<code data-backticks="1" data-nodeid="1625">completed</code>事件的时候，两个订阅者都能接收到。因为<code data-backticks="1" data-nodeid="1627">completed</code>事件把该 Subject 关闭了，之后所有订阅者都不能接收到<code data-backticks="1" data-nodeid="1629">onNext(4)</code>事件。</p>
<p data-nodeid="1367">下面是整段程序的执行效果。</p>
<pre class="lang-java" data-nodeid="1368"><code data-language="java">observer1: next(<span class="hljs-number">2</span>)
observer1: next(<span class="hljs-number">3</span>)
observer2: next(<span class="hljs-number">3</span>)
observer1: completed
observer2: completed
</code></pre>
<p data-nodeid="1369">PublishSubject 很适合发送新的事件，但有时候，消息发送者需要比订阅者先进行初始化，此时订阅者就无法接收到原有事件。例如在 Moments App 里面，<code data-backticks="1" data-nodeid="1633">UserDefaultsPersistentDataStore</code>就先于<code data-backticks="1" data-nodeid="1635">MomentsRepo</code>进行初始化并立刻读取 UserDefaults 里缓存的数据，假如我们使用 PublishSubject，<code data-backticks="1" data-nodeid="1637">MomentsRepo</code>将无法读取到第一条的朋友圈数据。</p>
<p data-nodeid="1370">那怎样解决这样的问题呢？RxSwift 提供了 BehaviorSubject 和 ReplaySubject 来帮助我们读取在 Subject 里缓存的数据。</p>
<h4 data-nodeid="1371">BehaviorSubject</h4>
<p data-nodeid="1372">BehaviorSubject 用于缓存一个事件，当订阅者订阅 BehaviorSubject 时，会马上收到该 Subject 里面最后一个事件。我们通过例子来看看 BehaviorSubject 是怎样工作的。</p>
<pre class="lang-swift" data-nodeid="1373"><code data-language="swift"><span class="hljs-keyword">let</span> behaviorSubject = <span class="hljs-type">BehaviorSubject</span>&lt;<span class="hljs-type">Int</span>&gt;(value: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> observer1 = behaviorSubject.subscribe { event <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer1: \(event)"</span>)
}
observer1.disposed(by: disposeBag)
behaviorSubject.onNext(<span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> observer2 = behaviorSubject.subscribe { event <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer2: \(event)"</span>)
}
observer2.disposed(by: disposeBag)
behaviorSubject.onNext(<span class="hljs-number">3</span>)
behaviorSubject.onCompleted()
behaviorSubject.onNext(<span class="hljs-number">4</span>)
</code></pre>
<p data-nodeid="1374">因为 BehaviorSubject 要给订阅者提供订阅前的最后一条事件，我们需要传递初始值来生成BehaviorSubject。在上面的代码中可以看到，我们传递了<code data-backticks="1" data-nodeid="1643">1</code>来新建<code data-backticks="1" data-nodeid="1645">behaviorSubject</code>对象，当<code data-backticks="1" data-nodeid="1647">observer1</code>订阅时马上就能接收到<code data-backticks="1" data-nodeid="1649">next(1)</code>事件。而<code data-backticks="1" data-nodeid="1651">observer2</code>订阅的时候只能接收到前一个<code data-backticks="1" data-nodeid="1653">next(2)</code>事件。接着，它们都能收到<code data-backticks="1" data-nodeid="1655">next(3)</code>事件。当收到<code data-backticks="1" data-nodeid="1657">completed</code>事件后，<code data-backticks="1" data-nodeid="1659">observer1</code>和<code data-backticks="1" data-nodeid="1661">observer2</code>都停止接收其他事件了。其运行效果如下：</p>
<pre class="lang-java" data-nodeid="1375"><code data-language="java">observer1: next(<span class="hljs-number">1</span>)
observer1: next(<span class="hljs-number">2</span>)
observer2: next(<span class="hljs-number">2</span>)
observer1: next(<span class="hljs-number">3</span>)
observer2: next(<span class="hljs-number">3</span>)
observer1: completed
observer2: completed
</code></pre>
<h4 data-nodeid="1376">ReplaySubject</h4>
<p data-nodeid="1377">BehaviorSubject 只能缓存一个事件，当我们需要缓存 N 个事件时，就可以使用 ReplaySubject。例如我们需要统计最后三天的天气信息，那么可以把 N 设置为 3，当订阅者开始订阅时，就可以得到前三天的天气信息。以下是 ReplaySubject 工作的大致过程。</p>
<pre class="lang-swift" data-nodeid="1378"><code data-language="swift"><span class="hljs-keyword">let</span> replaySubject = <span class="hljs-type">ReplaySubject</span>&lt;<span class="hljs-type">Int</span>&gt;.create(bufferSize: <span class="hljs-number">2</span>)
replaySubject.onNext(<span class="hljs-number">1</span>)
replaySubject.onNext(<span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> observer1 = replaySubject.subscribe { event <span class="hljs-keyword">in</span>
&nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer1: \(event)"</span>)
}
observer1.disposed(by: disposeBag)
replaySubject.onNext(<span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> observer2 = replaySubject.subscribe { event <span class="hljs-keyword">in</span>
&nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer2: \(event)"</span>)
}
observer2.disposed(by: disposeBag)
replaySubject.onNext(<span class="hljs-number">4</span>)
replaySubject.onCompleted()
replaySubject.onNext(<span class="hljs-number">5</span>)
</code></pre>
<p data-nodeid="1379">为了看出与 BehaviorSubject 的不同之处，在这里我把 N 设置为 “2”。首先我们把 2 传入<code data-backticks="1" data-nodeid="1666">bufferSize</code>来创建一个<code data-backticks="1" data-nodeid="1668">replaySubject</code>对象，然后发出两个<code data-backticks="1" data-nodeid="1670">next</code>事件，当<code data-backticks="1" data-nodeid="1672">observer1</code>订阅时会马上得到<code data-backticks="1" data-nodeid="1674">1</code>和<code data-backticks="1" data-nodeid="1676">2</code>两个值。</p>
<p data-nodeid="1380">接着<code data-backticks="1" data-nodeid="1679">replaySubject</code>再发出一个<code data-backticks="1" data-nodeid="1681">next(3)</code>事件。当<code data-backticks="1" data-nodeid="1683">observer2</code>订阅的时候会接收到最近的两个值<code data-backticks="1" data-nodeid="1685">2</code>和<code data-backticks="1" data-nodeid="1687">3</code>。在此以后<code data-backticks="1" data-nodeid="1689">observer1</code>和<code data-backticks="1" data-nodeid="1691">observer2</code>会不断接收<code data-backticks="1" data-nodeid="1693">replaySubject</code>的事件，直到收到<code data-backticks="1" data-nodeid="1695">completed</code>事件后停止。其运行效果如下：</p>
<pre class="lang-java" data-nodeid="1381"><code data-language="java">observer1: next(<span class="hljs-number">1</span>)
observer1: next(<span class="hljs-number">2</span>)
observer1: next(<span class="hljs-number">3</span>)
observer2: next(<span class="hljs-number">2</span>)
observer2: next(<span class="hljs-number">3</span>)
observer1: next(<span class="hljs-number">4</span>)
observer2: next(<span class="hljs-number">4</span>)
observer1: completed
observer2: completed
</code></pre>
<p data-nodeid="1382">除了能缓存更多的数据以外，还有一情况我们会选择使用 ReplaySubject 而不是BehaviorSubject。</p>
<p data-nodeid="1383">在初始化 BehaviorSubject 的时候，我们必须提供一个初始值。如果我没办法提供，只能把存放的类型定义为 Optional （可空）类型。但是我们可以使用 ReplaySubject 来避免这种情况。这就是为什么我们把<code data-backticks="1" data-nodeid="1699">UserDefaultsPersistentDataStore</code>和<code data-backticks="1" data-nodeid="1701">MomentsRepo</code>的<code data-backticks="1" data-nodeid="1703">momentsDetails</code>Subject 属性都定义为 ReplaySubject 而不是 BehaviorSubject 的原因。</p>
<p data-nodeid="1384">除了上面的三个 Subject 以外，RxSwift 还为我们提供了两个特殊的 Subject：<strong data-nodeid="1716">PublishRelay 和 BehaviorRelay</strong>，它们的名字和 BehaviorSubject 和 ReplaySubject 非常类似，区别是 Relay 只中继<code data-backticks="1" data-nodeid="1710">next</code>事件，我们并不能往 Relay 里发送<code data-backticks="1" data-nodeid="1712">completed</code>或<code data-backticks="1" data-nodeid="1714">error</code>事件。</p>
<h3 data-nodeid="1385">总结</h3>
<p data-nodeid="1386">在这一讲中，我们介绍了 Repository 模式的架构与实现，然后通过例子来解释各种 Subject 的区别。我把本讲 Subject 的例子代码都放在项目中的<strong data-nodeid="1723">RxSwift Playground 文件</strong>里面，希望你能多练习，灵活运用。</p>
<p data-nodeid="1387">下面是一些在项目场景中使用 Subject 的经验，希望对你有帮助。</p>
<ol data-nodeid="1388">
<li data-nodeid="1389">
<p data-nodeid="1390">如果需要把 Subject 传递给其他类型发送消息，例如在朋友圈时间轴列表页面把 Subject 传递给各个朋友圈子组件，然后接收来自子组件的事件。 这种情况我们一般会传递 PublishSubject，因为在传递前在主页面（如例子中的朋友圈时间轴页面）已经订阅了该 PublishSubject，子组件所发送事件，主页面都能收到。</p>
</li>
<li data-nodeid="1391">
<p data-nodeid="1392">BehaviorSubject 可用于状态管理，例如管理页面的加载状态，开始时可以把 BehaviorSubject 初始化为加载状态，一旦得到返回数据就可以转换为成功状态。</p>
</li>
<li data-nodeid="1393">
<p data-nodeid="1394">因为 BehaviorSubject 必须赋予初始值，但有些情况下，我们并没有初始化，如果使用 BehaviorSubject 必须把其存放的类型定义为 Optional 类型。为了避免使用 Optional，我们可以使用 bufferSize 为 1 的 ReplaySubject 来代替 BehaviorSubject。</p>
</li>
<li data-nodeid="1395">
<p data-nodeid="1396">Subject 和 Relay 都能用于中转事件，当中转的事件中没有<code data-backticks="1" data-nodeid="1729">completed</code>或<code data-backticks="1" data-nodeid="1731">error</code>时，我们都选择 Relay。</p>
</li>
</ol>
<p data-nodeid="1397"><strong data-nodeid="1736">思考题</strong></p>
<blockquote data-nodeid="1398">
<p data-nodeid="1399">请问你们的 App 使用本地数据库吗？使用的是哪一款数据库，有没有试过替换数据库的情况，能分享一下这方面的经验吗？</p>
</blockquote>
<p data-nodeid="1400">请把你的想法写到留言区哦，下一讲我将介绍如何使用 ViewModel 模式来为 UI 层的准备呈现的数据。</p>
<p data-nodeid="1401"><strong data-nodeid="1742">源码地址：</strong></p>
<blockquote data-nodeid="1402">
<p data-nodeid="1403" class="">RxSwift Playground 文件地址：<br>
<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Playgrounds/RxSwiftPlayground.playground/Contents.swift?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1747">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Playgrounds/RxSwiftPlayground.playground/Contents.swift</a><br>
Repo 源码地址：<br>
<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Moments/Moments/Features/Moments/Repositories/Moments?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1753">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Moments/Moments/Features/Moments/Repositories/Moments</a>Repo.swift<br>
DataStore 源码地址：<br>
<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/DataStore?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1760">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/DataStore</a></p>
</blockquote></div>

</body></html>