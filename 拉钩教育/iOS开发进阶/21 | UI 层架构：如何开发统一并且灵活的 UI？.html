<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>21 | UI 层架构：如何开发统一并且灵活的 UI？</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>21 | UI 层架构：如何开发统一并且灵活的 UI？</h1><p data-nodeid="1522" class="">作为 iOS 开发者，我们每天都花大量的时间来开发和调试 UI，那有没有什么办法帮助我们把繁杂的 UI 开发工作简化成有章可循的步骤，从而提高开发的效率呢？在这一讲中，我就和你聊聊，如何架构和开发一套灵活的 UI 框架。</p>
<h3 data-nodeid="1523">通用列表 UI 模块的架构与实现</h3>
<p data-nodeid="1524">列表 UI 是 App 最为常用的 UI 页面，它可以帮我们通过滚动的方式支持无限的内容。为了简化大量的重复性劳动，我在 Moments App 架构实现了一个通用的列表 UI 模块。下面是这个模块的架构图。</p>
<p data-nodeid="1525"><img src="https://s0.lgstatic.com/i/image6/M01/3C/A9/Cgp9HWCL1DiANqbhAAMguDPxTIw094.png" alt="图片1.png" data-nodeid="1641"><br>
这个框架使用了<code data-backticks="1" data-nodeid="1644">UIViewController</code>和<code data-backticks="1" data-nodeid="1646">UITableView</code>来封装列表页面。其核心是<code data-backticks="1" data-nodeid="1648">BaseTableViewController</code>。<code data-backticks="1" data-nodeid="1650">BaseTableViewController</code>继承于<code data-backticks="1" data-nodeid="1652">BaseViewController</code>，而<code data-backticks="1" data-nodeid="1654">BaseViewController</code>继承自<code data-backticks="1" data-nodeid="1656">UIViewController</code>。</p>
<p data-nodeid="1526">我们先看看<code data-backticks="1" data-nodeid="1659">BaseViewController</code>的具体实现，代码示例如下。</p>
<pre class="lang-swift" data-nodeid="1527"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseViewController</span>: <span class="hljs-title">UIViewController</span> </span>{
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> disposeBag: <span class="hljs-type">DisposeBag</span> = .<span class="hljs-keyword">init</span>()
    <span class="hljs-keyword">init</span>() {
      <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)
    }
    <span class="hljs-meta">@available</span>(*, unavailable, message: <span class="hljs-string">"We don't support init view controller from a nib."</span>)
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(nibName nibNameOrNil: <span class="hljs-type">String?</span>, bundle nibBundleOrNil: <span class="hljs-type">Bundle?</span>) {
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    }
    <span class="hljs-meta">@available</span>(*, unavailable, message: <span class="hljs-string">"We don't support init view controller from a nib."</span>)
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>?(coder: <span class="hljs-type">NSCoder</span>) {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-type">L10n</span>.<span class="hljs-type">Development</span>.fatalErrorInitCoderNotImplemented)
    }
}
</code></pre>
<p data-nodeid="1528">因为 Moments App 是使用纯代码的方式来编写 UI，所以<code data-backticks="1" data-nodeid="1662">BaseViewController</code>重写了<code data-backticks="1" data-nodeid="1664">init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)</code>和<code data-backticks="1" data-nodeid="1666">init?(coder: NSCoder)</code>两个方法，并直接抛出异常。这样做使得所有继承<code data-backticks="1" data-nodeid="1668">BaseViewController</code>的子类，都没办法通过 Storyboard 或者 Xib 文件来生成 ViewController 的实例。因为我们使用 RxSwift，<code data-backticks="1" data-nodeid="1670">BaseViewController</code>还定义了一个<code data-backticks="1" data-nodeid="1672">disposeBag</code>属性来方便管理所有 Obervable 序列的订阅。</p>
<p data-nodeid="1529"><code data-backticks="1" data-nodeid="1674">BaseTableViewController</code>继承了<code data-backticks="1" data-nodeid="1676">BaseViewController</code>，并使用<code data-backticks="1" data-nodeid="1678">UITableView</code>来封装一个通用的列表页面。我们一起看看它是怎样实现的。</p>
<p data-nodeid="1530">在 MVVM 模式里，View 依赖于 ViewModel。作为 View 的<code data-backticks="1" data-nodeid="1681">BaseTableViewController</code>依赖于 ViewModel 层的<code data-backticks="1" data-nodeid="1683">ListViewModel</code>协议，这使得<code data-backticks="1" data-nodeid="1685">BaseTableViewController</code>只依赖于接口而不是具体的类型，从而提高了程序的可扩展性。</p>
<p data-nodeid="1531">同时，<code data-backticks="1" data-nodeid="1688">BaseTableViewController</code>还定义了三个属性来显示 UI 控件：</p>
<ul data-nodeid="1532">
<li data-nodeid="1533">
<p data-nodeid="1534"><code data-backticks="1" data-nodeid="1690">tableView</code>属性用于显示一个 TableView；</p>
</li>
<li data-nodeid="1535">
<p data-nodeid="1536"><code data-backticks="1" data-nodeid="1692">activityIndicatorView</code>属性用于显示俗称小菊花的加载器；</p>
</li>
<li data-nodeid="1537">
<p data-nodeid="1538"><code data-backticks="1" data-nodeid="1694">errorLabel</code>用于显示出错信息的标签控件。</p>
</li>
</ul>
<p data-nodeid="1539">以下是属性定义的代码示例。</p>
<pre class="lang-swift" data-nodeid="1540"><code data-language="swift"><span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">ListViewModel!</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> tableView: <span class="hljs-type">UITableView</span> = configure(.<span class="hljs-keyword">init</span>()) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
    $<span class="hljs-number">0</span>.separatorStyle = .<span class="hljs-keyword">none</span>
    $<span class="hljs-number">0</span>.rowHeight = <span class="hljs-type">UITableView</span>.automaticDimension
    $<span class="hljs-number">0</span>.estimatedRowHeight = <span class="hljs-number">100</span>
    $<span class="hljs-number">0</span>.contentInsetAdjustmentBehavior = .never
    $<span class="hljs-number">0</span>.backgroundColor = <span class="hljs-type">UIColor</span>.designKit.background
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> activityIndicatorView: <span class="hljs-type">UIActivityIndicatorView</span> = configure(.<span class="hljs-keyword">init</span>(style: .large)) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> errorLabel: <span class="hljs-type">UILabel</span> = configure(.<span class="hljs-keyword">init</span>()) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
    $<span class="hljs-number">0</span>.isHidden = <span class="hljs-literal">true</span>
    $<span class="hljs-number">0</span>.textColor = <span class="hljs-type">UIColor</span>.designKit.primaryText
    $<span class="hljs-number">0</span>.text = <span class="hljs-type">L10n</span>.<span class="hljs-type">MomentsList</span>.errorMessage
}
</code></pre>
<p data-nodeid="1541">为了方便初始化 UIKit 的控件，我写了一个公共的<code data-backticks="1" data-nodeid="1698">configure()</code>方法，具体代码如下：</p>
<pre class="lang-swift" data-nodeid="1542"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">configure</span>&lt;T: AnyObject&gt;<span class="hljs-params">(<span class="hljs-number">_</span> object: T, closure: <span class="hljs-params">(T)</span></span></span> -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">T</span> {
    closure(object)
    <span class="hljs-keyword">return</span> object
}
</code></pre>
<p data-nodeid="1543">有了该方法，我们就可以把所有初始化操作都放在一个闭包（Closure）里面，方便代码的维护。</p>
<p data-nodeid="1544">接着我们看一下<code data-backticks="1" data-nodeid="1702">setupUI()</code>方法的代码实现。</p>
<pre class="lang-swift" data-nodeid="1545"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupUI</span><span class="hljs-params">()</span></span> {
    view.backgroundColor = <span class="hljs-type">UIColor</span>.designKit.background
    tableViewCellsToRegister.forEach {
        tableView.register($<span class="hljs-number">0</span>.value, forCellReuseIdentifier: $<span class="hljs-number">0</span>.key)
    }
    [tableView, activityIndicatorView, errorLabel].forEach {
        view.addSubview($<span class="hljs-number">0</span>)
    }
}
</code></pre>
<p data-nodeid="1546">该方法负责设置 UI 的样式，例如设置背景颜色，注册 TableView Cell 和添加子控件。</p>
<p data-nodeid="1547">配置完 UI 的样式以后，下一步是配置自动布局的约束（Auto Layout Constraint）。当使用 UIKit 作为 View 层的时候，我推荐使用苹果公司所推荐的<strong data-nodeid="1710">自动布局</strong>来排版 UI 页面。</p>
<p data-nodeid="1548">自动布局能帮助我们支持不同分辨率和屏幕对比率的页面，而且苹果公司每年都在不断优化自动布局引擎的性能。不过，它也有一个缺点，那就是手写自动布局的约束代码会十分冗长，为此我使用一个名叫<strong data-nodeid="1718">SnapKit 的库</strong>来进行简化。下面我们就通过<code data-backticks="1" data-nodeid="1716">setupConstraints()</code>的代码，来看看 SnapKit 的威力。</p>
<pre class="lang-swift" data-nodeid="1549"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupConstraints</span><span class="hljs-params">()</span></span> {
    tableView.snp.makeConstraints {
        $<span class="hljs-number">0</span>.edges.equalToSuperview()
    }
    activityIndicatorView.snp.makeConstraints {
        $<span class="hljs-number">0</span>.center.equalToSuperview()
    }
    errorLabel.snp.makeConstraints {
        $<span class="hljs-number">0</span>.center.equalToSuperview()
    }
}
</code></pre>
<p data-nodeid="1550">如上述代码所示，当使用 SnapKit 来配置自动布局的约束时，我们需要调用它的扩展方法<code data-backticks="1" data-nodeid="1720">makeConstraints</code>，然后把所有约束的配置都放到闭包里面。在这里，我是通过<code data-backticks="1" data-nodeid="1722">edges.equalToSuperview()</code>把<code data-backticks="1" data-nodeid="1724">tableView</code>延伸到它的父组件（也就是<code data-backticks="1" data-nodeid="1726">BaseTableViewController</code>的<code data-backticks="1" data-nodeid="1728">view</code>）中，然后通过<code data-backticks="1" data-nodeid="1730">center.equalToSuperview()</code>方法把<code data-backticks="1" data-nodeid="1732">activityIndicatorView</code>和<code data-backticks="1" data-nodeid="1734">errorLabel</code>都分别居中。</p>
<p data-nodeid="1551">假如不使用 SnapKit，要完成延伸<code data-backticks="1" data-nodeid="1737">tableView</code>的操作，就需要以下的代码。</p>
<pre class="lang-swift" data-nodeid="1552"><code data-language="swift"><span class="hljs-type">NSLayoutConstraint</span>.activate([
    tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
    tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
    tableView.topAnchor.constraint(equalTo: view.topAnchor),
    tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
])
</code></pre>
<p data-nodeid="1553">我们不得不分别配置每一个约束，并放进一个数组里面，然后传递给静态方法<code data-backticks="1" data-nodeid="1740">NSLayoutConstraint.activate</code>。 所以你看，使用 SnapKit 多么方便。</p>
<p data-nodeid="1554">完成了 UI 的布局以后，我们看一下数据绑定。Moments App 使用了 RxSwift 把 ViewModel 层和 View 层进行绑定，绑定的代码在<code data-backticks="1" data-nodeid="1743">setupBindings()</code>函数里，具体如下。</p>
<pre class="lang-swift" data-nodeid="1555"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupBindings</span><span class="hljs-params">()</span></span> {
    tableView.refreshControl = configure(<span class="hljs-type">UIRefreshControl</span>()) {
        <span class="hljs-keyword">let</span> refreshControl = $<span class="hljs-number">0</span>
        $<span class="hljs-number">0</span>.rx.controlEvent(.valueChanged)
            .<span class="hljs-built_in">filter</span> { refreshControl.isRefreshing }
            .bind { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>?.loadItems() }
            .disposed(by: disposeBag)
    }
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">RxTableViewSectionedReloadDataSource</span>&lt;<span class="hljs-type">SectionModel</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">ListItemViewModel</span>&gt;&gt;(configureCell: { <span class="hljs-number">_</span>, tableView, indexPath, item <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-type">String</span>(describing: type(of: item)), <span class="hljs-keyword">for</span>: indexPath)
        (cell <span class="hljs-keyword">as</span>? <span class="hljs-type">ListItemCell</span>)?.update(with: item)
        <span class="hljs-keyword">return</span> cell
    })
    viewModel.listItems
        .bind(to: tableView.rx.items(dataSource: dataSource))
        .disposed(by: disposeBag)
    viewModel.hasError
        .<span class="hljs-built_in">map</span> { !$<span class="hljs-number">0</span> }
        .bind(to: errorLabel.rx.isHidden)
        .disposed(by: disposeBag)
}
</code></pre>
<p data-nodeid="1556">这个函数由三部分组成，第一部分是通过 RxSwift 和 RxCocoa ，把<code data-backticks="1" data-nodeid="1746">UIRefreshControl</code>控件里的<code data-backticks="1" data-nodeid="1748">isRefreshing</code>事件和<code data-backticks="1" data-nodeid="1750">loadItems()</code>函数绑定起来。当用户下拉刷新控件的时候会调用<code data-backticks="1" data-nodeid="1752">loadItems()</code>函数来刷新列表的数据。</p>
<p data-nodeid="1557">第二部分是把 TableView Cell 控件与 ViewModel 的<code data-backticks="1" data-nodeid="1755">listItems</code>Subject 属性绑定起来，当<code data-backticks="1" data-nodeid="1757">listItems</code>发出新的事件时，我们会调用<code data-backticks="1" data-nodeid="1759">ListItemCell</code>的<code data-backticks="1" data-nodeid="1761">update(with viewModel: ListItemViewModel)</code>方法来更新 UI。<strong data-nodeid="1766">经过了这一绑定，UI 就能随着 ViewModel 的数据变化而自动更新。</strong></p>
<p data-nodeid="1558">第三部分与第二部分类似，都是把 ViewModel 与 View 层的控件进行绑定。在这里，我们把 ViewModel 的<code data-backticks="1" data-nodeid="1768">hasError</code>Subject 属性绑定到<code data-backticks="1" data-nodeid="1770">errorLabel.rx.isHidden</code>属性来控制<code data-backticks="1" data-nodeid="1772">errorLabel</code>是否可见。</p>
<p data-nodeid="1559">你可能注意到在<code data-backticks="1" data-nodeid="1775">errorLabel</code>后面有<code data-backticks="1" data-nodeid="1777">.rx</code>属性，这是 RxCocoa 为<code data-backticks="1" data-nodeid="1779">UILabel</code>控件所提供的一个扩展，它为<code data-backticks="1" data-nodeid="1781">isHidden</code>属性提供了响应式编程的功能。有了这一功能，它就可以与 ViewModel 的 Subject 属性进行绑定，从而实现自动更新。</p>
<p data-nodeid="1560">数据绑定以后，我们一起看看<code data-backticks="1" data-nodeid="1784">loadItems()</code>函数的实现。</p>
<pre class="lang-swift" data-nodeid="1561"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadItems</span><span class="hljs-params">()</span></span> {
    viewModel.hasError.onNext(<span class="hljs-literal">false</span>)
    viewModel.loadItems()
        .observeOn(<span class="hljs-type">MainScheduler</span>.instance)
        .<span class="hljs-keyword">do</span>(onDispose: { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">self</span>?.activityIndicatorView.rx.isAnimating.onNext(<span class="hljs-literal">false</span>)
            <span class="hljs-keyword">self</span>?.tableView.refreshControl?.endRefreshing()
        })
        .<span class="hljs-built_in">map</span> { <span class="hljs-literal">false</span> }
        .startWith(<span class="hljs-literal">true</span>)
        .distinctUntilChanged()
        .bind(to: activityIndicatorView.rx.isAnimating)
        .disposed(by: disposeBag)
}
</code></pre>
<p data-nodeid="1562"><code data-backticks="1" data-nodeid="1786">loadItems()</code>方法用于加载数据。当我们第一次进入朋友圈页面的时候，或者用户下拉刷新控件的时候，就会调用该方法来重新加载数据。</p>
<p data-nodeid="1563">该方法主要做两项工作，第一项是调用<code data-backticks="1" data-nodeid="1789">viewModel.hasError.onNext(false)</code>来更新 ViewModel 的<code data-backticks="1" data-nodeid="1791">hasError</code>属性， 它能让 UI 上的错误标签信息消失。</p>
<p data-nodeid="1564">从代码中你可以看到，尽管我们想更新 UI 层的<code data-backticks="1" data-nodeid="1794">errorLabel</code>控件，却没有直接通过<code data-backticks="1" data-nodeid="1796">errorLabel.isHidden = true</code>的方式来更新，而是通过 ViewModel 的<code data-backticks="1" data-nodeid="1798">hasError</code>属性来完成。这是因为我要保证 View/UI 层都是由 ViewModel 驱动，通过单方向的数据流来减少 Bug ，从而提高代码的可维护性。</p>
<p data-nodeid="1565"><code data-backticks="1" data-nodeid="1800">loadItems()</code>方法的第二项工作，是让 ViewModel 去加载数据并绑定到<code data-backticks="1" data-nodeid="1802">activityIndicatorView</code>控件的<code data-backticks="1" data-nodeid="1804">isAnimating</code>属性上。因为我们需要在主排程器上执行 UI 任务，因此调用了<code data-backticks="1" data-nodeid="1806">.observeOn(MainScheduler.instance)</code>，把所有任务都安排到主排程器上。</p>
<p data-nodeid="1566">当 ViewModel 的<code data-backticks="1" data-nodeid="1809">loadItems()</code>方法开始执行的时候，先通过<code data-backticks="1" data-nodeid="1811">.startWith(true)</code>来让<code data-backticks="1" data-nodeid="1813">activityIndicatorView</code>启动动画效果。当 ViewModel 的<code data-backticks="1" data-nodeid="1815">loadItems()</code>方法返回数据时，把结果数据通过<code data-backticks="1" data-nodeid="1817">.map { false }</code>方法来返回<code data-backticks="1" data-nodeid="1819">false</code>，从而使得<code data-backticks="1" data-nodeid="1821">activityIndicatorView</code>停止动画效果。</p>
<p data-nodeid="1567">假如用户在调用 ViewModel 的<code data-backticks="1" data-nodeid="1824">loadItems()</code>方法的过程中，退出列表页面，我们通过<code data-backticks="1" data-nodeid="1826">.do(onDispose:{})</code>方法来停止<code data-backticks="1" data-nodeid="1828">activityIndicatorView</code>和<code data-backticks="1" data-nodeid="1830">refreshControl</code>两个控件的刷新动画。</p>
<p data-nodeid="1568">到此为止，我们已经知道<code data-backticks="1" data-nodeid="1833">BaseTableViewController</code>是如何通过 TableView 来实现列表 UI 的了。</p>
<p data-nodeid="1569">为了显现不同的 TableView Cell，接下来我们了解下通用的 Cell 是如何实现的。</p>
<p data-nodeid="1570">这部分由四个类型所组成，分别是<code data-backticks="1" data-nodeid="1837">ListItemCell</code>协议及其子结构体<code data-backticks="1" data-nodeid="1839">BaseTableViewCell</code>，以及<code data-backticks="1" data-nodeid="1841">ListItemView</code>协议及其子结构体<code data-backticks="1" data-nodeid="1843">BaseListItemView</code>。</p>
<p data-nodeid="1571"><code data-backticks="1" data-nodeid="1845">ListItemCell</code>协议的定义非常简单，如下所示。</p>
<pre class="lang-swift" data-nodeid="1572"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ListItemCell</span>: <span class="hljs-title">class</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span>
}
</code></pre>
<p data-nodeid="1573">该协议只包含了一个<code data-backticks="1" data-nodeid="1848">update(with viewModel: ListItemViewModel)</code>方法来让其子类型根据<code data-backticks="1" data-nodeid="1850">ListItemViewModel</code>的数据进行更新。</p>
<p data-nodeid="1574">其子类型<code data-backticks="1" data-nodeid="1853">BaseTableViewCell</code>的具体代码如下：</p>
<pre class="lang-swift" data-nodeid="1575"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseTableViewCell</span>&lt;<span class="hljs-title">V</span>: <span class="hljs-title">BaseListItemView</span>&gt;: <span class="hljs-title">UITableViewCell</span>, <span class="hljs-title">ListItemCell</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> view: <span class="hljs-type">V</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(style: <span class="hljs-type">UITableViewCell</span>.<span class="hljs-type">CellStyle</span>, reuseIdentifier: <span class="hljs-type">String?</span>) {
        view = .<span class="hljs-keyword">init</span>()
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)
        selectionStyle = .<span class="hljs-keyword">none</span>
        contentView.addSubview(view)
        view.snp.makeConstraints {
            $<span class="hljs-number">0</span>.edges.equalToSuperview()
        }
    }
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>?(coder: <span class="hljs-type">NSCoder</span>) {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-type">L10n</span>.<span class="hljs-type">Development</span>.fatalErrorInitCoderNotImplemented)
    }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span> {
        view.update(with: viewModel)
    }
}
</code></pre>
<p data-nodeid="1576"><code data-backticks="1" data-nodeid="1855">BaseTableViewCell</code>是一个<code data-backticks="1" data-nodeid="1857">UITableViewCell</code>的子类，并遵循了<code data-backticks="1" data-nodeid="1859">ListItemCell</code>协议，因此它需要实现<code data-backticks="1" data-nodeid="1861">update(with viewModel: ListItemViewModel)</code>方法。在该方法里面，它直接调用<code data-backticks="1" data-nodeid="1863">view</code>属性的<code data-backticks="1" data-nodeid="1865">update(with viewModel: ListItemViewModel)</code>来更新<code data-backticks="1" data-nodeid="1867">BaseListItemView</code>组件的 UI。</p>
<p data-nodeid="1577">那为什么我们不把所有 UI 子控件都直接写在 Cell 里，而使用一个额外的<code data-backticks="1" data-nodeid="1870">BaseListItemView</code>呢？因为这样做可以把<code data-backticks="1" data-nodeid="1872">BaseListItemView</code>复用到<code data-backticks="1" data-nodeid="1874">UICollectionView</code>等其他容器中。</p>
<p data-nodeid="1578">接下来我们一起看看<code data-backticks="1" data-nodeid="1877">BaseListItemView</code>及其所遵循的<code data-backticks="1" data-nodeid="1879">ListItemView</code>协议的代码。</p>
<pre class="lang-swift" data-nodeid="1579"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ListItemView</span>: <span class="hljs-title">class</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span>
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseListItemView</span>: <span class="hljs-title">UIView</span>, <span class="hljs-title">ListItemView</span> </span>{
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> disposeBag: <span class="hljs-type">DisposeBag</span> = .<span class="hljs-keyword">init</span>()
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span> {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-type">L10n</span>.<span class="hljs-type">Development</span>.fatalErrorSubclassToImplement)
    }
}
</code></pre>
<p data-nodeid="1580"><code data-backticks="1" data-nodeid="1881">ListItemView</code>协议只定义了<code data-backticks="1" data-nodeid="1883">update(with viewModel: ListItemViewModel)</code>接口来通过 ViewModel 更新 UI。因为每个 UI 组件的布局与呈现都可能不一样，因此，<code data-backticks="1" data-nodeid="1885">BaseListItemView</code>在实现<code data-backticks="1" data-nodeid="1887">update(with viewModel: ListItemViewModel)</code>方法时，直接抛出了异常，这样能迫使其子类重写该方法。</p>
<p data-nodeid="1581">上面就是通用列表 UI 模块的架构与实现，有了这一个框架，我们就能快速实现不同的列表页面，下面以朋友圈功能作为例子来看看如何实现一个朋友圈时间轴页面。</p>
<h3 data-nodeid="1582">朋友圈时间轴页面的实现</h3>
<p data-nodeid="1583">首先我们一起看看朋友圈时间轴页面的架构图。</p>
<p data-nodeid="1584"><img src="https://s0.lgstatic.com/i/image6/M00/3C/B1/CioPOWCL09mAbIiFAAIX3-W1eco290.png" alt="图片2.png" data-nodeid="1894"><br>
<code data-backticks="1" data-nodeid="1896">MomentsTimelineViewController</code>用于显示朋友圈时间轴页面，其具体代码如下。</p>
<pre class="lang-swift" data-nodeid="1585"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MomentsTimelineViewController</span>: <span class="hljs-title">BaseTableViewController</span> </span>{
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() {
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()
        viewModel = <span class="hljs-type">MomentsTimelineViewModel</span>(userID: <span class="hljs-type">UserDataStore</span>.current.userID)
    }
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidAppear</span><span class="hljs-params">(<span class="hljs-number">_</span> animated: Bool)</span></span> {
        <span class="hljs-keyword">super</span>.viewDidAppear(animated)
        viewModel.trackScreenviews()
    }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> tableViewCellsToRegister: [<span class="hljs-type">String</span> : <span class="hljs-type">UITableViewCell</span>.<span class="hljs-type">Type</span>] {
        <span class="hljs-keyword">return</span> [
            <span class="hljs-type">UserProfileListItemViewModel</span>.reuseIdentifier: <span class="hljs-type">BaseTableViewCell</span>&lt;<span class="hljs-type">UserProfileListItemView</span>&gt;.<span class="hljs-keyword">self</span>,
            <span class="hljs-type">MomentListItemViewModel</span>.reuseIdentifier: <span class="hljs-type">BaseTableViewCell</span>&lt;<span class="hljs-type">MomentListItemView</span>&gt;.<span class="hljs-keyword">self</span>
        ]
    }
}
</code></pre>
<p data-nodeid="1586">因为<code data-backticks="1" data-nodeid="1899">BaseViewController</code>已经封装好绝大部分的 UI 处理逻辑，作为子类，<code data-backticks="1" data-nodeid="1901">MomentsTimelineViewController</code>的实现变得非常简单，只需三部分。</p>
<p data-nodeid="3060" class="">首先是初始化<code data-backticks="1" data-nodeid="3062">viewModel</code>。因为<code data-backticks="1" data-nodeid="3064">BaseViewController</code>通过<code data-backticks="1" data-nodeid="3066">var viewModel: ListViewModel!</code>来定义<code data-backticks="1" data-nodeid="3068">viewModel</code>属性，作为子类的<code data-backticks="1" data-nodeid="3070">MomentsTimelineViewController</code>也必须初始化<code data-backticks="1" data-nodeid="3072">viewModel</code>属性，否则程序会崩溃。具体来说，我们只需创建一个<code data-backticks="1" data-nodeid="3074">MomentsTimelineViewModel</code>对象来完成初始化即可。它的实现我在上一讲已经介绍过了，你可以再留意下。</p>



<p data-nodeid="1589">然后，我在<code data-backticks="1" data-nodeid="1919">func viewDidAppear(_ animated: Bool)</code>方法里面调用<code data-backticks="1" data-nodeid="1921">viewModel.trackScreenviews()</code>来让 ViewModel 发送用户行为数据。</p>
<p data-nodeid="1590">为了帮<code data-backticks="1" data-nodeid="1924">BaseViewController</code>提供需要注册的 TableView Cell ，最后我重写了<code data-backticks="1" data-nodeid="1926">tableViewCellsToRegister</code>属性。该属性存放<code data-backticks="1" data-nodeid="1928">BaseTableViewCell</code>的实例。<code data-backticks="1" data-nodeid="1930">BaseTableViewCell</code>使用范型（generic）来存放<code data-backticks="1" data-nodeid="1932">BaseListItemView</code>的子类，这些子类包括<code data-backticks="1" data-nodeid="1934">UserProfileListItemView</code>和<code data-backticks="1" data-nodeid="1936">MomentListItemView</code>。</p>
<p data-nodeid="1591">你可以从下图中看到它们所呈现的 UI 组件。</p>
<p data-nodeid="1592"><img src="https://s0.lgstatic.com/i/image6/M01/3C/B3/CioPOWCL3JKAWyl6AAalmHPesaU548.png" alt="图片4.png" data-nodeid="1941"></p>
<p data-nodeid="1593"><code data-backticks="1" data-nodeid="1942">MomentsTimelineViewController</code>我们已介绍完毕了，下面咱们以<code data-backticks="1" data-nodeid="1944">UserProfileListItemView</code>为例，看一下开发子控件的步骤与实现。</p>
<p data-nodeid="1594"><code data-backticks="1" data-nodeid="1946">UserProfileListItemView</code>用于显示用户自己的资料，例如用户名字，头像和背景图。因为有了通用和统一的 UI 开发框架，每次开发 UI 页面的步骤都是一致的，具体我分为以下几步完成：</p>
<ol data-nodeid="1595">
<li data-nodeid="1596">
<p data-nodeid="1597">初始化 UI 控件的属性；</p>
</li>
<li data-nodeid="1598">
<p data-nodeid="1599">配置 UI 控件的样式；</p>
</li>
<li data-nodeid="1600">
<p data-nodeid="1601">设置自动布局的约束；</p>
</li>
<li data-nodeid="1602">
<p data-nodeid="1603">重写<code data-backticks="1" data-nodeid="1952">update(with viewModel: ListItemViewModel)</code>方法，根据 ViewModel 的数据来更新 UI。</p>
</li>
</ol>
<p data-nodeid="1604">先看一下初始化 UI 控件属性的代码。</p>
<pre class="lang-swift" data-nodeid="1605"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> backgroundImageView: <span class="hljs-type">UIImageView</span> = configure(.<span class="hljs-keyword">init</span>()) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
    $<span class="hljs-number">0</span>.contentMode = .scaleAspectFill
    $<span class="hljs-number">0</span>.accessibilityIgnoresInvertColors = <span class="hljs-literal">true</span>
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> avatarImageView: <span class="hljs-type">UIImageView</span> = configure(.<span class="hljs-keyword">init</span>()) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
    $<span class="hljs-number">0</span>.asAvatar(cornerRadius: <span class="hljs-number">8</span>)
    $<span class="hljs-number">0</span>.contentMode = .scaleAspectFill
    $<span class="hljs-number">0</span>.accessibilityIgnoresInvertColors = <span class="hljs-literal">true</span>
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> nameLabel: <span class="hljs-type">UILabel</span> = configure(.<span class="hljs-keyword">init</span>()) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
    $<span class="hljs-number">0</span>.font = <span class="hljs-type">UIFont</span>.designKit.title3
    $<span class="hljs-number">0</span>.textColor = .white
    $<span class="hljs-number">0</span>.numberOfLines = <span class="hljs-number">1</span>
}
</code></pre>
<p data-nodeid="1606">我们分别调用<code data-backticks="1" data-nodeid="1956">configure()</code>函数来初始化三个 UI 控件的属性，<code data-backticks="1" data-nodeid="1958">backgroundImageView</code>用于显示背景图，<code data-backticks="1" data-nodeid="1960">avatarImageView</code>用于显示用户头像，而<code data-backticks="1" data-nodeid="1962">nameLabel</code>用于显示用户名字。</p>
<p data-nodeid="1607">你可以根据下图，看到它们分别使用在哪里。</p>
<p data-nodeid="1608"><img src="https://s0.lgstatic.com/i/image6/M01/3C/B3/CioPOWCL3LGAfuNrABZKzpfsijg925.png" alt="图片5.png" data-nodeid="1967"></p>
<p data-nodeid="1609">接着来看在第二步中如何配置 UI 控件的样式，我用<code data-backticks="1" data-nodeid="1969">setupUI()</code>方法来实现。</p>
<pre class="lang-swift" data-nodeid="1610"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupUI</span><span class="hljs-params">()</span></span> {
    backgroundColor = <span class="hljs-type">UIColor</span>.designKit.background
    [backgroundImageView, avatarImageView, nameLabel].forEach {
        addSubview($<span class="hljs-number">0</span>)
    }
}
</code></pre>
<p data-nodeid="1611">在这里，我使用了 DesignKit 来设置了背景颜色，并把子控件添加到当前 View 里面。</p>
<p data-nodeid="1612">然后看第三步如何设置自动布局的约束，其实现代码如下。</p>
<pre class="lang-swift" data-nodeid="1613"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupConstraints</span><span class="hljs-params">()</span></span> {
    backgroundImageView.snp.makeConstraints {
        $<span class="hljs-number">0</span>.top.leading.trailing.equalToSuperview()
        $<span class="hljs-number">0</span>.bottom.equalToSuperview().offset(-<span class="hljs-type">Spacing</span>.medium)
        $<span class="hljs-number">0</span>.height.equalTo(backgroundImageView.snp.width).multipliedBy(<span class="hljs-number">0.8</span>).priority(<span class="hljs-number">999</span>)
    }
    avatarImageView.snp.makeConstraints {
        $<span class="hljs-number">0</span>.<span class="hljs-keyword">right</span>.equalToSuperview().offset(-<span class="hljs-type">Spacing</span>.medium)
        $<span class="hljs-number">0</span>.bottom.equalToSuperview()
        $<span class="hljs-number">0</span>.height.equalTo(<span class="hljs-number">80</span>)
        $<span class="hljs-number">0</span>.width.equalTo(<span class="hljs-number">80</span>)
    }
    nameLabel.snp.makeConstraints {
        $<span class="hljs-number">0</span>.<span class="hljs-keyword">right</span>.equalTo(<span class="hljs-keyword">self</span>.avatarImageView.snp.<span class="hljs-keyword">left</span>).offset(-<span class="hljs-type">Spacing</span>.medium)
        $<span class="hljs-number">0</span>.centerY.equalTo(<span class="hljs-keyword">self</span>.avatarImageView.snp.centerY)
    }
}
</code></pre>
<p data-nodeid="1614">其中<code data-backticks="1" data-nodeid="1974">backgroundImageView</code>的顶部和两边都延展到父控件，因为底部需要留白来显示用户头像，因此添加了<code data-backticks="1" data-nodeid="1976">medium</code>作为间距。背景图片的长宽比是 5:4。</p>
<p data-nodeid="1615"><code data-backticks="1" data-nodeid="1978">avatarImageView</code>位于父控件的右下角，并设定长度和宽度都为 80pt。<code data-backticks="1" data-nodeid="1980">nameLabel</code>位于<code data-backticks="1" data-nodeid="1982">avatarImageView</code>的左边，并与之水平。这样我们就使用 SnapKit 完成用户资料 UI 的布局了。<br>
最后一部分是调用<code data-backticks="1" data-nodeid="1986">update()</code>方法来更新 UI，其代码如下。</p>
<pre class="lang-swift" data-nodeid="1616"><code data-language="swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span> {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> viewModel = viewModel <span class="hljs-keyword">as</span>? <span class="hljs-type">UserProfileListItemViewModel</span> <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>
    }
    backgroundImageView.kf.setImage(with: viewModel.backgroundImageURL)
    avatarImageView.kf.setImage(with: viewModel.avatarURL)
    nameLabel.text = viewModel.name
}
</code></pre>
<p data-nodeid="4088">因为<code data-backticks="1" data-nodeid="4091">UserProfileListItemViewModel</code>已经为<code data-backticks="1" data-nodeid="4093">UserProfileListItemView</code>准备好呈现所需的所有数据，因此，只要简单的赋值就可以更新 UI 了。</p>
<p data-nodeid="4089"><code data-backticks="1" data-nodeid="4095">MomentListItemView</code>的代码结构和<code data-backticks="1" data-nodeid="4097">UserProfileListItemView</code>基本一样，你可以到拉勾教育的代码仓库进行查看。</p>

<h3 data-nodeid="1618">总结</h3>
<p data-nodeid="1619">在这一讲中，我为你介绍了如何架构和实现一个通用的列表 UI 模块，有了这个模块，我们按照以下这几个步骤就可以完成 UI 的开发了。</p>
<ol data-nodeid="1620">
<li data-nodeid="1621">
<p data-nodeid="1622">初始化 UI 控件的属性，把 UI 分解成不同的子控件，然后通过<code data-backticks="1" data-nodeid="2001">configure()</code>来初始化各个控件属性。</p>
</li>
<li data-nodeid="1623">
<p data-nodeid="1624">配置 UI 控件的样式，如配置背景颜色等，并把各个子控件添加到父控件里面。</p>
</li>
<li data-nodeid="1625">
<p data-nodeid="1626">设置自动布局的约束，推荐使用 SnapKit 来简化配置约束的工作。</p>
</li>
<li data-nodeid="1627">
<p data-nodeid="1628">重写<code data-backticks="1" data-nodeid="2006">update(with viewModel: ListItemViewModel)</code>方法，根据 ViewModel 的数据来更新 UI。如果有数据绑定，那么使用 RxSwift 和 RxCocoa 把 ViewModel 的 Subject 属性绑定到 UI 控件上。如果不需要数据绑定，只需把 ViewModel 准备好的值赋给 UI 控件即可。</p>
</li>
</ol>
<p data-nodeid="1629"><strong data-nodeid="2011">思考题</strong></p>
<blockquote data-nodeid="1630">
<p data-nodeid="1631">请问你们使用苹果提供的自动布局吗？如果是，是使用原生语法还是类似 SnapKit 那种库呢？或者说使用 Texture 等其他非苹果的框架进行布局？能分享你的使用经验吗？</p>
</blockquote>
<p data-nodeid="1632">可以把你的思考写到留言区哦，下一讲，我会介绍如何使用现有架构添加点赞功能。</p>
<p data-nodeid="1633"><strong data-nodeid="2017">源码地址</strong></p>
<blockquote data-nodeid="1634">
<p data-nodeid="1635" class="">通用列表 UI 的源码地址：<br>
<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Views?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2022">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Views</a><br>
朋友圈时间轴页面实现的源码地址：<br>
<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/Views?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2028">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/Views</a></p>
</blockquote></div>

</body></html>