<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>23 | TDD 与单元测试：如何保证功能模块的高质量？</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>23 | TDD 与单元测试：如何保证功能模块的高质量？</h1><p data-nodeid="86083">如果一个 App 有很多的 Bug 或者崩溃率非常高，我们往往就需要花大量的时间和精力去不断查错和“救火”。那怎样才能提高代码的质量，让我们可以把有效的时间专注于产品功能的迭代上呢？经过多年实践经验的总结，我们发现<strong data-nodeid="86089">测试驱动开发</strong>，也叫作 TDD（Test-Driven Development），是一种行而有效的方法实践。</p>


<p data-nodeid="84435"><strong data-nodeid="84542">TDD 的核心是编写单元测试</strong>。单元测试能方便我们模拟不同的测试场景，覆盖不同的边界条件，从而提高代码的质量并减少 Bug 的数量。同时，使用 TDD 所开发的代码能降低模块间的耦合度，提高模块的灵活性和可扩展性。</p>
<p data-nodeid="84436">下面我们以 Moments App 作为例子来看看如何通过编写单元测试来进行 TDD。这里主要讲述测试代码的步骤与结构，以及如何为网络层、Repository 层和 ViewModel 层编写单元测试。</p>
<h3 data-nodeid="84437">测试代码的步骤与结构</h3>
<p data-nodeid="84438">在编写测试代码时候，我们一般遵守 AAA 步骤，所谓<strong data-nodeid="84550">AAA 就是 Arrange、Act 和 Assert</strong>。</p>
<ul data-nodeid="84439">
<li data-nodeid="84440">
<p data-nodeid="84441">Arrange：用于搭建测试案例，例如，初始化测试对象及其依赖。</p>
</li>
<li data-nodeid="84442">
<p data-nodeid="84443">Act：表示执行测试，例如，调用测试对象的方法。</p>
</li>
<li data-nodeid="84444">
<p data-nodeid="84445">Assert：用于检验测试的结果。</p>
</li>
</ul>
<p data-nodeid="84446">那怎样才能按照 AAA 步骤来编写测试代码呢？为了简化编写测试的工作，并提高代码的结构性与可读性，我们在 Moments App 中使用了 Quick 和 Nimble 库。下面我以<code data-backticks="1" data-nodeid="84555">MomentsTimelineViewModelTests</code>为例子给你讲述一种实用的测试代码结构：</p>
<pre class="lang-swift" data-nodeid="84447"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MomentsTimelineViewModelTests</span>: <span class="hljs-title">QuickSpec</span> </span>{
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spec</span><span class="hljs-params">()</span></span> {
        describe(<span class="hljs-string">"MomentsTimelineViewModel"</span>) {
            <span class="hljs-keyword">var</span> testSubject: <span class="hljs-type">MomentsTimelineViewModel!</span>
            beforeEach {
                testSubject = <span class="hljs-type">MomentsTimelineViewModel</span>() <span class="hljs-comment">// Arrange</span>
            }
            context(<span class="hljs-string">"loadItems()"</span>) {
                beforeEach {
                    testSubject.loadItems() <span class="hljs-comment">// Act</span>
                }
                it(<span class="hljs-string">"call \`momentsRepo.getMoments\` with the correct parameters"</span>) {
                    expect(mockMomentsRepo.getMomentsHasBeenCalled).to(beTrue()) <span class="hljs-comment">// Assert</span>
                }
                it(<span class="hljs-string">"check another assertion"</span>) { }
            }
            context(<span class="hljs-string">"anotherMethod()"</span>) { }
        }
    }
}
</code></pre>
<p data-nodeid="84448"><strong data-nodeid="84579">首先是测试类的定义</strong>。我们定义了一个继承于<code data-backticks="1" data-nodeid="84561">QuickSpec</code>的测试类，测试类通常以<code data-backticks="1" data-nodeid="84563">&lt;需要测试的类型&gt;Tests</code>的规范来命名。在上面的例子中，我们需要测试<code data-backticks="1" data-nodeid="84565">MomentsTimelineViewModel</code>，因此把测试类定义为<code data-backticks="1" data-nodeid="84567">MomentsTimelineViewModelTests</code>。然后在类里面重写<code data-backticks="1" data-nodeid="84569">spec()</code>方法来封装所有测试案例。接着在<code data-backticks="1" data-nodeid="84571">spec()</code>方法里面通过<code data-backticks="1" data-nodeid="84573">describe()</code>方法来进行分组，我的做法是一个测试类型只有一个<code data-backticks="1" data-nodeid="84575">describe()</code>方法，并把要测试类型的名称传递给该方法，在例子中就写成<code data-backticks="1" data-nodeid="84577">describe("MomentsTimelineViewModel")</code>，这样能保证在批量执行测试案例时可以快速定位出错的测试类。</p>
<p data-nodeid="84449"><strong data-nodeid="84612">接下来是执行 AAA 中的 Arrange 步骤来搭建测试案例所需的对象</strong>。在<code data-backticks="1" data-nodeid="84584">describe()</code>方法里，我们先定义一个名叫<code data-backticks="1" data-nodeid="84586">testSubject</code>的测试对象，它的类型为需要测试的类型，在我们的例子中，<code data-backticks="1" data-nodeid="84588">testSubject</code>的类型是<code data-backticks="1" data-nodeid="84590">MomentsTimelineViewModel!</code>。你可能注意到，我们定义<code data-backticks="1" data-nodeid="84592">testSubject</code>时使用了<code data-backticks="1" data-nodeid="84594">!</code>来表示该对象不会为<code data-backticks="1" data-nodeid="84596">nil</code>。不过，这里需要提醒一下，在生产代码中，我们绝对不使用<code data-backticks="1" data-nodeid="84598">!</code>来定义属性，因为一旦该属性为<code data-backticks="1" data-nodeid="84600">nil</code>时，调用该属性的方法就会导致程序崩溃。那为什么在测试代码中反而使用<code data-backticks="1" data-nodeid="84602">!</code>呢？因为我们希望在执行每一个测试案例之前都重新生成一个新的<code data-backticks="1" data-nodeid="84604">testSubject</code>对象来保证每个案例都是无状态的，所以我们需要把初始化操作放到<code data-backticks="1" data-nodeid="84606">beforeEach()</code>方法里面，如果<code data-backticks="1" data-nodeid="84608">testSubject</code>不是定义为<code data-backticks="1" data-nodeid="84610">!</code>，就会有编译错误。</p>
<p data-nodeid="84450"><strong data-nodeid="84629">然后是执行 AAA 里面的 Act 步骤</strong>。测试类型中的每一个公共的方法和属性都需要测试，因此，我们需要把它们的测试案例进行分组。为此，我会使用到<code data-backticks="1" data-nodeid="84617">context()</code>方法。例如，当我们要测试<code data-backticks="1" data-nodeid="84619">loadItems()</code>方法时，就把方法名字传递给<code data-backticks="1" data-nodeid="84621">context()</code>方法，写成<code data-backticks="1" data-nodeid="84623">context("loadItems()")</code>，并在该 context 下的<code data-backticks="1" data-nodeid="84625">beforeEach()</code>方法里调用测试方法<code data-backticks="1" data-nodeid="84627">loadItems()</code>，这样就执行 Act 步骤了。</p>
<p data-nodeid="84451"><strong data-nodeid="84646">最后看一下如何执行 AAA 里面的 Assert 步骤</strong>。我们可以通过<code data-backticks="1" data-nodeid="84634">it()</code>方法来检验每个测试案例的执行结果。为了使得测试更加容易读，我通常把测试的预期行为都写在<code data-backticks="1" data-nodeid="84636">it()</code>方法里面，示例中的<code data-backticks="1" data-nodeid="84638">it("call momentsRepo.getMoments()with the correct parameters")</code>表示当我们调用<code data-backticks="1" data-nodeid="84640">loadItems()</code>方法时就必须调用<code data-backticks="1" data-nodeid="84642">momentsRepo</code>属性的<code data-backticks="1" data-nodeid="84644">getMoments()</code>函数。</p>
<p data-nodeid="84452">至此，编写单元测试代码的步骤与框架就讲完了。下面我们再结合真实的例子来看看如何为网络层、Repository 层和 ViewModel 层编写测试代码。</p>
<h3 data-nodeid="84453">网络层的测试</h3>
<p data-nodeid="84454">我们以<code data-backticks="1" data-nodeid="84650">GetMomentsByUserIDSessionTests</code>为例子看看如何为网络层编写单元测试的代码。因为我们使用了 RxSwift，在测试的时候可以引用<strong data-nodeid="84656">RxTest 库</strong>来简化测试的流程。</p>
<p data-nodeid="84455">首先，我们在<code data-backticks="1" data-nodeid="84658">describe("GetMomentsByUserIDSession")</code>函数里定义需要初始化的变量，代码如下：</p>
<pre class="lang-swift" data-nodeid="84456"><code data-language="swift"><span class="hljs-keyword">var</span> testSubject: <span class="hljs-type">GetMomentsByUserIDSession!</span>
<span class="hljs-keyword">var</span> testScheduler: <span class="hljs-type">TestScheduler!</span>
<span class="hljs-keyword">var</span> testObserver: <span class="hljs-type">TestableObserver</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;!
<span class="hljs-keyword">var</span> mockResponseEvent: <span class="hljs-type">Recorded</span>&lt;<span class="hljs-type">Event</span>&lt;<span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span>&gt;&gt;!
</code></pre>
<ul data-nodeid="84457">
<li data-nodeid="84458">
<p data-nodeid="84459"><code data-backticks="1" data-nodeid="84660">testSubject</code>是测试的对象，在这个例子中是我们需要测试的<code data-backticks="1" data-nodeid="84662">GetMomentsByUserIDSession</code>。</p>
</li>
<li data-nodeid="84460">
<p data-nodeid="84461"><code data-backticks="1" data-nodeid="84664">testScheduler</code>的类型是来自 RxTest 的<code data-backticks="1" data-nodeid="84666">TestScheduler</code>，是一个用于测试的排程器。</p>
</li>
<li data-nodeid="84462">
<p data-nodeid="84463"><code data-backticks="1" data-nodeid="84668">testObserver</code>的类型是 RxTest 的<code data-backticks="1" data-nodeid="84670">TestableObserver</code>，用来订阅 Observable 序列里的事件，并通过接收到的事件来检查测试的结果。</p>
</li>
<li data-nodeid="84464">
<p data-nodeid="84465"><code data-backticks="1" data-nodeid="84672">mockResponseEvent</code>是<code data-backticks="1" data-nodeid="84674">Recorded</code>类型，也是来自 RxTest，用于模拟事件的发送，例如模拟成功接收到网络数据事件或者错误事件。</p>
</li>
</ul>
<p data-nodeid="84466">所需的变量定义完毕以后，可以在<code data-backticks="1" data-nodeid="84677">beforeEach()</code>方法里面初始化<code data-backticks="1" data-nodeid="84679">testScheduler</code>和<code data-backticks="1" data-nodeid="84681">testObserver</code>，具体代码如下：</p>
<pre class="lang-swift" data-nodeid="84467"><code data-language="swift">beforeEach {
    testScheduler = <span class="hljs-type">TestScheduler</span>(initialClock: <span class="hljs-number">0</span>)
    testObserver = testScheduler.createObserver(<span class="hljs-type">MomentsDetails</span>.<span class="hljs-keyword">self</span>)
}
</code></pre>
<p data-nodeid="87186">因为初始化操作都在<code data-backticks="1" data-nodeid="87189">beforeEach()</code>方法里面，所以每个测试案例执行前都会重新初始化这两个变量。</p>
<p data-nodeid="87187">初始化完毕后，我们就可以测试<code data-backticks="1" data-nodeid="87192">GetMomentsByUserIDSession</code>的<code data-backticks="1" data-nodeid="87194">getMoments()</code>方法了，具体代码如下：</p>

<pre class="lang-swift" data-nodeid="84469"><code data-language="swift">context(<span class="hljs-string">"getMoments(userID:)"</span>) {
    context(<span class="hljs-string">"when response status code 200 with valid response"</span>) {
        beforeEach {
            mockResponseEvent = .next(<span class="hljs-number">100</span>, <span class="hljs-type">TestData</span>.successResponse)
            getMoments(mockEvent: mockResponseEvent)
        }
    }
}
</code></pre>
<p data-nodeid="84470">我们使用<code data-backticks="1" data-nodeid="84693">context("getMoments(userID:)")</code>把<code data-backticks="1" data-nodeid="84695">getMoments(userID:)</code>所有的测试案例都组织在一起。先看成功的测试案例，该案例封装在<code data-backticks="1" data-nodeid="84697">context("when response status code 200 with valid response")</code>函数里面，表示网络成功返回有效数据时的情况。在<code data-backticks="1" data-nodeid="84699">beforeEach()</code>方法里做了两件事情，第一件执行 Arrange 步骤，让<code data-backticks="1" data-nodeid="84701">mockResponseEvent</code>发出一个<code data-backticks="1" data-nodeid="84703">.next</code>事件，该事件里面包含了类型为<code data-backticks="1" data-nodeid="84705">GetMomentsByUserIDSession.Response</code>的数据对象<code data-backticks="1" data-nodeid="84707">successResponse</code>。下面是这个数据对象的定义：</p>
<pre class="lang-swift" data-nodeid="84471"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestData</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> successResponse: <span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span> = {
        <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">try</span>! <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span>.<span class="hljs-keyword">self</span>,
                                               from: <span class="hljs-type">TestData</span>.successjson.data(using: .utf8)!)
        <span class="hljs-keyword">return</span> response
    }()
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> successjson = <span class="hljs-string">"""
    {
      "data": { ... } // JSON 数据
    }
    """</span>
}
</code></pre>
<p data-nodeid="84472">代码中的私有结构体<code data-backticks="1" data-nodeid="84710">TestData</code>用于配置测试数据，它提供了一个名叫<code data-backticks="1" data-nodeid="84712">successResponse</code>的静态属性来返回类型为<code data-backticks="1" data-nodeid="84714">GetMomentsByUserIDSession.Response</code>的测试数据。在这个属性里，我们使用了<code data-backticks="1" data-nodeid="84716">JSONDecoder().decode()</code>方法来解码 JSON 字符串。在开发的过程，我们可以从 BFF 的返回值中拷贝该 JSON 字符串。通过这个测试案例，我们可以快速地测试<code data-backticks="1" data-nodeid="84718">GetMomentsByUserIDSession</code>结构体的映射是否正确。这种做法比通过修改后台来返回测试数据要方便很多。</p>
<p data-nodeid="84473"><code data-backticks="1" data-nodeid="84720">beforeEach()</code>方法里第二件事情是执行 Act 步骤，可以通过调用<code data-backticks="1" data-nodeid="84722">getMoments(mockEvent: mockResponseEvent)</code>方法来完成这一任务。该方法是一个私有方法，其定义如下：</p>
<pre class="lang-swift" data-nodeid="84474"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(mockEvent: Recorded&lt;Event&lt;GetMomentsByUserIDSession.Response&gt;&gt;)</span></span> {
    <span class="hljs-keyword">let</span> testableObservable = testScheduler.createHotObservable([mockEvent])
    testSubject = <span class="hljs-type">GetMomentsByUserIDSession</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> testableObservable.asObservable() }
    testSubject.getMoments(userID: <span class="hljs-string">"0"</span>).subscribe(testObserver).disposed(by: disposeBag)
    testScheduler.start()
}
</code></pre>
<p data-nodeid="84475">首先我们把模拟数据传递给<code data-backticks="1" data-nodeid="84725">testScheduler.createHotObservable()</code>方法来生成一个新的<code data-backticks="1" data-nodeid="84727">testableObservable</code>对象，然后把该对象注入<code data-backticks="1" data-nodeid="84729">GetMomentsByUserIDSession</code>的初始化方法里并生成新的测试对象<code data-backticks="1" data-nodeid="84731">testSubject</code>，接着调用测试对象的<code data-backticks="1" data-nodeid="84733">getMoments(userID:)</code>方法，最后通过调用<code data-backticks="1" data-nodeid="84735">testScheduler.start()</code>方法来启动排程器，模拟一个异步网络请求的过程。</p>
<p data-nodeid="84476">执行完 Act 步骤以后，我们还需要执行 Assert 步骤来检验测试的结果，验证的代码都放在<code data-backticks="1" data-nodeid="84738">it("should complete and map the response correctly")</code>方法里面，如下所示：</p>
<pre class="lang-swift" data-nodeid="84477"><code data-language="swift">it(<span class="hljs-string">"should complete and map the response correctly"</span>) {
    <span class="hljs-keyword">let</span> expectedMomentsDetails = <span class="hljs-type">TestFixture</span>.momentsDetails
    <span class="hljs-keyword">let</span> actualMomentsDetails = testObserver.events.first!.value.element!
    expect(actualMomentsDetails).toEventually(<span class="hljs-built_in">equal</span>(expectedMomentsDetails))
}
</code></pre>
<p data-nodeid="84478">我们从<code data-backticks="1" data-nodeid="84741">testObserver</code>里取出它接收到的第一个事件，然后调用<code data-backticks="1" data-nodeid="84743">expect()</code>方法来比较实际数据和预期数据。因为网络的数据是异步返回的，所以我们在比较过程时使用了<code data-backticks="1" data-nodeid="84745">toEventually()</code>方法，该方法会等待结果返回以后才进行比较。</p>
<p data-nodeid="84479">成功案例已经测试完毕，接下来我们看一个失败的案例。下面的代码模拟了网络访问失败的情况：</p>
<pre class="lang-swift" data-nodeid="84480"><code data-language="swift">context(<span class="hljs-string">"when response status code non-200"</span>) {
    <span class="hljs-keyword">let</span> networkError: <span class="hljs-type">APISessionError</span> = .networkError(error: <span class="hljs-type">MockError</span>(), statusCode: <span class="hljs-number">500</span>)
    beforeEach {
        mockResponseEvent = .error(<span class="hljs-number">100</span>, networkError, <span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span>.<span class="hljs-keyword">self</span>)
        getMoments(mockEvent: mockResponseEvent)
    }
    it(<span class="hljs-string">"should throw a network error"</span>) {
        <span class="hljs-keyword">let</span> actualError = testObserver.events.first!.value.error <span class="hljs-keyword">as</span>! <span class="hljs-type">APISessionError</span>
        expect(actualError).toEventually(<span class="hljs-built_in">equal</span>(networkError))
    }
}
</code></pre>
<p data-nodeid="84481">你可以看到，测试代码的结构和成功案例是一致的，不同的地方是我们让<code data-backticks="1" data-nodeid="84749">mockResponseEvent</code>返回一个错误的事件，在检验的过程中，我们从<code data-backticks="1" data-nodeid="84751">testObserver</code>取出<code data-backticks="1" data-nodeid="84753">error</code>来进行对比，而不是<code data-backticks="1" data-nodeid="84755">element</code>。</p>
<p data-nodeid="84482">网络测试的代码就讲到这里，你可以打开拉勾教育网的代码仓库来查看更多网络层的测试案例。</p>
<h3 data-nodeid="84483">Repository 层的测试</h3>
<p data-nodeid="84484">下面我们以<code data-backticks="1" data-nodeid="84760">MomentsRepoTests</code>为例子看一下如何测试 Repository 层。</p>
<p data-nodeid="84485"><code data-backticks="1" data-nodeid="84762">MomentsRepoTests</code>用于测试<code data-backticks="1" data-nodeid="84764">MomentsRepo</code>。我们在《19 | 数据层架构：如何使用仓库模式设计数据存储层？》中描述过，<code data-backticks="1" data-nodeid="84766">MomentsRepo</code>依赖了<code data-backticks="1" data-nodeid="84768">PersistentDataStoreType</code>来读取本地数据，并且依赖了<code data-backticks="1" data-nodeid="84770">GetMomentsByUserIDSessionType</code>从 BFF 读取朋友圈信息。那我们测试<code data-backticks="1" data-nodeid="84772">MomentsRepo</code>的时候是不是也一同测试两个类型的实现呢？答案是否定的，因为<strong data-nodeid="84788">所谓单元测试就是只单独测试某个类型的具体实现，而不测试它的依赖类型</strong>。回到<code data-backticks="1" data-nodeid="84778">MomentsRepoTests</code>的例子，它仅仅测试<code data-backticks="1" data-nodeid="84780">MomentsRepo</code>的实现。也就是说，哪怕我们替换了<code data-backticks="1" data-nodeid="84782">PersistentDataStoreType</code>和<code data-backticks="1" data-nodeid="84784">GetMomentsByUserIDSessionType</code>的实现，在不修改<code data-backticks="1" data-nodeid="84786">MomentsRepoTests</code>的情况下，所有测试案例都必须通过验证。</p>
<p data-nodeid="84486">那怎样才能使得<code data-backticks="1" data-nodeid="84790">MomentsRepoTests</code>只测试<code data-backticks="1" data-nodeid="84792">MomentsRepo</code>的实现，而不测试其他任何的依赖类型呢？我们可以通过 Mock 类型来达到这一目的。下面是 Mock 类型的示例代码：</p>
<pre class="lang-swift" data-nodeid="84487"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockUserDefaultsPersistentDataStore</span>: <span class="hljs-title">PersistentDataStoreType</span> </span>{
    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> momentsDetails: <span class="hljs-type">ReplaySubject</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; = .create(bufferSize: <span class="hljs-number">1</span>)
    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> savedMomentsDetails: <span class="hljs-type">MomentsDetails?</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">save</span><span class="hljs-params">(momentsDetails: MomentsDetails)</span></span> {
        savedMomentsDetails = momentsDetails
    }
}
<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockGetMomentsByUserIDSession</span>: <span class="hljs-title">GetMomentsByUserIDSessionType</span> </span>{
    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> getMomentsHasbeenCalled = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> passedUserID: <span class="hljs-type">String</span> = <span class="hljs-string">""</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; {
        passedUserID = userID
        getMomentsHasbeenCalled = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Observable</span>.just(<span class="hljs-type">TestFixture</span>.momentsDetails)
    }
}
</code></pre>
<p data-nodeid="84488">我们分别定义了两个 Mock 类型来遵循<code data-backticks="1" data-nodeid="84795">PersistentDataStoreType</code>和<code data-backticks="1" data-nodeid="84797">GetMomentsByUserIDSessionType</code>协议，这些 Mock 类型只是把传递的参数保存在属性中，并不进行具体的操作，例如不会读写本地数据库和访问网络。</p>
<p data-nodeid="84489">有了这些 Mock 类型以后，我们就可以把它们注入测试对象<code data-backticks="1" data-nodeid="84800">testSubject</code>中，具体代码如下：</p>
<pre class="lang-swift" data-nodeid="84490"><code data-language="swift">beforeEach {
    mockUserDefaultsPersistentDataStore = <span class="hljs-type">MockUserDefaultsPersistentDataStore</span>()
    mockGetMomentsByUserIDSession = <span class="hljs-type">MockGetMomentsByUserIDSession</span>()
    testSubject = <span class="hljs-type">MomentsRepo</span>(persistentDataStore: mockUserDefaultsPersistentDataStore, getMomentsByUserIDSession: mockGetMomentsByUserIDSession)
}
</code></pre>
<p data-nodeid="84491">在上一讲的思考题中我提问过：为什么保存依赖的属性都是通过<code data-backticks="1" data-nodeid="84803">init()</code>方法来注入，而不是在内部进行初始化？<strong data-nodeid="84817">一个重要的原因是我们可以在执行单元测试时把 Mock 类型注入进来</strong>。例如在生产代码中，我们为<code data-backticks="1" data-nodeid="84809">MomentsRepo</code>的<code data-backticks="1" data-nodeid="84811">persistentDataStore</code>属性注入<code data-backticks="1" data-nodeid="84813">UserDefaultsPersistentDataStore.shared</code>来访问 iOS 系统的 UserDefaults。UserDefaults 上的数据在程序退出以后还会保留，而单元测试的案例是无状态的，因此所有测试都不应该读写 UserDefaults 上的数据。我们可以在测试代码中，通过注入<code data-backticks="1" data-nodeid="84815">MockUserDefaultsPersistentDataStore</code>的对象来避免访问 UserDefaults。</p>
<p data-nodeid="84492">依赖注入是面向抽象编程中一种有效的实践方式，不但方便我们编写测试代码，使得测试不依赖于任何的具体环境，同时还能帮我们很容易地替换某个模块的具体实现，例如，当我们决定使用 CoreData 来替换 UserDefaults 作为本地数据存储时，只需在生产代码中注入<code data-backticks="1" data-nodeid="84819">CoreDataPersistentDataStore.shared</code>即可。</p>
<p data-nodeid="84493">有了 Mock 类型以后，我们看一下如何测试<code data-backticks="1" data-nodeid="84822">MomentsRepo</code>的<code data-backticks="1" data-nodeid="84824">momentsDetails</code>属性，其中 Arrange 和 Act 步骤的代码如下：</p>
<pre class="lang-swift" data-nodeid="84494"><code data-language="swift">context(<span class="hljs-string">"momentsDetails"</span>) {
    <span class="hljs-keyword">var</span> testObserver: <span class="hljs-type">TestObserver</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;!
    beforeEach {
        testObserver = <span class="hljs-type">TestObserver</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;() <span class="hljs-comment">// Arrange</span>
        testSubject.momentsDetails.subscribe(testObserver).disposed(by: disposeBag) <span class="hljs-comment">// Act</span>
    }
}
</code></pre>
<p data-nodeid="84495">首先，初始化了一个<code data-backticks="1" data-nodeid="84827">TestObserver</code>对象来帮助测试 RxSwift 的代码。<code data-backticks="1" data-nodeid="84829">TestObserver</code>是我们自定义的一个类，定义如下：</p>
<pre class="lang-swift" data-nodeid="84496"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestObserver</span>&lt;<span class="hljs-title">ElementType</span>&gt;: <span class="hljs-title">ObserverType</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastEvent: <span class="hljs-type">Event</span>&lt;<span class="hljs-type">ElementType</span>&gt;?
    <span class="hljs-keyword">var</span> lastElement: <span class="hljs-type">ElementType?</span> {
        <span class="hljs-keyword">return</span> lastEvent?.element
    }
    <span class="hljs-keyword">var</span> lastError: <span class="hljs-type">Error?</span> {
        <span class="hljs-keyword">return</span> lastEvent?.error
    }
    <span class="hljs-keyword">var</span> isCompleted: <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">return</span> lastEvent?.isCompleted ?? <span class="hljs-literal">false</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">on</span><span class="hljs-params">(<span class="hljs-number">_</span> event: Event&lt;ElementType&gt;)</span></span> {
        lastEvent = event
    }
}
</code></pre>
<p data-nodeid="84497"><code data-backticks="1" data-nodeid="84831">TestObserver</code>定义了<code data-backticks="1" data-nodeid="84833">on(_ event: Event&lt;ElementType&gt;)</code>方法来接收事件，并提供了<code data-backticks="1" data-nodeid="84835">lastElement</code>、<code data-backticks="1" data-nodeid="84837">lastError</code>和<code data-backticks="1" data-nodeid="84839">isCompleted</code>属性来检查最后一条事件的类型。有了<code data-backticks="1" data-nodeid="84841">testObserver</code>对象，我们可以把它传递给<code data-backticks="1" data-nodeid="84843">subscribe()</code>方法来订阅<code data-backticks="1" data-nodeid="84845">momentsDetails</code>属性的事件，然后通过它来验证 RxSwift 代码的测试结果，下面是 Assert 步骤的代码：</p>
<pre class="lang-swift" data-nodeid="84498"><code data-language="swift">it(<span class="hljs-string">"should be \`nil\` by default"</span>) {
    expect(testObserver.lastElement).to(beNil()) <span class="hljs-comment">// Assert</span>
}
context(<span class="hljs-string">"when persistentDataStore has new data"</span>) {
    beforeEach {
        mockUserDefaultsPersistentDataStore.momentsDetails.onNext(<span class="hljs-type">TestFixture</span>.momentsDetails)
    }
    it(<span class="hljs-string">"should notify a next event with the new data"</span>) {
        expect(testObserver.lastElement).toEventually(<span class="hljs-built_in">equal</span>(<span class="hljs-type">TestFixture</span>.momentsDetails)) <span class="hljs-comment">// Assert</span>
    }
}
</code></pre>
<p data-nodeid="84499">在开始的时候，<code data-backticks="1" data-nodeid="84848">testObserver</code>不应该接收到任何事件，所以它的<code data-backticks="1" data-nodeid="84850">lastElement</code>属性返回<code data-backticks="1" data-nodeid="84852">nil</code>。当我们往 Mock 类型<code data-backticks="1" data-nodeid="84854">mockUserDefaultsPersistentDataStore</code>的<code data-backticks="1" data-nodeid="84856">momentsDetails</code>属性发出一个<code data-backticks="1" data-nodeid="84858">next</code>事件后，<code data-backticks="1" data-nodeid="84860">testObserver</code>会接收到该事件，我们可以调用<code data-backticks="1" data-nodeid="84862">toEventually()</code>方法来进行检查。</p>
<p data-nodeid="84500">下面我们再看看<code data-backticks="1" data-nodeid="84865">getMoments(userID:)</code>方法的测试。具体代码如下：</p>
<pre class="lang-swift" data-nodeid="84501"><code data-language="swift">context(<span class="hljs-string">"getMoments(userID:)"</span>) {
    beforeEach {
        testSubject.getMoments(userID: <span class="hljs-string">"1"</span>).subscribe().disposed(by: disposeBag)
    }
    it(<span class="hljs-string">"should call \`GetMomentsByUserIDSessionType.getMoments\`"</span>) {
        expect(mockGetMomentsByUserIDSession.getMomentsHasbeenCalled).to(beTrue())
        expect(mockGetMomentsByUserIDSession.passedUserID).to(be(<span class="hljs-string">"1"</span>))
    }
    it(<span class="hljs-string">"should save a \`MomentsDetails\` object"</span>) {
        expect(mockUserDefaultsPersistentDataStore.savedMomentsDetails).to(<span class="hljs-built_in">equal</span>(<span class="hljs-type">TestFixture</span>.momentsDetails))
    }
}
</code></pre>
<p data-nodeid="84502">我们在<code data-backticks="1" data-nodeid="84868">beforeEach()</code>方法中执行了 Act 步骤来调用<code data-backticks="1" data-nodeid="84870">getMoments(userID:)</code>方法，这里首先复习一下《第 19 讲| 数据层架构：如何使用仓库模式设计数据存储层？》里讲过的<code data-backticks="1" data-nodeid="84872">MomentsRepo</code>方法的实现。</p>
<pre class="lang-swift" data-nodeid="84503"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt; {
    <span class="hljs-keyword">return</span> getMomentsByUserIDSession
        .getMoments(userID: userID)
        .<span class="hljs-keyword">do</span>(onNext: { persistentDataStore.save(momentsDetails: $<span class="hljs-number">0</span>) })
        .<span class="hljs-built_in">map</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> () }
        .catchErrorJustReturn(())
}
</code></pre>
<p data-nodeid="84504">在该方法实现中，我们会调用<code data-backticks="1" data-nodeid="84875">getMomentsByUserIDSession</code>的<code data-backticks="1" data-nodeid="84877">getMoments(userID:)</code>来读取网络数据，并调用<code data-backticks="1" data-nodeid="84879">persistentDataStore</code>的<code data-backticks="1" data-nodeid="84881">save(momentsDetails:)</code>方法把网络返回结果保存到本地数据库中。在测试过程中，我们已经为这两个依赖项分别注入了不同的 Mock 对象，因此在检验结果的时候，我们可以通过比较 Mock 对象的属性就能验证测试是否正确执行。例如，我们检查<code data-backticks="1" data-nodeid="84883">mockGetMomentsByUserIDSession.passedUserID</code>来验证<code data-backticks="1" data-nodeid="84885">getMomentsByUserIDSession</code>的执行结果，然后检查<code data-backticks="1" data-nodeid="84887">mockUserDefaultsPersistentDataStore.savedMomentsDetails</code>来验证<code data-backticks="1" data-nodeid="84889">persistentDataStore</code>的执行结果。</p>
<h3 data-nodeid="84505">ViewModel 层的测试</h3>
<p data-nodeid="84506">完成 Repository 层的测试以后，我们再一起看看如何测试 ViewModel 层的代码。</p>
<p data-nodeid="84507">朋友圈功能的 ViewModel 层由三个 ViewModel 类型所组成，其中<code data-backticks="1" data-nodeid="84894">MomentsTimelineViewModel</code>类型的测试方式与<code data-backticks="1" data-nodeid="84896">MomentsRepo</code>是一样的，<strong data-nodeid="84902">都是通过注入 Mock 类型类来测试 RxSwift 返回的结果</strong>。你可以在拉勾教育网的代码仓库查看详细的代码实现。</p>
<p data-nodeid="84508">因为<code data-backticks="1" data-nodeid="84904">UserProfileListItemViewModel</code>的责任是把 Model 类型的数据转换成 UI 呈现所需的 ViewModel 类型，那么作为其测试类型，<code data-backticks="1" data-nodeid="84906">UserProfileListItemViewModelTests</code>的工作就是验证这些数据转换的逻辑是否正确。我们一起看看<code data-backticks="1" data-nodeid="84908">UserProfileListItemViewModelTests</code>的实现代码，首先是成功的测试案例，如下所示：</p>
<pre class="lang-swift" data-nodeid="84509"><code data-language="swift">context(<span class="hljs-string">"init(userDetails:)"</span>) {
    context(<span class="hljs-string">"when all data provided"</span>) {
        beforeEach {
            testSubject = <span class="hljs-type">UserProfileListItemViewModel</span>(userDetails: <span class="hljs-type">TestFixture</span>.userDetails)
        }
        it(<span class="hljs-string">"should initialize the properties correctly"</span>) {
            expect(testSubject.name).to(<span class="hljs-built_in">equal</span>(<span class="hljs-string">"Jake Lin"</span>))
            expect(testSubject.avatarURL).to(<span class="hljs-built_in">equal</span>(<span class="hljs-type">URL</span>(string: <span class="hljs-string">"https://avatars-url.com"</span>)))
            expect(testSubject.backgroundImageURL).to(<span class="hljs-built_in">equal</span>(<span class="hljs-type">URL</span>(string: <span class="hljs-string">"https://background-image-url.com"</span>)))
        }
    }
}
</code></pre>
<p data-nodeid="84510">因为所有的转换逻辑都封装在<code data-backticks="1" data-nodeid="84911">UserProfileListItemViewModel</code>的<code data-backticks="1" data-nodeid="84913">init(userDetails:)</code>方法里面，所以我们可以通过测试该<code data-backticks="1" data-nodeid="84915">init()</code>方法来验证数据转换的逻辑。上面的例子中，我们把预先准备好的 Model 数据<code data-backticks="1" data-nodeid="84917">TestFixture.userDetails</code>传递给<code data-backticks="1" data-nodeid="84919">UserProfileListItemViewModel</code>来初始化<code data-backticks="1" data-nodeid="84921">testSubject</code>，然后在<code data-backticks="1" data-nodeid="84923">it("should initialize the properties correctly")</code>方法里检验各个属性的转换结果，例如<code data-backticks="1" data-nodeid="84925">name</code>等于 “Jake Lin”，而<code data-backticks="1" data-nodeid="84927">avatarURL</code>和<code data-backticks="1" data-nodeid="84929">backgroundImageURL</code>都正确地从字符串转换成 URL 类型。</p>
<p data-nodeid="84511">下面是转换错误时的情况，代码如下：</p>
<pre class="lang-swift" data-nodeid="84512"><code data-language="swift">context(<span class="hljs-string">"when \`userDetails.avatar\` is not a valid URL"</span>) {
    beforeEach {
        testSubject = <span class="hljs-type">UserProfileListItemViewModel</span>(userDetails: <span class="hljs-type">MomentsDetails</span>.<span class="hljs-type">UserDetails</span>(id: <span class="hljs-string">"1"</span>, name: <span class="hljs-string">"name"</span>, avatar: <span class="hljs-string">"this is not a valid URL"</span>, backgroundImage: <span class="hljs-string">"https://background-image-url.com"</span>))
    }
    it(<span class="hljs-string">"\`avatarURL\` should be nil"</span>) {
        expect(testSubject.avatarURL).to(beNil())
    }
}
</code></pre>
<p data-nodeid="84513">当我们把无效的 URL 字符串传递给<code data-backticks="1" data-nodeid="84933">avatar</code>属性时，转换后的<code data-backticks="1" data-nodeid="84935">testSubject.avatarURL</code>就会变成<code data-backticks="1" data-nodeid="84937">nil</code>。</p>
<p data-nodeid="84514">其他转换错误的案例与上面的例子类似，你可以在拉勾教育的代码仓库里进行查看。</p>
<p data-nodeid="84515">到此为止，我们已经讲完如何为 MVVM 架构开发单元测试了。</p>
<h3 data-nodeid="84516">总结</h3>
<p data-nodeid="84517">在这一讲，我们以朋友圈功能作为例子，讲述如何通过 AAA 方法一步步地为网络层、Repository 层和 ViewModel 层编写单元测试。<strong data-nodeid="84947">通过 TDD 方式所开发的代码会迫使我们定义良好的接口，并使用依赖注入的方式来管理所有依赖项，因此，通过 TDD 方法所开发的模块都具备强内聚、弱耦合、可扩展等特性</strong>。同时，单元测试能帮助我们便捷地模拟不同的测试案例，从而提高代码的质量，减少 Bug 和 App 的崩溃率。希望你在工作中也可以推动 TDD，根据我的经验，编写单元测试所花费的时间远比以后修改 Bug 所需时间要少很多。</p>
<p data-nodeid="84518">现在，“架构与实现”模块我们已经讲述完毕了。在这个模块中，我们讲述了如何使用 BFF 设计跨平台的系统架构，然后分析了如何使用 RxSwift 来设计一套根据数据流自动更新的 MVVM 框架，并详细介绍了 MVVM 每一层的具体实现。</p>
<p data-nodeid="84519">在结束这一模块前，我还想再分享一下我个人对 App 架构与实现的理解，希望对你有所帮助。</p>
<p data-nodeid="84520">苹果公司所提供的 MVC 模式并没有很好地解决 App 架构的问题，iOS 开发社区在探索的过程中形成了多种架构，例如，使用 MVC 加上 Coordinator 的 MVCC 模式，还有 MVP、VIPER 以及文章中讲述的 MVVM 架构等。尽管它们的架构与实现可能不一样，但是它们的目的都是解决臃肿的 MVC 问题。除此之外，它们在设计过程中都遵循一些通用的原则，例如单一责任原则（每一个组件只完成单独的一个功能）和开闭原则（通过抽象的协议来封闭具体的实现，但同时开放对类型的扩展），等等。</p>
<p data-nodeid="84521">基于这些通用的设计原则，并结合多年的经验与教训，<strong data-nodeid="84960">我为 Moments App 重新架构和实现了一套基于 RxSwift 的 MVVM 架构</strong>。通过这一模块的学习，想必你已经见识到这套框架的威力了，但并不代表这就是默认的或者标准的 MVVM 实现方式，甚至可以说在软件架构领域根本就没有什么一成不变的标准方案，<strong data-nodeid="84961">一套好的方案应该可以根据需求的变化而不断地迭代与改进</strong>。</p>
<p data-nodeid="84522">当你想使用这套框架的时候，可以结合自己的项目，遵循通用的设计原则来慢慢改进，例如，把所有的网络层逻辑都封装到一个独立的模块中，其他模块必须通过网络层模块来访问网络，或者把所有数据访问都放到 Repository 模块中，UI 需要访问数据时都通过 Repository 来存取。又例如，当一个模块需要依赖于其他模块时，都在初始化方法中进行依赖注入，这样能方便我们以后替换具体实现，提高架构的可扩展性。</p>
<p data-nodeid="88292" class="te-preview-highlight">还有一点我想强调一下，写代码是一门手艺活。这个模块的代码实现比较多，我建议你从 GitHub 上把代码下载下来，并对照文章的内容一同学习，然后通过实现新功能来加深理解。<strong data-nodeid="88298">任何架构能力都是建立在代码能力之上的，要提高架构能力首先需要不断提高编写高质量代码的能力。</strong> 编写高质量代码通常需要灵活运用各种软件设计的原则，当能熟练使用这些原则时，架构 App 也就变成水到渠成的事情了。</p>

<p data-nodeid="84524"><strong data-nodeid="84971">思考题</strong></p>
<blockquote data-nodeid="84525">
<p data-nodeid="84526">这是架构与实现模块的最后一篇，我建议你在朋友圈时间轴页面里添加分享文章的功能，并编写相关的单元测试。通过这个功能的开发，能让你从头到尾理解整个 MVVM 框架的核心思想。</p>
</blockquote>
<p data-nodeid="84527">如果你完成该功能，请提交一个 PR 哦。如果你有什么想法，也可以写到留言区。下一讲我们会讲述“如何统一管理 Certificates 和 Profiles”，这就进入下一个模块——上架与优化。</p>
<p data-nodeid="84528"><strong data-nodeid="84977">源码地址</strong></p>
<blockquote data-nodeid="84529">
<p data-nodeid="84530">单元测试的源码地址：<br>
<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/MomentsTests?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="84982">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/MomentsTests</a></p>
</blockquote></div>

</body></html>