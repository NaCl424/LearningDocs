<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>26 | 经典的 N+1 SQL 问题如何正确解决？（下）</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>26 | 经典的 N+1 SQL 问题如何正确解决？（下）</h1><p data-nodeid="9740" class="">你好，上一讲我们介绍了什么是 N+1 的 SQL 问题，以及减少 N 对应 SQL 条数的机制有哪些，相信你对此已经有了大概的了解。那么这一讲我们接着说这个经典的 SQL 问题，看看还有没有其他的解决方式。</p>
<h3 data-nodeid="9741">Hibernate 中 @Fetch 数据的策略</h3>
<p data-nodeid="9742">Hibernate 提供了一个 @Fetch 注解，用来改变获取数据的策略。我们来研究一下这一注解的语法，代码如下所示。</p>
<pre class="lang-java" data-nodeid="9743"><code data-language="java"><span class="hljs-comment">// fetch注解只能用在方法和字段上面</span>
<span class="hljs-meta">@Target({ElementType.METHOD, ElementType.FIELD})</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Fetch {
   <span class="hljs-comment">//注解里面，只有一个属性获取数据的模式</span>
   <span class="hljs-function">FetchMode <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;
}
<span class="hljs-comment">//其中FetchMode的值有如下几种：</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FetchMode {
   <span class="hljs-comment">//默认模式，就是会有N+1 sql的问题；</span>
   SELECT,
   <span class="hljs-comment">//通过join的模式，用一个sql把主体数据和关联关系数据一口气查出来</span>
   JOIN,
   <span class="hljs-comment">//通过子查询的模式，查询关联关系的数据</span>
   SUBSELECT
}
</code></pre>
<p data-nodeid="9744">需要注意的是，不要把这个注解和 JPA 协议里面的 FetchType.EAGER、FetchType.LAZY 搞混了，JPA 协议的关联关系中的 FetchTyp 解决的是取关联关系数据时机的问题，也就是说 EAGER 代表的是立即获得关联关系的数据，LAZY 是需要的时候再获得关联关系的数据。</p>
<p data-nodeid="9745">这和 Hibernate 的 FetchMode 是两回事，FetchMode 解决的是获得数据策略的问题，也就是说，获得关联关系数据的策略有三种模式：SELECT（默认）、JOIN、SUBSELECT。下面我通过例子来分别介绍一下这三种模式有什么区别，分别起到什么作用。</p>
<h4 data-nodeid="9746">FetchMode.SELECT</h4>
<p data-nodeid="9747">我们直接更改一下 UserInfo 实体，将 @Fetch(value = FetchMode.SELECT) 作为获取数据的策略，使用 FetchType.EAGER 作为获取数据的时机，代码如下所示。</p>
<pre class="lang-java" data-nodeid="9748"><code data-language="java"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@SuperBuilder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@Table</span>
<span class="hljs-meta">@ToString(exclude = "addressList")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEntity</span> </span>{
   <span class="hljs-keyword">private</span> String name;
   <span class="hljs-keyword">private</span> String telephone;
   <span class="hljs-meta">@OneToMany(mappedBy = "userInfo",cascade = CascadeType.PERSIST,fetch = FetchType.EAGER)</span>
   <span class="hljs-meta">@Fetch(value = FetchMode.SELECT)</span>
   <span class="hljs-keyword">private</span> List&lt;Address&gt; addressList;
}
</code></pre>
<p data-nodeid="9749">然后还是执行 userInfoRepository.findAll(); 这个方法，看一下打印的 SQL 有哪些。</p>
<pre class="lang-sql" data-nodeid="9750"><code data-language="sql">org.hibernate.SQL                        :
<span class="hljs-keyword">select</span> userinfo0_.id                    <span class="hljs-keyword">as</span> id1_1_,
       userinfo0_.create_time           <span class="hljs-keyword">as</span> create_t2_1_,
       userinfo0_.create_user_id        <span class="hljs-keyword">as</span> create_u3_1_,
       userinfo0_.last_modified_time    <span class="hljs-keyword">as</span> last_mod4_1_,
       userinfo0_.last_modified_user_id <span class="hljs-keyword">as</span> last_mod5_1_,
       userinfo0_.version               <span class="hljs-keyword">as</span> version6_1_,
       userinfo0_.ages                  <span class="hljs-keyword">as</span> ages7_1_,
       userinfo0_.email_address         <span class="hljs-keyword">as</span> email_ad8_1_,
       userinfo0_.last_name             <span class="hljs-keyword">as</span> last_nam9_1_,
       userinfo0_.name                  <span class="hljs-keyword">as</span> name10_1_,
       userinfo0_.telephone             <span class="hljs-keyword">as</span> telepho11_1_
<span class="hljs-keyword">from</span> user_info userinfo0_ 
org.hibernate.SQL                        :
<span class="hljs-keyword">select</span> addresslis0_.user_info_id          <span class="hljs-keyword">as</span> user_inf8_0_0_,
       addresslis0_.id                    <span class="hljs-keyword">as</span> id1_0_0_,
       addresslis0_.id                    <span class="hljs-keyword">as</span> id1_0_1_,
       addresslis0_.create_time           <span class="hljs-keyword">as</span> create_t2_0_1_,
       addresslis0_.create_user_id        <span class="hljs-keyword">as</span> create_u3_0_1_,
       addresslis0_.last_modified_time    <span class="hljs-keyword">as</span> last_mod4_0_1_,
       addresslis0_.last_modified_user_id <span class="hljs-keyword">as</span> last_mod5_0_1_,
       addresslis0_.version               <span class="hljs-keyword">as</span> version6_0_1_,
       addresslis0_.city                  <span class="hljs-keyword">as</span> city7_0_1_,
       addresslis0_.user_info_id          <span class="hljs-keyword">as</span> user_inf8_0_1_
<span class="hljs-keyword">from</span> address addresslis0_
<span class="hljs-keyword">where</span> addresslis0_.user_info_id = ? 
org.hibernate.SQL                        :
<span class="hljs-keyword">select</span> addresslis0_.user_info_id          <span class="hljs-keyword">as</span> user_inf8_0_0_,
       addresslis0_.id                    <span class="hljs-keyword">as</span> id1_0_0_,
       addresslis0_.id                    <span class="hljs-keyword">as</span> id1_0_1_,
       addresslis0_.create_time           <span class="hljs-keyword">as</span> create_t2_0_1_,
       addresslis0_.create_user_id        <span class="hljs-keyword">as</span> create_u3_0_1_,
       addresslis0_.last_modified_time    <span class="hljs-keyword">as</span> last_mod4_0_1_,
       addresslis0_.last_modified_user_id <span class="hljs-keyword">as</span> last_mod5_0_1_,
       addresslis0_.version               <span class="hljs-keyword">as</span> version6_0_1_,
       addresslis0_.city                  <span class="hljs-keyword">as</span> city7_0_1_,
       addresslis0_.user_info_id          <span class="hljs-keyword">as</span> user_inf8_0_1_
<span class="hljs-keyword">from</span> address addresslis0_
<span class="hljs-keyword">where</span> addresslis0_.user_info_id = ? 
org.hibernate.SQL                        :
<span class="hljs-keyword">select</span> addresslis0_.user_info_id          <span class="hljs-keyword">as</span> user_inf8_0_0_,
       addresslis0_.id                    <span class="hljs-keyword">as</span> id1_0_0_,
       addresslis0_.id                    <span class="hljs-keyword">as</span> id1_0_1_,
       addresslis0_.create_time           <span class="hljs-keyword">as</span> create_t2_0_1_,
       addresslis0_.create_user_id        <span class="hljs-keyword">as</span> create_u3_0_1_,
       addresslis0_.last_modified_time    <span class="hljs-keyword">as</span> last_mod4_0_1_,
       addresslis0_.last_modified_user_id <span class="hljs-keyword">as</span> last_mod5_0_1_,
       addresslis0_.version               <span class="hljs-keyword">as</span> version6_0_1_,
       addresslis0_.city                  <span class="hljs-keyword">as</span> city7_0_1_,
       addresslis0_.user_info_id          <span class="hljs-keyword">as</span> user_inf8_0_1_
<span class="hljs-keyword">from</span> address addresslis0_
<span class="hljs-keyword">where</span> addresslis0_.user_info_id = ?
</code></pre>
<p data-nodeid="9751">从上述 SQL 中可以看出，这依然是 N+1 的 SQL 问题，FetchMode.Select 是默认策略，加与不加是同样的效果，代表获取关系的时候新开一个 SQL 进行查询。</p>
<h4 data-nodeid="9752">FetchMode.JOIN</h4>
<p data-nodeid="9753">FetchMode.JOIN 的意思是主表信息和关联关系通过一个 SQL JOIN 的方式查出来，我们看一下例子。</p>
<p data-nodeid="9754">首先，将 UserInfo 里面的 FetchMode 改成 JOIN 模式，关键代码如下。</p>
<pre class="lang-java" data-nodeid="9755"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEntity</span> </span>{
   <span class="hljs-keyword">private</span> String name;
   <span class="hljs-keyword">private</span> String telephone;
   <span class="hljs-meta">@OneToMany(mappedBy = "userInfo",cascade = CascadeType.PERSIST,fetch = FetchType.EAGER)</span>
   <span class="hljs-meta">@Fetch(value = FetchMode.JOIN)</span> <span class="hljs-comment">//唯一变化的地方采用JOIN模式</span>
   <span class="hljs-keyword">private</span> List&lt;Address&gt; addressList;
}
</code></pre>
<p data-nodeid="9756">然后，调用一下 userInfoRepository.findAll(); 这个方法，发现依然是这三条 SQL，如下图所示。</p>
<p data-nodeid="10863" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/80/74/CgqCHl_Qr5uACOYLAAEMvYccGw4336.png" alt="Lark20201209-190554.png" data-nodeid="10866"></p>



<p data-nodeid="9758">这是因为 FetchMode.JOIN 只支持通过 ID 或者联合唯一键获取数据才有效，这正是 JOIN 策略模式的局限性所在。</p>
<p data-nodeid="9759">那么我们再调用一下 userInfoRepository.findById(id)，看看控制台的 SQL 执行情况，代码如下。</p>
<pre class="lang-java" data-nodeid="9760"><code data-language="java">select userinfo0_.id                      as id1_1_0_,
       userinfo0_.create_time             as create_t2_1_0_,
       userinfo0_.create_user_id          as create_u3_1_0_,
       userinfo0_.last_modified_time      as last_mod4_1_0_,
       userinfo0_.last_modified_user_id   as last_mod5_1_0_,
       userinfo0_.version                 as version6_1_0_,
       userinfo0_.ages                    as ages7_1_0_,
       userinfo0_.email_address           as email_ad8_1_0_,
       userinfo0_.last_name               as last_nam9_1_0_,
       userinfo0_.name                    as name10_1_0_,
       userinfo0_.telephone               as telepho11_1_0_,
       addresslis1_.user_info_id          as user_inf8_0_1_,
       addresslis1_.id                    as id1_0_1_,
       addresslis1_.id                    as id1_0_2_,
       addresslis1_.create_time           as create_t2_0_2_,
       addresslis1_.create_user_id        as create_u3_0_2_,
       addresslis1_.last_modified_time    as last_mod4_0_2_,
       addresslis1_.last_modified_user_id as last_mod5_0_2_,
       addresslis1_.version               as version6_0_2_,
       addresslis1_.city                  as city7_0_2_,
       addresslis1_.user_info_id          as user_inf8_0_2_
from user_info userinfo0_
         left outer join address addresslis1_ on userinfo0_.id = addresslis1_.user_info_id
where userinfo0_.id = ?
</code></pre>
<p data-nodeid="9761">这时我们会发现，当查询 UserInfo 的时候，它会通过 left outer join 把 Address 的信息也查询出来，虽然 SQL 上会有冗余信息，但是你会发现我们之前的 N+1 的 SQL 直接变成 1 条 SQL 了。</p>
<p data-nodeid="9762">此时我们修改 UserInfo 里面的 @OneToMany，这个 @Fetch(value = FetchMode.JOIN) 同样适用于 @ManyToOne；然后再改一下 Address 实例，用 @Fetch(value = FetchMode.JOIN) 把 Adress 里面的 UserInfo 关联关系改成 JOIN 模式；接着我们用 LAZY 获取数据的时机，会发现其对获取数据的策略没有任何影响。</p>
<p data-nodeid="9763">这里我只是给你演示获取数据时机的不同情况，关键代码如下。</p>
<pre class="lang-java" data-nodeid="9764"><code data-language="java"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@SuperBuilder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@ToString(exclude = "userInfo")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEntity</span> </span>{
   <span class="hljs-keyword">private</span> String city;
   <span class="hljs-meta">@ManyToOne(cascade = CascadeType.PERSIST,fetch = FetchType.LAZY)</span>
   <span class="hljs-meta">@JsonBackReference</span>
   <span class="hljs-meta">@Fetch(value = FetchMode.JOIN)</span>
   <span class="hljs-keyword">private</span> UserInfo userInfo;
}
</code></pre>
<p data-nodeid="9765">同样的道理，JOIN 对列表性的查询是没有效果的，我们调用一下 addressRepository.findById(id)，产生的 SQL 如下所示。</p>
<pre class="lang-sql" data-nodeid="9766"><code data-language="sql">org.hibernate.SQL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : 
<span class="hljs-keyword">select</span> address0_.id                     <span class="hljs-keyword">as</span> id1_0_0_,
       address0_.create_time            <span class="hljs-keyword">as</span> create_t2_0_0_,
       address0_.create_user_id         <span class="hljs-keyword">as</span> create_u3_0_0_,
       address0_.last_modified_time     <span class="hljs-keyword">as</span> last_mod4_0_0_,
       address0_.last_modified_user_id  <span class="hljs-keyword">as</span> last_mod5_0_0_,
       address0_.version                <span class="hljs-keyword">as</span> version6_0_0_,
       address0_.city                   <span class="hljs-keyword">as</span> city7_0_0_,
       address0_.user_info_id           <span class="hljs-keyword">as</span> user_inf8_0_0_,
       userinfo1_.id                    <span class="hljs-keyword">as</span> id1_1_1_,
       userinfo1_.create_time           <span class="hljs-keyword">as</span> create_t2_1_1_,
       userinfo1_.create_user_id        <span class="hljs-keyword">as</span> create_u3_1_1_,
       userinfo1_.last_modified_time    <span class="hljs-keyword">as</span> last_mod4_1_1_,
       userinfo1_.last_modified_user_id <span class="hljs-keyword">as</span> last_mod5_1_1_,
       userinfo1_.version               <span class="hljs-keyword">as</span> version6_1_1_,
       userinfo1_.ages                  <span class="hljs-keyword">as</span> ages7_1_1_,
       userinfo1_.email_address         <span class="hljs-keyword">as</span> email_ad8_1_1_,
       userinfo1_.last_name             <span class="hljs-keyword">as</span> last_nam9_1_1_,
       userinfo1_.name                  <span class="hljs-keyword">as</span> name10_1_1_,
       userinfo1_.telephone             <span class="hljs-keyword">as</span> telepho11_1_1_
<span class="hljs-keyword">from</span> address address0_
         <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> user_info userinfo1_ <span class="hljs-keyword">on</span> address0_.user_info_id = userinfo1_.id
<span class="hljs-keyword">where</span> address0_.id = ?
</code></pre>
<p data-nodeid="9767">我们发现此时只会产生一个 SQL，即通过 from address left outer join user_info 一次性把所有信息都查出来，然后 Hibernate 再根据查询出来的结果组合到不同的实体里面。</p>
<p data-nodeid="9768">也就是说 FetchMode.JOIN 对于关联关系的查询 LAZY 是不起作用的，因为 JOIN 的模式是通过一条 SQL 查出来所有信息，所以 FetchMode.JOIN 会忽略 FetchType。</p>
<p data-nodeid="9769">那么我们再来看第三种模式。</p>
<h4 data-nodeid="9770">FetchMode.SUBSELECT</h4>
<p data-nodeid="9771">这种模式很简单，就是将关联关系通过子查询的形式查询出来，我们还是结合例子来理解一下。</p>
<p data-nodeid="9772">首先，将 UserInfo 里面的关联关系改成 @Fetch(value = FetchMode.SUBSELECT)，关键代码如下。</p>
<pre class="lang-java" data-nodeid="9773"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEntity</span> </span>{
   <span class="hljs-meta">@OneToMany(mappedBy = "userInfo",cascade = CascadeType.PERSIST,fetch = FetchType.LAZY)</span> <span class="hljs-comment">//我们这里测试一下LAZY情况</span>
   <span class="hljs-meta">@Fetch(value = FetchMode.SUBSELECT)</span> <span class="hljs-comment">//唯一变化之处</span>
   <span class="hljs-keyword">private</span> List&lt;Address&gt; addressList;
}
</code></pre>
<p data-nodeid="9774">接着，像上面的做法一样，执行一下 userInfoRepository.findAll()；方法，看一下控制台的 SQL 情况，如下所示。</p>
<pre class="lang-java" data-nodeid="9775"><code data-language="java">org.hibernate.SQL                        :
select userinfo0_.id                    as id1_1_,
       userinfo0_.create_time           as create_t2_1_,
       userinfo0_.create_user_id        as create_u3_1_,
       userinfo0_.last_modified_time    as last_mod4_1_,
       userinfo0_.last_modified_user_id as last_mod5_1_,
       userinfo0_.version               as version6_1_,
       userinfo0_.ages                  as ages7_1_,
       userinfo0_.email_address         as email_ad8_1_,
       userinfo0_.last_name             as last_nam9_1_,
       userinfo0_.name                  as name10_1_,
       userinfo0_.telephone             as telepho11_1_
from user_info userinfo0_ 
org.hibernate.SQL                        :
select addresslis0_.user_info_id          as user_inf8_0_1_,
       addresslis0_.id                    as id1_0_1_,
       addresslis0_.id                    as id1_0_0_,
       addresslis0_.create_time           as create_t2_0_0_,
       addresslis0_.create_user_id        as create_u3_0_0_,
       addresslis0_.last_modified_time    as last_mod4_0_0_,
       addresslis0_.last_modified_user_id as last_mod5_0_0_,
       addresslis0_.version               as version6_0_0_,
       addresslis0_.city                  as city7_0_0_,
       addresslis0_.user_info_id          as user_inf8_0_0_
from address addresslis0_
where addresslis0_.<span class="hljs-function">user_info_id <span class="hljs-title">in</span> <span class="hljs-params">(select userinfo0_.id from user_info userinfo0_)</span>
</span></code></pre>
<p data-nodeid="9776">这个时候会发现，查询 Address 信息是直接通过 addresslis0_.user_info_id in (select userinfo0_.id from user_info userinfo0_) 子查询的方式进行的，也就是说 N+1 SQL 变成了 1+1 的 SQL，这有点类似我们配置 @BatchSize 的效果。</p>
<p data-nodeid="9777">FetchMode.SUBSELECT 支持 ID 查询和各种条件查询，唯一的缺点是只能配置在 @OneToMany 和 @ManyToMany 的关联关系上，不能配置在 @ManyToOne 和 @OneToOne 的关联关系上，所以我们在 Address 里面关联 UserInfo 的时候就没有办法做实验了。</p>
<p data-nodeid="9778">总之，@Fetch 的不同模型，都有各自的优缺点：FetchMode.SELECT 默认，和不配置的效果一样；FetchMode.JOIN 只支持类似 findById(id) 的方法，只能根据 ID 查询才有效果；FetchMode.SUBSELECT 虽然不限使用方式，但是只支持 **ToMany 的关联关系。</p>
<p data-nodeid="9779">所以你在使用 @Fetch 的时候需要注意一下它的局限性，我个人是比较推荐 @BatchSize 的方式。</p>
<p data-nodeid="9780">那么除了上面的处理方式，我们也可以采用之前写 Mybatis 的思路来查询关联关系，下面来看一下该如何转变思路。</p>
<h3 data-nodeid="9781">转化解决问题的思路</h3>
<p data-nodeid="9782">这时需要我们在思想上进行转变，利用 JPA 的优势，摒弃它的缺陷。想想我们没有用 JPA 的时候是怎么做的？难道一定要用实体之间的关联关系吗？如果用的是 Mybatis，你在给前端返回关联关系数据的时候一般怎么写呢？</p>
<p data-nodeid="9783">答案肯定是写成 1+1 SQL 的形式，也就是一条主 SQL、一条查关联关系的 SQL。我们还用 UserInfo 和 Address 实体来演示，代码如下。</p>
<pre class="lang-java" data-nodeid="9784"><code data-language="java"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@SuperBuilder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@Table</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEntity</span> </span>{
   <span class="hljs-keyword">private</span> String name;
   <span class="hljs-keyword">private</span> String telephone;
   <span class="hljs-meta">@Transient</span> <span class="hljs-comment">//在UserInfo实体中，我们不利用JPA来关联实体的关联关系了，而是把它设置成@Transisent，只维护java对象的关系，不维护DB之间的关联关系</span>
   <span class="hljs-keyword">private</span> List&lt;Address&gt; addressList;
}
<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@SuperBuilder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@ToString(exclude = "userInfo")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEntity</span> </span>{
   <span class="hljs-keyword">private</span> String city;
   <span class="hljs-keyword">private</span> String userId;
   <span class="hljs-meta">@Transient</span> <span class="hljs-comment">//同样Address里面也可以不维护UserInfo的关联关系</span>
   <span class="hljs-keyword">private</span> UserInfo userInfo;
}
</code></pre>
<p data-nodeid="9785">当我们查询所有 UserInfo 信息的时候，又想把每个 UserInfo 的 Address 信息都带上，应该怎么做呢？请看如下代码。</p>
<pre class="lang-java" data-nodeid="9786"><code data-language="java"><span class="hljs-comment">/**
 * 自己实现一套 Batch fetch的逻辑
 */</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserInfo&gt; <span class="hljs-title">getAllUserWithAddress</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-comment">//先查出来所有的UserInfo信息</span>
   List&lt;UserInfo&gt; userInfos = userInfoRepository.findAll();
   <span class="hljs-comment">//再查出来上面userInfos里面的所有userId列表，再查询出来上面的查询结果所对应的所有Address信息</span>
   List&lt;Address&gt; addresses = addressRepository.findByUserIdIn(userInfos.stream().map(userInfo -&gt; userInfo.getId()).collect(Collectors.toList()));
   <span class="hljs-comment">//我们自己再写一个转化逻辑，把各自user info的address信息放置到响应的UserInfo实例里面；</span>
   Map&lt;Long,List&lt;Address&gt;&gt; addressMaps = addresses
         .stream()
         .collect(Collectors.groupingBy(Address::getUserId));<span class="hljs-comment">//里面Map结构方便获取</span>
   <span class="hljs-keyword">return</span> userInfos.stream().map(userInfo -&gt; {
       userInfo.setAddressList(addressMaps.get(userInfo.getId()));
       <span class="hljs-keyword">return</span> userInfo;
   }).collect(Collectors.toList());
}
</code></pre>
<p data-nodeid="9787">你会发现，这要比原来的方式稍微复杂一点，但是如果我们做框架的话，上面有些逻辑可以抽到一个 Util 类里面去。</p>
<p data-nodeid="9788">不过需要注意的是，实际工作中我们肯定不是 findAll()，而是会根据一些业务逻辑查询一个 UserInfo 的 List 信息，然后再根据查询出来的 userInfo 的 ID 列表去二次查询 Address 信息，这样最多只需要 2 个 SQL 就可完成实际业务逻辑。</p>
<p data-nodeid="9789">那么反向思考，我们通过 Address 对象查询 UserInfo 也是一样的道理，可以先查询出 List<code data-backticks="1" data-nodeid="9893">&lt;Address&gt;</code>，再查询出 List<code data-backticks="1" data-nodeid="9895">&lt;Address&gt;</code>里面包含的所有 UserInfoId 列表，然后再去查询 UserInfo 信息，通过 Map 组装到 Address 里面。</p>
<p data-nodeid="9790">Tips：实体里面如果关联关系有非常多的请求，想维护关联关系是一件非常难的事情。我们可以利用 Mybatis 的思想、JPA 的快捷查询语法，来组装想要的任何关联关系的对象。这样的代码虽然比起原生的 JPA 语法较复杂，但是比起 Mybatis 还是要简单很多，理解起来也更容易，问题反倒会更少一点。</p>
<p data-nodeid="9791">上面我们介绍完了 Hibernate 中的做法，其实 JPA 协议也提供了另外一种解题思路：利用 @EntityGraph 注解来解决，我们详细看一下。</p>
<h3 data-nodeid="9792">@EntityGraph 使用详解</h3>
<p data-nodeid="9793">众所周知，实体与实体之间的关联关系错综复杂，就像一个大网图一样，网状分布交叉引用。而 JPA 协议在 2.1 版本之后企图用 Entity Graph 的方式，描绘出一个实体与实体之间的关联关系。</p>
<p data-nodeid="9794">普通做法为，通过 @ManyToOne/@OneToMany/@ManyToMany/@OneToOne 这些关联关系注解表示它们之间的关系时，只能配置 EAGER 或者 LAZY，没办法根据不同的配置、不同的关联关系加载时机。</p>
<p data-nodeid="9795">而 JPA 协议企图通过 @NamedEntityGraph 注解来描述实体之间的关联关系，当被 @EntityGraph 使用的时候进行 EAGER 加载，以减少 N+1 的 SQL，我们来看一下具体用法。</p>
<h4 data-nodeid="9796">@NamedEntityGraph 和 @EntityGraph 用法</h4>
<p data-nodeid="9797">还是直接通过一个例子来说明，请看下面的代码。</p>
<pre class="lang-java" data-nodeid="9798"><code data-language="java"><span class="hljs-comment">//可以被@NamedEntityGraphs注解重复使用，只能配置在类上面，用来声明不同的EntityGraph；</span>
<span class="hljs-meta">@Repeatable(NamedEntityGraphs.class)</span>
<span class="hljs-meta">@Target({TYPE})</span>
<span class="hljs-meta">@Retention(RUNTIME)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NamedEntityGraph {
    <span class="hljs-comment">//指定一个名字</span>
    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
    <span class="hljs-comment">//哪些关联关系属性可以被EntityGraph包含进去，默认一个没有。可以配置多个</span>
    NamedAttributeNode[] attributeNodes() <span class="hljs-keyword">default</span> {};

    <span class="hljs-comment">//是否所有的关联关系属性自动包含在内，默认false;</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">includeAllAttributes</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;

    <span class="hljs-comment">//配置subgraphs，子实体图(可以理解为关联关系实体图，即如果算层级，可以配置第二层级)，可以被NamedAttributeNode引用</span>
    NamedSubgraph[] subgraphs() <span class="hljs-keyword">default</span> {};
    <span class="hljs-comment">//配置subclassSubgraphs的namedSubgraph有哪些。即如果算层级，可以配置第三层级</span>
    NamedSubgraph[] subclassSubgraphs() <span class="hljs-keyword">default</span> {};
}
</code></pre>
<p data-nodeid="9799">上述代码中，可以看到 @NamedEntityGraphs 能够配置多个 @NamedEntityGraph。我们接着往下看。</p>
<pre class="lang-java" data-nodeid="9800"><code data-language="java"><span class="hljs-comment">//只能使用在实体类上面</span>
<span class="hljs-meta">@Target({TYPE})</span>
<span class="hljs-meta">@Retention(RUNTIME)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NamedEntityGraphs{
    NamedEntityGraph[] value();<span class="hljs-comment">//可以同时指定多个NamedEntityGraph</span>
}
</code></pre>
<p data-nodeid="9801">上面这段代码中，NamedSubgraph 用来指定关联关系的策略，也就关联关系有两层。</p>
<p data-nodeid="9802">我们再看一下 @NamedEntityGraph 里面的 NamedAttributeNode 属性有哪些值，代码如下。</p>
<pre class="lang-java" data-nodeid="9803"><code data-language="java"><span class="hljs-comment">// 用来进行属性节点的描述</span>
<span class="hljs-meta">@Target({})</span>
<span class="hljs-meta">@Retention(RUNTIME)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NamedAttributeNode {
    <span class="hljs-comment">//要包含的关联关系的属性的名字，必填</span>
    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">//如果我们在@NamedEntityGraph里面配置了子关联关系，这个是配置subgraph的名字</span>
    <span class="hljs-function">String <span class="hljs-title">subgraph</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
   <span class="hljs-comment">//当关联关系是被Map结构引用的时候，我们可以指定key的方式，一般很少用</span>
    <span class="hljs-function">String <span class="hljs-title">keySubgraph</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
}
</code></pre>
<p data-nodeid="9804">上面就是对 @NamedAttributeNode 的介绍，我们再看一下 @EntityGraph 里面的 @NamedSubgraph 的结构，代码如下。</p>
<pre class="lang-java" data-nodeid="9805"><code data-language="java"><span class="hljs-meta">@Target({})</span>
<span class="hljs-meta">@Retention(RUNTIME)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NamedSubgraph {
    <span class="hljs-comment">//指定一个名字</span>
    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">//子关联关系的类的class</span>
    <span class="hljs-function">Class <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span>.class</span>;
    <span class="hljs-comment">//二层关联关系的要包含的关联关系的属性的名字</span>
    NamedAttributeNode[] attributeNodes();
}
</code></pre>
<p data-nodeid="9806">其中，@NamedEntityGraph 的注解都是配置在实体本身上面的，而 @EntityGraph 是用在 ***Repository 接口里的方法中的。</p>
<p data-nodeid="9807">接着我们再来了解一下 @EntityGraph 注解的语法，如下所示。</p>
<pre class="lang-java" data-nodeid="9808"><code data-language="java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE })</span>
<span class="hljs-comment">//EntityGraph 作用在Repository的接口里面的方法上面</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EntityGraph {
   <span class="hljs-comment">//指@EntityGraph注解引用的@NamedEntityGraph里面定义的name，如果是空EntityGraph就不会起作用，如果为空相当于没有配置；</span>
   <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
   <span class="hljs-comment">//EntityGraph的类型，默认是EntityGraphType.FETCH类型，我们接着往下看EntityGraphType一共有几个值</span>
   <span class="hljs-function">EntityGraphType <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> EntityGraphType.FETCH</span>;
    <span class="hljs-comment">//可以指定attributePaths用来覆盖@NamedEntityGraph里面的attributeNodes的配置，默认配置是空，以@NamedEntityGraph里面的为准；</span>
   String[] attributePaths() <span class="hljs-keyword">default</span> {};
   <span class="hljs-comment">//JPA 2.1支持的EntityGraphType对应的枚举值</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> EntityGraphType {
      <span class="hljs-comment">//LOAD模式，当被指定了这种模式、被@EntityGraph管理的attributes的时候，原来的FetchType的类型直接忽略变成Eager模式，而不被@EntityGraph管理的attributes还是保持默认的FetchType</span>
      LOAD(<span class="hljs-string">"javax.persistence.loadgraph"</span>),
      <span class="hljs-comment">//FETCH模式，当被指定了这种模式、被@EntityGraph管理的attributes的时候，原来的FetchType的类型直接忽略变成Eager模式，而不被@EntityGraph管理的attributes将会变成Lazy模式，和LOAD的区别就是对不被@NamedEntityGraph配置的关联关系的属性的FetchType不一样；</span>
      FETCH(<span class="hljs-string">"javax.persistence.fetchgraph"</span>);
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String key;
      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">EntityGraphType</span><span class="hljs-params">(String value)</span> </span>{
         <span class="hljs-keyword">this</span>.key = value;
      }
      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-keyword">return</span> key;
      }
   }
}
</code></pre>
<p data-nodeid="9809">现在你知道这个注解的基本用法了，下面我们通过实例来具体操作一下。</p>
<h4 data-nodeid="9810">@EntityGraph 使用实例</h4>
<p data-nodeid="9811">我们通过改造 Address 和 UserInfo 实体，来分别测试一下 @NamedEntityGraph 和 @EntityGraph 的用法。</p>
<p data-nodeid="9812"><strong data-nodeid="9922">第一步：在实体里面配置 @EntityGraph</strong>，关键代码如下。</p>
<pre class="lang-java" data-nodeid="9813"><code data-language="java"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@SuperBuilder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@ToString(exclude = "userInfo")</span>
<span class="hljs-comment">//这里我们直接使用@NamedEntityGraph，因为只需要配置一个@NamedEntityGraph，我们指定一个名字getAllUserInfo，指定被这个名字的实体试图关联的关联关系属性是userInfo</span>
<span class="hljs-meta">@NamedEntityGraph(name = "getAllUserInfo",attributeNodes = @NamedAttributeNode(value = "userInfo"))</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEntity</span> </span>{
   <span class="hljs-keyword">private</span> String city;
   <span class="hljs-meta">@JsonBackReference</span> <span class="hljs-comment">//防止JSON死循环</span>
   <span class="hljs-meta">@ManyToOne(cascade = CascadeType.PERSIST,fetch = FetchType.LAZY)</span><span class="hljs-comment">//采用默认的lazy模式</span>
   <span class="hljs-keyword">private</span> UserInfo userInfo;
}
<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@SuperBuilder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@Table</span>
<span class="hljs-meta">@ToString(exclude = "addressList")</span>
<span class="hljs-comment">//UserInfo对应的关联关系，我们利用@NamedEntityGraphs配置了两个，一个是针对Address的关联关系，一个是name叫rooms的实体图包含了rooms属性；我们在UserInfo里面增加了两个关联关系；</span>
<span class="hljs-meta">@NamedEntityGraphs(value = {@NamedEntityGraph(name = "addressGraph",attributeNodes = @NamedAttributeNode(value = "addressList")),@NamedEntityGraph(name = "rooms",attributeNodes = @NamedAttributeNode(value = "rooms"))})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEntity</span> </span>{
   <span class="hljs-keyword">private</span> String name;
   <span class="hljs-keyword">private</span> String telephone;
   <span class="hljs-keyword">private</span> Integer ages;
   <span class="hljs-comment">//默认LAZY模式</span>
   <span class="hljs-meta">@OneToMany(mappedBy = "userInfo",cascade = CascadeType.PERSIST,fetch = FetchType.LAZY)</span>
   <span class="hljs-keyword">private</span> List&lt;Address&gt; addressList;
   <span class="hljs-comment">//默认EAGER模式</span>
   <span class="hljs-meta">@OneToMany(cascade = CascadeType.PERSIST,fetch = FetchType.EAGER)</span>
   <span class="hljs-keyword">private</span> List&lt;Room&gt; rooms;
}
</code></pre>
<p data-nodeid="9814">**第二步：在我们需要的 *<strong data-nodeid="9931">Repository 的方法上面直接使用 @EntityGraph</strong>，关键代码如下。</p>
<pre class="lang-java" data-nodeid="9815"><code data-language="java"><span class="hljs-comment">//因为要用findAll()做测试，所以可以覆盖JpaRepository里面的findAll()方法，加上@EntityGraph注解</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInfoRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">UserInfo</span>, <span class="hljs-title">Long</span>&gt;</span>{
   <span class="hljs-meta">@Override</span>
   <span class="hljs-comment">//我们指定EntityGraph引用的是，在UserInfo实例里面配置的name=addressGraph的NamedEntityGraph；</span>
   <span class="hljs-comment">// 这里采用的是LOAD的类型，也就是说被addressGraph配置的实体图属性address采用的fetch会变成 FetchType.EAGER模式，而没有被addressGraph实体图配置关联关系属性room还是采用默认的EAGER模式</span>
<span class="hljs-meta">@EntityGraph(value = "addressGraph",type = EntityGraph.EntityGraphType.LOAD)</span>
   <span class="hljs-function">List&lt;UserInfo&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;
}}
</code></pre>
<p data-nodeid="9816">同样的道理，其对于 AddressRepository 也是适用的，代码如下。</p>
<pre class="lang-java" data-nodeid="9817"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AddressRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Address</span>, <span class="hljs-title">Long</span>&gt;</span>{
<span class="hljs-meta">@Override</span> <span class="hljs-comment">//可以覆盖原始方法，添加上不同的@EntityGraph策略</span>
<span class="hljs-comment">//使用@EntityGraph查询所有Address的时候，指定name = "getAllUserInfo"的@NamedEntityGraph，采用默认的EntityGraphType.FETCH，如果Address里面有多个关联关系的时候，只有在name = "getAllUserInfo"的实体图配置的userInfo属性上采用Eager模式，其他关联关系属性没有指定，默认采用LAZY模式；</span>
<span class="hljs-meta">@EntityGraph(value = "getAllUserInfo")</span>
<span class="hljs-function">List&lt;Address&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<p data-nodeid="9818"><strong data-nodeid="9937">第三步：看一下上面的两个方法执行的 SQL</strong>。</p>
<p data-nodeid="9819">当我们再次执行 userInfoRepository.findAll(); 这个方法的时候会发现，被配置 EntityGraph 的 Address 和 user_info 通过 left join 一条 SQL 就把所有的信息都查出来了，SQL 如下所示。</p>
<pre class="lang-java" data-nodeid="9820"><code data-language="java">org.hibernate.SQL                        :
select userinfo0_.id                      as id1_2_0_,
       addresslis1_.id                    as id1_0_1_,
       userinfo0_.create_time             as create_t2_2_0_,
       userinfo0_.create_user_id          as create_u3_2_0_,
       userinfo0_.last_modified_time      as last_mod4_2_0_,
       userinfo0_.last_modified_user_id   as last_mod5_2_0_,
       userinfo0_.version                 as version6_2_0_,
       userinfo0_.ages                    as ages7_2_0_,
       userinfo0_.email_address           as email_ad8_2_0_,
       userinfo0_.last_name               as last_nam9_2_0_,
       userinfo0_.name                    as name10_2_0_,
       userinfo0_.telephone               as telepho11_2_0_,
       addresslis1_.create_time           as create_t2_0_1_,
       addresslis1_.create_user_id        as create_u3_0_1_,
       addresslis1_.last_modified_time    as last_mod4_0_1_,
       addresslis1_.last_modified_user_id as last_mod5_0_1_,
       addresslis1_.version               as version6_0_1_,
       addresslis1_.city                  as city7_0_1_,
       addresslis1_.user_info_id          as user_inf8_0_1_,
       addresslis1_.user_info_id          as user_inf8_0_0__,
       addresslis1_.id                    as id1_0_0__
from user_info userinfo0_
    left outer join address addresslis1_ on userinfo0_.id = addresslis1_.user_info_id
</code></pre>
<p data-nodeid="9821">而我们没有配置 rooms 这个关联关系的属性时，rooms 的查询还是会触发 N+1 的 SQL。</p>
<p data-nodeid="9822">从中可以看到 @EntityGraph 的效果有点类似 Hibernate 里面提供的 FetchModel.JOIN 的模式，但不同的是 @EntityGraph 可以搭配任何的查询情况，只需要我们在查询方法上直接加 @EntityGraph 注解即可。</p>
<p data-nodeid="9823">这种方法还有个优势就是 @EntityGraph 和 @NamedEntityGraph 是 JPA 协议规定的，这样可以对 Hibernate 无感。</p>
<p data-nodeid="9824">那么我们再看一下 @ManyToOne 的模式是否同样奏效，访问 addressRepository.findAll() 这个方法看一下 SQL，如下所示。</p>
<pre class="lang-java" data-nodeid="9825"><code data-language="java">org.hibernate.SQL                        :
select address0_.id                     as id1_0_0_,
       userinfo1_.id                    as id1_2_1_,
       address0_.create_time            as create_t2_0_0_,
       address0_.create_user_id         as create_u3_0_0_,
       address0_.last_modified_time     as last_mod4_0_0_,
       address0_.last_modified_user_id  as last_mod5_0_0_,
       address0_.version                as version6_0_0_,
       address0_.city                   as city7_0_0_,
       address0_.user_info_id           as user_inf8_0_0_,
       userinfo1_.create_time           as create_t2_2_1_,
       userinfo1_.create_user_id        as create_u3_2_1_,
       userinfo1_.last_modified_time    as last_mod4_2_1_,
       userinfo1_.last_modified_user_id as last_mod5_2_1_,
       userinfo1_.version               as version6_2_1_,
       userinfo1_.ages                  as ages7_2_1_,
       userinfo1_.email_address         as email_ad8_2_1_,
       userinfo1_.last_name             as last_nam9_2_1_,
       userinfo1_.name                  as name10_2_1_,
       userinfo1_.telephone             as telepho11_2_1_
from address address0_
         left outer join user_info userinfo1_ on address0_.user_info_id = userinfo1_.id
</code></pre>
<p data-nodeid="9826">可以看到 address left join 的模式中，一个 SQL 把所有的 address 和 user_info 都查询出来了。</p>
<p data-nodeid="9827">综上所述，@EntityGraph 可以用在任何 ***Repository 的查询方法上，针对不同的场景配置不同的关联关系策略，就可以减少 N+1 的 SQL，成为一条 SQL。</p>
<h3 data-nodeid="9828">总结</h3>
<p data-nodeid="9829">通过这两讲的介绍，你可以知道关联关系在 Hibernate 的 JPA 中的优点就是使用方便、效率高；而缺点就是需要了解很多知识，才能知道最佳实践是什么。</p>
<p data-nodeid="9830">关于这四种处理 N+1 SQL 的方法，你在使用的时候可以根据实际情况自由选择，不局限于某一种解决方式。</p>
<p data-nodeid="9831">在我介绍的内容中，有一些方法不是 JPA 协议的标准，而是 Hibernate 的语法，所以你在用的时候要看一下注解或者配置的源码注释，看看是否有变化，再根据实际情况自由调整。不过思路上的转化可以不需要关心版本的变化。</p>
<p data-nodeid="9832">好了，本讲到这里就结束了。全网最全的 N+1 SQL 处理方案，如果你觉得有用，就动动手指分享吧。下一讲我们来聊聊 SPEL 表达式的相关内容，再见。</p>
<blockquote data-nodeid="9833">
<p data-nodeid="9834" class="">点击下方链接查看源码（不定时更新）<br>
<a href="https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa" data-nodeid="9962">https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa</a></p>
</blockquote></div>

</body></html>