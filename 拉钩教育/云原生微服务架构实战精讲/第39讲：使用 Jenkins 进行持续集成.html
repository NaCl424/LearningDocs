<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第39讲：使用 Jenkins 进行持续集成</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>第39讲：使用 Jenkins 进行持续集成</h1><p data-nodeid="2749" class="">从本课时开始，我们将开始进入<strong data-nodeid="2963">持续集成（Continuous Integration）</strong> 和<strong data-nodeid="2964">持续部署（Continuous Deployment）</strong> 相关的内容，持续集成和部署是目前软件开发中的标准实践。在微服务架构的应用中，持续集成和部署的重要性和复杂度都提高了，因为每个服务都需要独立的集成和部署。本课时将介绍如何使用 Jenkins 进行持续集成。</p>
<p data-nodeid="2750">我们首先要明确的是持续集成的目标，即从源代码到容器镜像，每一个源代码的提交，都应该创建出对应的不可变的容器镜像，这个构建过程是可重复的。对于同样的代码提交，无论在什么时候构建，所得到的容器镜像都应该是完全相同的，这就保证了容器镜像是可丢弃的，可以随时从源代码中构建出所需要的镜像，这使得我们可以把不同环境上的应用部署回退到任意版本。创建出来的镜像一般被发布到镜像注册表中，由 Kubernetes 在运行时拉取并运行。</p>
<p data-nodeid="2751">下面首先介绍如何使用 Dockerfile 创建镜像。</p>
<h3 data-nodeid="2752">使用 Dockerfile</h3>
<p data-nodeid="2753">为了部署在 Kubernetes 上，我们需要为每个微服务创建各自的容器镜像。</p>
<p data-nodeid="2754">创建简单的 Docker 镜像并不是复杂的事情，只需要编写描述镜像内容的 Dockerfile 文件，再使用 docker build 命令来创建镜像即可。下面代码中的 Dockerfile 用来创建地址管理服务的镜像。</p>
<pre class="lang-dockerfile" data-nodeid="2755"><code data-language="dockerfile"><span class="hljs-keyword">FROM</span> adoptopenjdk/openjdk8:jre8u262-b10-alpine 
<span class="hljs-keyword">ADD</span><span class="bash"> target/happyride-address-service-1.0.0-SNAPSHOT.jar /opt/app.jar </span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [ <span class="hljs-string">"java"</span>, <span class="hljs-string">"-jar"</span>, <span class="hljs-string">"/opt/app.jar"</span> ]</span>
</code></pre>
<p data-nodeid="2756">这个 Dockerfile 的内容很简单，只有 3 条指令，具体的说明如下表所示。</p>
<table data-nodeid="2758">
<thead data-nodeid="2759">
<tr data-nodeid="2760">
<th data-org-content="**指令**" data-nodeid="2762"><strong data-nodeid="2974">指令</strong></th>
<th data-org-content="**说明**" data-nodeid="2763"><strong data-nodeid="2978">说明</strong></th>
</tr>
</thead>
<tbody data-nodeid="2766">
<tr data-nodeid="2767">
<td data-org-content="FROM" data-nodeid="2768">FROM</td>
<td data-org-content="使用的基础镜像是 AdoptOpenJDK 的 JRE 8 的 Alpine 镜像" data-nodeid="2769">使用的基础镜像是 AdoptOpenJDK 的 JRE 8 的 Alpine 镜像</td>
</tr>
<tr data-nodeid="2770">
<td data-org-content="ADD" data-nodeid="2771">ADD</td>
<td data-org-content="添加服务的 JAR 文件到 /opt 目录" data-nodeid="2772">添加服务的 JAR 文件到 /opt 目录</td>
</tr>
<tr data-nodeid="2773">
<td data-org-content="ENTRYPOINT" data-nodeid="2774">ENTRYPOINT</td>
<td data-org-content="设置容器镜像运行时的入口为使用 Java 命令来运行 JAR 文件" data-nodeid="2775">设置容器镜像运行时的入口为使用 Java 命令来运行 JAR 文件</td>
</tr>
</tbody>
</table>
<p data-nodeid="2776">这里利用了 Spring Boot 的 Maven 插件来把整个应用打包成单一的 JAR 文件。</p>
<p data-nodeid="2777">我们使用下面的命令来创建并运行镜像，-t 参数的作用是为镜像指定一个标签：</p>
<pre class="lang-shell" data-nodeid="2778"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> docker build . -t <span class="hljs-built_in">local</span>/address-service:1.0.0 </span>
<span class="hljs-meta">$</span><span class="bash"> docker run <span class="hljs-built_in">local</span>/address-service:1.0.0</span>
</code></pre>
<p data-nodeid="2779">在 Maven 构建过程的 package 阶段中，在 Spring Boot 的 Maven 插件产生了 JAR 文件之后，使用 Maven 的 exec-maven-plugin 插件来调用 docker build 命令。下面的代码给出了 Maven 插件的使用示例。</p>
<pre class="lang-xml" data-nodeid="2780"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>exec-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">executable</span>&gt;</span>docker<span class="hljs-tag">&lt;/<span class="hljs-name">executable</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">arguments</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>-f<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>\${project.basedir}/src/docker/Dockerfile<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>-t<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>happyride/\${project.artifactId}:\${project.version} 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">arguments</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<p data-nodeid="2781">在使用 Maven 插件完成构建之后，产生的容器镜像会缓存在本地，可以通过 docker images 命令来查看。</p>
<h3 data-nodeid="2782">OCI 镜像规范</h3>
<p data-nodeid="2783">虽然我们在谈论容器镜像时，通常会使用 Docker 镜像来代替，但两者并不是等同的。为了对容器镜像的格式进行规范化，Linux 基金会下的开放容器倡议（Open Container Initiative，OCI）组织负责维护容器镜像规范和容器运行规范。在 OCI 规范的基础上，不同的厂商可以开发自己的基于 OCI 规范的工具或产品。</p>
<p data-nodeid="2784">OCI 镜像规范以 Docker 公司贡献的 Docker 镜像版本 2 格式作为基础。每个 OCI 镜像由下表中的几个部分组成：</p>
<table data-nodeid="2786">
<thead data-nodeid="2787">
<tr data-nodeid="2788">
<th data-org-content="**组成部分**" data-nodeid="2790"><strong data-nodeid="2995">组成部分</strong></th>
<th data-org-content="**说明**" data-nodeid="2791"><strong data-nodeid="2999">说明</strong></th>
</tr>
</thead>
<tbody data-nodeid="2794">
<tr data-nodeid="2795">
<td data-org-content="清单文件" data-nodeid="2796">清单文件</td>
<td data-org-content="描述对应于特定底层架构和操作系统的容器镜像" data-nodeid="2797">描述对应于特定底层架构和操作系统的容器镜像</td>
</tr>
<tr data-nodeid="2798">
<td data-org-content="清单文件索引" data-nodeid="2799">清单文件索引</td>
<td data-org-content="清单文件的索引" data-nodeid="2800">清单文件的索引</td>
</tr>
<tr data-nodeid="2801">
<td data-org-content="层（Layer）" data-nodeid="2802">层（Layer）</td>
<td data-org-content="对文件系统的改动" data-nodeid="2803">对文件系统的改动</td>
</tr>
<tr data-nodeid="2804">
<td data-org-content="配置" data-nodeid="2805">配置</td>
<td data-org-content="与容器运行相关的配置" data-nodeid="2806">与容器运行相关的配置</td>
</tr>
</tbody>
</table>
<p data-nodeid="2807">在上表中，镜像中的层是开发中需要注意的概念。把镜像划分成多个层之后，可以更有效地利用缓存，从而加快构建的速度。在推送镜像到注册表时，只有改变的层才会被推送。以一个 Java 应用来说，如果把应用所依赖的第三方库和应用自身的类文件划分成不同的层，由于第三方库很少变化，在构建镜像时，只需要更新和推送类文件所在的层即可。如果整个 Java 应用的全部文件被划分在一个层中，那么每次构建镜像时，该层都必然被更新，即便其中的第三方库没有变化，这也会产生不必要的传输开销。</p>
<h3 data-nodeid="2808">使用 Spring Boot 的 Buildpacks</h3>
<p data-nodeid="2809">Dockerfile 虽然简单易懂，但是缺乏必要的组织，造成复用起来很困难，只能复制粘贴 Dockerfile 中的部分内容。如果有很多服务都使用 Spring Boot 开发，那么每个服务中都需要复制一份大部分内容都重复的 Dockerfile。解决这个问题的一种做法是使用 Buildpacks。</p>
<p data-nodeid="2810"><a href="https://buildpacks.io/" data-nodeid="3013">Buildpacks</a>是 CNCF 之下的一个沙盒项目，其所要解决的问题是从源代码中构建出 OCI 容器镜像。与 Dockerfile 相比，Buildpacks 的抽象层次更高，更容易理解和复用，它的基本组成单元是 Buildpack。每个 Buildpack 分成<strong data-nodeid="3023">检测</strong>和<strong data-nodeid="3024">构建</strong>两个步骤：检测步骤用来判断该 Buildpack 是否应该被应用；构建步骤则负责对镜像进行修改，包括修改层的内容，或是修改配置。每个 Buildpack 只对镜像做特定的改动。</p>
<p data-nodeid="2811">在每一个应用的镜像构建过程中，会有多个 Buildpack 按照顺序来依次检测和应用修改。通过这种方式，不同的 Buildpack 可以进行组合和复用。</p>
<p data-nodeid="2812">Spring Boot 从 2.3.0 版本开始，支持使用 Buildpacks 来创建 OCI 镜像。在 Maven 中，只需要使用 Spring Boot Maven 插件的 build-image 命令即可。下面的代码给出了插件的基本用法。</p>
<pre class="lang-xml" data-nodeid="2813"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build-image<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<p data-nodeid="2814">在生成的 Spring Boot 镜像中，不仅仅包含了 JRE 和应用的 JAR 文件，还包含了一些辅助的工具，如下表所示：</p>
<table data-nodeid="2816">
<thead data-nodeid="2817">
<tr data-nodeid="2818">
<th data-org-content="**工具**" data-nodeid="2820"><strong data-nodeid="3031">工具</strong></th>
<th data-org-content="**说明**" data-nodeid="2821"><strong data-nodeid="3035">说明</strong></th>
</tr>
</thead>
<tbody data-nodeid="2824">
<tr data-nodeid="2825">
<td data-org-content="memory-calculator" data-nodeid="2826">memory-calculator</td>
<td data-org-content="计算 JVM 使用的内存大小" data-nodeid="2827">计算 JVM 使用的内存大小</td>
</tr>
<tr data-nodeid="2828">
<td data-org-content="jvmkill" data-nodeid="2829">jvmkill</td>
<td data-org-content="当无法分配内存或创建线程时，终止 JVM" data-nodeid="2830">当无法分配内存或创建线程时，终止 JVM</td>
</tr>
<tr data-nodeid="2831">
<td data-org-content="class-counter" data-nodeid="2832">class-counter</td>
<td data-org-content="计算类文件的数量" data-nodeid="2833">计算类文件的数量</td>
</tr>
<tr data-nodeid="2834">
<td data-org-content="link-local-dns" data-nodeid="2835">link-local-dns</td>
<td data-org-content="修改 DNS 设置" data-nodeid="2836">修改 DNS 设置</td>
</tr>
<tr data-nodeid="2837">
<td data-org-content="openssl-security-provider" data-nodeid="2838">openssl-security-provider</td>
<td data-org-content="加载 JRE 的权威机构证书" data-nodeid="2839">加载 JRE 的权威机构证书</td>
</tr>
<tr data-nodeid="2840">
<td data-org-content="security-providers-configurer" data-nodeid="2841">security-providers-configurer</td>
<td data-org-content="配置 Java 的安全服务的提供者" data-nodeid="2842">配置 Java 的安全服务的提供者</td>
</tr>
<tr data-nodeid="2843">
<td data-org-content="java-security-properties" data-nodeid="2844">java-security-properties</td>
<td data-org-content="Java 安全属性" data-nodeid="2845">Java 安全属性</td>
</tr>
</tbody>
</table>
<p data-nodeid="2846">这些工具的作用是优化 Java 应用在容器中的运行。下面的代码是 Spring Boot 应用的容器在运行时的输出，从中可以看到，JVM 的内存设置会根据容器的内存限制来做出调整。</p>
<pre class="lang-java" data-nodeid="2847"><code data-language="java">Container memory limit unset. Configuring JVM <span class="hljs-keyword">for</span> <span class="hljs-number">1</span>G container. 
Calculated JVM Memory Configuration: -XX:MaxDirectMemorySize=<span class="hljs-number">10</span>M -XX:MaxMetaspaceSize=<span class="hljs-number">126109</span>K -XX:ReservedCodeCacheSize=<span class="hljs-number">240</span>M -Xss1M -Xmx410466K (Head Room: <span class="hljs-number">0</span>%, Loaded Class Count: <span class="hljs-number">19851</span>, Thread Count: <span class="hljs-number">250</span>, Total Memory: <span class="hljs-number">1073741824</span>) 
Adding <span class="hljs-number">127</span> container CA certificates to JVM truststore
</code></pre>
<p data-nodeid="2848">下面的代码给出了 Spring Boot 的 Buildpacks 在构建时的部分输出，从中可以看到，在检测阶段中，在 16 个 Buildpack 中， 只有 5 个会参与构建，并给出了每个 Buildpack 的名称和版本号。</p>
<pre class="lang-java" data-nodeid="2849"><code data-language="java">[INFO]&nbsp; &gt; Running creator 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;===&gt; DETECTING 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;<span class="hljs-number">5</span> of <span class="hljs-number">16</span> buildpacks participating 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;paketo-buildpacks/bellsoft-liberica <span class="hljs-number">2.11</span>.<span class="hljs-number">0</span> 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;paketo-buildpacks/executable-jar&nbsp; &nbsp; <span class="hljs-number">2.0</span>.<span class="hljs-number">2</span> 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;paketo-buildpacks/apache-tomcat&nbsp; &nbsp; &nbsp;<span class="hljs-number">1.4</span>.<span class="hljs-number">0</span> 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;paketo-buildpacks/dist-zip&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">1.3</span>.<span class="hljs-number">8</span> 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;paketo-buildpacks/spring-boot&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">2.3</span>.<span class="hljs-number">0</span>
</code></pre>
<h3 data-nodeid="2850">使用 Jib</h3>
<p data-nodeid="2851"><a href="https://github.com/GoogleContainerTools/jib" data-nodeid="3055">Jib</a> 是由 Google 维护的工具，用来对 Java 应用进行容器化。其优势在于不需要依赖 Docker 守护进程，就可以创建出 OCI 容器镜像，构建镜像也不需要编写 Dockerfile。Jib 会自动把应用分成多层，把应用依赖的第三方库和应用自身的类文件分开。</p>
<p data-nodeid="2852">Jib 支持 3 种不同的构建方式，对应于不同的 Maven 目标，如下表所示。</p>
<table data-nodeid="2854">
<thead data-nodeid="2855">
<tr data-nodeid="2856">
<th data-org-content="**Maven 目标**" data-nodeid="2858"><strong data-nodeid="3061">Maven 目标</strong></th>
<th data-org-content="**说明**" data-nodeid="2859"><strong data-nodeid="3065">说明</strong></th>
</tr>
</thead>
<tbody data-nodeid="2862">
<tr data-nodeid="2863">
<td data-org-content="build" data-nodeid="2864">build</td>
<td data-org-content="不使用 Docker 来构建镜像，并推送到注册表" data-nodeid="2865">不使用 Docker 来构建镜像，并推送到注册表</td>
</tr>
<tr data-nodeid="2866">
<td data-org-content="dockerBuild" data-nodeid="2867">dockerBuild</td>
<td data-org-content="使用 Docker 来构建镜像" data-nodeid="2868">使用 Docker 来构建镜像</td>
</tr>
<tr data-nodeid="2869">
<td data-org-content="buildTar" data-nodeid="2870">buildTar</td>
<td data-org-content="把镜像打包成 tar 文件" data-nodeid="2871">把镜像打包成 tar 文件</td>
</tr>
</tbody>
</table>
<p data-nodeid="2872">下面的代码给出了 jib 的 Maven 插件的基本用法，其中 from 表示基础镜像的名称，to 表示构建出来的镜像的发布地址。这里使用的是 build 目标来创建并发布 OCI 镜像，并不依赖 Docker。</p>
<pre class="lang-xml" data-nodeid="2873"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.cloud.tools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jib-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span>adoptopenjdk/openjdk8:jre8u262-b10-alpine<span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; docker-registry:5000/happyride/\${project.artifactId}:\${parsedVersion.majorVersion}.\${parsedVersion.minorVersion}.\${parsedVersion.incrementalVersion}-\${git.commit.id.abbrev} 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">allowInsecureRegistries</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">allowInsecureRegistries</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">container</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">format</span>&gt;</span>OCI<span class="hljs-tag">&lt;/<span class="hljs-name">format</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">container</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<p data-nodeid="2874">与 Spring Boot 构建镜像的方式相比，Jib 的优势在于可以对任意 Java 应用进行构建，并且不依赖 Docker 运行时的支持；不足之处在于缺少对 Java 应用运行的优化。</p>
<h3 data-nodeid="2875">容器镜像注册表</h3>
<p data-nodeid="2876">在本地开发环境上运行 docker build 命令之后，产生的镜像会缓存在本地。当在 Kubernetes 上部署时，这些本地缓存的镜像并不能直接使用。根据部署环境的不同，可以通过相应的方式来使用镜像。</p>
<p data-nodeid="2877">在本地开发环境中，Minikube 内置包含了 Docker 运行时，为 Kubernetes 提供容器运行时的支持。我们可以配置本地开发环境中的 docker 命令，来连接 Minikube 中的 Docker 守护进程。在本地上构建完成之后，得到的镜像会被缓存在 Minikube 的 Docker 进程中，从而可以在 Kubernetes 中直接使用。</p>
<p data-nodeid="2878">使用下面的命令可以显示连接到 Minikube 的 Docker 守护进程的配置方式。</p>
<pre class="lang-plain" data-nodeid="2879"><code data-language="plain">$ minikube docker-env
</code></pre>
<p data-nodeid="2880">上述命令的输出如下所示，只是设置了一些环境变量：</p>
<pre class="lang-sql" data-nodeid="2881"><code data-language="sql">export DOCKER_TLS_VERIFY="1" 
export DOCKER_HOST="tcp://192.168.64.9:2376" 
export DOCKER_CERT_PATH="/Users/alexcheng/.minikube/certs" 
export MINIKUBE_ACTIVE_DOCKERD="minikube" 
<span class="hljs-comment"># To point your shell to minikube's docker-daemon, run: </span>
<span class="hljs-comment"># eval $(minikube -p minikube docker-env)</span>
</code></pre>
<p data-nodeid="2882">按照命令输出中的提示操作完成设置之后，在当前命令行窗口中使用 Maven 命令来构建镜像。在 Kubernetes 中，只需要重新创建 Pod，就可以使用新构建的镜像来进行测试。</p>
<p data-nodeid="2883">如果应用安装在用户的私有环境中，并且不能自由的访问外部的网络，可以使用 docker export 命令把镜像导出成压缩文件，保存在移动存储设备中。在内部网络中，把镜像的压缩文件复制到 Kubernetes 的每个节点上，再使用 docker import 命令把镜像导入缓存中。</p>
<p data-nodeid="2884">除了上述两种特殊情况之外，最常用的做法是使用容器镜像注册表来保存镜像。在持续集成中，容器镜像被发布到注册表中；在 Kubernetes 上运行时，容器镜像从注册表中下载到本地并运行。</p>
<p data-nodeid="2885">云平台一般都提供各自的容器注册表服务，也可以使用独立的注册表服务。Docker 的注册表实现是开源的，可以在集群内部安装自己的私有注册表。</p>
<h3 data-nodeid="2886">容器镜像的标签</h3>
<p data-nodeid="2887">在持续集成中，每次构建出来的容器镜像都应该有唯一的标签，如果不指定标签，那么默认使用的是 latest 标签。在实际的开发中，并不建议使用 latest 标签，因为该标签所指向的容器镜像的内容是不固定的。如果在测试或生产环境中使用了 latest 标签，那么一段时间之后重新运行测试或再次部署时，所得到的结果可能完全不同，因为对应的镜像可能被更新了。为了保证测试和部署的可重复性，所有的测试和部署都应该使用带标签的形式来引用镜像。</p>
<p data-nodeid="2888">镜像标签最常用的格式是使用语义化版本号，目前绝大部分的公开镜像都使用版本号作为标签。在实际开发中，单纯使用版本号并不足以区分不同的构建版本，因为同一个版本在开发过程中可能多次构建。通常的做法是在版本号之后添加后缀，作为附加的区分信息。常用的后缀包括构建时间、构建编号和 Git 提交的标识符，如下表所示：</p>
<table data-nodeid="2890">
<thead data-nodeid="2891">
<tr data-nodeid="2892">
<th data-org-content="**后缀**" data-nodeid="2894"><strong data-nodeid="3089">后缀</strong></th>
<th data-org-content="**说明**" data-nodeid="2895"><strong data-nodeid="3093">说明</strong></th>
</tr>
</thead>
<tbody data-nodeid="2898">
<tr data-nodeid="2899">
<td data-org-content="构建时间" data-nodeid="2900">构建时间</td>
<td data-org-content="使用构建完成时的时间戳" data-nodeid="2901">使用构建完成时的时间戳</td>
</tr>
<tr data-nodeid="2902">
<td data-org-content="构建编号" data-nodeid="2903">构建编号</td>
<td data-org-content="持续集成服务为每个构建分配的标识符" data-nodeid="2904">持续集成服务为每个构建分配的标识符</td>
</tr>
<tr data-nodeid="2905">
<td data-org-content="Git 提交标识符" data-nodeid="2906">Git 提交标识符</td>
<td data-org-content="触发持续集成的 Git 提交的标识符" data-nodeid="2907">触发持续集成的 Git 提交的标识符</td>
</tr>
</tbody>
</table>
<p data-nodeid="2908">在上表的这 3 种后缀形式中，并不推荐使用构建时间，因为时间本身并不能提供更多有用的信息。使用构建编号的好处是方便与已有的项目管理系统和 bug 追踪系统进行集成。测试团队一般工作在特定的构建编号之上。推荐的做法是使用 Git 提交的标识符作为后缀，从使用的镜像标签就可以快速定位到产生该镜像的代码。</p>
<p data-nodeid="2909">我们可以使用 Maven 的 git-commit-id-maven-plugin 插件来获取 Git 中提交的标识符，并在构建过程中引用。</p>
<p data-nodeid="2910">下面的代码给出了该插件的使用示例。该插件会提供一系列与 Git 相关的属性，比如 git.commit.id.abbrev 属性表示 Git 提交标识符的缩略形式。</p>
<pre class="lang-xml" data-nodeid="2911"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>pl.project13.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>git-commit-id-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span> 
      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>get-the-git-infos<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> 
      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span> 
        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>revision<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span> 
      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span> 
      <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>initialize<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span> 
    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span> 
  <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<p data-nodeid="2912">最终生成的镜像标签类似与于 1.0.0-3228a39。</p>
<h3 data-nodeid="2913">使用 Jenkins</h3>
<p data-nodeid="2914">示例应用使用 Jenkins 作为持续集成的服务。Jenkins 使用 Helm 安装，运行在 Kubernetes 上。当需要运行构建任务时，Jenkins 会启动一个新的 Pod 来执行。</p>
<p data-nodeid="2915">下面的代码是 Jenkins 中流水线的声明。构建的容器运行的是 Maven 的镜像，从 GitHub 获取源代码之后，通过 Maven 来执行构建过程，构建过程中会发布镜像到注册表中。</p>
<pre class="lang-dart" data-nodeid="2916"><code data-language="dart">podTemplate(yaml: <span class="hljs-string">''' 
apiVersion: v1 
kind: Pod 
spec: 
&nbsp; securityContext: 
&nbsp; &nbsp; fsGroup: 1000 
&nbsp; containers: 
&nbsp; - name: maven 
&nbsp; &nbsp; image: maven:3.6.3-jdk-8 
&nbsp; &nbsp; command: 
&nbsp; &nbsp; - sleep 
&nbsp; &nbsp; args: 
&nbsp; &nbsp; - infinity 
&nbsp; &nbsp; resources: 
&nbsp; &nbsp; &nbsp; requests: 
&nbsp; &nbsp; &nbsp; &nbsp; cpu: 1 
&nbsp; &nbsp; &nbsp; &nbsp; memory: 1Gi 
&nbsp; &nbsp; volumeMounts: 
&nbsp; &nbsp; &nbsp; - name: dockersock 
&nbsp; &nbsp; &nbsp; &nbsp; mountPath: "/var/run/docker.sock" 
&nbsp; volumes: 
&nbsp; &nbsp; - name: dockersock 
&nbsp; &nbsp; &nbsp; hostPath: 
&nbsp; &nbsp; &nbsp; &nbsp; path: /var/run/docker.sock 
'''</span>) { 
&nbsp; &nbsp; node(POD_LABEL) { 
&nbsp; &nbsp; &nbsp; &nbsp; git <span class="hljs-string">'https://github.com/alexcheng1982/happyride'</span> 
&nbsp; &nbsp; &nbsp; &nbsp; container(<span class="hljs-string">'maven'</span>) { 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sh <span class="hljs-string">'mvn -B -ntp -Dmaven.test.failure.ignore deploy'</span> 
&nbsp; &nbsp; &nbsp; &nbsp; } 
&nbsp; &nbsp; &nbsp; &nbsp; junit <span class="hljs-string">'**/target/surefire-reports/TEST-*.xml'</span> 
&nbsp; &nbsp; &nbsp; &nbsp; archiveArtifacts <span class="hljs-string">'**/target/*.jar'</span> 
&nbsp; &nbsp; } 
}
</code></pre>
<p data-nodeid="2917">这里需要着重介绍的是对 Docker 的使用。在构建过程中，单元测试和镜像发布都需要依赖 Docker 进程。在流水线的定义中，通过卷绑定的方式，把 Kubernetes 节点上的 /var/run/docker.sock 文件传到构建的 Pod 中，使得 Pod 中的容器可以访问节点上的 Docker 进程。通过这种方式，避免了在 Maven 容器中启动额外的 Docker 进程。</p>
<h3 data-nodeid="2918">其他构建镜像的工具</h3>
<p data-nodeid="2919">目前所介绍的构建容器镜像的方式是使用 Docker，这也是目前比较主流的方式。Docker 在本地开发时很方便，但在持续集成中也有一些不足之处。</p>
<p data-nodeid="2920">构建时需要有 Docker 守护进程存在，这就意味着需要在持续集成服务器上安装 Docker，并保持 Docker 在后台运行。如果在 Kubernetes 上运行，那么可以复用 Kubernetes 节点上的 Docker 进程。</p>
<p data-nodeid="2921">另外一个问题来自 Docker 自身。随着多年的开发，Docker 自身已经过于臃肿，提供了非常多的功能。在持续集成中，我们只需要能够构建镜像，并推送到容器注册表即可，并不需要 Docker 提供的其他功能。</p>
<p data-nodeid="2922">OCI 镜像规范的出现，使得容器镜像的格式不再锁定于特定的公司，从而促进了容器镜像构建相关工具的发展。目前已经有一些工具可以创建出 OCI 镜像，如下表所示。</p>
<table data-nodeid="2924">
<thead data-nodeid="2925">
<tr data-nodeid="2926">
<th data-org-content="**名称**" data-nodeid="2928"><strong data-nodeid="3116">名称</strong></th>
<th data-org-content="**支持者**" data-nodeid="2929"><strong data-nodeid="3120">支持者</strong></th>
</tr>
</thead>
<tbody data-nodeid="2932">
<tr data-nodeid="2933">
<td data-org-content="[BuildKit](https://github.com/moby/buildkit)" data-nodeid="2934"><a href="https://github.com/moby/buildkit" data-nodeid="3123">BuildKit</a></td>
<td data-org-content="Docker Inc" data-nodeid="2935">Docker Inc</td>
</tr>
<tr data-nodeid="2936">
<td data-org-content="[buildah](https://buildah.io/)" data-nodeid="2937"><a href="https://buildah.io/" data-nodeid="3127">buildah</a></td>
<td data-org-content="Red Hat" data-nodeid="2938">Red Hat</td>
</tr>
<tr data-nodeid="2939">
<td data-org-content="[umoci](https://umo.ci/)" data-nodeid="2940"><a href="https://umo.ci/" data-nodeid="3131">umoci</a></td>
<td data-org-content="SUSE" data-nodeid="2941">SUSE</td>
</tr>
<tr data-nodeid="2942">
<td data-org-content="[Kaniko](https://github.com/GoogleContainerTools/kaniko)" data-nodeid="2943"><a href="https://github.com/GoogleContainerTools/kaniko" data-nodeid="3135">Kaniko</a></td>
<td data-org-content="Google" data-nodeid="2944">Google</td>
</tr>
<tr data-nodeid="2945">
<td data-org-content="[Makisu](https://github.com/uber/makisu)" data-nodeid="2946"><a href="https://github.com/uber/makisu" data-nodeid="3139">Makisu</a></td>
<td data-org-content="Uber" data-nodeid="2947">Uber</td>
</tr>
</tbody>
</table>
<p data-nodeid="2948">在这些工具中，值得一提的是 Docker 的 BuildKit，其支持并发的构建，可以更高效地进行缓存，因此构建的速度更快。BuildKit 从 18.06 版本开始已经被集成到 Docker 中，可以通过下面的命令来启用 BuildKit。</p>
<pre class="lang-plain" data-nodeid="2949"><code data-language="plain">DOCKER_BUILDKIT=1 docker build
</code></pre>
<p data-nodeid="2950">有一些其他工具对 BuildKit 进行了封装，可以简化它的使用，包括 <a href="https://github.com/genuinetools/img" data-nodeid="3145">img</a>、阿里巴巴的 <a href="https://github.com/alibaba/pouch" data-nodeid="3149">pouch</a> 和 Rancher 的 <a href="https://github.com/rancher/k3c" data-nodeid="3153">k3c</a> 等。本课时不对这些工具进行具体的介绍，详细的使用请参考相关文档。</p>
<h3 data-nodeid="2951">总结</h3>
<p data-nodeid="2952">在微服务架构中，持续集成可以保证每一个代码提交都可以有与之对应的容器镜像，容器镜像是不可变的，而且构建的过程是可重复的。通过本课时的学习，你可以了解如何从 Dockerfile 中创建出 Docker 容器镜像，以及如何使用 Spring Boot 插件和 Google 的 Jib 工具来创建 Java 应用的容器镜像，还可以了解如何使用 Jenkins 来进行持续集成。</p>
<p data-nodeid="6490" class="">最后呢，成老师邀请你为本专栏课程进行结课评价，因为你的每一个观点都是我们最关注的点。<a href="https://wj.qq.com/s2/6902680/3fb2/" data-nodeid="6494">点击链接，即可参与课程评价</a>。</p></div>

</body></html>