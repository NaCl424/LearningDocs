<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>09 | 你的第一个 API 测试框架（一）</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>09 | 你的第一个 API 测试框架（一）</h1><p data-nodeid="110722" class="">通过上一节课的学习，我们已经对搭建 Web 自动化测试框架非常熟悉了。</p>
<p data-nodeid="110723">接下来，我将带你一步步搭建 API 测试框架，同样也是分为两个课时讲解，今天课时的主要内容是 Requests 和 pytest 的基本介绍，下一课时则是详细讲解 pytest 的使用，以及 pytest 集成测试报告，课时具体安排如下所示。</p>
<p data-nodeid="110724"><img src="https://s0.lgstatic.com/i/image/M00/5A/80/Ciqc1F94gWOAbwCSAADOdv9P5Zg817.png" alt="Drawing 0.png" data-nodeid="110909"></p>
<p data-nodeid="110725">首先我们看下 API 测试框架和 Web 测试框架的区别。</p>
<p data-nodeid="110726">两者唯一的区别在于测试请求的方式不同，Web 自动化测试框架是通过操作浏览器对目标对象进行操作的，而 API 测试框架通常是通过<strong data-nodeid="110916">直接请求 HTTP 接口来完成的</strong>，特别是随着近几年微服务技术的普及，RESTFUL 风格的 HTTP 接口调用越来越多。</p>
<blockquote data-nodeid="110727">
<p data-nodeid="110728">想要了解更多关于 HTTP 协议和 RESTFUL 的内容，可参考公众号 iTesting 的两篇文章<a href="https://mp.weixin.qq.com/s/PLidZRuIGA6snNejmH9Llw" data-nodeid="110920">《更好地理解 RSTFUL》</a>和<a href="https://mp.weixin.qq.com/s/cyzpqlAd5S4WUr8UreQNHA" data-nodeid="110924">《HTTP协议总结》</a>。</p>
</blockquote>
<p data-nodeid="110729">那么 HTTP 形式的 API， 有哪几种请求方式呢？</p>
<blockquote data-nodeid="110730">
<p data-nodeid="110731"><code data-backticks="1" data-nodeid="110927">GET</code><br>
GET 方法请求一个指定资源的表示形式，使用 GET 的请求应该只被用于获取数据。<br>
<code data-backticks="1" data-nodeid="110931">HEAD</code><br>
HEAD 方法请求一个与 GET 请求的响应相同的响应，但没有响应体。<br>
<code data-backticks="1" data-nodeid="110935">POST</code><br>
POST 方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。<br>
<code data-backticks="1" data-nodeid="110939">PUT</code><br>
PUT 方法用请求有效载荷替换目标资源的所有当前表示。<br>
<code data-backticks="1" data-nodeid="110943">DELETE</code><br>
DELETE 方法删除指定的资源。<br>
<code data-backticks="1" data-nodeid="110947">CONNECT</code><br>
CONNECT 方法建立一个到由目标资源标识的服务器的隧道。<br>
<code data-backticks="1" data-nodeid="110951">OPTIONS</code><br>
OPTIONS 方法用于描述目标资源的通信选项。<br>
<code data-backticks="1" data-nodeid="110955">TRACE</code><br>
TRACE 方法沿着到目标资源的路径执行一个消息环回测试。<br>
<code data-backticks="1" data-nodeid="110959">PATCH</code><br>
PATCH 方法用于对资源应用部分修改。</p>
</blockquote>
<p data-nodeid="110732">一般情况下，在测试中使用最多的请求方式是 GET、POST、PUT、DELETE 这四种。并且如果是通过代码方式发送请求，在 Python 里我们最经常用的就是 Requests 库。</p>
<p data-nodeid="110733">如果我们要使用 Requests 库作为发送接口请求的命令，我们就必须了解下 Requests 是什么，以及具体怎么用。</p>
<h3 data-nodeid="110734">Requests</h3>
<p data-nodeid="110735">那什么是 Request 呢？Requests 官方说它是一个<strong data-nodeid="110970">简单而优雅的 HTTP 库</strong>。</p>
<h4 data-nodeid="110736">1.Requests 安装</h4>
<p data-nodeid="110737">Requests 的安装非常简单，只要在命令行里输入如下命令即可：</p>
<pre class="lang-python" data-nodeid="110738"><code data-language="python">$ python -m pip install requests
</code></pre>
<h4 data-nodeid="110739">2.Requests 使用</h4>
<p data-nodeid="110740">Requests 的使用也非常简单，下面我们就来看下。</p>
<ul data-nodeid="110741">
<li data-nodeid="110742">
<p data-nodeid="110743"><strong data-nodeid="110978">发送 get 请求</strong></p>
</li>
</ul>
<pre class="lang-python" data-nodeid="110744"><code data-language="python"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># 发送get请求</span>
    requests.get(<span class="hljs-string">'https://httpbin.org/ip'</span>)
</code></pre>
<p data-nodeid="110745">是不是非常简单？但在实际应用中，GET 接口请求常常要带参数 query string，而且有时候需要加 Header，鉴权（OAuth）甚至代理（Proxy），那么这部分接口请求如何发送呢？</p>
<pre class="lang-python" data-nodeid="111228"><code data-language="python"><span class="hljs-keyword">import</span> requests

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># 发送get请求 --带参数</span>
    <span class="hljs-comment"># 等同于直接访问https://httpbin.org/get?kevin=hello</span>
    requests.get(<span class="hljs-string">'https://httpbin.org/get'</span>, params={<span class="hljs-string">'kevin'</span>: <span class="hljs-string">'hello'</span>})

    <span class="hljs-comment"># 当访问接口发生301跳转时，可以设置允许或者禁止跳转</span>
    requests.get(<span class="hljs-string">'http://github.com/'</span>, allow_redirects=<span class="hljs-literal">False</span>)

    <span class="hljs-comment"># 发送get请求， 加proxy</span>
    proxies = {<span class="hljs-string">'http'</span>: <span class="hljs-string">'http://10.10.1.10:3128'</span>,
               <span class="hljs-string">'https'</span>: <span class="hljs-string">'http://10.10.1.10:1080'</span>}
    requests.get(<span class="hljs-string">'https://httpbin.org/get'</span>, proxies=proxies)

    <span class="hljs-comment"># 发送get请求，加鉴权 -- Basic Auth</span>
    <span class="hljs-comment"># 首先导入HTTPBasicAuth，一般导入语句写在py文件的最前面。</span>
    <span class="hljs-keyword">from</span> requests.auth <span class="hljs-keyword">import</span> HTTPBasicAuth
    requests.get(<span class="hljs-string">'https://api.github.com/user'</span>, auth=HTTPBasicAuth(<span class="hljs-string">'user'</span>, <span class="hljs-string">'password'</span>))

    <span class="hljs-comment"># 发送get请求，加鉴权 -- Digest Auth</span>
    <span class="hljs-comment"># 首先导入HTTPDigestAuth，一般导入语句写在py文件的最前面。</span>
    <span class="hljs-keyword">from</span> requests.auth <span class="hljs-keyword">import</span> HTTPDigestAuth
    requests.get(<span class="hljs-string">'https://api.github.com/user'</span>, auth=HTTPDigestAuth(<span class="hljs-string">'user'</span>, <span class="hljs-string">'password'</span>))

    <span class="hljs-comment"># OAuth 1 Authentication</span>
    <span class="hljs-comment"># 首先安装requests_oauthlib&nbsp;（可通过pip install）</span>
    <span class="hljs-keyword">from</span> requests_oauthlib <span class="hljs-keyword">import</span> OAuth1
    url = <span class="hljs-string">'https://api.twitter.com/1.1/account/verify_credentials.json'</span>
    auth = OAuth1(<span class="hljs-string">'YOUR_APP_KEY'</span>, <span class="hljs-string">'YOUR_APP_SECRET'</span>, <span class="hljs-string">'USER_OAUTH_TOKEN'</span>, <span class="hljs-string">'USER_OAUTH_TOKEN_SECRET'</span>)
    requests.get(url, auth=auth)
</code></pre>

<p data-nodeid="110747">以上是不同情况下的 get 请求，在测试中可以根据实际需求选择具体使用哪种方式。</p>
<ul data-nodeid="110748">
<li data-nodeid="110749">
<p data-nodeid="110750"><strong data-nodeid="110984">发送 post 请求</strong></p>
</li>
</ul>
<p data-nodeid="110751">post 请求通常都会带数据 Payloads，当然也会需要 Header、OAuth，发送方式如下：</p>
<pre class="lang-python" data-nodeid="110752"><code data-language="python"><span class="hljs-keyword">import</span> requests

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    url = <span class="hljs-string">'https://httpbin.org/anything'</span>
    headers = {<span class="hljs-string">'user-agent'</span>: <span class="hljs-string">'my-app/  0.0.1'</span>}
    payloads = {<span class="hljs-string">'iTesting'</span>: <span class="hljs-string">'better to follow'</span>}
    auth = {<span class="hljs-string">"username"</span>:<span class="hljs-string">"iTesting"</span>, <span class="hljs-string">"password"</span>: <span class="hljs-string">"Kevin"</span>}

    <span class="hljs-comment"># 直接post</span>
    r = requests.post(url, data=payloads)
    <span class="hljs-comment"># post带header</span>
&nbsp; &nbsp; r = requests.post(url, headers=headers, data=payloads)

    <span class="hljs-comment"># post带鉴权, auth类型跟get请求支持的auth类型相同。</span>
    r = requests.post(url, headers=headers, data=payloads， auth=HTTPBasicAuth(<span class="hljs-string">'user'</span>, <span class="hljs-string">'password'</span>))
</code></pre>
<ul data-nodeid="110753">
<li data-nodeid="110754">
<p data-nodeid="110755"><strong data-nodeid="110989">发送 put 请求</strong></p>
</li>
</ul>
<pre class="lang-python" data-nodeid="110756"><code data-language="python"><span class="hljs-keyword">import</span> requests

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># 直接发送put请求 </span>
    <span class="hljs-comment"># 如需要加header，auth，即参考post请求</span>
    r = requests.put(<span class="hljs-string">'https://httpbin.org/put'</span>, data={<span class="hljs-string">'hello'</span>: <span class="hljs-string">'iTesting'</span>})
    print(r.text)
</code></pre>
<ul data-nodeid="110757">
<li data-nodeid="110758">
<p data-nodeid="110759"><strong data-nodeid="110993">发送 delete 请求</strong></p>
</li>
</ul>
<pre class="lang-python" data-nodeid="110760"><code data-language="python"><span class="hljs-keyword">import</span> requests

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># 直接发送delete请求</span>
    r = requests.delete(<span class="hljs-string">'https://httpbin.org/anything'</span>, data={<span class="hljs-string">'hello'</span>: <span class="hljs-string">'iTesting'</span>})
    print(r.text)
</code></pre>
<h4 data-nodeid="110761">3.获取接口返回值</h4>
<p data-nodeid="110762">接口的请求通常会有返回值，在接口测试中，特别是在顺序访问多个接口，并且前一个接口的返回是后一个接口的入参时，常常需要把接口返回的结果保持下来解析，那么如何保持接口请求呢？</p>
<p data-nodeid="110763">Requests 中提供了以下方式来保存接口返回值：</p>
<pre class="lang-python" data-nodeid="110764"><code data-language="python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span>
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    s = requests.session()
    r = s.post(<span class="hljs-string">'https://httpbin.org/anything'</span>, data={<span class="hljs-string">'hello'</span>: <span class="hljs-string">'kevin'</span>})
    <span class="hljs-comment"># 返回文本型response</span>
    print(r.text)
    <span class="hljs-comment"># #返回文本型response，并用utf-8格式编码</span>
    <span class="hljs-comment"># # 当你用r.text得出的结果是不可读的内容例如包括类似xu'\xe1'或者有错误提示“'ascii' codec can't encode characters in position”时，可以用encode</span>
    print(r.text.encode(<span class="hljs-string">'utf-8'</span>))
    <span class="hljs-comment"># # 获取二进制返回值</span>
    print(r.content)
    <span class="hljs-comment"># # 获取请求返回码</span>
    print(r.status_code)
    <span class="hljs-comment"># 获取response的headers</span>
    print(r.headers)
    <span class="hljs-comment"># 获取请求返回的cookies</span>
    s.get(<span class="hljs-string">'http://google.com'</span>)
    print(request.cookies.get_dict())
</code></pre>
<p data-nodeid="110765">获取接口返回值后，如果你的前一个接口的返回是下一个接口的入参，那么就可以根据需要采用以上方式的任意一个解析出你需要的返回值，然后传递给下一个接口即可。</p>
<h4 data-nodeid="110766">4.Requests 保存 Session</h4>
<p data-nodeid="110767">以上 4 种 Requests 使用方式是直接发送接口请求，我们知道 HTTP 协议是无状态的协议，这也就导致每次接口请求都是独立的，也就意味着你的多个接口请求之间不能共用数据，比如登录态、cookie 等都是不能共用，这显然不符合我们的需求。</p>
<p data-nodeid="110768">基于此，Requests 库提供了 Session 会话对象， 用来帮我们跨请求保持参数，使用&nbsp;requests.Session()&nbsp;, 可以在一个 Session 实例的所有请求中保留 cookie，下面我们来看下&nbsp;requests.Session() 的基本用法：</p>
<pre class="lang-python" data-nodeid="110769"><code data-language="python"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># 初始化一个session对象</span>
    s = requests.Session()

    <span class="hljs-comment"># 第一个get，先设置一个session</span>
    <span class="hljs-comment"># httpbin这个网站允许我们通过如下方式设置，在set后写你需要的值即可</span>
 s.get(<span class="hljs-string">'https://httpbin.org/cookies/set/sessioncookie/iTestingIsGood'</span>)
 
    <span class="hljs-comment"># 设置好后获取所有的cookies</span>
    r = s.get(<span class="hljs-string">'https://httpbin.org/cookies'</span>)

    <span class="hljs-comment"># 打印，确定我们的cookies被保存了 </span>
    print(r.text)
    <span class="hljs-comment"># 结果如下</span>
    <span class="hljs-comment"># '{"cookies": {"sessioncookie": "iTestingIsGood"}}'</span>
</code></pre>
<p data-nodeid="110770">requests.Session() 的使用非常简单，首先你初始化一个 session 对象，接着你使用这个初始化后对象实例直接发起请求，在整个 session 内的所有请求之间是可以共享状态的。上个例子中我们就先初始化了 Session() 对象，假设是 s，然后通过 s.get() 方法去设置了一个 cookie，它的名字是 sessioncookie，它的值是 itestingIsGood。最后，我们去访问 cookies 接口，就拿到了我们刚设置的 cookie。通过 requests.Session() 的方式，我们就实现了 cookie 的保持。</p>
<p data-nodeid="110771">现在，我们更改一下运行方式，注释掉 9 行语句设置 sessioncookie 的那条语句， 再次运行结果如下：</p>
<pre class="lang-python" data-nodeid="110772"><code data-language="python">{
&nbsp; <span class="hljs-string">"cookies"</span>: {}
}
</code></pre>
<p data-nodeid="110773">你会发现，本次运行并没有拿到任何 cookie，由此可见，正是由于 requests.Session() ，cookie 才在两次请求中保持了。</p>
<p data-nodeid="110774">一般在测试中，你可以通过直接请求登录接口便能拿到登录态，例如如下的形态：</p>
<pre class="lang-python" data-nodeid="110775"><code data-language="python"><span class="hljs-comment"># 本代码仅供演示用法</span>
<span class="hljs-keyword">import</span> requests

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    s = requests.Session()
    <span class="hljs-comment"># 登录获取登录态</span>
    s.post(login_url, data=data, headers=headers, verify = <span class="hljs-literal">False</span>)
    <span class="hljs-comment"># 登录态获取后，请求登录后才能访问的接口，也能请求成功。</span>
    s.post（<span class="hljs-string">'your-api'</span>）
</code></pre>
<p data-nodeid="110776">为了更好地理解 requests.Session() 是如何保持登录态的，我们来看一个实际例子：</p>
<pre class="lang-python" data-nodeid="110777"><code data-language="python"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    api = <span class="hljs-string">'https://gate.lagou.com/v1/entry/message/newMessageList'</span>
    s = requests.Session()
    r = s.get(api)
    print(r.text)
    <span class="hljs-comment"># 结果如下：</span>
    <span class="hljs-comment"># {"state": 1003, "message": "非法的访问"}</span>
</code></pre>
<p data-nodeid="110778">在这个例子中，我直接访问拉勾教育的一个接口，这个接口是用来获取当前账户有没有新的 Message 的，但由于我没有登录，所以我访问的结果是返回“非法的访问”。那么我的登录态怎么获取呢？</p>
<p data-nodeid="110779">因为我们无法得知 lagou教育生产环境上的登录接口，故我们采用另外一个办法绕过，我首先采用人工登录的方式，然后打开浏览器 console，去 Applicaton → Cookies下查看 cookies：</p>
<p data-nodeid="110780"><img src="https://s0.lgstatic.com/i/image/M00/5A/80/Ciqc1F94gZyAfOrUAAoNlT33MlE974.png" alt="Drawing 1.png" data-nodeid="111010"></p>
<p data-nodeid="110781">经过尝试，我们得出 lagou 网站用于保持登录态的两个 cookie 的 key 是 _gid 和 gate_login_token。由此，更改我们的代码如下：</p>
<pre class="lang-python" data-nodeid="110782"><code data-language="python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span>
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    url = <span class="hljs-string">'https://gate.lagou.com/v1/entry/message/newMessageList'</span>
    cookie = {<span class="hljs-string">'cookie'</span>: <span class="hljs-string">'_gid=GA1.2.438589688.1601450871; gate_login_token=475844a837230240e1e73e4ecfa34102e65fa8e5384801cca67bbe983a142abb;'</span>}
    headers = {<span class="hljs-string">'x-l-req-header'</span>: <span class="hljs-string">'{deviceType: 9}'</span>}
    s = requests.Session()
    <span class="hljs-comment"># 直接带登录态发送请求</span>
    r = s.get(url, cookies=cookie, headers=headers)
    <span class="hljs-comment"># 不经过登录，也能访问登录后才能访问的接口</span>
    print(r.text.encode(<span class="hljs-string">'utf-8'</span>))
    <span class="hljs-comment"># {"state":1,"message":"成功","content":{"newMessageList":[],"newMessageCount":0}}</span>
</code></pre>
<p data-nodeid="110783">由此看出，通过在不同接口请求中传递维持登录态的 cookies，就可以实现登录态在多个接口中的传递。</p>
<h3 data-nodeid="110784">unittest 框架集成 Requests</h3>
<p data-nodeid="110785">至此，我们已经对如何使用 Requests 发送接口请求了然于胸了。现在我把它嵌入到我们上一节讲到的 unittest 框架中去：</p>
<p data-nodeid="110786"><img src="https://s0.lgstatic.com/i/image/M00/5B/98/Ciqc1F9_zauANTCUAABZM3jMEa0315.png" alt="Lark20201009-103932.png" data-nodeid="111023"></p>
<p data-nodeid="110787">我们文件结构不变，仅仅只把原来调用 Selenium/WebDriver 的地方换成 Requests 即可。</p>
<p data-nodeid="110788">先来看下我们之前的框架文件结构：</p>
<pre class="lang-java" data-nodeid="110789"><code data-language="java">|--lagouTest
    |--tests
        |--test_baidu.py
        |--__init__.py
    |--common
        |--html_reporter.py
        |--__init__.py
    |--HTMLTestRunner.py
    |--main.py
    |--__init__.py
    |--txtReport.py
</code></pre>
<p data-nodeid="110790">其他文件不用更改，我们仅需要在 tests 文件夹下面新建一个测试接口的文件，例如 test_lagou.py，如此我们的文件结构就变成了如下：</p>
<pre class="lang-java" data-nodeid="110791"><code data-language="java">|--lagouTest
    |--tests
        |--test_baidu.py
        |--test_lagou.py
        |--__init__.py
    |--common
        |--html_reporter.py
        |--__init__.py
    |--HTMLTestRunner.py
    |--main.py
    |--__init__.py
    |--txtReport.py
</code></pre>
<p data-nodeid="110792">test_lagou.py 下的代码如下：</p>
<pre class="lang-python" data-nodeid="110793"><code data-language="python"><span class="hljs-comment"># coding=utf-8</span>
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> unittest
<span class="hljs-keyword">import</span> requests

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLaGou</span>(<span class="hljs-params">unittest.TestCase</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setUp</span>(<span class="hljs-params">self</span>):</span>
        self.s = requests.Session()
        self.url = <span class="hljs-string">'https://www.lagou.com'</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_visit_lagou</span>(<span class="hljs-params">self</span>):</span>
        result = self.s.get(self.url)
        <span class="hljs-keyword">assert</span> result.status_code == <span class="hljs-number">200</span>
        unittest.TestCase.assertIn(self, <span class="hljs-string">'拉勾'</span>, result.text)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_get_new_message</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-comment"># 此处需要一个方法登录获取登录的cookie，但因我们无法知道拉勾登录真实的API，故采用此方式登录</span>
        message_url = <span class="hljs-string">'https://gate.lagou.com/v1/entry/message/newMessageList'</span>
        cookie = {
            <span class="hljs-string">'cookie'</span>: <span class="hljs-string">'_gid=GA1.2.438589688.1601450871; gate_login_token=475844a837230240e1e73e4ecfa34102e65fa8e5384801cca67bbe983a142abb;'</span>}
        headers = {<span class="hljs-string">'x-l-req-header'</span>: <span class="hljs-string">'{deviceType: 9}'</span>}
        <span class="hljs-comment"># 直接带登录态发送请求</span>
        result = self.s.get(message_url, cookies=cookie, headers=headers)
        <span class="hljs-keyword">assert</span> result.status_code == <span class="hljs-number">200</span>
        <span class="hljs-keyword">assert</span> json.loads(result.content)[<span class="hljs-string">'message'</span>] == <span class="hljs-string">'成功'</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tearDown</span>(<span class="hljs-params">self</span>):</span>
        self.s.close()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    unittest.main(verbosity=<span class="hljs-number">2</span>)
</code></pre>
<p data-nodeid="110794">在本文件里，我们定义了一个测试类 TestLaGou，然后在 setUp 方法里初始化了 requests.Session() 对象，接着定义了两个测试用例 test_visit_lagou 和 test_get_new_message，在这两个测试用例中，分别发送不同的接口请求并且断言，最后在测试结束后关闭了这个 Session 对象。</p>
<p data-nodeid="110795">直接运行 main.py, 运行成功后，浏览器打开在项目根目录下生成的 test_report 文件，如下图所示：</p>
<p data-nodeid="110796"><img src="https://s0.lgstatic.com/i/image/M00/5A/8B/CgqCHl94ge-AdRRDAABZxh02p1w599.png" alt="Drawing 3.png" data-nodeid="111048"></p>
<p data-nodeid="110797">可以看到 test_visit_lagou 和 test_get_new_message 这两条测试用例均运行成功了。</p>
<p data-nodeid="110798">你可以看出用 unittest 集成 API 测试也非常简单？在此，给你留一个课后作业，那就是：<strong data-nodeid="111064">仔细学习下 Appium 的基础知识，然后把 Appium 和 unittest 集成起来，生成一个可用于移动端测试的自动化框架。</strong></p>
<p data-nodeid="110799">这个时候，我们再来看下，我们的测试框架变成了什么样子？</p>
<p data-nodeid="110800"><img src="https://s0.lgstatic.com/i/image/M00/5A/80/Ciqc1F94gfiAV8RRAAGrePedYyM644.png" alt="Drawing 4.png" data-nodeid="111068"></p>
<p data-nodeid="110801">（很多模块我们还没有完成，将在后续章节逐一完善）</p>
<p data-nodeid="110802">通过前面章节的学习，我们依托测试框架核心模块 unittest，快速搭建了我们的 Web 自动化测试框架、API 自动化测试框架，但我们在 unittest 的使用中，发现了如下缺点：</p>
<ul data-nodeid="110803">
<li data-nodeid="110804">
<p data-nodeid="110805">重复代码太多，比如 seUp(), tearDown() 每个测试类都需要。</p>
</li>
<li data-nodeid="110806">
<p data-nodeid="110807">unittest 数据驱动支持不好，并且不明显， case 一多就容易乱。</p>
</li>
<li data-nodeid="110808">
<p data-nodeid="110809">有一定的学习成本，例如 unittest 里的 assertIn* 语法，便是 unittest 特有的。</p>
</li>
</ul>
<p data-nodeid="110810">学过测试框架设计原则的我们都知道， 一个好的框架必须做到避免重复代码。 那么测试框架核心模块，是不是只有 unittest 一个呢？有没有更好的测试框架核心模块来解决上述问题呢？</p>
<h3 data-nodeid="110811">pytest</h3>
<p data-nodeid="110812">pytest 是一个成熟、全套的 python 自动化测试工具，旨在帮助你写出更好的程序。它可以用来做单元测试，也可以用来做功能测试、接口自动化测试；相比 unittest，它能支持更多、更全面的功能，有着以下特色和优势。</p>
<p data-nodeid="110813">直接使用纯粹的 python 语言， 不需要你过多学习框架特定的语法，例如 self.assert* 等，以此减少你的学习成本；</p>
<ul data-nodeid="113269">
<li data-nodeid="113270">
<p data-nodeid="113271">pytest 框架不需要写诸如 setUp()、tearDown() 这样的方法，它可以直接开始测试；</p>
</li>
<li data-nodeid="113272">
<p data-nodeid="113273" class="">pytest 可以自动识别测试用例，无须像 unittest 一样将测试用例放进 TestSuite 里组装；</p>
</li>
<li data-nodeid="113274">
<p data-nodeid="113275">test fixtures 包括数据参数化测试非常好用；</p>
</li>
<li data-nodeid="113276">
<p data-nodeid="113277">pytest 支持错误重试；</p>
</li>
<li data-nodeid="113278">
<p data-nodeid="113279">pytest 支持并发测试。</p>
</li>
</ul>


<p data-nodeid="110825">下面我们就一起看下，如何使用 pytest 来搭建我们的第一个接口测试框架？</p>
<p data-nodeid="110826">俗话说“不积跬步，无以至千里”。在创建我们的第一个接口测试框架之前，我们先来看下 pytest的基础用法。</p>
<h4 data-nodeid="110827">1. pytest 安装</h4>
<p data-nodeid="110828">pytest 不是 python 标准库，故使用时需要安装：</p>
<pre class="lang-python" data-nodeid="110829"><code data-language="python">pip install -U pytest
</code></pre>
<p data-nodeid="110830">安装好后，你可以再 terminal 里查看它的版本：</p>
<pre class="lang-python" data-nodeid="110831"><code data-language="python">pytest --version
<span class="hljs-comment"># pytest 6.1.0</span>
</code></pre>
<h4 data-nodeid="110832">2. pytest 简单使用</h4>
<p data-nodeid="110833">下面来看下，你的第一个 pytest 脚本怎么写：</p>
<pre class="lang-python" data-nodeid="110834"><code data-language="python"><span class="hljs-comment"># iTesting.py</span>
<span class="hljs-comment"># coding=utf-8</span>
<span class="hljs-keyword">import</span> pytest

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSample</span>(<span class="hljs-params">object</span>):</span>
    <span class="hljs-comment"># 测试用例默认以test开头</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_equal</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_not_equal</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> != <span class="hljs-number">0</span>
</code></pre>
<p data-nodeid="110835">在这个测试文件（iTesting.py）里，我定义了一个测试类 TestSample，然后在这个测试类下面定义了两个测试用例，分别是 test_equal 和 test_not_equal，下面来运行下这个测试类：</p>
<pre class="lang-powershell" data-nodeid="110836"><code data-language="powershell"><span class="hljs-comment"># 以在Windows下执行为例</span>
<span class="hljs-comment"># 假设我们的测试目录在D:\_Automation\lagouAPITest</span>
D:\_Automation\lagouAPITest&gt;python <span class="hljs-literal">-m</span> pytest iTesting.py
</code></pre>
<p data-nodeid="110837">运行后，你会看到如下结果：</p>
<pre class="lang-python" data-nodeid="110838"><code data-language="python">=== test session starts ====
platform win32 -- Python <span class="hljs-number">3.8</span><span class="hljs-number">.5</span>, pytest<span class="hljs-number">-6.1</span><span class="hljs-number">.0</span>, py<span class="hljs-number">-1.9</span><span class="hljs-number">.0</span>, pluggy<span class="hljs-number">-0.13</span><span class="hljs-number">.1</span>
rootdir: D:\_Automation\lagouAPITest
collected <span class="hljs-number">2</span> items

iTesting.py ..&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<span class="hljs-number">100</span>%]
=== <span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ====
</code></pre>
<p data-nodeid="110839">是不是非常简单？而且在整个测试中，你只需要有 python 的原生语法基础知识就好了，不需要再额外地学习。</p>
<h4 data-nodeid="110840">3. pytest 直接运行 unittest 测试用例</h4>
<p data-nodeid="110841">不仅如此，pytest 还可以兼容 unittest，原来使用 unittest 框架写的代码，可以被 pytest 直接调用。</p>
<p data-nodeid="110842">我们来看下如下 unittest 测试用例：</p>
<pre class="lang-python" data-nodeid="110843"><code data-language="python"><span class="hljs-comment"># 文件名tests/test_sample.py</span>
<span class="hljs-comment"># coding=utf-8</span>
<span class="hljs-keyword">import</span> unittest

<span class="hljs-comment">#测试类必须要继承TestCase类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSample</span>(<span class="hljs-params">unittest.TestCase</span>):</span>
    <span class="hljs-comment">#测试用例默认以test开头</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_equal</span>(<span class="hljs-params">self</span>):</span>
        self.assertEqual(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_not_equal</span>(<span class="hljs-params">self</span>):</span>
        self.assertNotEqual(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    unittest.main()
</code></pre>
<p data-nodeid="110844">在运行时，我们可以直接用如下方式调用：</p>
<pre class="lang-python" data-nodeid="110845"><code data-language="python">D:\_Automation\lagouTest&gt;python -m pytest tests/test_sample.py
</code></pre>
<p data-nodeid="110846">如果你想运行整个测试用例集，或者你想把之前用 unittest 的测试用例全部换成用 pytest 执行，该如何操作呢？</p>
<p data-nodeid="110847">我们把 main.py 文件里，所有关于执行测试用例的部分，从 unittest 执行更改为 pytest 执行，更改后的 main.py 函数如下：</p>
<pre class="lang-python" data-nodeid="110848"><code data-language="python"><span class="hljs-comment"># coding=utf-8</span>
<span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> glob
<span class="hljs-comment"># 查找所有待执行的测试用例module，见《04|必知必会，打好Python基本功》</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_modules_from_folder</span>(<span class="hljs-params">folder</span>):</span>
    absolute_f = os.path.abspath(folder)
    md = glob.glob(os.path.join(absolute_f, <span class="hljs-string">"*.py"</span>))
    <span class="hljs-keyword">return</span> [f <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> md <span class="hljs-keyword">if</span> os.path.isfile(f) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> f.endswith(<span class="hljs-string">'__init__.py'</span>)]

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># 得出测试文件夹地址</span>
    test_folder = os.path.join(os.path.dirname(__file__), <span class="hljs-string">'tests'</span>)
    <span class="hljs-comment"># 得出测试文件夹下的所有测试用例</span>
    target_file = find_modules_from_folder(test_folder)
    <span class="hljs-comment"># 直接运行所有的测试用例</span>
    pytest.main([*target_file, <span class="hljs-string">'-v'</span>])
</code></pre>
<p data-nodeid="110849">然后在命令行下执行：</p>
<pre class="lang-python" data-nodeid="110850"><code data-language="python">D:\_Automation\lagouTest&gt;python main.py
</code></pre>
<p data-nodeid="110851">你会发现，整个测试用例集用 pytest 开始执行了，执行结果如下：</p>
<p data-nodeid="110852"><img src="https://s0.lgstatic.com/i/image/M00/5A/80/Ciqc1F94giqAf8W1AAB1RPOx38c013.png" alt="Drawing 5.png" data-nodeid="111119"></p>
<p data-nodeid="110853">正因为 pytest 完全兼容 unittest，以及具备刚刚介绍的那些诸多优点，才使得 pytest 风靡于整个 python 社区。</p>
<h4 data-nodeid="110854">4. pytest 查找测试用例的原则</h4>
<p data-nodeid="110855">在我们介绍 pytest 的诸多使用方法之前，我先介绍下使用 pytest 查找测试用例的原则：</p>
<p data-nodeid="110856"><strong data-nodeid="111128">指定命令行参数时的查找原则</strong></p>
<p data-nodeid="110857">如果指定了命令行参数，则根据命令行参数执行。</p>
<p data-nodeid="110858">这句话很好理解，像我们之前的测试里，均指定了测试要执行的 module（例如 “python -m pytest tests/test_sample.py”），故 pytest 只会查找 test_sample.py 文件。</p>
<p data-nodeid="110859"><strong data-nodeid="111138">未指定命令行参数时的查找原则</strong></p>
<p data-nodeid="110860">如果未指定命令行参数（即直接在命令行输入 pytest），则从 testpath（已配置）或从当前目录开始查找可用的测试用例， 其步骤如下：</p>
<ul data-nodeid="110861">
<li data-nodeid="110862">
<p data-nodeid="110863">搜索由任何符合以下规则的文件&nbsp;test_*.py&nbsp;或&nbsp;*_test.py&nbsp;文件。</p>
</li>
<li data-nodeid="110864">
<p data-nodeid="110865">找到后，从这些文件中，收集如下测试项：test 为前缀的函数；Test 为前缀的类里面的以 test 为前缀的函数。</p>
</li>
</ul>
<p data-nodeid="110866">我们举个例子来理解下这个原则， 假设我的项目结构如下：<br>
<img src="https://s0.lgstatic.com/i/image/M00/67/E2/Ciqc1F-idzWAefg8AACJWi5QaQU000.png" alt="WechatIMG371.png" data-nodeid="111152"><br>
注意：我有一个测试文件为 sample.py，里面包括两个测试用例，然后我 tests 文件夹下有两个 .py 文件共计 4 个测试用例，如果我在命令行里输入以下命令：</p>
<pre class="lang-python" data-nodeid="110867"><code data-language="python">&nbsp;D:\_Automation\lagouTest&gt;pytest
</code></pre>
<p data-nodeid="110868">你会发现运行结果如下：</p>
<p data-nodeid="110869"><img src="https://s0.lgstatic.com/i/image/M00/5A/80/Ciqc1F94gkKAGOlHAABgpOiBFGM362.png" alt="Drawing 7.png" data-nodeid="111158"></p>
<p data-nodeid="110870">仅仅有 4 个测试用例运行了，但不包括 sample.py 里的两个测试用例，这就是 pytest 默认查找在起作用，因为运行 pytest 时，我没有指定运行某个文件，所以 pytest 自动在当前目录下查找以“test_”开头或者以“_test” 结尾的 py 文件，显然sample.py 不符合这个规则，故被忽略了。</p>
<p data-nodeid="110871">而我如果直接在命令行运行：</p>
<pre class="lang-python" data-nodeid="110872"><code data-language="python">D:\_Automation\lagouTest&gt;pytest sample.py
</code></pre>
<p data-nodeid="110873">你将看到 sample.py 里的两个测试方法都被执行了（因为指定了运行文件）。</p>
<p data-nodeid="110874"><img src="https://s0.lgstatic.com/i/image/M00/5A/8B/CgqCHl94gk2AWAstAAA-R09vUPU514.png" alt="Drawing 8.png" data-nodeid="111168"></p>
<p data-nodeid="110875">下面我们再一次更改，更改 sample.py 为 test_sample.py，然后把这个文件里的方法“test_equal”改成“equal_test”，于是项目文件结构如下：</p>
<p data-nodeid="110876"><img src="https://s0.lgstatic.com/i/image/M00/5A/8B/CgqCHl94glSAB2tlAACdqGmQ4DQ752.png" alt="Drawing 9.png" data-nodeid="111178"></p>
<p data-nodeid="110877">在命令行运行：</p>
<pre class="lang-python" data-nodeid="110878"><code data-language="python">D:\_Automation\lagouTest&gt;pytest
</code></pre>
<p data-nodeid="110879">你可以看到运行结果如下：</p>
<p data-nodeid="110880"><img src="https://s0.lgstatic.com/i/image/M00/5A/80/Ciqc1F94glyAYHH8AABaEreP5ms475.png" alt="Drawing 10.png" data-nodeid="111183"></p>
<p data-nodeid="110881">共有 5 个测试被执行，其中不包括 equal_test 方法，因为它不是以 test 开头。</p>
<h3 data-nodeid="110882">pytest 集成 Requests</h3>
<p data-nodeid="110883">知道了 pytest 如何使用，我们来看下，如何创建第一个 API 接口测试框架？</p>
<p data-nodeid="110884">首先创建我们的项目文件结构：</p>
<pre class="lang-plain" data-nodeid="110885"><code data-language="plain">|--lagouAPITest
    |--tests
        |--test_baidu.py
        |--test_lagou.py
        |--__init__.py
    |--common
        |--__init__.py
    |--__init__.py
</code></pre>
<p data-nodeid="110886">其中：</p>
<ul data-nodeid="110887">
<li data-nodeid="110888">
<p data-nodeid="110889">各个__init__.py 文件都是空文件。</p>
</li>
<li data-nodeid="110890">
<p data-nodeid="110891">tests 文件夹下的 test_baidu.py 是我们在第 7、8课时**“你的第一个 Web 测试框架”**里创建的，里面的内容我们保持不变，仍然以 unittest 作为测试框架的核心模块。</p>
</li>
<li data-nodeid="110892">
<p data-nodeid="110893">tests 文件夹下的另外一个文件 test_lagou.py 是我刚刚在<strong data-nodeid="111214">unittest 框架集成 Requests</strong>这一小节建立的，当时我们是以 unittest 作为测试框架的核心驱动模块，现在我们把它更改为由 pytest 驱动。</p>
</li>
</ul>
<p data-nodeid="110894">更改后的 test_lagou.py 文件内容如下：</p>
<pre class="lang-python" data-nodeid="110895"><code data-language="python"><span class="hljs-comment"># coding=utf-8</span>
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> requests

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLaGou</span>:</span>
    <span class="hljs-comment"># 在pytest里，针对一个类方法的setup为setup_method,</span>
    <span class="hljs-comment"># setup_method作用同unittest里的setUp()</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setup_method</span>(<span class="hljs-params">self, method</span>):</span>
        self.s = requests.Session()
        self.url = <span class="hljs-string">'https://www.lagou.com'</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_visit_lagou</span>(<span class="hljs-params">self</span>):</span>
        result = self.s.get(self.url)
        <span class="hljs-keyword">assert</span> result.status_code == <span class="hljs-number">200</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-string">'拉勾'</span> <span class="hljs-keyword">in</span> result.text
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_get_new_message</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-comment"># 此处需要一个方法登录获取登录的cookie</span>
        message_url = <span class="hljs-string">'https://gate.lagou.com/v1/entry/message/newMessageList'</span>
        cookie = {
            <span class="hljs-string">'cookie'</span>: <span class="hljs-string">'_gid=GA1.2.438589688.1601450871; gate_login_token=475844a837230240e1e73e4ecfa34102e65fa8e5384801cca67bbe983a142abb;'</span>}
        headers = {<span class="hljs-string">'x-l-req-header'</span>: <span class="hljs-string">'{deviceType: 9}'</span>}
        <span class="hljs-comment"># 直接带登录态发送请求</span>
        result = self.s.get(message_url, cookies=cookie, headers=headers)
        <span class="hljs-keyword">assert</span> result.status_code == <span class="hljs-number">200</span>
        <span class="hljs-keyword">assert</span> json.loads(result.content)[<span class="hljs-string">'message'</span>] == <span class="hljs-string">'成功'</span>
    <span class="hljs-comment"># 在pytest里，针对一个类方法的teardown为teardown_method,</span>
    <span class="hljs-comment"># teardown_method作用同unittest里的dearDown()</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">teardown_method</span>(<span class="hljs-params">self, method</span>):</span>
        self.s.close()
</code></pre>
<p data-nodeid="110896">在命令行中运行整个测试用例集：</p>
<pre class="lang-plain" data-nodeid="110897"><code data-language="plain">D:\_Automation\lagouAPITest&gt;pytest -v
</code></pre>
<p data-nodeid="110898">运行结果如下所示：</p>
<p data-nodeid="110899"><img src="https://s0.lgstatic.com/i/image/M00/5A/8B/CgqCHl94gmiAMkWPAABpsxQSdJE404.png" alt="Drawing 11.png" data-nodeid="111222"></p>
<p data-nodeid="110900">整个测试用例集的 4 条测试用例全部被 pytest 识别到并执行了（有一条 case 被人为 skip了）。由此可见，使用 pytest 集成 Requests 非常简单，我们甚至不需要定义 main.py 文件也可以运行所有的测试用例。</p>
<h3 data-nodeid="110901">小结</h3>
<p data-nodeid="110902">最后，我们回顾一下这一课时的主要内容。</p>
<p data-nodeid="115311" class="te-preview-highlight">我们知道 API 测试框架通常是通过直接请求 HTTP 接口来完成的，所以我先介绍了一个 HTTP 库—— Requests。通过上节课对 Web 自动化测试框架，我们将测试驱动模块由 Selenium/WebDriver 换成了 Requests，并借此搭建了第一个基于 unittest 的接口测试框架。但在 unittest 框架集成 Requests 的过程中，我们发现了 unittest 使用中的许多不便。</p>


<p data-nodeid="110904" class="">所以便向你介绍了另一个测试框架核心模块——pytest，简单讲解了 pytest 的安装、使用，以及 pytest 集成 Requests 的过程。下一课时我将详细讲解 pytest 的应用，以及如何生成 pytest 测试报告，将一步步带领你深入 pytest，在此过程中会带你完整搭建出一个基于 pytest 的接口自动化测试框架。</p></div>

</body></html>