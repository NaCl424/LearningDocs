<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第40讲：跟我来一起实现智能化解析算法吧</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>第40讲：跟我来一起实现智能化解析算法吧</h1><p data-nodeid="3062">在上一节课我们介绍了智能解析算法的实现原理，接下来我们就一起动手用代码来实现一下智能解析算法吧。</p>



<h3 data-nodeid="4016" class="">学习目标</h3>

<p data-nodeid="1626">这里使用的案例还是凤凰网的一篇资讯文章，链接为：<a href="http://news.ifeng.com/c/7kQcQG2peWU" data-nodeid="1757">http://news.ifeng.com/c/7kQcQG2peWU</a>，本节我们主要实现的提取字段为标题、时间、正文内容。</p>
<p data-nodeid="1627">我们会用 Python 来对上一节讲解的智能解析算法进行实现，实现新闻内容的提取。</p>
<h3 data-nodeid="4970" class="">准备工作</h3>

<p data-nodeid="6868">首先让我们将上述 URL 打开，然后在浏览器里面打开开发者工具，并打开 Elements 选项卡，最后把 HTML 代码复制下来，如图所示：</p>
<p data-nodeid="6869" class=""><img src="https://s0.lgstatic.com/i/image/M00/28/39/CgqCHl74UmGAJc3ZAAMZ_A3o4rs583.png" alt="image.png" data-nodeid="6873"></p>


<p data-nodeid="1631">复制下来之后我们把源代码保存成一个 html 文件，名字叫作 sample.html。</p>
<p data-nodeid="1632">然后我们定义如下代码，将 html 里面的字符转化成 lxml 里面的 HtmlElement 对象，代码如下：</p>
<pre class="lang-java" data-nodeid="8303"><code data-language="java">from lxml.html <span class="hljs-keyword">import</span> HtmlElement, fromstring
​
html = open(<span class="hljs-string">'sample.html'</span>, encoding=<span class="hljs-string">'utf-8'</span>).read()
element = fromstring(html=html)
</code></pre>


<p data-nodeid="1634">这里 element 对象其实就是整个网页对应的 HtmlElement 对象，其根节点就是 html，下面我们会用到它来进行页面解析，从这个 HtmlElement 对象里面提取出我们想要的时间、标题、正文内容。</p>
<h3 data-nodeid="9256" class="">时间</h3>

<p data-nodeid="1636">对于时间来说，我们这里就根据两个方面来进行提取，一个就是 meta 标签，如果里面包含了发布时间的相关信息，一般提取出来就是对的，可信度非常高，如果提取不到，那就用正则表达式来匹配一些时间规则进行提取。</p>
<p data-nodeid="1637">首先我们就来进行 meta 标签的提取，这里我们列出来了一些用来匹配发布时间的 XPath 规则，内容如下：</p>
<pre class="lang-java" data-nodeid="10687"><code data-language="java">METAS = [
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "rnews:datePublished")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "article:published_time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "og:published_time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "og:release_date")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@itemprop, "datePublished")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@itemprop, "dateUpdate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "OriginalPublicationDate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "article_date_original")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "og:time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "apub:time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "publication_date")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "sailthru.date")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "PublishDate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "publishdate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "PubDate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "pubtime")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "_pubtime")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "weibo: article:create_at")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@pubdate, "pubdate")]/@content'</span>,
]
</code></pre>


<p data-nodeid="1639">在这里我们就定义一个 extract_by_meta 的方法，它接受一个 HtmlElement 对象，定义如下：</p>
<pre class="lang-java" data-nodeid="11640"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_by_meta</span><span class="hljs-params">(element: HtmlElement)</span> -&gt; str:
 &nbsp; &nbsp;<span class="hljs-keyword">for</span> xpath in METAS:
 &nbsp; &nbsp; &nbsp; &nbsp;datetime </span>= element.xpath(xpath)
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> datetime:
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(datetime)
</code></pre>

<p data-nodeid="1641">这里我们其实就是对 METAS 进行逐个遍历，然后查找整个 HtmlElement 里面是不是有匹配的内容，比如说：</p>
<pre class="lang-java" data-nodeid="12593"><code data-language="java"><span class="hljs-comment">//meta[starts-with(@property, "og:published_time")]/@content</span>
</code></pre>

<p data-nodeid="1643">这个就是查找 meta 节点中是不是存在以 og:published_time 开头的 property 属性，如果存在，那就提取出其中的 content 属性内容。<br>
比如说我们的案例中刚好有一个 meta 节点，内容为：</p>
<pre class="lang-java" data-nodeid="13546"><code data-language="java">&lt;meta name=<span class="hljs-string">"og:time "</span> content=<span class="hljs-string">"2019-02-20 02:26:00"</span>&gt;
</code></pre>

<p data-nodeid="1645">经过处理，它会匹配到这个 XPath 表达式：</p>
<pre class="lang-java" data-nodeid="14499"><code data-language="java"><span class="hljs-comment">//meta[starts-with(@name, "og:time")]/@content</span>
</code></pre>

<p data-nodeid="15452">这样其实 extract_by_meta 方法就成功匹配到时间信息，然后提取出 2019-02-20 02:26:00 这个值了。</p>
<p data-nodeid="15453">这就相当于时间提取的第一步成功了，而且一般来说匹配到的结果可信度都是非常高的，我们可以直接将这个内容返回作为最终的提取结果即可。</p>

<p data-nodeid="1648">可是并不是所有的页面都会包含这个 meta 标签，如果不包含的话，我们还需要进行第二步的提取。</p>
<p data-nodeid="1649">下面我们再来实现第二步，也就是根据一些时间正则表达式来进行提取的方法。这里我们其实就是定义一些时间的正则表达式写法，内容如下：</p>
<pre class="lang-java" data-nodeid="16412"><code data-language="java">REGEXES = [
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[1-24]\d时[0-60]\d分)([1-24]\d时)"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[1-24]\d时[0-60]\d分)([1-24]\d时)"</span>,
 &nbsp;  ...
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2})"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2})"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}年\d{1,2}月\d{1,2}日)"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}年\d{1,2}月\d{1,2}日)"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{1,2}月\d{1,2}日)"</span>
]
</code></pre>

<p data-nodeid="1651">由于内容比较多，这里省略了部分内容。其实这里就是一些日期的常见写法格式，由于日期的写法是有限的，所以我们通过一些有限的正则表达就能进行匹配。<br>
接下来我们就定义一个正则搜索的方法，实现如下：</p>
<pre class="lang-java" data-nodeid="17365"><code data-language="java"><span class="hljs-keyword">import</span> re
​
<span class="hljs-function">def <span class="hljs-title">extract_by_regex</span><span class="hljs-params">(element: HtmlElement)</span> -&gt; str:
 &nbsp; &nbsp;text </span>= <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//text()'</span>))
 &nbsp; &nbsp;<span class="hljs-keyword">for</span> regex in REGEXES:
 &nbsp; &nbsp; &nbsp; &nbsp;result = re.search(regex, text)
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> result:
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">return</span> result.group(<span class="hljs-number">1</span>)
</code></pre>

<p data-nodeid="1653">这里我们先查找了 element 的文本内容，然后对文本内容进行正则表达式搜索，符合条件的就直接返回。<br>
最后，时间提取的方法我们直接定义为：</p>
<pre class="lang-java" data-nodeid="18318"><code data-language="java">extract_by_meta(element) <span class="hljs-function">or <span class="hljs-title">extract_by_regex</span><span class="hljs-params">(element)</span>
</span></code></pre>

<p data-nodeid="1655">即可，这样就会优先提取 meta，其次根据正则表达式提取。</p>
<h3 data-nodeid="19271" class="">标题</h3>

<p data-nodeid="1657">接下来我们来实现标题的提取，根据上节内容，标题的提取我们在这里实现三个来源的提取：</p>
<ul data-nodeid="1658">
<li data-nodeid="1659">
<p data-nodeid="1660">查找 meta 节点里面的标题信息。</p>
</li>
<li data-nodeid="1661">
<p data-nodeid="1662">查找 title 节点的标题信息。</p>
</li>
<li data-nodeid="1663">
<p data-nodeid="1664">查找 h 节点的信息。</p>
</li>
</ul>
<p data-nodeid="1665">首先就是从 meta 节点提取，其实过程还是类似的，我们定义如下的 meta 节点的 XPath 提取规则，内容如下：</p>
<pre class="lang-java" data-nodeid="20225"><code data-language="java">METAS = [
    <span class="hljs-string">'//meta[starts-with(@property, "og:title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@name, "og:title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@property, "title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@name, "title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@property, "page:title")]/@content'</span>,
]
</code></pre>

<p data-nodeid="1667">实现的提取方法也是完全一样的：</p>
<pre class="lang-java" data-nodeid="21178"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_by_meta</span><span class="hljs-params">(element: HtmlElement)</span> -&gt; str:
    <span class="hljs-keyword">for</span> xpath in METAS:
        title </span>= element.xpath(xpath)
        <span class="hljs-keyword">if</span> title:
            <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(title)
</code></pre>

<p data-nodeid="23084">关于这一部分就不再展开说明了。</p>
<p data-nodeid="23085">接下来我们还可以提取 title 和 h 节点的信息，通过基本的 XPath 表达式就可以实现，代码如下：</p>

<pre class="lang-java" data-nodeid="22131"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_by_title</span><span class="hljs-params">(element: HtmlElement)</span>:
    return ''.<span class="hljs-title">join</span><span class="hljs-params">(element.xpath(<span class="hljs-string">'//title//text()'</span>)</span>).<span class="hljs-title">strip</span><span class="hljs-params">()</span>
def <span class="hljs-title">extract_by_h</span><span class="hljs-params">(element: HtmlElement)</span>:
    return ''.<span class="hljs-title">join</span><span class="hljs-params">(
        element.xpath(<span class="hljs-string">'(//h1//text() | //h2//text() | //h3//text())'</span>)</span>).<span class="hljs-title">strip</span><span class="hljs-params">()</span>
</span></code></pre>

<p data-nodeid="24040">这里我们提取了 title、h1~h3 节点的信息，然后返回了它们的纯文本内容。</p>
<p data-nodeid="24041">紧接着，我们分别调用以下这三个方法，看看针对这个案例，其结果是怎样的，调用如下：</p>

<pre class="lang-yaml" data-nodeid="44535"><code data-language="yaml"><span class="hljs-string">title_extracted_by_meta</span> <span class="hljs-string">=</span> <span class="hljs-string">extract_by_meta(element)</span>
<span class="hljs-string">title_extracted_by_h</span> <span class="hljs-string">=</span> <span class="hljs-string">extract_by_h(element)</span>
<span class="hljs-string">title_extracted_by_title</span> <span class="hljs-string">=</span> <span class="hljs-string">extract_by_title(element)</span>
</code></pre>


<p data-nodeid="1673">运行结果如下：</p>
<pre class="lang-yaml" data-nodeid="43582"><code data-language="yaml"><span class="hljs-string">title_extracted_by_meta</span> <span class="hljs-string">故宫，你低调点！故宫：不，实力已不允许我继续低调</span>
<span class="hljs-string">title_extracted_by_h</span> <span class="hljs-string">故宫，你低调点！故宫：不，实力已不允许我继续低调为您推荐精品有声好书精选</span>
<span class="hljs-string">title_extracted_by_title</span> <span class="hljs-string">故宫，你低调点！故宫：不，实力已不允许我继续低调_凤凰网资讯_凤凰网</span>
</code></pre>




















<p data-nodeid="45488">这里我们观察到，三个方法都返回了差不多的结果，但是后缀还是不太一样。</p>
<p data-nodeid="45489">title_extracted_by_meta 实际上是完全正确的内容，可以直接返回，一般来说，它的可信度也非常高，如果匹配到，那就直接返回就好了。</p>

<p data-nodeid="1676">但是如果不存在 title_extracted_by_meta 的结果呢？那只能靠 title_extracted_by_title 和 title_extracted_by_h 了。</p>
<p data-nodeid="1677">这里我们观察到 title_extracted_by_title 和 title_extracted_by_h 包含一些冗余信息，仔细想想确实是这样的，因为 title 一般来说会再加上网站的名称，而 h 节点众多，通常会包含很多噪音。</p>
<p data-nodeid="1678">这里我们可以提取它们的公共连续内容其实就好了，这里用到一个算法，就是最长连续公共子串，即 Longest Common String，这里我们直接借助于 Python 的 difflib 库来实现即可，如果你感兴趣的话也可以手动实现一下。</p>
<p data-nodeid="1679">这里我们的实现如下：</p>
<pre class="lang-java" data-nodeid="51215"><code data-language="java"><span class="hljs-function">from difflib <span class="hljs-keyword">import</span> SequenceMatcher
def <span class="hljs-title">lcs</span><span class="hljs-params">(a, b)</span>:
    match </span>= SequenceMatcher(None, a, b).find_longest_match(<span class="hljs-number">0</span>, len(a), <span class="hljs-number">0</span>, len(b))
    <span class="hljs-keyword">return</span> a[match[<span class="hljs-number">0</span>]: match[<span class="hljs-number">0</span>] + match[<span class="hljs-number">2</span>]]
</code></pre>






<p data-nodeid="52168">这里定义了一个 lcs 方法，它接收两个字符串类型的参数，比如 <code data-backticks="1" data-nodeid="52171">abcd</code> 和 <code data-backticks="1" data-nodeid="52173">bcde</code>，那么它的返回结果就是它们的公共部分，即 <code data-backticks="1" data-nodeid="52175">bcd</code>。</p>
<p data-nodeid="52169">好，那么对于 title_extracted_by_title 和 title_extracted_by_h，我们调用下 lcs 方法就好了，实现如下：</p>

<pre class="lang-java" data-nodeid="53142"><code data-language="java">lcs(title_extracted_by_title, title_extracted_by_h)
</code></pre>

<p data-nodeid="1683">最终我们可以把标题的提取定义成一个方法，实现如下：</p>
<pre class="lang-java" data-nodeid="54095"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_title</span><span class="hljs-params">(element: HtmlElement)</span>:
    title_extracted_by_meta </span>= extract_by_meta(element)
    title_extracted_by_h = extract_by_h(element)
    title_extracted_by_title = extract_by_title(element)
    <span class="hljs-keyword">if</span> title_extracted_by_meta:
        <span class="hljs-keyword">return</span> title_extracted_by_meta
    <span class="hljs-keyword">if</span> title_extracted_by_title and title_extracted_by_h:
        <span class="hljs-keyword">return</span> lcs(title_extracted_by_title, title_extracted_by_h)
    <span class="hljs-keyword">if</span> title_extracted_by_title:
        <span class="hljs-keyword">return</span> title_extracted_by_title
    <span class="hljs-keyword">return</span> title_extracted_by_h
</code></pre>

<p data-nodeid="1685">这里我们就定义了一些优先级判定逻辑，如：</p>
<ul data-nodeid="1686">
<li data-nodeid="1687">
<p data-nodeid="1688">如果存在 title_extracted_by_meta，由于其可信度非常高，直接返回即可。</p>
</li>
<li data-nodeid="1689">
<p data-nodeid="1690">如果不存在 title_extracted_by_meta，而 title_extracted_by_title 和 title_extracted_by_h 同时存在，取二者的最长公共子串返回即可。</p>
</li>
<li data-nodeid="1691">
<p data-nodeid="1692">如果上述条件不成立， title_extracted_by_title 存在，返回 title_extracted_by_title 即可。</p>
</li>
<li data-nodeid="1693">
<p data-nodeid="1694">如果上述条件不成立，只能返回 title_extracted_by_h 了。</p>
</li>
</ul>
<p data-nodeid="1695">以上就是我们的标题提取逻辑。</p>
<h3 data-nodeid="55048" class="">正文</h3>

<p data-nodeid="1697">接下来终于轮到重头戏，正文提取了。在上一节课我们介绍了利用文本密度和符号密度进行提取的方法，下面我们就来实现一下吧。</p>
<p data-nodeid="1698">正文的提取需要我们做一些预处理工作，比如一个 html 标签内有很多噪音，非常影响正文的提取，比如说 script、style 这些内容，一定不会包含正文，但是它们会严重影响文本密度的计算，所以这里我们先定义一个预处理操作。</p>
<pre class="lang-java" data-nodeid="56002"><code data-language="java">from lxml.html <span class="hljs-keyword">import</span> HtmlElement, etree
CONTENT_USELESS_TAGS = [<span class="hljs-string">'meta'</span>, <span class="hljs-string">'style'</span>, <span class="hljs-string">'script'</span>, <span class="hljs-string">'link'</span>, <span class="hljs-string">'video'</span>, <span class="hljs-string">'audio'</span>, <span class="hljs-string">'iframe'</span>, <span class="hljs-string">'source'</span>, <span class="hljs-string">'svg'</span>, <span class="hljs-string">'path'</span>,
                        <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'img'</span>]
CONTENT_STRIP_TAGS = [<span class="hljs-string">'span'</span>, <span class="hljs-string">'blockquote'</span>]
CONTENT_NOISE_XPATHS = [
    <span class="hljs-string">'//div[contains(@class, "comment")]'</span>,
    <span class="hljs-string">'//div[contains(@class, "advertisement")]'</span>,
    <span class="hljs-string">'//div[contains(@class, "advert")]'</span>,
    <span class="hljs-string">'//div[contains(@style, "display: none")]'</span>,
]

<span class="hljs-function">def <span class="hljs-title">preprocess4content</span><span class="hljs-params">(element: HtmlElement)</span>:
    # remove tag and its content
    etree.<span class="hljs-title">strip_elements</span><span class="hljs-params">(element, *CONTENT_USELESS_TAGS)</span>
    # only move tag pair
    etree.<span class="hljs-title">strip_tags</span><span class="hljs-params">(element, *CONTENT_STRIP_TAGS)</span>
    # remove noise tags
    <span class="hljs-title">remove_children</span><span class="hljs-params">(element, CONTENT_NOISE_XPATHS)</span>
    
    <span class="hljs-keyword">for</span> child in <span class="hljs-title">children</span><span class="hljs-params">(element)</span>:
        
        # merge text in span or strong to parent p tag
        <span class="hljs-keyword">if</span> child.tag.<span class="hljs-title">lower</span><span class="hljs-params">()</span> </span>== <span class="hljs-string">'p'</span>:
            etree.strip_tags(child, <span class="hljs-string">'span'</span>)
            etree.strip_tags(child, <span class="hljs-string">'strong'</span>)
            
            <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">not</span> <span class="hljs-params">(child.text and child.text.strip()</span>):
                <span class="hljs-title">remove_element</span><span class="hljs-params">(child)</span>
        
        # <span class="hljs-keyword">if</span> a div tag does not contain any sub node, it could be converted to p node.
        <span class="hljs-keyword">if</span> child.tag.<span class="hljs-title">lower</span><span class="hljs-params">()</span> </span>== <span class="hljs-string">'div'</span> and not child.getchildren():
            child.tag = <span class="hljs-string">'p'</span>
</code></pre>

<p data-nodeid="1700">这里我们定义了一些规则，比如 CONTENT_USELESS_TAGS 代表一些噪音节点，可以直接调用 strip_elements 把整个节点和它的内容删除。<br>
另外定义了 CONTENT_STRIP_TAGS ，这些节点文本内容需要保留，但是它的标签是可以删掉的。</p>
<p data-nodeid="1701">另外我们还定义了 CONTENT_NOISE_XPATHS，这是一些很明显不是正文的节点，如评论、广告等，直接移除就好。</p>
<p data-nodeid="1702">这里还依赖于几个工具方法，定义如下：</p>
<pre class="lang-java" data-nodeid="56955"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">remove_element</span><span class="hljs-params">(element: HtmlElement)</span>:
    parent </span>= element.getparent()
    <span class="hljs-keyword">if</span> parent is not None:
        parent.remove(element)
<span class="hljs-function">def <span class="hljs-title">remove_children</span><span class="hljs-params">(element: HtmlElement, xpaths=None)</span>:
    <span class="hljs-keyword">if</span> not xpaths:
        return
    <span class="hljs-keyword">for</span> xpath in xpaths:
        nodes </span>= element.xpath(xpath)
        <span class="hljs-keyword">for</span> node in nodes:
            remove_element(node)
    <span class="hljs-keyword">return</span> <span class="hljs-function">element
def <span class="hljs-title">children</span><span class="hljs-params">(element: HtmlElement)</span>:
    yield element
    <span class="hljs-keyword">for</span> child_element in element:
        <span class="hljs-keyword">if</span> <span class="hljs-title">isinstance</span><span class="hljs-params">(child_element, HtmlElement)</span>:
            yield from <span class="hljs-title">children</span><span class="hljs-params">(child_element)</span>
</span></code></pre>

<p data-nodeid="57908">另外对于一些节点我们还做了特殊处理，如 p 节点内部的 span、strong 节点去掉标签，只留内容。如果是 div 节点，而且没有子节点了，那么可以换成 p 节点。</p>
<p data-nodeid="57909">当然还有一些细节的处理，你如果想到了可以继续优化。预处理完毕之后，整个 element 就比较规整了，去除了很多噪声和干扰数据。</p>

<p data-nodeid="1705">接下来我们就来实现文本密度和符号密度的计算吧。为了方便处理，这里我把节点定义成了一个 Python Object，名字叫作 ElementInfo，它里面有很多字段，代表了某一个节点的信息，比如文本密度、符号密度等，定义如下：</p>
<pre class="lang-dart" data-nodeid="63629"><code data-language="dart">from lxml.html <span class="hljs-keyword">import</span> HtmlElement
from pydantic <span class="hljs-keyword">import</span> BaseModel
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementInfo</span>(<span class="hljs-title">BaseModel</span>):
    <span class="hljs-title">id</span>: <span class="hljs-title">int</span> = <span class="hljs-title">None</span>
    <span class="hljs-title">tag_name</span>: <span class="hljs-title">str</span> = <span class="hljs-title">None</span>
    <span class="hljs-title">element</span>: <span class="hljs-title">HtmlElement</span> = <span class="hljs-title">None</span>
    <span class="hljs-title">number_of_char</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_linked_char</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_tag</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_linked_tag</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_p_tag</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_punctuation</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">density_of_punctuation</span>: <span class="hljs-title">int</span> = 1
    <span class="hljs-title">density_of_text</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">density_score</span>: <span class="hljs-title">int</span> = 0
    
    <span class="hljs-title">class</span> <span class="hljs-title">Config</span>:
        <span class="hljs-title">arbitrary_types_allowed</span> = <span class="hljs-title">True</span>
</span></code></pre>






<p data-nodeid="1707">这里我们定义了几个字段。</p>
<ul data-nodeid="1708">
<li data-nodeid="1709">
<p data-nodeid="1710">id：节点的唯一 id。</p>
</li>
<li data-nodeid="1711">
<p data-nodeid="1712">tag_name：节点的标签值，如 p、div、img 等。</p>
</li>
<li data-nodeid="1713">
<p data-nodeid="1714">element：节点对应的 HtmlElement 对象。</p>
</li>
<li data-nodeid="1715">
<p data-nodeid="1716">number_of_char：节点的总字符数。</p>
</li>
<li data-nodeid="1717">
<p data-nodeid="1718">number_of_linked_char：节点带超链接的字符数。</p>
</li>
<li data-nodeid="1719">
<p data-nodeid="1720">number_of_tag：节点的标签数。</p>
</li>
<li data-nodeid="1721">
<p data-nodeid="1722">number_of_linked_tag：节点的带链接的标签数，即 a 的标签数。</p>
</li>
<li data-nodeid="1723">
<p data-nodeid="1724">number_of_p_tag：节点的 p 标签数。</p>
</li>
<li data-nodeid="1725">
<p data-nodeid="1726">number_of_punctuation：节点包含的标点符号数。</p>
</li>
<li data-nodeid="1727">
<p data-nodeid="1728">density_of_punctuation：节点的符号密度。</p>
</li>
<li data-nodeid="1729">
<p data-nodeid="1730">density_of_text：节点的文本密度。</p>
</li>
<li data-nodeid="1731">
<p data-nodeid="1732">density_score：最终评分。</p>
</li>
</ul>
<p data-nodeid="1733">好，下面我们要做的就是对整个 HTML 的所有节点进行处理，然后得到每个节点的信息，实现如下：</p>
<pre class="lang-dart" data-nodeid="71253"><code data-language="dart"># start to evaluate every child element
element_infos = []
child_elements = children_of_body(element)
<span class="hljs-keyword">for</span> child_element <span class="hljs-keyword">in</span> child_elements:
    # <span class="hljs-keyword">new</span> element info
    element_info = ElementInfo()
    element_info.element = child_element
    element_info = fill_element_info(element_info)
    element_infos.append(element_info)
</code></pre>








<p data-nodeid="72206">这里我们先调用了 children_of_body 获取了最初 element 节点的所有子节点，然后对节点进行处理。</p>
<p data-nodeid="72207">其中这里依赖 children_of_body 和 fill_element_info 方法，分别是获取所有 body 内的子节点（包括 body）以及计算节点信息，实现如下：</p>

<pre class="lang-dart" data-nodeid="82704"><code data-language="dart">def children_of_body(element: HtmlElement):
    body_xpath = <span class="hljs-string">'//body'</span>
    elements = element.xpath(body_xpath)
    <span class="hljs-keyword">if</span> elements:
        <span class="hljs-keyword">return</span> children(elements[<span class="hljs-number">0</span>])
    <span class="hljs-keyword">return</span> []

def fill_element_info(element_info: ElementInfo):
    element = element_info.element
    
    # fill id
    element_info.id = hash(element)
    element_info.tag_name = element.tag
    
    # fill number_of_char
    element_info.number_of_char = number_of_char(element)
    element_info.number_of_linked_char = number_of_linked_char(element)
    element_info.number_of_tag = number_of_tag(element)
    element_info.number_of_linked_tag = number_of_linked_tag(element)
    element_info.number_of_p_tag = number_of_p_tag(element)
    element_info.number_of_punctuation = number_of_punctuation(element)
    
    # fill density
    element_info.density_of_text = density_of_text(element_info)
    element_info.density_of_punctuation = density_of_punctuation(element_info)
    <span class="hljs-keyword">return</span> element_info
</code></pre>











<p data-nodeid="1737">这里 fill_element_info 方法非常重要，其实就是填充了 element_info 的几乎所有指标信息，这里又依赖了 number_of_char、number_of_linked_char、number_of_tag、number_of_linked_tag、number_of_p_tag、number_of_punctuation、density_of_text、density_of_punctuation 方法，实现如下：</p>
<pre class="lang-dart" data-nodeid="93187"><code data-language="dart">def number_of_char(element: HtmlElement):
    text = <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//text()'</span>))
    text = re.sub(<span class="hljs-string">r'\s*'</span>, <span class="hljs-string">''</span>, text, flags=re.S)
    <span class="hljs-keyword">return</span> len(text)

def number_of_linked_char(element: HtmlElement):
    text = <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//a//text()'</span>))
    text = re.sub(<span class="hljs-string">r'\s*'</span>, <span class="hljs-string">''</span>, text, flags=re.S)
    <span class="hljs-keyword">return</span> len(text)

def number_of_tag(element: HtmlElement):
    <span class="hljs-keyword">return</span> len(element.xpath(<span class="hljs-string">'.//*'</span>))

def number_of_p_tag(element: HtmlElement):
    <span class="hljs-keyword">return</span> len(element.xpath(<span class="hljs-string">'.//p'</span>))

def number_of_linked_tag(element: HtmlElement):
    <span class="hljs-keyword">return</span> len(element.xpath(<span class="hljs-string">'.//a'</span>))

def density_of_text(element_info: ElementInfo):
    # <span class="hljs-keyword">if</span> denominator <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>, just <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> element_info.number_of_tag - element_info.number_of_linked_tag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">return</span> (element_info.number_of_char - element_info.number_of_linked_char) / \
           (element_info.number_of_tag - element_info.number_of_linked_tag)

def density_of_punctuation(element_info: ElementInfo):
    result = (element_info.number_of_char - element_info.number_of_linked_char) / \
             (element_info.number_of_punctuation + <span class="hljs-number">1</span>)
    # result should not be zero
    <span class="hljs-keyword">return</span> result or <span class="hljs-number">1</span>

def number_of_punctuation(element: HtmlElement):
    text = <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//text()'</span>))
    text = re.sub(<span class="hljs-string">r'\s*'</span>, <span class="hljs-string">''</span>, text, flags=re.S)
    punctuations = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> text <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> PUNCTUATION]
    <span class="hljs-keyword">return</span> len(punctuations)
</code></pre>











<p data-nodeid="94140">这里比较重要的就是 density_of_text 和 density_of_punctuation 两个方法了，分别代表文本密度和符号密度，其算法原理在上一节已经提到了，可以参考论文《洪鸿辉，等 基于文本富豪密度的网页正文提取方法》的内容。</p>
<p data-nodeid="94141">好，这样我们运行完毕之后，就可以得到每个节点的各个指标啦。最后，我们继续参考论文《洪鸿辉，等 基于文本富豪密度的网页正文提取方法》的公式，根据各个指标计算每个节点的得分情况，最后提取内容即可：</p>

<pre class="lang-dart" data-nodeid="107493"><code data-language="dart"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
# start to evaluate every child element
element_infos = []
child_elements = children_of_body(element)
<span class="hljs-keyword">for</span> child_element <span class="hljs-keyword">in</span> child_elements:
    # <span class="hljs-keyword">new</span> element info
    element_info = ElementInfo()
    element_info.element = child_element
    element_info = fill_element_info(element_info)
    element_infos.append(element_info)
    # <span class="hljs-keyword">get</span> std of density_of_text among all elements
    density_of_text = [element_info.density_of_text <span class="hljs-keyword">for</span> element_info <span class="hljs-keyword">in</span> element_infos]
    density_of_text_std = np.std(density_of_text, ddof=<span class="hljs-number">1</span>)
    # <span class="hljs-keyword">get</span> density_score of every element
    <span class="hljs-keyword">for</span> element_info <span class="hljs-keyword">in</span> element_infos:
        score = np.log(density_of_text_std) * \
                element_info.density_of_text * \
                np.log10(element_info.number_of_p_tag + <span class="hljs-number">2</span>) * \
                np.log(element_info.density_of_punctuation)
        element_info.density_score = score
    # sort element info by density_score
    element_infos = sorted(element_infos, key=lambda x: x.density_score, reverse=True)
    element_info_first = element_infos[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> element_infos <span class="hljs-keyword">else</span> None
    text = <span class="hljs-string">'\n'</span>.join(element_info_first.element.xpath(<span class="hljs-string">'.//p//text()'</span>))
</code></pre>














<p data-nodeid="108446">这里我们首先计算了 density_of_text 的标准差，然后对各个节点计算了最终的密度得分，最后排序得到最高的节点，获取文本值即可。</p>
<p data-nodeid="108447">运行结果如下：</p>

<pre class="lang-java" data-nodeid="109406"><code data-language="java"><span class="hljs-string">"“我的名字叫紫禁城，快要600岁了，这上元的夜啊，总是让我沉醉，这么久了却从未停止。”\n“重檐之上的月光，曾照进古人的宫殿；城墙上绵延的灯彩，映出了角楼的瑰丽。今夜，一群博物馆人将我点一段话。\n半小时后，“紫禁城上元之夜”的灯光点亮了北京夜空。\n午门城楼及东西雁翅楼用白、黄、红三种颜色光源装扮！\n太和门广场变成了超大的夜景灯光秀场！\n图片来源：东方IC 版权作品 请勿转载\n午门城宫博物院供图\n故宫的角楼被灯光装点出满满的节日气氛！\n故宫博物院供图\n令人惊叹的是，故宫的“网红”藏品《清明上河图》《千里江山图卷》在“灯会”中展开画卷。\n灯光版《清明上河图》\n以灯为笔，以屋顶为，故宫博物院最北端神武门也被灯光点亮！\n故宫博物院供图\n上元之夜，故宫邀请了劳动模范、北京榜样、快递小哥、环卫工人、解放军和武警官兵、消防指战员、公安干警等各界代表以及预约成功的观众，共3000人故宫博物院供图\n时间退回到两天前，故宫博物院发布了2月19日(正月十五)、20日(正月十六)即将举办“紫禁城上元之夜”文化活动的消息。\n图片来源：视觉中国\n18日凌晨，一众网友前往故宫博物院官网抢票，网站甚节就有诸多讲究。\n有灯无月不娱人，有月无灯不算春。\n春到人间人似玉，灯烧月下月如怠。\n满街珠翠游村女，沸地笙歌赛社神。\n不展芳尊开口笑，如何消得此良辰。\n——唐伯虎《元宵》\n明代宫中过上元节，皇宵节晚会”。\n2月18日，北京故宫午门调试灯光。中新社记者 杜洋 摄\n其中，灯戏颇为有趣。由多人舞灯拼出吉祥文字及图案，每人手执彩灯、身着不同颜色的服装，翩翩起舞，类似于现代的大型团体操表演。\n但这紫禁城，恭亲王奕 与英法联军交换了《天津条约》批准书，并订立《中英北京条约》《中法北京条约》作为补充。\n战争结束了，侵略者摇身一变成了游客。一位外国“摄影师”拍下了当年的紫禁城，并在日记里写到，百年。\n直到上世纪40年代时，故宫的环境仍然并不是想象中的博物馆的状态。\n曾有故宫博物院工作人员撰文回忆，当时的故宫内杂草丛生，房倒屋漏，有屋顶竟长出了树木。光是清理当时宫中存留的垃圾、杂草就用单霁翔到任故宫院长。那时，他拿到的故宫博物院介绍，写了这座博物馆诸多的“世界之最”。\n可他觉得，当自己真正走到观众中间，这些“世界之最”都没有了。\n2月18日，北京故宫午门调试灯光。中新社记者 杜洋 摄外环境进行了大整治。\n游客没有地方休息，那就拆除了宫中的临时建筑、新增供游客休息的椅子；\n游客排队上厕所，那就将一个职工食堂都改成了洗手间；\n游客买票难，那就全面采用电子购票，新增多个售票点；馆。\n今年，持续整个正月的“过大年”展览和“紫禁城上元之夜”，让本该是淡季的故宫变得一票难求。\n在不少普通人眼中，近600岁的故宫正变得越来越年轻。\n资料图：故宫博物院院长单霁翔。中新社记者 刘关关 摄元宵节活动进行评估后，或结合二十四节气等重要时间节点推出夜场活动。\n你期待吗？\n作者：上官云 宋宇晟"</span>
</code></pre>

<p data-nodeid="1743">可以看到，正文就被成功提取出来了。</p>
<h3 data-nodeid="110359" class="">整理</h3>

<p data-nodeid="1745">最后整理一下，三者结果合并，输出为 JSON 格式，实现如下：</p>
<pre class="lang-java" data-nodeid="111313"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract</span><span class="hljs-params">(html)</span>:
    return </span>{
        <span class="hljs-string">'title'</span>: extract_title(html),
        <span class="hljs-string">'datetime'</span>: extract_datetime(html),
        <span class="hljs-string">'content'</span>: extract_content(html)
    }
</code></pre>

<p data-nodeid="113212">最后，我们可以看到类似的输出效果，内容如下：</p>
<p data-nodeid="113213" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/28/3D/CgqCHl74VdaATYm8AAKNT19ZZkg888.png" alt="image (1).png" data-nodeid="113221"></p>


<p data-nodeid="1748">到此为止，我们就成功提取出来了标题、时间和正文内容并输出为 JSON 格式了。其他的一些字段相对没有那么重要，你可以根据类似的方法来进行提取和实验。</p>
<p data-nodeid="1749">本节代码：<a href="https://github.com/Gerapy/GerapyAutoExtractor" data-nodeid="2100">https://github.com/Gerapy/GerapyAutoExtractor</a>。</p></div>

</body></html>