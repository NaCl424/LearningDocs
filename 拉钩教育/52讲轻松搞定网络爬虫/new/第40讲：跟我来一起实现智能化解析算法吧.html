<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第40讲：跟我来一起实现智能化解析算法吧</title>
<style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style><style type="text/css">/*
 * Copyright (C) 2018 Drake, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

:root {
    --monospace: "JetBrains Mono", HYZhengYuan, "Fira Code", Menlo, "Ubuntu Mono", Consolas; /*code font*/
    --text-font: var(--monospace); /*default font*/
    --title-font: var(--monospace); /*title font*/

    --text-color: #333333;
    --bg-color: #ffffff;
    --control-text-color: var(--text-color);
    --meta-content-color: var(--text-color);
    --active-file-border-color: var(--drake-accent);
    --rawblock-edit-panel-bd: var(--code-block-bg-color);
    --item-hover-bg-color: #E5E5E596;
    --active-file-bg-color: var(--item-hover-bg-color);

    --drake-accent: #e95f59;
    --drake-highlight: #d63200;
    --a-color: #036aca;
    --variable-color: var(--drake-highlight);
    --outline-active-color: var(--a-color);
    --code-block-bg-color: #2b2b2b;
    --code-block-color: #A9B7C6;
    --title-color: #135ce0;
    --blockquote-border-color: #b2aec5;
    --blockquote-color: #595959;
    --blockquote-bg-color: #fff9f9;
    --strong-color: var(--title-color);
    --h2-underline-color: var(--title-color);
    --horizontal-divider-color: var(--title-color);
    --height-light-color: var(--drake-highlight);
    --height-light-border-color: var(--drake-highlight);
    --yaml-color: #777777;
    --yaml-bg-color: #f7f7f7;
    --footnotes-bg-color: #3c3d3e;
    --footnotes-highlight: #FFD760;
    --table-border-color: #dfe2e5;
    --table-header-bg-color: #f6f8fa;
    --table-bg-color: var(--bg-color);
    --table-n2-bg-color: #f6f8fa;
    --input-bg-color: var(--item-hover-bg-color);
    --btn-hover-bg-color: var(--item-hover-bg-color);
    --checkbox-checked: url("data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cpath d='M425.984 726.016l384-384-59.99-61.995-324.01 324.011-152.021-152.021L213.973 512zm384-598.016q36.01 0 61.013 25.984T896 213.974v596.01q0 34.005-25.003 59.99t-61.013 25.983h-596.01q-36.011 0-61.014-25.984t-25.003-59.989v-596.01q0-34.006 25.003-59.99T213.973 128h596.011z' fill='%2365b73b'/%3E%3C/svg%3E");
    --checkbox-unchecked: url("data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cpath d='M810.667 213.333v597.334H213.333V213.333h597.334m0-85.333H213.333C166.4 128 128 166.4 128 213.333v597.334C128 857.6 166.4 896 213.333 896h597.334C857.6 896 896 857.6 896 810.667V213.333C896 166.4 857.6 128 810.667 128z' fill='%23333333'/%3E%3C/svg%3E");
}

html {
    font-size: 15px;
}

body {
    font-family: var(--text-font) !important;
    color: var(--text-color);
    -webkit-font-feature-settings: "liga" on, "calt" on;
    -webkit-font-smoothing: subpixel-antialiased;
    text-rendering: optimizeLegibility;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
    line-height: 1.8rem;
}

img {
    max-width: 100%;
}

#write {
    background-image: linear-gradient(
            90deg
            ,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(
            1turn
            ,rgba(60,10,30,.04) 3%,transparent 0);
    background-size: 20px 20px;
    background-position: 50%;
}

/*code block*/
#write .md-fences {
    font-size: 1rem;
    padding: 0.5rem !important;
    border-radius: 2px;
    word-wrap: normal;
    background-color: var(--code-block-bg-color);
    color: var(--code-block-color);
    border: none;
}

/*code snippet*/
#write code, tt {
    border-radius: 2px;
    color: var(--drake-highlight);
}

/*variable*/
var {
    color: var(--variable-color);
    font-weight: bold;
}

/*raw block*/
.md-rawblock-control:not(.md-rawblock-tooltip) {
    border-radius: 2px 0 2px 2px;
    padding: 0.2rem !important;
}
.md-rawblock:hover > .md-rawblock-container {
    background: none;
}
.md-rawblock-input {
    font-size: 1rem;
}
.md-rawblock-tooltip-btn:hover {
    background: none;
}
.md-rawblock:hover > .md-rawblock-tooltip {
    border-radius: 2px 2px 0 0;
    margin-bottom: 2px !important;
}
.md-rawblock-tooltip.md-rawblock-control {
    border-radius: 2px 2px 0 0;
    color: var(--code-block-color);
}
.md-rawblock-tooltip-name {
    color: var(--code-block-color);
    opacity: 1;
}

/*quote block*/
blockquote:before {
    display: block;
    position: absolute;
    content: '';
    width: 4px;
    left: 0;
    top: 0;
    height: 100%;
    background-color: var(--blockquote-border-color);
    border-radius: 2px;
}

blockquote {
    color: var(--blockquote-color);
    border-radius: 2px;
    padding: 10px 16px;
    background-color: var(--blockquote-bg-color);
    position: relative;
    border-left: none;
}

#write strong {
    color: var(--strong-color);
    font-weight: bold;
}
#write blockquote strong {
    color: var(--blockquote-color);
}

/*link*/
#write a {
    color: var(--a-color);
    text-decoration: none;
}
#write a .md-plain, .md-htmlblock-container a:hover {
    border-bottom: .1rem solid var(--a-color);
}
[md-inline=link] a {
    margin: 0 .2rem;
}
a:any-link {
    color: var(--a-color);
}

img {
    border-left: none;
    border-right: none;
    vertical-align: baseline;
    border-radius: 2px;
}

#write {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px 30px 100px;
}
#typora-source .CodeMirror-lines {
    max-width: 1200px;
}

#write p {
    word-spacing: .05rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    font-family: var(--title-font);
    position: relative;
    margin-top: 2rem;
    margin-bottom: 1rem;
    font-weight: bold;
    cursor: text;
    color: var(--title-color);
}

h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before {
    visibility: hidden;
}

h1 {
    font-size: 1.6rem;
    text-align: center;
    margin-top: 0;
}

h2.md-end-block.md-heading {
    font-size: 1.6rem;
    display: inline-block;
}

h2.md-end-block.md-heading:after {
    display: block;
    content: '';
    height: 2px;
    margin-top: 4px;
    background-color: var(--h2-underline-color);
    border-radius: 2px;
}

h3 {
    font-size: 1.4rem;
}

h4 {
    font-size: 1.2rem;
}

h5 {
    font-size: 1rem;
}

h6 {
    font-size: 1rem;
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}

h2 tt,
h2 code {
    font-size: inherit !important;
}

h3 tt,
h3 code {
    font-size: inherit !important;
}

h4 tt,
h4 code {
    font-size: inherit !important;
}

h5 tt,
h5 code {
    font-size: inherit !important;
}

h6 tt,
h6 code {
    font-size: inherit !important;
}

blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}
p {
    margin: 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: var(--horizontal-divider-color);
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul, ol {
    padding-inline-start: 2em;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

table {
    padding: 0;
    word-break: initial;
    background-color: var(--table-bg-color);
}
table tr {
    border-top: .1em solid var(--table-border-color);
    margin: 0;
    padding: 0;
}
table th {
    font-weight: bold;
    border: .1em solid var(--table-border-color);
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table td {
    border: .1em solid var(--table-border-color);
    margin: 0;
    padding: 6px 13px;
}
table thead {
    background-color: var(--table-header-bg-color);
}
table tr:nth-child(2n) {
    background-color: var(--table-n2-bg-color);
}
table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

#write em {
    padding: 0 5px 0 2px;
}

/* height light */
#write mark {
    border: .1em solid var(--height-light-border-color);
    color: var(--height-light-color);
    background-color: transparent;
    padding: .1rem .5rem;
    border-radius: 2rem;
    margin: 0 .2rem;
    font-size: .95rem;
}

/*shortcut*/
kbd {
    border: .1em solid #5b5b5e;
    background: transparent;
    color: var(--text-color);
    margin: 0 .4rem;
    font-size: .95rem;
    padding: .3em .4em;
    border-radius: .4em;
    vertical-align: top;
    box-shadow: .1em .1em .2em rgba(0, 0, 0, 0.3);
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 12px;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

/*YAML*/
#write pre.md-meta-block {
    padding: 1rem;
    font-size: 1rem;
    background-color: var(--yaml-bg-color);
    border: 0;
    border-radius: 2px;
    color: var(--yaml-color);
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

#write > h3.md-focus:before {
    left: -1.5625rem;
    top: .375rem;
}

#write > h4.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h5.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h6.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

.md-image > .md-meta {
    border-radius: 2px;
    font-family: initial;
    padding: 2px 0 0 4px;
    color: inherit;
}

.md-tag {
    color: inherit;
}

.md-toc {
    margin-top: 20px;
    padding-bottom: 20px;
}

.typora-quick-open-item {
    font-size: 1rem !important;
    height: 50px;
    padding-left: 8px;
    padding-top: 4px;
    padding-bottom: 4px;
}

#typora-quick-open {
    box-shadow: 0 0 8px #00000045;
    padding: 0;
}

.ty-quick-open-category.ty-has-prev .ty-quick-open-category-title {
    border-top: none;
}

#typora-quick-open-input {
    margin: 8px;
    box-shadow: none;
    border-radius: 2px;
}

#typora-quick-open-input input {
    font-size: 1rem;
    box-shadow: none;
    padding-top: 2px;
    padding-left: 10px;
    padding-right: 10px;
    line-height: 32px;
    max-height: 32px;
    border: none;
}

.modal-dialog#typora-quick-open {
    border-radius: 8px;
}

.ty-quick-open-category-title {
    padding-left: 8px;
    color: #BEBEBE;
    font-size: 0.8rem;
    margin-bottom: 4px;
}

.typora-quick-open-item-path {
    font-size: 0.8rem;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-top: 1px;
}

/*search input*/
.form-control {
    border: none;
    border-radius: 2px;
    box-shadow: none;
}

#md-searchpanel .btn {
    border-radius: 2px;
}

#search-panel-replaceall-btn {
    padding-right: 5px !important;
    text-align: center !important;
}

#search-panel-replace-btn {
    text-align: center !important;
}

#md-searchpanel input {
    background: var(--input-bg-color);
    border-radius: 2px;
}

.searchpanel-search-option-btn {
    border-radius: 2px;
    border: none;
    background: transparent;
    color: var(--text-color);
}

.searchpanel-search-option-btn.active {
    background: var(--text-color);
    color: var(--bg-color);
}

.form-control:focus {
    box-shadow: none;
}

#md-notification:before {
    top: 10px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: initial;
}

/*sidebar*/
.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

#typora-sidebar {
    font-size: 1.1rem;
}

.sidebar-tabs {
    border-bottom: none;
}

.file-list-item-summary, .file-list-item-parent-loc, .file-list-item-time, .file-list-item-summary {
    font-size: 0.9rem !important;
    font-family: var(--text-font);
}

.file-list-item-file-ext-part {
    display: none;
}

.outline-item {
    font-size: 1rem;
}

/*footnotes mark*/
#write .md-footnote {
    background-color: inherit;
    color: var(--drake-highlight);
    font-size: 0.9rem;
    border-radius: 0.9rem;
    padding-left: 0;
}

#write .md-footnote:before {
    content: "[";
}

#write .md-footnote:after {
    content: "]";
}

/*footnotes content*/
.md-hover-tip .code-tooltip-content {
    border-radius: 2px;
}

/*footnotes title*/
span.md-def-name {
    padding-right: 3ch;
    padding-left: 0;
    position: relative;
    font-weight: normal;
}

/*footnotes desc*/
.footnotes {
    font-size: 1rem;
    font-weight: normal;
    color: var(--text-color);
    position: relative;
}

/*footnotes tooltip text*/
.code-tooltip-content .md-plain {
    font-size: 0.9rem;
    font-family: inherit;
}

.code-tooltip-content code {
    padding: 0 2px;
    font-family: inherit;
    color: var(--footnotes-highlight);
    background-color: inherit;
}

.code-tooltip-content a {
    color: var(--footnotes-highlight);
}

div.code-tooltip-content {
    box-shadow: 0 0 8px #00000045;
    background: var(--footnotes-bg-color);
}

.footnotes {
    opacity: 1;
}

.md-def-name:after {
    content: ". ^";
    color: var(--text-color);
}

.md-def-footnote .md-def-name:before {
    content: "";
    color: var(--text-color);
    position: absolute;
}

.md-def-name:before {
    content: "";
    color: var(--text-color);
    position: absolute;
}

.md-content.md-url, .md-def-content.md-def-url.md-auto-disp {
    text-decoration: none;
    border-bottom: .1rem solid var(--text-color);
}

.CodeMirror-scroll::-webkit-scrollbar {
    display: none;
}

.file-list-item-summary {
    font-size: 1em;
}

.pin-outline #outline-content .outline-active strong, .pin-outline .outline-active {
    font-weight: 500;
    color: var(--outline-active-color);
}

.file-list-item.active {
    border-left: 4px solid var(--drake-accent);
}

#md-searchpanel .btn:not(.close-btn):hover {
    box-shadow: none;
    background: var(--btn-hover-bg-color);
}

/*checkbox*/
#write input[type=checkbox] {
    opacity: 0;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
    margin-top: 0;
    top: 0;
}

#write .ul-list li.md-task-list-item.task-list-done::before {
    content: "";
    background: var(--checkbox-checked) 0 0 no-repeat;
    background-size: 100%;
    display: inline-block;
    position: absolute;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
}

#write .ul-list li.md-task-list-item.task-list-not-done::before {
    content: "";
    background: var(--checkbox-unchecked) 0 0 no-repeat;
    background-size: 100%;
    display: inline-block;
    position: absolute;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
}

/*insert table*/
.btn {
    border-radius: 2px;
}

.modal-content {
    border-radius: 8px;
}

.btn-primary:hover, .btn-primary:active {
    background-color: var(--btn-hover-bg-color);
    color: var(--drake-highlight);
}

.btn-primary {
    background-color: transparent;
    color: var(--drake-highlight);
}

.btn-default {
    background-color: transparent;
}

.btn:active {
    box-shadow: none;
    border-color: transparent;
}

.modal-footer {
    border-top: none;
}

#table-insert-col, #table-insert-row {
    background: var(--input-bg-color);
    border-radius: 2px;
}

/*preference panel*/
#megamenu-content {
    background-image: none !important;
    background-color: var(--bg-color);
}
#top-titlebar {
    height: inherit;
    background-color: var(--bg-color);
}
#megamenu-menu-sidebar {
    background-color: var(--bg-color);
    color: var(--text-color);
}
.long-btn {
    width: inherit;
    min-width: 300px;
    border: 1px solid var(--text-color);
    border-radius: 6px;
}
.megamenu-menu-panel h1 {
    margin-bottom: 3rem;
    text-align: left;
}
.megamenu-menu-panel h1, .megamenu-menu-panel h2 {
    font-weight: normal;
}
#recent-file-panel-search-input {
    height: 45px;
    border: none;
    border-bottom: 1px solid var(--text-color);
    padding-left: 8px;
}
#recent-file-panel-search-input::placeholder {
    color: var(--text-color);
    opacity: .5;
}
.megamenu-menu-header {
    border-bottom: none;
}
#recent-file-panel-action-btn {
    background: none;
    border: none;
}
#recent-file-panel-action-btn-container {
    float: none;
    display: inline-block;
}
#top-titlebar .toolbar-icon.btn.hover, #top-titlebar .toolbar-icon.btn:hover {
    background-color: var(--btn-hover-bg-color);
    color: var(--text-color);
}
.megamenu-menu-panel .btn:hover {
    background-color: var(--btn-hover-bg-color) !important;
    color: var(--text-color);
}
#recent-file-panel tbody tr:nth-child(2n-1),
.megamenu-menu-panel table thead,
.megamenu-menu-panel table tr {
    background-color: transparent;
}
.megamenu-menu-panel table {
    font-weight: normal;
}
#megamenu-back-btn {
    color: var(--text-color);
    border: 1px solid var(--text-color);
}
.megamenu-menu-header #megamenu-menu-header-title {
    color: var(--text-color);
}
header, .context-menu, .megamenu-content, footer {
    font-family: var(--text-font);
}
.ty-preferences select {
    padding-left: 2px;
}
.preference-item-hint {
    font-size: 14px;
}
a.ty-link {
    color: var(--a-color);
    margin: 0 .2rem;
}

/**
    code render
    Name: IntelliJ IDEA darcula theme
    From IntelliJ IDEA by JetBrains
 */
.cm-s-inner.CodeMirror {
    background: var(--code-block-bg-color);
    color: var(--code-block-color);
}

.cm-s-inner span.cm-meta {
    color: #BBB529;
}

.cm-s-inner span.cm-number {
    color: #6897BB;
}

.cm-s-inner span.cm-keyword {
    color: #CC7832;
}

.cm-s-inner span.cm-def {
    color: #FFD760;
}

.cm-s-inner span.cm-variable {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-variable-2 {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-variable-3 {
    color: #9876AA;
}

.cm-s-inner span.cm-type {
    color: #AABBCC;
}

.cm-s-inner span.cm-property {
    color: #FFC66D;
}

.cm-s-inner span.cm-operator {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-string {
    color: #6A8759;
}

.cm-s-inner span.cm-string-2 {
    color: #6A8759;
}

.cm-s-inner span.cm-comment {
    color: #787878;
}

.cm-s-inner span.cm-link {
    color: #CC7832;
}

.cm-s-inner span.cm-atom {
    color: #CC7832;
}

.cm-s-inner span.cm-error {
    color: #BC3F3C;
}

.cm-s-inner span.cm-tag {
    color: #E8BF6A;
}

.cm-s-inner span.cm-quote {
    color: #a6e22e;
}

.cm-s-inner span.cm-attribute {
    color: #9876AA;
}

.cm-s-inner span.cm-qualifier {
    color: #6A8759;
}

.cm-s-inner span.cm-bracket {
    color: #E8BF6A;
}

.cm-s-inner span.cm-builtin {
    color: #FF9E59;
}

.cm-s-inner span.cm-special {
    color: #FF9E59;
}

.cm-s-inner span.cm-matchhighlight {
    color: #FFFFFF;
    background-color: rgba(50, 89, 48, .7);
    font-weight: normal;
}

.cm-s-inner span.cm-searching {
    color: #FFFFFF;
    background-color: rgba(61, 115, 59, .7);
    font-weight: normal;
}

.cm-s-inner .CodeMirror-gutters {
    border-right: 1px solid rgba(120, 120, 120, 0.3);
}

.cm-s-inner .CodeMirror-linenumber {
    color: #585b5d;
}

.cm-s-inner .CodeMirror-matchingbracket {
    background-color: #3B514D;
    color: #FFEF28 !important;
}

.cm-s-inner .CodeMirror-selected {
    background: #214283 !important;
}

.cm-s-inner .CodeMirror-selectedtext {
    background: #214283 !important;
}

.cm-s-typora-default .CodeMirror-selectedtext {
    background: var(--select-text-bg-color) !important;
}

.cm-overlay.CodeMirror-selectedtext {
    background: var(--select-text-bg-color) !important;
}

.cm-s-inner div.CodeMirror-cursor {
    border-left: 1px solid var(--code-block-color);
}/*# sourceURL=/Users/didi/Documents/Codes/Fun/lagou/public/drake-juejin.css*/</style></head>
<body>
  <div id="write"><h1>第40讲：跟我来一起实现智能化解析算法吧</h1><p data-nodeid="3062">在上一节课我们介绍了智能解析算法的实现原理，接下来我们就一起动手用代码来实现一下智能解析算法吧。</p>



<h3 data-nodeid="4016" class="">学习目标</h3>

<p data-nodeid="1626">这里使用的案例还是凤凰网的一篇资讯文章，链接为：<a href="http://news.ifeng.com/c/7kQcQG2peWU" data-nodeid="1757">http://news.ifeng.com/c/7kQcQG2peWU</a>，本节我们主要实现的提取字段为标题、时间、正文内容。</p>
<p data-nodeid="1627">我们会用 Python 来对上一节讲解的智能解析算法进行实现，实现新闻内容的提取。</p>
<h3 data-nodeid="4970" class="">准备工作</h3>

<p data-nodeid="6868">首先让我们将上述 URL 打开，然后在浏览器里面打开开发者工具，并打开 Elements 选项卡，最后把 HTML 代码复制下来，如图所示：</p>
<p data-nodeid="6869" class=""><img src="https://s0.lgstatic.com/i/image/M00/28/39/CgqCHl74UmGAJc3ZAAMZ_A3o4rs583.png" alt="image.png" data-nodeid="6873"></p>


<p data-nodeid="1631">复制下来之后我们把源代码保存成一个 html 文件，名字叫作 sample.html。</p>
<p data-nodeid="1632">然后我们定义如下代码，将 html 里面的字符转化成 lxml 里面的 HtmlElement 对象，代码如下：</p>
<pre class="lang-java hljs" data-nodeid="8303"><code data-language="java">from lxml.html <span class="hljs-keyword">import</span> HtmlElement, fromstring
​
html = open(<span class="hljs-string">'sample.html'</span>, encoding=<span class="hljs-string">'utf-8'</span>).read()
element = fromstring(html=html)
</code></pre>


<p data-nodeid="1634">这里 element 对象其实就是整个网页对应的 HtmlElement 对象，其根节点就是 html，下面我们会用到它来进行页面解析，从这个 HtmlElement 对象里面提取出我们想要的时间、标题、正文内容。</p>
<h3 data-nodeid="9256" class="">时间</h3>

<p data-nodeid="1636">对于时间来说，我们这里就根据两个方面来进行提取，一个就是 meta 标签，如果里面包含了发布时间的相关信息，一般提取出来就是对的，可信度非常高，如果提取不到，那就用正则表达式来匹配一些时间规则进行提取。</p>
<p data-nodeid="1637">首先我们就来进行 meta 标签的提取，这里我们列出来了一些用来匹配发布时间的 XPath 规则，内容如下：</p>
<pre class="lang-java hljs" data-nodeid="10687"><code data-language="java">METAS = [
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "rnews:datePublished")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "article:published_time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "og:published_time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "og:release_date")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@itemprop, "datePublished")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@itemprop, "dateUpdate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "OriginalPublicationDate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "article_date_original")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "og:time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "apub:time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "publication_date")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "sailthru.date")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "PublishDate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "publishdate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "PubDate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "pubtime")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "_pubtime")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "weibo: article:create_at")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@pubdate, "pubdate")]/@content'</span>,
]
</code></pre>


<p data-nodeid="1639">在这里我们就定义一个 extract_by_meta 的方法，它接受一个 HtmlElement 对象，定义如下：</p>
<pre class="lang-java hljs" data-nodeid="11640"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_by_meta</span><span class="hljs-params">(element: HtmlElement)</span> -&gt; str:
 &nbsp; &nbsp;<span class="hljs-keyword">for</span> xpath in METAS:
 &nbsp; &nbsp; &nbsp; &nbsp;datetime </span>= element.xpath(xpath)
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> datetime:
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(datetime)
</code></pre>

<p data-nodeid="1641">这里我们其实就是对 METAS 进行逐个遍历，然后查找整个 HtmlElement 里面是不是有匹配的内容，比如说：</p>
<pre class="lang-java hljs" data-nodeid="12593"><code data-language="java"><span class="hljs-comment">//meta[starts-with(@property, "og:published_time")]/@content</span>
</code></pre>

<p data-nodeid="1643">这个就是查找 meta 节点中是不是存在以 og:published_time 开头的 property 属性，如果存在，那就提取出其中的 content 属性内容。<br>
比如说我们的案例中刚好有一个 meta 节点，内容为：</p>
<pre class="lang-java hljs" data-nodeid="13546"><code data-language="java">&lt;meta name=<span class="hljs-string">"og:time "</span> content=<span class="hljs-string">"2019-02-20 02:26:00"</span>&gt;
</code></pre>

<p data-nodeid="1645">经过处理，它会匹配到这个 XPath 表达式：</p>
<pre class="lang-java hljs" data-nodeid="14499"><code data-language="java"><span class="hljs-comment">//meta[starts-with(@name, "og:time")]/@content</span>
</code></pre>

<p data-nodeid="15452">这样其实 extract_by_meta 方法就成功匹配到时间信息，然后提取出 2019-02-20 02:26:00 这个值了。</p>
<p data-nodeid="15453">这就相当于时间提取的第一步成功了，而且一般来说匹配到的结果可信度都是非常高的，我们可以直接将这个内容返回作为最终的提取结果即可。</p>

<p data-nodeid="1648">可是并不是所有的页面都会包含这个 meta 标签，如果不包含的话，我们还需要进行第二步的提取。</p>
<p data-nodeid="1649">下面我们再来实现第二步，也就是根据一些时间正则表达式来进行提取的方法。这里我们其实就是定义一些时间的正则表达式写法，内容如下：</p>
<pre class="lang-java hljs" data-nodeid="16412"><code data-language="java">REGEXES = [
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[1-24]\d时[0-60]\d分)([1-24]\d时)"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[1-24]\d时[0-60]\d分)([1-24]\d时)"</span>,
 &nbsp;  ...
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2})"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2})"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}年\d{1,2}月\d{1,2}日)"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}年\d{1,2}月\d{1,2}日)"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{1,2}月\d{1,2}日)"</span>
]
</code></pre>

<p data-nodeid="1651">由于内容比较多，这里省略了部分内容。其实这里就是一些日期的常见写法格式，由于日期的写法是有限的，所以我们通过一些有限的正则表达就能进行匹配。<br>
接下来我们就定义一个正则搜索的方法，实现如下：</p>
<pre class="lang-java hljs" data-nodeid="17365"><code data-language="java"><span class="hljs-keyword">import</span> re
​
<span class="hljs-function">def <span class="hljs-title">extract_by_regex</span><span class="hljs-params">(element: HtmlElement)</span> -&gt; str:
 &nbsp; &nbsp;text </span>= <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//text()'</span>))
 &nbsp; &nbsp;<span class="hljs-keyword">for</span> regex in REGEXES:
 &nbsp; &nbsp; &nbsp; &nbsp;result = re.search(regex, text)
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> result:
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">return</span> result.group(<span class="hljs-number">1</span>)
</code></pre>

<p data-nodeid="1653">这里我们先查找了 element 的文本内容，然后对文本内容进行正则表达式搜索，符合条件的就直接返回。<br>
最后，时间提取的方法我们直接定义为：</p>
<pre class="lang-java hljs" data-nodeid="18318"><code data-language="java">extract_by_meta(element) <span class="hljs-function">or <span class="hljs-title">extract_by_regex</span><span class="hljs-params">(element)</span>
</span></code></pre>

<p data-nodeid="1655">即可，这样就会优先提取 meta，其次根据正则表达式提取。</p>
<h3 data-nodeid="19271" class="">标题</h3>

<p data-nodeid="1657">接下来我们来实现标题的提取，根据上节内容，标题的提取我们在这里实现三个来源的提取：</p>
<ul data-nodeid="1658">
<li data-nodeid="1659">
<p data-nodeid="1660">查找 meta 节点里面的标题信息。</p>
</li>
<li data-nodeid="1661">
<p data-nodeid="1662">查找 title 节点的标题信息。</p>
</li>
<li data-nodeid="1663">
<p data-nodeid="1664">查找 h 节点的信息。</p>
</li>
</ul>
<p data-nodeid="1665">首先就是从 meta 节点提取，其实过程还是类似的，我们定义如下的 meta 节点的 XPath 提取规则，内容如下：</p>
<pre class="lang-java hljs" data-nodeid="20225"><code data-language="java">METAS = [
    <span class="hljs-string">'//meta[starts-with(@property, "og:title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@name, "og:title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@property, "title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@name, "title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@property, "page:title")]/@content'</span>,
]
</code></pre>

<p data-nodeid="1667">实现的提取方法也是完全一样的：</p>
<pre class="lang-java hljs" data-nodeid="21178"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_by_meta</span><span class="hljs-params">(element: HtmlElement)</span> -&gt; str:
    <span class="hljs-keyword">for</span> xpath in METAS:
        title </span>= element.xpath(xpath)
        <span class="hljs-keyword">if</span> title:
            <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(title)
</code></pre>

<p data-nodeid="23084">关于这一部分就不再展开说明了。</p>
<p data-nodeid="23085">接下来我们还可以提取 title 和 h 节点的信息，通过基本的 XPath 表达式就可以实现，代码如下：</p>

<pre class="lang-java hljs" data-nodeid="22131"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_by_title</span><span class="hljs-params">(element: HtmlElement)</span>:
    return ''.<span class="hljs-title">join</span><span class="hljs-params">(element.xpath(<span class="hljs-string">'//title//text()'</span>)</span>).<span class="hljs-title">strip</span><span class="hljs-params">()</span>
def <span class="hljs-title">extract_by_h</span><span class="hljs-params">(element: HtmlElement)</span>:
    return ''.<span class="hljs-title">join</span><span class="hljs-params">(
        element.xpath(<span class="hljs-string">'(//h1//text() | //h2//text() | //h3//text())'</span>)</span>).<span class="hljs-title">strip</span><span class="hljs-params">()</span>
</span></code></pre>

<p data-nodeid="24040">这里我们提取了 title、h1~h3 节点的信息，然后返回了它们的纯文本内容。</p>
<p data-nodeid="24041">紧接着，我们分别调用以下这三个方法，看看针对这个案例，其结果是怎样的，调用如下：</p>

<pre class="lang-yaml hljs" data-nodeid="44535"><code data-language="yaml"><span class="hljs-string">title_extracted_by_meta</span> <span class="hljs-string">=</span> <span class="hljs-string">extract_by_meta(element)</span>
<span class="hljs-string">title_extracted_by_h</span> <span class="hljs-string">=</span> <span class="hljs-string">extract_by_h(element)</span>
<span class="hljs-string">title_extracted_by_title</span> <span class="hljs-string">=</span> <span class="hljs-string">extract_by_title(element)</span>
</code></pre>


<p data-nodeid="1673">运行结果如下：</p>
<pre class="lang-yaml hljs" data-nodeid="43582"><code data-language="yaml"><span class="hljs-string">title_extracted_by_meta</span> <span class="hljs-string">故宫，你低调点！故宫：不，实力已不允许我继续低调</span>
<span class="hljs-string">title_extracted_by_h</span> <span class="hljs-string">故宫，你低调点！故宫：不，实力已不允许我继续低调为您推荐精品有声好书精选</span>
<span class="hljs-string">title_extracted_by_title</span> <span class="hljs-string">故宫，你低调点！故宫：不，实力已不允许我继续低调_凤凰网资讯_凤凰网</span>
</code></pre>




















<p data-nodeid="45488">这里我们观察到，三个方法都返回了差不多的结果，但是后缀还是不太一样。</p>
<p data-nodeid="45489">title_extracted_by_meta 实际上是完全正确的内容，可以直接返回，一般来说，它的可信度也非常高，如果匹配到，那就直接返回就好了。</p>

<p data-nodeid="1676">但是如果不存在 title_extracted_by_meta 的结果呢？那只能靠 title_extracted_by_title 和 title_extracted_by_h 了。</p>
<p data-nodeid="1677">这里我们观察到 title_extracted_by_title 和 title_extracted_by_h 包含一些冗余信息，仔细想想确实是这样的，因为 title 一般来说会再加上网站的名称，而 h 节点众多，通常会包含很多噪音。</p>
<p data-nodeid="1678">这里我们可以提取它们的公共连续内容其实就好了，这里用到一个算法，就是最长连续公共子串，即 Longest Common String，这里我们直接借助于 Python 的 difflib 库来实现即可，如果你感兴趣的话也可以手动实现一下。</p>
<p data-nodeid="1679">这里我们的实现如下：</p>
<pre class="lang-java hljs" data-nodeid="51215"><code data-language="java"><span class="hljs-function">from difflib <span class="hljs-keyword">import</span> SequenceMatcher
def <span class="hljs-title">lcs</span><span class="hljs-params">(a, b)</span>:
    match </span>= SequenceMatcher(None, a, b).find_longest_match(<span class="hljs-number">0</span>, len(a), <span class="hljs-number">0</span>, len(b))
    <span class="hljs-keyword">return</span> a[match[<span class="hljs-number">0</span>]: match[<span class="hljs-number">0</span>] + match[<span class="hljs-number">2</span>]]
</code></pre>






<p data-nodeid="52168">这里定义了一个 lcs 方法，它接收两个字符串类型的参数，比如 <code data-backticks="1" data-nodeid="52171">abcd</code> 和 <code data-backticks="1" data-nodeid="52173">bcde</code>，那么它的返回结果就是它们的公共部分，即 <code data-backticks="1" data-nodeid="52175">bcd</code>。</p>
<p data-nodeid="52169">好，那么对于 title_extracted_by_title 和 title_extracted_by_h，我们调用下 lcs 方法就好了，实现如下：</p>

<pre class="lang-java hljs" data-nodeid="53142"><code data-language="java">lcs(title_extracted_by_title, title_extracted_by_h)
</code></pre>

<p data-nodeid="1683">最终我们可以把标题的提取定义成一个方法，实现如下：</p>
<pre class="lang-java hljs" data-nodeid="54095"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_title</span><span class="hljs-params">(element: HtmlElement)</span>:
    title_extracted_by_meta </span>= extract_by_meta(element)
    title_extracted_by_h = extract_by_h(element)
    title_extracted_by_title = extract_by_title(element)
    <span class="hljs-keyword">if</span> title_extracted_by_meta:
        <span class="hljs-keyword">return</span> title_extracted_by_meta
    <span class="hljs-keyword">if</span> title_extracted_by_title and title_extracted_by_h:
        <span class="hljs-keyword">return</span> lcs(title_extracted_by_title, title_extracted_by_h)
    <span class="hljs-keyword">if</span> title_extracted_by_title:
        <span class="hljs-keyword">return</span> title_extracted_by_title
    <span class="hljs-keyword">return</span> title_extracted_by_h
</code></pre>

<p data-nodeid="1685">这里我们就定义了一些优先级判定逻辑，如：</p>
<ul data-nodeid="1686">
<li data-nodeid="1687">
<p data-nodeid="1688">如果存在 title_extracted_by_meta，由于其可信度非常高，直接返回即可。</p>
</li>
<li data-nodeid="1689">
<p data-nodeid="1690">如果不存在 title_extracted_by_meta，而 title_extracted_by_title 和 title_extracted_by_h 同时存在，取二者的最长公共子串返回即可。</p>
</li>
<li data-nodeid="1691">
<p data-nodeid="1692">如果上述条件不成立， title_extracted_by_title 存在，返回 title_extracted_by_title 即可。</p>
</li>
<li data-nodeid="1693">
<p data-nodeid="1694">如果上述条件不成立，只能返回 title_extracted_by_h 了。</p>
</li>
</ul>
<p data-nodeid="1695">以上就是我们的标题提取逻辑。</p>
<h3 data-nodeid="55048" class="">正文</h3>

<p data-nodeid="1697">接下来终于轮到重头戏，正文提取了。在上一节课我们介绍了利用文本密度和符号密度进行提取的方法，下面我们就来实现一下吧。</p>
<p data-nodeid="1698">正文的提取需要我们做一些预处理工作，比如一个 html 标签内有很多噪音，非常影响正文的提取，比如说 script、style 这些内容，一定不会包含正文，但是它们会严重影响文本密度的计算，所以这里我们先定义一个预处理操作。</p>
<pre class="lang-java hljs" data-nodeid="56002"><code data-language="java">from lxml.html <span class="hljs-keyword">import</span> HtmlElement, etree
CONTENT_USELESS_TAGS = [<span class="hljs-string">'meta'</span>, <span class="hljs-string">'style'</span>, <span class="hljs-string">'script'</span>, <span class="hljs-string">'link'</span>, <span class="hljs-string">'video'</span>, <span class="hljs-string">'audio'</span>, <span class="hljs-string">'iframe'</span>, <span class="hljs-string">'source'</span>, <span class="hljs-string">'svg'</span>, <span class="hljs-string">'path'</span>,
                        <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'img'</span>]
CONTENT_STRIP_TAGS = [<span class="hljs-string">'span'</span>, <span class="hljs-string">'blockquote'</span>]
CONTENT_NOISE_XPATHS = [
    <span class="hljs-string">'//div[contains(@class, "comment")]'</span>,
    <span class="hljs-string">'//div[contains(@class, "advertisement")]'</span>,
    <span class="hljs-string">'//div[contains(@class, "advert")]'</span>,
    <span class="hljs-string">'//div[contains(@style, "display: none")]'</span>,
]

<span class="hljs-function">def <span class="hljs-title">preprocess4content</span><span class="hljs-params">(element: HtmlElement)</span>:
    # remove tag and its content
    etree.<span class="hljs-title">strip_elements</span><span class="hljs-params">(element, *CONTENT_USELESS_TAGS)</span>
    # only move tag pair
    etree.<span class="hljs-title">strip_tags</span><span class="hljs-params">(element, *CONTENT_STRIP_TAGS)</span>
    # remove noise tags
    <span class="hljs-title">remove_children</span><span class="hljs-params">(element, CONTENT_NOISE_XPATHS)</span>
    
    <span class="hljs-keyword">for</span> child in <span class="hljs-title">children</span><span class="hljs-params">(element)</span>:
        
        # merge text in span or strong to parent p tag
        <span class="hljs-keyword">if</span> child.tag.<span class="hljs-title">lower</span><span class="hljs-params">()</span> </span>== <span class="hljs-string">'p'</span>:
            etree.strip_tags(child, <span class="hljs-string">'span'</span>)
            etree.strip_tags(child, <span class="hljs-string">'strong'</span>)
            
            <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">not</span> <span class="hljs-params">(child.text and child.text.strip()</span>):
                <span class="hljs-title">remove_element</span><span class="hljs-params">(child)</span>
        
        # <span class="hljs-keyword">if</span> a div tag does not contain any sub node, it could be converted to p node.
        <span class="hljs-keyword">if</span> child.tag.<span class="hljs-title">lower</span><span class="hljs-params">()</span> </span>== <span class="hljs-string">'div'</span> and not child.getchildren():
            child.tag = <span class="hljs-string">'p'</span>
</code></pre>

<p data-nodeid="1700">这里我们定义了一些规则，比如 CONTENT_USELESS_TAGS 代表一些噪音节点，可以直接调用 strip_elements 把整个节点和它的内容删除。<br>
另外定义了 CONTENT_STRIP_TAGS ，这些节点文本内容需要保留，但是它的标签是可以删掉的。</p>
<p data-nodeid="1701">另外我们还定义了 CONTENT_NOISE_XPATHS，这是一些很明显不是正文的节点，如评论、广告等，直接移除就好。</p>
<p data-nodeid="1702">这里还依赖于几个工具方法，定义如下：</p>
<pre class="lang-java hljs" data-nodeid="56955"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">remove_element</span><span class="hljs-params">(element: HtmlElement)</span>:
    parent </span>= element.getparent()
    <span class="hljs-keyword">if</span> parent is not None:
        parent.remove(element)
<span class="hljs-function">def <span class="hljs-title">remove_children</span><span class="hljs-params">(element: HtmlElement, xpaths=None)</span>:
    <span class="hljs-keyword">if</span> not xpaths:
        return
    <span class="hljs-keyword">for</span> xpath in xpaths:
        nodes </span>= element.xpath(xpath)
        <span class="hljs-keyword">for</span> node in nodes:
            remove_element(node)
    <span class="hljs-keyword">return</span> <span class="hljs-function">element
def <span class="hljs-title">children</span><span class="hljs-params">(element: HtmlElement)</span>:
    yield element
    <span class="hljs-keyword">for</span> child_element in element:
        <span class="hljs-keyword">if</span> <span class="hljs-title">isinstance</span><span class="hljs-params">(child_element, HtmlElement)</span>:
            yield from <span class="hljs-title">children</span><span class="hljs-params">(child_element)</span>
</span></code></pre>

<p data-nodeid="57908">另外对于一些节点我们还做了特殊处理，如 p 节点内部的 span、strong 节点去掉标签，只留内容。如果是 div 节点，而且没有子节点了，那么可以换成 p 节点。</p>
<p data-nodeid="57909">当然还有一些细节的处理，你如果想到了可以继续优化。预处理完毕之后，整个 element 就比较规整了，去除了很多噪声和干扰数据。</p>

<p data-nodeid="1705">接下来我们就来实现文本密度和符号密度的计算吧。为了方便处理，这里我把节点定义成了一个 Python Object，名字叫作 ElementInfo，它里面有很多字段，代表了某一个节点的信息，比如文本密度、符号密度等，定义如下：</p>
<pre class="lang-dart hljs" data-nodeid="63629"><code data-language="dart">from lxml.html <span class="hljs-keyword">import</span> HtmlElement
from pydantic <span class="hljs-keyword">import</span> BaseModel
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementInfo</span>(<span class="hljs-title">BaseModel</span>):
    <span class="hljs-title">id</span>: <span class="hljs-title">int</span> = <span class="hljs-title">None</span>
    <span class="hljs-title">tag_name</span>: <span class="hljs-title">str</span> = <span class="hljs-title">None</span>
    <span class="hljs-title">element</span>: <span class="hljs-title">HtmlElement</span> = <span class="hljs-title">None</span>
    <span class="hljs-title">number_of_char</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_linked_char</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_tag</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_linked_tag</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_p_tag</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_punctuation</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">density_of_punctuation</span>: <span class="hljs-title">int</span> = 1
    <span class="hljs-title">density_of_text</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">density_score</span>: <span class="hljs-title">int</span> = 0
    
    <span class="hljs-title">class</span> <span class="hljs-title">Config</span>:
        <span class="hljs-title">arbitrary_types_allowed</span> = <span class="hljs-title">True</span>
</span></code></pre>






<p data-nodeid="1707">这里我们定义了几个字段。</p>
<ul data-nodeid="1708">
<li data-nodeid="1709">
<p data-nodeid="1710">id：节点的唯一 id。</p>
</li>
<li data-nodeid="1711">
<p data-nodeid="1712">tag_name：节点的标签值，如 p、div、img 等。</p>
</li>
<li data-nodeid="1713">
<p data-nodeid="1714">element：节点对应的 HtmlElement 对象。</p>
</li>
<li data-nodeid="1715">
<p data-nodeid="1716">number_of_char：节点的总字符数。</p>
</li>
<li data-nodeid="1717">
<p data-nodeid="1718">number_of_linked_char：节点带超链接的字符数。</p>
</li>
<li data-nodeid="1719">
<p data-nodeid="1720">number_of_tag：节点的标签数。</p>
</li>
<li data-nodeid="1721">
<p data-nodeid="1722">number_of_linked_tag：节点的带链接的标签数，即 a 的标签数。</p>
</li>
<li data-nodeid="1723">
<p data-nodeid="1724">number_of_p_tag：节点的 p 标签数。</p>
</li>
<li data-nodeid="1725">
<p data-nodeid="1726">number_of_punctuation：节点包含的标点符号数。</p>
</li>
<li data-nodeid="1727">
<p data-nodeid="1728">density_of_punctuation：节点的符号密度。</p>
</li>
<li data-nodeid="1729">
<p data-nodeid="1730">density_of_text：节点的文本密度。</p>
</li>
<li data-nodeid="1731">
<p data-nodeid="1732">density_score：最终评分。</p>
</li>
</ul>
<p data-nodeid="1733">好，下面我们要做的就是对整个 HTML 的所有节点进行处理，然后得到每个节点的信息，实现如下：</p>
<pre class="lang-dart hljs" data-nodeid="71253"><code data-language="dart"># start to evaluate every child element
element_infos = []
child_elements = children_of_body(element)
<span class="hljs-keyword">for</span> child_element <span class="hljs-keyword">in</span> child_elements:
    # <span class="hljs-keyword">new</span> element info
    element_info = ElementInfo()
    element_info.element = child_element
    element_info = fill_element_info(element_info)
    element_infos.append(element_info)
</code></pre>








<p data-nodeid="72206">这里我们先调用了 children_of_body 获取了最初 element 节点的所有子节点，然后对节点进行处理。</p>
<p data-nodeid="72207">其中这里依赖 children_of_body 和 fill_element_info 方法，分别是获取所有 body 内的子节点（包括 body）以及计算节点信息，实现如下：</p>

<pre class="lang-dart hljs" data-nodeid="82704"><code data-language="dart">def children_of_body(element: HtmlElement):
    body_xpath = <span class="hljs-string">'//body'</span>
    elements = element.xpath(body_xpath)
    <span class="hljs-keyword">if</span> elements:
        <span class="hljs-keyword">return</span> children(elements[<span class="hljs-number">0</span>])
    <span class="hljs-keyword">return</span> []

def fill_element_info(element_info: ElementInfo):
    element = element_info.element
    
    # fill id
    element_info.id = hash(element)
    element_info.tag_name = element.tag
    
    # fill number_of_char
    element_info.number_of_char = number_of_char(element)
    element_info.number_of_linked_char = number_of_linked_char(element)
    element_info.number_of_tag = number_of_tag(element)
    element_info.number_of_linked_tag = number_of_linked_tag(element)
    element_info.number_of_p_tag = number_of_p_tag(element)
    element_info.number_of_punctuation = number_of_punctuation(element)
    
    # fill density
    element_info.density_of_text = density_of_text(element_info)
    element_info.density_of_punctuation = density_of_punctuation(element_info)
    <span class="hljs-keyword">return</span> element_info
</code></pre>











<p data-nodeid="1737">这里 fill_element_info 方法非常重要，其实就是填充了 element_info 的几乎所有指标信息，这里又依赖了 number_of_char、number_of_linked_char、number_of_tag、number_of_linked_tag、number_of_p_tag、number_of_punctuation、density_of_text、density_of_punctuation 方法，实现如下：</p>
<pre class="lang-dart hljs" data-nodeid="93187"><code data-language="dart">def number_of_char(element: HtmlElement):
    text = <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//text()'</span>))
    text = re.sub(<span class="hljs-string">r'\s*'</span>, <span class="hljs-string">''</span>, text, flags=re.S)
    <span class="hljs-keyword">return</span> len(text)

def number_of_linked_char(element: HtmlElement):
    text = <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//a//text()'</span>))
    text = re.sub(<span class="hljs-string">r'\s*'</span>, <span class="hljs-string">''</span>, text, flags=re.S)
    <span class="hljs-keyword">return</span> len(text)

def number_of_tag(element: HtmlElement):
    <span class="hljs-keyword">return</span> len(element.xpath(<span class="hljs-string">'.//*'</span>))

def number_of_p_tag(element: HtmlElement):
    <span class="hljs-keyword">return</span> len(element.xpath(<span class="hljs-string">'.//p'</span>))

def number_of_linked_tag(element: HtmlElement):
    <span class="hljs-keyword">return</span> len(element.xpath(<span class="hljs-string">'.//a'</span>))

def density_of_text(element_info: ElementInfo):
    # <span class="hljs-keyword">if</span> denominator <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>, just <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> element_info.number_of_tag - element_info.number_of_linked_tag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">return</span> (element_info.number_of_char - element_info.number_of_linked_char) / \
           (element_info.number_of_tag - element_info.number_of_linked_tag)

def density_of_punctuation(element_info: ElementInfo):
    result = (element_info.number_of_char - element_info.number_of_linked_char) / \
             (element_info.number_of_punctuation + <span class="hljs-number">1</span>)
    # result should not be zero
    <span class="hljs-keyword">return</span> result or <span class="hljs-number">1</span>

def number_of_punctuation(element: HtmlElement):
    text = <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//text()'</span>))
    text = re.sub(<span class="hljs-string">r'\s*'</span>, <span class="hljs-string">''</span>, text, flags=re.S)
    punctuations = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> text <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> PUNCTUATION]
    <span class="hljs-keyword">return</span> len(punctuations)
</code></pre>











<p data-nodeid="94140">这里比较重要的就是 density_of_text 和 density_of_punctuation 两个方法了，分别代表文本密度和符号密度，其算法原理在上一节已经提到了，可以参考论文《洪鸿辉，等 基于文本富豪密度的网页正文提取方法》的内容。</p>
<p data-nodeid="94141">好，这样我们运行完毕之后，就可以得到每个节点的各个指标啦。最后，我们继续参考论文《洪鸿辉，等 基于文本富豪密度的网页正文提取方法》的公式，根据各个指标计算每个节点的得分情况，最后提取内容即可：</p>

<pre class="lang-dart hljs" data-nodeid="107493"><code data-language="dart"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
# start to evaluate every child element
element_infos = []
child_elements = children_of_body(element)
<span class="hljs-keyword">for</span> child_element <span class="hljs-keyword">in</span> child_elements:
    # <span class="hljs-keyword">new</span> element info
    element_info = ElementInfo()
    element_info.element = child_element
    element_info = fill_element_info(element_info)
    element_infos.append(element_info)
    # <span class="hljs-keyword">get</span> std of density_of_text among all elements
    density_of_text = [element_info.density_of_text <span class="hljs-keyword">for</span> element_info <span class="hljs-keyword">in</span> element_infos]
    density_of_text_std = np.std(density_of_text, ddof=<span class="hljs-number">1</span>)
    # <span class="hljs-keyword">get</span> density_score of every element
    <span class="hljs-keyword">for</span> element_info <span class="hljs-keyword">in</span> element_infos:
        score = np.log(density_of_text_std) * \
                element_info.density_of_text * \
                np.log10(element_info.number_of_p_tag + <span class="hljs-number">2</span>) * \
                np.log(element_info.density_of_punctuation)
        element_info.density_score = score
    # sort element info by density_score
    element_infos = sorted(element_infos, key=lambda x: x.density_score, reverse=True)
    element_info_first = element_infos[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> element_infos <span class="hljs-keyword">else</span> None
    text = <span class="hljs-string">'\n'</span>.join(element_info_first.element.xpath(<span class="hljs-string">'.//p//text()'</span>))
</code></pre>














<p data-nodeid="108446">这里我们首先计算了 density_of_text 的标准差，然后对各个节点计算了最终的密度得分，最后排序得到最高的节点，获取文本值即可。</p>
<p data-nodeid="108447">运行结果如下：</p>

<pre class="lang-java hljs" data-nodeid="109406"><code data-language="java"><span class="hljs-string">"“我的名字叫紫禁城，快要600岁了，这上元的夜啊，总是让我沉醉，这么久了却从未停止。”\n“重檐之上的月光，曾照进古人的宫殿；城墙上绵延的灯彩，映出了角楼的瑰丽。今夜，一群博物馆人将我点一段话。\n半小时后，“紫禁城上元之夜”的灯光点亮了北京夜空。\n午门城楼及东西雁翅楼用白、黄、红三种颜色光源装扮！\n太和门广场变成了超大的夜景灯光秀场！\n图片来源：东方IC 版权作品 请勿转载\n午门城宫博物院供图\n故宫的角楼被灯光装点出满满的节日气氛！\n故宫博物院供图\n令人惊叹的是，故宫的“网红”藏品《清明上河图》《千里江山图卷》在“灯会”中展开画卷。\n灯光版《清明上河图》\n以灯为笔，以屋顶为，故宫博物院最北端神武门也被灯光点亮！\n故宫博物院供图\n上元之夜，故宫邀请了劳动模范、北京榜样、快递小哥、环卫工人、解放军和武警官兵、消防指战员、公安干警等各界代表以及预约成功的观众，共3000人故宫博物院供图\n时间退回到两天前，故宫博物院发布了2月19日(正月十五)、20日(正月十六)即将举办“紫禁城上元之夜”文化活动的消息。\n图片来源：视觉中国\n18日凌晨，一众网友前往故宫博物院官网抢票，网站甚节就有诸多讲究。\n有灯无月不娱人，有月无灯不算春。\n春到人间人似玉，灯烧月下月如怠。\n满街珠翠游村女，沸地笙歌赛社神。\n不展芳尊开口笑，如何消得此良辰。\n——唐伯虎《元宵》\n明代宫中过上元节，皇宵节晚会”。\n2月18日，北京故宫午门调试灯光。中新社记者 杜洋 摄\n其中，灯戏颇为有趣。由多人舞灯拼出吉祥文字及图案，每人手执彩灯、身着不同颜色的服装，翩翩起舞，类似于现代的大型团体操表演。\n但这紫禁城，恭亲王奕 与英法联军交换了《天津条约》批准书，并订立《中英北京条约》《中法北京条约》作为补充。\n战争结束了，侵略者摇身一变成了游客。一位外国“摄影师”拍下了当年的紫禁城，并在日记里写到，百年。\n直到上世纪40年代时，故宫的环境仍然并不是想象中的博物馆的状态。\n曾有故宫博物院工作人员撰文回忆，当时的故宫内杂草丛生，房倒屋漏，有屋顶竟长出了树木。光是清理当时宫中存留的垃圾、杂草就用单霁翔到任故宫院长。那时，他拿到的故宫博物院介绍，写了这座博物馆诸多的“世界之最”。\n可他觉得，当自己真正走到观众中间，这些“世界之最”都没有了。\n2月18日，北京故宫午门调试灯光。中新社记者 杜洋 摄外环境进行了大整治。\n游客没有地方休息，那就拆除了宫中的临时建筑、新增供游客休息的椅子；\n游客排队上厕所，那就将一个职工食堂都改成了洗手间；\n游客买票难，那就全面采用电子购票，新增多个售票点；馆。\n今年，持续整个正月的“过大年”展览和“紫禁城上元之夜”，让本该是淡季的故宫变得一票难求。\n在不少普通人眼中，近600岁的故宫正变得越来越年轻。\n资料图：故宫博物院院长单霁翔。中新社记者 刘关关 摄元宵节活动进行评估后，或结合二十四节气等重要时间节点推出夜场活动。\n你期待吗？\n作者：上官云 宋宇晟"</span>
</code></pre>

<p data-nodeid="1743">可以看到，正文就被成功提取出来了。</p>
<h3 data-nodeid="110359" class="">整理</h3>

<p data-nodeid="1745">最后整理一下，三者结果合并，输出为 JSON 格式，实现如下：</p>
<pre class="lang-java hljs" data-nodeid="111313"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract</span><span class="hljs-params">(html)</span>:
    return </span>{
        <span class="hljs-string">'title'</span>: extract_title(html),
        <span class="hljs-string">'datetime'</span>: extract_datetime(html),
        <span class="hljs-string">'content'</span>: extract_content(html)
    }
</code></pre>

<p data-nodeid="113212">最后，我们可以看到类似的输出效果，内容如下：</p>
<p data-nodeid="113213" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/28/3D/CgqCHl74VdaATYm8AAKNT19ZZkg888.png" alt="image (1).png" data-nodeid="113221"></p>


<p data-nodeid="1748">到此为止，我们就成功提取出来了标题、时间和正文内容并输出为 JSON 格式了。其他的一些字段相对没有那么重要，你可以根据类似的方法来进行提取和实验。</p>
<p data-nodeid="1749">本节代码：<a href="https://github.com/Gerapy/GerapyAutoExtractor" data-nodeid="2100">https://github.com/Gerapy/GerapyAutoExtractor</a>。</p></div>

</body></html>