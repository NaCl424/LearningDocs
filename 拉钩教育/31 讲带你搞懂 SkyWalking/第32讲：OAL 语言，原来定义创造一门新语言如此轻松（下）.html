<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第32讲：OAL 语言，原来定义创造一门新语言如此轻松（下）</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>第32讲：OAL 语言，原来定义创造一门新语言如此轻松（下）</h1><p data-nodeid="45396">了解了 OAL 语言的基础语法以及 official_analysis.oal 文件中典型的 OAL 语句之后，我们来看 official_analysis.oal 文件是如何被解析的。</p>



<p data-nodeid="46178">在generate-tool-grammar 模块中会使 antlr4-maven-plugin 这个 Maven 插件处理 OALParser.g4 以及 OALLexer.g4 文件，得到相应的辅助类，如下图所示，这与前文 Antlr4 示例相同：</p>
<p data-nodeid="46179" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/1A/CgqCHl8ETYeADqgoAAE8NIoy0_c302.png" alt="Drawing 0.png" data-nodeid="46183"></p>


<p data-nodeid="44380">generate-tool 模块会使用上述辅助类识别 official_analysis.oal 文件并最终转换成 OALScripts 对象，相关的代码片段如下：</p>
<pre class="lang-java" data-nodeid="46576"><code data-language="java"><span class="hljs-comment">// 构造 official_analysis.oal 文件的完整路径</span>
String scriptFilePath = StringUtil.join(File.separatorChar,
    modulePath, <span class="hljs-string">"src"</span>, <span class="hljs-string">"main"</span>, <span class="hljs-string">"resources"</span>, <span class="hljs-string">"official_analysis.oal"</span>);
<span class="hljs-comment">// 创建 ScriptParser实例</span>
ScriptParser scriptParser =  
      ScriptParser.createFromFile(scriptFilePath);
<span class="hljs-comment">// 调用 parse()方法识别 official_analysis.oal文件</span>
OALScripts oalScripts = scriptParser.parse(); 
</code></pre>

<p data-nodeid="47375" class="">在 ScriptParser.parse() 方法中可以看到，generate-tool 模块与前文示例一样，也是使用 Listener 模式遍历生成的抽象语法树（AST）。最后生成的 OALScripts 对象底层封装了一个 List<code data-backticks="1" data-nodeid="47377">&lt;AnalysisResult&gt;</code>，每个 AnalysisResult 对应一条 OAL 语句。</p>

<p data-nodeid="48155">下面以 instance_jvm_old_gc_time 这条 OAL 语句生成的 AST 为例介绍 OALListener 中各个回调方法的执行流程，下图是该语句生成的简化版 AST，其中的红色箭头标记了 ParseTreeWalker 遍历各个节点的路径：</p>
<p data-nodeid="48156" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/0E/Ciqc1F8ETZ2APvsSAAMOZtTc1cI758.png" alt="Drawing 1.png" data-nodeid="48168"></p>



<p data-nodeid="44384">另外，上图还按序标记了在对应节点上触发的 OALListener 方法，下面是这些方法的具体功能：</p>
<p data-nodeid="44385">(1).enterAggregationStatement() 方法：创建该语句对应的 AnalysisResult 对象。</p>
<p data-nodeid="44386">(2).exitVariable() 方法：填充 AnalysisResult 的 varName、metricsName、tableName 三个字段，会对大小写以及下划线进行处理。</p>
<p data-nodeid="44387">(3).enterSource() 方法：填充 AnalysisResult 的 sourceName、sourceScopeId 两个字段。</p>
<p data-nodeid="44388">(4).enterSourceAttribute() 方法：填充 AnalysisResult 的 sourceAttribute 字段。</p>
<p data-nodeid="44389">(5).enterFilterStatement() 方法：创建 ConditionExpression 对象。</p>
<p data-nodeid="44390">(6)~(8) 三个方法分别填充 ConditionExpression 对象中的三个字段。</p>
<p data-nodeid="44391">(9).exitFilterStatement() 方法：将 ConditionExpression 添加到 AnalysisResult 中的 filterExpressionsParserResult 集合。</p>
<p data-nodeid="44392">(10).enterFunctionName() 方法：填充 AnalysisResult 的 aggregationFunctionName 字段。</p>
<p data-nodeid="48945">到此为止，该 AnalysisResult 填充的字段如下图所示：</p>
<p data-nodeid="48946" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/0E/Ciqc1F8ETaeAbBI9AAK4QkZfEcY292.png" alt="Drawing 2.png" data-nodeid="48950"></p>


<p data-nodeid="44395">(11).exitAggregationStatement() 方法：这里使用 DeepAnalysis 分析前 10 步从 OAL 语句获取到的信息，从而完整填充整个 AnalysisResult 对象。</p>
<ul data-nodeid="49725">
<li data-nodeid="49726">
<p data-nodeid="49727">在 DeepAnalysis 中首先会根据 aggregationFunctionName 确定当前指标的类型并填充 metricsClassName 字段。示例中的 longAvg 会查找到 LongAvgMetrics 类，如下图所示：</p>
</li>
</ul>
<p data-nodeid="49728" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/1A/CgqCHl8ETbGAKMAIAAEGRmp6VX8630.png" alt="Drawing 3.png" data-nodeid="49732"></p>


<ul data-nodeid="44400">
<li data-nodeid="44401">
<p data-nodeid="44402">接下来会查找 LongAvgMetrics 类中 @Entrance 注解标注的入口方法，即 combine() 方法，创建相应的 EntryMethod 对象填充到 entryMethod 字段中。这里生成的 EntryMethod 对象不仅包含入口方法的名称，还会根据入口方法参数上的注解生成相应的参数表达式。</p>
</li>
</ul>
<p data-nodeid="44403">依然以 LongAvgMetrics 为例，combine() 方法的定义如下：</p>
<pre class="lang-java" data-nodeid="50125"><code data-language="java"><span class="hljs-meta">@Entrance</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-meta">@SourceFrom</span> <span class="hljs-keyword">long</span> summation, <span class="hljs-meta">@ConstOne</span> <span class="hljs-keyword">int</span> count)</span> </span>{
    <span class="hljs-keyword">this</span>.summation += summation;
    <span class="hljs-keyword">this</span>.count += count;
}
</code></pre>

<p data-nodeid="50518">之前我们只关心了方法内的具体逻辑，没有关注方法以及参数上的注解。@Entrance 注解标识了该方法为入口方法，@SourceFrom 标识了该参数来自 OAL 语句前面指定的 source.sourceAttribute，即 ServiceInstanceJVMGC.time，@ ConstOne 标识该参数固定为 1。</p>
<p data-nodeid="50519">查找 @Entrance 标注的方法的逻辑比较简单，就是遍历 LongAvgMetrics 以及父类所有方法即可。这里来看处理 @SourceFrom 以及 @ConstOne 注解的相关代码如下：</p>

<pre class="lang-java" data-nodeid="50914"><code data-language="java">EntryMethod entryMethod = <span class="hljs-keyword">new</span> EntryMethod();
result.setEntryMethod(entryMethod);&nbsp;
<span class="hljs-comment">// @Entrance注解标注的入口方法名</span>
entryMethod.setMethodName(entranceMethod.getName());

<span class="hljs-comment">// 根据入口方法的参数设置参数代码</span>
<span class="hljs-keyword">for</span> (Parameter parameter : entranceMethod.getParameters()) {
&nbsp; &nbsp; Annotation[] parameterAnnotations = parameter.getAnnotations();
&nbsp; &nbsp; Annotation annotation = parameterAnnotations[<span class="hljs-number">0</span>];
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (annotation <span class="hljs-keyword">instanceof</span> SourceFrom) {
&nbsp; &nbsp; &nbsp; &nbsp; entryMethod.addArg(<span class="hljs-string">"source."</span> + ClassMethodUtil
             .toGetMethod(result.getSourceAttribute()) + <span class="hljs-string">"()"</span>);
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (annotation <span class="hljs-keyword">instanceof</span> ConstOne) {
&nbsp; &nbsp; &nbsp; &nbsp; entryMethod.addArg(<span class="hljs-string">"1"</span>);
&nbsp; &nbsp; }&nbsp;
&nbsp; &nbsp; <span class="hljs-comment">// 还有针对其他注解的处理，例如 @Expression、@ExpressionArg0等，不再展开</span>
}
</code></pre>

<p data-nodeid="51693">最终创建的 EntryMethod 对象如下图所示：</p>
<p data-nodeid="51694" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/0E/Ciqc1F8ETcGAFSJfAAD90Ejj-vM209.png" alt="Drawing 4.png" data-nodeid="51698"></p>


<ul data-nodeid="52475">
<li data-nodeid="52476">
<p data-nodeid="52477">扫描 LongAvgMetrics 中的全部字段，将所有 @Column 注解标注的字段封装成 DataColumn 对象记录到 persistentFields 集合中。</p>
</li>
<li data-nodeid="52478">
<p data-nodeid="52479">根据 sourceName 字段的值从 generator-scope-meta.yml 文件中查找该 source 默认新增的字段，如下图所示，InstanceJvmOldGcTimeMetrics 需要新增 entityId、serviceId 两个字段，这也与我们之前的分析相同。这些新增字段会记录到 fieldsFromSource 集合中。</p>
</li>
</ul>
<p data-nodeid="52480" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/1A/CgqCHl8ETciAVpVKAAEuRAJmdIU888.png" alt="Drawing 5.png" data-nodeid="52485"></p>


<p data-nodeid="44414">到此为止，instance_jvm_old_gc_time 这条 OAL 语句对应的 AnalysisResult 对象填充完毕。在第 11 步 exitAggregationStatement() 方法的最后，会将该 AnalysisResult 对象记录到 OALScripts.metricsStmts 集合中，作为后续 FreeMarker 填充模板的数据。</p>
<h3 data-nodeid="54438" class="">MetricsImplementor 模板</h3>





<p data-nodeid="44416">在完成 official_analysis.oal 文件中全部 OAL 语句的处理之后，会将 OALScripts 对象传入到 FileGenerator 中完成 Java 代码生成。在 FileGenerator 的构造方法中会初始化 Configuration 对象，与前面介绍的 FreeMarker 示例相同。</p>
<p data-nodeid="44417">在 FileGenerator.generate() 方法中会遍历全部 AnalysisResult 对象，为每个 AnalysisResult 对象生成相应的 Metrics 类以及 Dispatcher 类。创建 Metrics 类时使用的是 MetricsImplementor.ftl 模板文件，相关代码如下：</p>
<pre class="lang-java" data-nodeid="54816"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateMetricsImplementor</span><span class="hljs-params">(AnalysisResult result,Writer output)</span> </span>{
   configuration.getTemplate(<span class="hljs-string">"MetricsImplementor.ftl"</span>)
        .process(result, output);
}
</code></pre>

<p data-nodeid="44419">在 MetricsImplementor.ftl 这个模板文件中，我们重点关注一下字段生成的逻辑以及 id() 方法的逻辑，具体如下所示：</p>
<pre class="lang-dart" data-nodeid="57832"><code data-language="dart">&lt;!-- 直接获取 AnalysisResult中相应的字段值，生成的<span class="hljs-meta">@Stream</span>注解--&gt;
<span class="hljs-meta">@Stream</span>(name = <span class="hljs-string">"<span class="hljs-subst">\${tableName}</span>"</span>, 
        scopeId = \${sourceScopeId}, 
        builder = \${metricsName}Metrics.Builder.<span class="hljs-keyword">class</span>, 
        processor = MetricsStreamProcessor.<span class="hljs-keyword">class</span>)
&lt;!-- 填充类名以及父类名称 --&gt;        
public <span class="hljs-keyword">class</span> \${metricsName}Metrics <span class="hljs-keyword">extends</span> \${metricsClassName} 
    <span class="hljs-keyword">implements</span> WithMetadata {
&lt;!-- 遍历 AnalysisResult中的 fieldsFromSource集合，生成相应的字段 --&gt;
&lt;#list fieldsFromSource <span class="hljs-keyword">as</span> sourceField&gt;
    &lt;!-- 设置 <span class="hljs-meta">@Column</span>注解的名称 --&gt;
    <span class="hljs-meta">@Setter</span> <span class="hljs-meta">@Getter</span> <span class="hljs-meta">@Column</span>(columnName = <span class="hljs-string">"<span class="hljs-subst">\${sourceField.columnName}</span>"</span>) 
    &lt;!-- 根据配置是否添加 <span class="hljs-meta">@IDColumn</span>注解 --&gt;
    &lt;#<span class="hljs-keyword">if</span> sourceField.isID()&gt;<span class="hljs-meta">@IDColumn</span>&lt;/#<span class="hljs-keyword">if</span>&gt;   
    private \${sourceField.typeName} \${sourceField.fieldName};
&lt;/#list&gt;

    <span class="hljs-meta">@Override</span> public <span class="hljs-built_in">String</span> id() {
        <span class="hljs-built_in">String</span> splitJointId = <span class="hljs-built_in">String</span>.valueOf(getTimeBucket());
&lt;!-- 遍历 AnalysisResult中的 fieldsFromSource集合 --&gt;
&lt;#list fieldsFromSource <span class="hljs-keyword">as</span> sourceField&gt;
    &lt;#<span class="hljs-keyword">if</span> sourceField.isID()&gt; &lt;!-- 根据ID配置决定是否参与构造Document Id--&gt;
        &lt;#<span class="hljs-keyword">if</span> sourceField.getTypeName() == <span class="hljs-string">"java.lang.String"</span>&gt;
            splitJointId += Const.ID_SPLIT + \${sourceField.fieldName};
        &lt;#<span class="hljs-keyword">else</span>&gt;
            splitJointId += Const.ID_SPLIT +
                  <span class="hljs-built_in">String</span>.valueOf(\${sourceField.fieldName});
        &lt;/#<span class="hljs-keyword">if</span>&gt;
    &lt;/#<span class="hljs-keyword">if</span>&gt;
&lt;/#list&gt;
        <span class="hljs-keyword">return</span> splitJointId;
    }
    &lt;!-- 省略后续其他方法 --&gt;
}
</code></pre>








<p data-nodeid="44421">Metrics 类其他方法的生成方式与 id() 方法类似，只是使用的 AnalysisResult 字段不同。你可以将 MetricsImplementor.ftl 模板与 InstanceJvmOldGcTimeMetrics.java 进行比较，更便于理解。</p>
<h3 data-nodeid="59729" class="">DispatcherTemplate 模板</h3>





<p data-nodeid="60443">在前文介绍 Dispatcher 的时候提到，不同 Dispatcher 实现会对关联的 Source 进行分析并转换成 Metrics 传入到 MetricsStreamProcessor 进行后续的流处理。例如，ServiceInstanceJVMGCDispatcher 会将一个 ServiceInstanceJVMGC 对象转换成下图展示的四个 Metrics 对象：</p>
<p data-nodeid="60444" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/0E/Ciqc1F8ETfCABEkKAAEpESqaVTE235.png" alt="Drawing 6.png" data-nodeid="60448"></p>


<p data-nodeid="44425">相应的，FileGenerator 生成 Dispatcher 实现类的代码之前，会将由同一个 Source 衍生出来的 Metrics 封装到一个 DispatcherContext 对象， DispatcherContext 的核心字段如下：</p>
<pre class="lang-java" data-nodeid="60809"><code data-language="java"><span class="hljs-keyword">private</span> String source; <span class="hljs-comment">// Source 名称</span>
<span class="hljs-keyword">private</span> String packageName; <span class="hljs-comment">// Dispatcher所在包名</span>
<span class="hljs-comment">// 该 Source所有衍生 Metrics对应的 AnalysisResult对象集合</span>
<span class="hljs-keyword">private</span> List&lt;AnalysisResult&gt; metrics = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); 
</code></pre>

<p data-nodeid="44427">生成 Dispatcher 实现类使用的是 DispatcherTemplate.ftl 模板文件，填充的数据来自 DispatcherContext，入口是 FileGenerator.generateDispatcher() 方法：</p>
<pre class="lang-java" data-nodeid="61170"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateDispatcher</span><span class="hljs-params">(AnalysisResult result, Writer output)</span> </span>{
    String scopeName = result.getSourceName(); 
    <span class="hljs-comment">// 根据 Source名称查找相应的 DispatcherContext</span>
    DispatcherContext context =  
         allDispatcherContext.getAllContext().get(scopeName);
    <span class="hljs-comment">// 生成 Dispatcher实现类的代码并写入到指定文件中</span>
    configuration.getTemplate(<span class="hljs-string">"DispatcherTemplate.ftl"</span>)
           .process(context, output);
}
</code></pre>

<p data-nodeid="44429">接下来看 DispatcherTemplate.ftl 的实现，它会遍历 DispatcherContext.metrics 集合为每个 Metrics 生成相应的 do*() 方法，核心实现如下：</p>
<pre class="lang-java" data-nodeid="61531"><code data-language="java">&lt;#list metrics as metrics&gt; &lt;!-- 遍历 DispatcherContext.metrics 集合 --&gt;
    &lt;!--&nbsp;填充 do*()方法签名 --&gt;
    &lt;!-- 示例中对应 doInstanceJvmOldGcTime(ServiceInstanceJVMGC)方法 --&gt;
    private void do\${metrics.metricsName}(\${source} source) {
        &lt;!--&nbsp;创建相应的Metrics实例 --&gt;
        \${metrics.metricsName}Metrics metrics = 
              new \${metrics.metricsName}Metrics();
    &lt;#if metrics.filterExpressions??&gt;
        &lt;!--根据 OAL语句中 filter表达式生成对source过滤的代码(略)&nbsp;--&gt;
    &lt;/#if&gt;
        &lt;!-- 下面开始填充 Metrics对象 --&gt;
        metrics.setTimeBucket(source.getTimeBucket());
    &lt;#list metrics.fieldsFromSource as field&gt;
        metrics.\${field.fieldSetter}(source.\${field.fieldGetter}());
    &lt;/#list&gt;
        &lt;!-- 根据 AnalysisResult.entryMethod 生成调用入口方法的代码 --&gt;
        &lt;!-- doInstanceJvmOldGcTime() 方法中调用的是 combine() 方法 --&gt;
        metrics.\${metrics.entryMethod.methodName}(
          &lt;!-- 生成入口方法的参数 --&gt;
           &lt;#list metrics.entryMethod.argsExpressions as arg&gt;
             \${arg}&lt;#if arg_has_next&gt;, &lt;/#if&gt;&lt;/#list&gt;
         );
        MetricsStreamProcessor.getInstance().in(metrics);
    }
&lt;/#list&gt;
</code></pre>

<p data-nodeid="44431">为了更好地理解 FreeMarker 填充数据的逻辑，你可以将 DispatcherTemplate.ftl 模板生成 do*() 方法的逻辑与生成后的 ServiceInstanceJVMGCDispatcher.doInstanceJvmOldGcTime() 方法进行比较。</p>
<h3 data-nodeid="62975" class="">内置&nbsp;oal 引擎</h3>




<p data-nodeid="44433">从&nbsp;6.3 版本的开始，SkyWalking&nbsp;将 OAL&nbsp;引擎内置到&nbsp;OAP&nbsp;Server 中，在&nbsp;OAP Server 启动时会动态生成 Metrics&nbsp;类实现以及相应 Dispatcher 实现，我们可以在 CoreModuleProvider.prepare() 方法中看到下面这段代码（6.3 版本之后的代码）：</p>
<pre class="lang-java te-preview-highlight" data-nodeid="63331"><code data-language="java">oalEngine = OALEngineLoader.get();
oalEngine.setStreamListener(streamAnnotationListener);
oalEngine.setDispatcherListener(receiver.getDispatcherManager());
oalEngine.start(getClass().getClassLoader());
</code></pre>

<p data-nodeid="44435">在 oalEngine.start() 方法中会解析 official_analysis.oal 文件得到 OALScripts 对象，然后使用 Javassist 和 FreeMarker 生成的 Metrics 和 Dispatcher 实现类，最后直接通过传入的 ClassLoader 加载到 JVM。<br>
6.3 版本中生成代码的核心实现与 6.2 版本中生成代码的核心实现基本类似，只有下面的微小区别：</p>
<ul data-nodeid="44436">
<li data-nodeid="44437">
<p data-nodeid="44438">6.3 版本之后的 OAL 语法略有改动，但改动很小，并不影响理解。</p>
</li>
<li data-nodeid="44439">
<p data-nodeid="44440">6.3 版本之后在运行时生成代码，而 6.2 版本是在编译期生成。</p>
</li>
<li data-nodeid="44441">
<p data-nodeid="44442">6.3 版本之后生成代码时使用了 Javassist 和 FreeMarker，6.2 版本只使用了 FreeMarker。</p>
</li>
<li data-nodeid="44443">
<p data-nodeid="44444">6.3 版本之后生成的代码默认不会保存到磁盘中，我们可以在环境变量中设置 SW_OAL_ENGINE_DEBUG=Y 参数保存运行时生成的 Java 文件。如果你感兴趣可以对比 6.2 和 6.3 生成的 Java 代码，会发现两者区别不大。</p>
</li>
</ul></div>

</body></html>