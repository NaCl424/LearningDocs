<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>28 | 复杂问题简单化，代理帮你隐藏了多少底层细节？</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>28 | 复杂问题简单化，代理帮你隐藏了多少底层细节？</h1><p data-nodeid="1153" class="">在前面介绍 DubboProtocol 的相关实现时，我们知道 Protocol 这一层以及后面介绍的 Cluster 层暴露出来的接口都是 Dubbo 内部的一些概念，业务层无法直接使用。为了让业务逻辑能够无缝使用 Dubbo，我们就需要将业务逻辑与 Dubbo 内部概念打通，这就用到了动态生成代理对象的功能。Proxy 层在 Dubbo 架构中的位置如下所示（虽然在架构图中 Proxy 层与 Protocol 层距离很远，但 Proxy 的具体代码实现就位于 dubbo-rpc-api 模块中）：</p>
<p data-nodeid="1154"><img src="https://s0.lgstatic.com/i/image/M00/63/B5/CgqCHl-WrK6Af2f9ACAFYNhhHPc051.png" alt="Drawing 0.png" data-nodeid="1275"></p>
<div data-nodeid="1155"><p style="text-align:center">Dubbo 架构中 Proxy 层的位置图</p></div>
<p data-nodeid="1156">在 Consumer 进行调用的时候，Dubbo 会通过<strong data-nodeid="1285">动态代理</strong>将业务接口实现对象转化为相应的 Invoker 对象，然后在 Cluster 层、Protocol 层都会使用 Invoker。在 Provider 暴露服务的时候，也会有 Invoker 对象与业务接口实现对象之间的转换，这同样也是通过<strong data-nodeid="1286">动态代理</strong>实现的。</p>
<p data-nodeid="1157">实现动态代理的常见方案有：JDK 动态代理、CGLib 动态代理和 Javassist 动态代理。这些方案的应用都还是比较广泛的，例如，Hibernate 底层使用了 Javassist 和 CGLib，Spring 使用了 CGLib 和 JDK 动态代理，MyBatis 底层使用了 JDK 动态代理和 Javassist。</p>
<p data-nodeid="1158">从性能方面看，Javassist 与 CGLib 的实现方式相差无几，两者都比 JDK 动态代理性能要高，具体高多少，这就要看具体的机器、JDK 版本、测试基准的具体实现等条件了。</p>
<p data-nodeid="1159"><strong data-nodeid="1293">Dubbo 提供了两种方式来实现代理，分别是 JDK 动态代理和 Javassist</strong>。我们可以在 proxy 这个包内，看到相应工厂类，如下图所示：</p>
<p data-nodeid="1160"><img src="https://s0.lgstatic.com/i/image/M00/63/AA/Ciqc1F-WrLqALvCWAACKW4k6bv4319.png" alt="Drawing 1.png" data-nodeid="1296"></p>
<div data-nodeid="1161"><p style="text-align:center">ProxyFactory 核心实现的位置</p></div>
<p data-nodeid="1162">了解了 Proxy 存在的必要性以及 Dubbo 提供的两种代理生成方式之后，下面我们就开始对 Proxy 层的实现进行深入分析。</p>
<h3 data-nodeid="1163">ProxyFactory</h3>
<p data-nodeid="1164">关于 ProxyFactory 接口，我们在前面的第 23 课时中已经介绍过了，这里做一下简单回顾。ProxyFactory 是一个扩展接口，其中定义了<strong data-nodeid="1303">两个核心方法：一个是 getProxy() 方法，为 Invoker 对象创建代理对象；另一个是 getInvoker() 方法，将代理对象反向封装成 Invoker 对象。</strong></p>
<pre class="lang-java" data-nodeid="1165"><code data-language="java"><span class="hljs-meta">@SPI("javassist")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProxyFactory</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 为传入的Invoker对象创建代理对象</span>
&nbsp; &nbsp; <span class="hljs-meta">@Adaptive({PROXY_KEY})</span>
&nbsp; &nbsp; &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
&nbsp; &nbsp; <span class="hljs-meta">@Adaptive({PROXY_KEY})</span>
&nbsp; &nbsp; &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, <span class="hljs-keyword">boolean</span> generic)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
&nbsp; &nbsp; <span class="hljs-comment">// 将传入的代理对象封装成Invoker对象</span>
&nbsp; &nbsp; <span class="hljs-meta">@Adaptive({PROXY_KEY})</span>
&nbsp; &nbsp; &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
}
</code></pre>
<p data-nodeid="1166">看到 ProxyFactory 上的 @SPI 注解我们知道，其默认实现使用 Javassist 来创建代码对象。</p>
<p data-nodeid="1167"><strong data-nodeid="1309">AbstractProxyFactory 是代理工厂的抽象类</strong>，继承关系如下图所示：</p>
<p data-nodeid="1168"><img src="https://s0.lgstatic.com/i/image/M00/63/AA/Ciqc1F-WrMiAXWheAACKwcyiNxw669.png" alt="Drawing 2.png" data-nodeid="1312"></p>
<div data-nodeid="1169"><p style="text-align:center">AbstractProxyFactory 继承关系图</p></div>
<h3 data-nodeid="1170">AbstractProxyFactory</h3>
<p data-nodeid="1171">AbstractProxyFactory 主要处理的是需要代理的接口，具体实现在 getProxy() 方法中：</p>
<pre class="lang-java" data-nodeid="1172"><code data-language="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, <span class="hljs-keyword">boolean</span> generic)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
&nbsp; &nbsp; Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<span class="hljs-comment">// 记录要代理的接口</span>
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 获取URL中interfaces参数指定的接口</span>
&nbsp; &nbsp; String config = invoker.getUrl().getParameter(INTERFACES);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (config != <span class="hljs-keyword">null</span> &amp;&amp; config.length() &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 按照逗号切分interfaces参数，得到接口集合</span>
&nbsp; &nbsp; &nbsp; &nbsp; String[] types = COMMA_SPLIT_PATTERN.split(config);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (String type : types) { <span class="hljs-comment">// 记录这些接口信息</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interfaces.add(ReflectUtils.forName(type));
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (generic) { <span class="hljs-comment">// 针对泛化接口的处理</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!GenericService.class.isAssignableFrom(invoker.getInterface())) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interfaces.add(GenericService.class);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 从URL中获取interface参数指定的接口</span>
&nbsp; &nbsp; &nbsp; &nbsp; String realInterface = invoker.getUrl().getParameter(Constants.INTERFACE);
&nbsp; &nbsp; &nbsp; &nbsp; interfaces.add(ReflectUtils.forName(realInterface));
&nbsp; &nbsp; }
    <span class="hljs-comment">// 获取Invoker中type字段指定的接口</span>
&nbsp; &nbsp; interfaces.add(invoker.getInterface());
    <span class="hljs-comment">// 添加EchoService、Destroyable两个默认接口</span>
&nbsp; &nbsp; interfaces.addAll(Arrays.asList(INTERNAL_INTERFACES));
    <span class="hljs-comment">// 调用抽象的getProxy()重载方法</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> getProxy(invoker, interfaces.toArray(<span class="hljs-keyword">new</span> Class&lt;?&gt;[<span class="hljs-number">0</span>]));
}
</code></pre>
<p data-nodeid="1173">AbstractProxyFactory 从多个地方获取需要代理的接口之后，会调用子类实现的 getProxy() 方法创建代理对象。</p>
<p data-nodeid="1174">JavassistProxyFactory 对 getProxy() 方法的实现比较简单，直接委托给了 dubbo-common 模块中的 Proxy 工具类进行代理类的生成。下面我们就来深入分析 Proxy 生成代理类的全流程。</p>
<h3 data-nodeid="1175">Proxy</h3>
<p data-nodeid="1176"><strong data-nodeid="1322">在 dubbo-common 模块，Proxy 中的 getProxy() 方法提供了动态创建代理类的核心实现</strong>。这个创建代理类的流程比较长，为了便于你更好地理解，这里我们将其拆开，一步步进行分析。</p>
<p data-nodeid="1177">首先是查找 PROXY_CACHE_MAP 这个代理类缓存（new WeakHashMap&lt;ClassLoader, Map&lt;String, Object&gt;&gt;() 类型），其中第一层 Key 是 ClassLoader 对象，第二层 Key 是上面整理得到的接口拼接而成的，Value 是被缓存的代理类的 WeakReference（弱引用）。</p>
<p data-nodeid="1178">WeakReference（弱引用）的特性是：WeakReference 引用的对象生命周期是两次 GC 之间，也就是说当垃圾收集器扫描到只具有弱引用的对象时，无论当前内存空间是否足够，都会回收该对象。（由于垃圾收集器是一个优先级很低的线程，不一定会很快发现那些只具有弱引用的对象。）</p>
<p data-nodeid="1179">WeakReference 的特性决定了它特别适合用于数据可恢复的内存型缓存。查找缓存的结果有下面三个：</p>
<ul data-nodeid="1180">
<li data-nodeid="1181">
<p data-nodeid="1182">如果缓存中查找不到任务信息，则会在缓存中添加一个 PENDING_GENERATION_MARKER 占位符，当前线程后续创建生成代理类并最终替换占位符。</p>
</li>
<li data-nodeid="1183">
<p data-nodeid="1184">如果在缓存中查找到了 PENDING_GENERATION_MARKER 占位符，说明其他线程已经在生成相应的代理类了，当前线程会阻塞等待。</p>
</li>
<li data-nodeid="1185">
<p data-nodeid="1186">如果缓存中查找到完整代理类，则会直接返回，不会再执行后续动态代理类的生成。</p>
</li>
</ul>
<p data-nodeid="1187">下面是 Proxy.getProxy() 方法中对 PROXY_CACHE_MAP 缓存进行查询的相关代码片段：</p>
<pre class="lang-java" data-nodeid="1188"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Proxy <span class="hljs-title">getProxy</span><span class="hljs-params">(ClassLoader cl, Class&lt;?&gt;... ics)</span> </span>{
&nbsp; &nbsp; StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ics.length; i++) { <span class="hljs-comment">// 循环处理每个接口类</span>
&nbsp; &nbsp; &nbsp; &nbsp; String itf = ics[i].getName();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!ics[i].isInterface()) { <span class="hljs-comment">// 传入的必须是接口类，否则直接报错</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(itf + <span class="hljs-string">" is not a interface."</span>);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 加载接口类，加载失败则直接报错</span>
&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; tmp = Class.forName(itf, <span class="hljs-keyword">false</span>, cl);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (tmp != ics[i]) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"..."</span>);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; sb.append(itf).append(<span class="hljs-string">';'</span>); <span class="hljs-comment">// 将接口类的完整名称用分号连接起来</span>
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 接口列表将会作为第二层集合的Key</span>
&nbsp; &nbsp; String key = sb.toString();
&nbsp; &nbsp; <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; cache;
&nbsp; &nbsp; <span class="hljs-keyword">synchronized</span> (PROXY_CACHE_MAP) { <span class="hljs-comment">// 加锁同步</span>
&nbsp; &nbsp; &nbsp; &nbsp; cache = PROXY_CACHE_MAP.computeIfAbsent(cl, k -&gt; <span class="hljs-keyword">new</span> HashMap&lt;&gt;());
&nbsp; &nbsp; }
&nbsp; &nbsp; Proxy proxy = <span class="hljs-keyword">null</span>;
&nbsp; &nbsp; <span class="hljs-keyword">synchronized</span> (cache) { <span class="hljs-comment">// 加锁</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">do</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object value = cache.get(key);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Reference&lt;?&gt;) { <span class="hljs-comment">// 获取到WeakReference</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy = (Proxy) ((Reference&lt;?&gt;) value).get();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (proxy != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 查找到缓存的代理类</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> proxy;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (value == PENDING_GENERATION_MARKER) { <span class="hljs-comment">// 获取到占位符</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache.wait(); <span class="hljs-comment">// 阻塞等待其他线程生成好代理类，并添加到缓存中</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 设置占位符，由当前线程生成代理类</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache.put(key, PENDING_GENERATION_MARKER);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 退出当前循环</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>);
&nbsp; &nbsp; }
&nbsp; &nbsp; ... ... <span class="hljs-comment">// 后续动态生成代理类的逻辑</span>
}
</code></pre>
<p data-nodeid="1189">完成缓存的查找之后，下面我们再来看代理类的生成过程。</p>
<p data-nodeid="1190">第一步，调用 ClassGenerator.newInstance() 方法创建 ClassLoader 对应的 ClassPool。ClassGenerator 中封装了 Javassist 的基本操作，还定义了很多字段用来暂存代理类的信息，在其 toClass() 方法中会用这些暂存的信息来动态生成代理类。下面就来简单说明一下这些字段。</p>
<ul data-nodeid="1191">
<li data-nodeid="1192">
<p data-nodeid="1193">mClassName（String 类型）：代理类的类名。</p>
</li>
<li data-nodeid="1194">
<p data-nodeid="1195">mSuperClass（String 类型）：代理类父类的名称。</p>
</li>
<li data-nodeid="1196">
<p data-nodeid="1197">mInterfaces（Set<code data-backticks="1" data-nodeid="1355">&lt;String&gt;</code> 类型）：代理类实现的接口。</p>
</li>
<li data-nodeid="1198">
<p data-nodeid="1199">mFields（List类型）：代理类中的字段。</p>
</li>
<li data-nodeid="1200">
<p data-nodeid="1201">mConstructors（List<code data-backticks="1" data-nodeid="1359">&lt;String&gt;</code>类型）：代理类中全部构造方法的信息，其中包括构造方法的具体实现。</p>
</li>
<li data-nodeid="1202">
<p data-nodeid="1203">mMethods（List<code data-backticks="1" data-nodeid="1362">&lt;String&gt;</code>类型）：代理类中全部方法的信息，其中包括方法的具体实现。</p>
</li>
<li data-nodeid="1204">
<p data-nodeid="1205">mDefaultConstructor（boolean 类型）：标识是否为代理类生成的默认构造方法。</p>
</li>
</ul>
<p data-nodeid="1206">在 ClassGenerator 的 toClass() 方法中，会根据上述字段用 Javassist 生成代理类，具体实现如下：</p>
<pre class="lang-java" data-nodeid="1207"><code data-language="java"><span class="hljs-keyword">public</span> Class&lt;?&gt; toClass(ClassLoader loader, ProtectionDomain pd) {
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (mCtc != <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; mCtc.detach();
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 在代理类继承父类的时候，会将该id作为后缀编号，防止代理类重名</span>
&nbsp; &nbsp; <span class="hljs-keyword">long</span> id = CLASS_NAME_COUNTER.getAndIncrement();&nbsp;
&nbsp; &nbsp; CtClass ctcs = mSuperClass == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : mPool.get(mSuperClass);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (mClassName == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 确定代理类的名称</span>
&nbsp; &nbsp; &nbsp; &nbsp; mClassName = (mSuperClass == <span class="hljs-keyword">null</span> || javassist.Modifier.isPublic(ctcs.getModifiers())
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? ClassGenerator.class.getName() : mSuperClass + <span class="hljs-string">"$sc"</span>) + id;
&nbsp; &nbsp; }
&nbsp; &nbsp; mCtc = mPool.makeClass(mClassName); <span class="hljs-comment">// 创建CtClass，用来生成代理类</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (mSuperClass != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 设置代理类的父类</span>
&nbsp; &nbsp; &nbsp; &nbsp; mCtc.setSuperclass(ctcs);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 设置代理类实现的接口，默认会添加DC这个接口</span>
&nbsp; &nbsp; mCtc.addInterface(mPool.get(DC.class.getName()));&nbsp;
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (mInterfaces != <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (String cl : mInterfaces) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mCtc.addInterface(mPool.get(cl));
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (mFields != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 设置代理类的字段</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (String code : mFields) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mCtc.addField(CtField.make(code, mCtc));
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (mMethods != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 生成代理类的方法</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (String code : mMethods) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (code.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">':'</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mCtc.addMethod(CtNewMethod.copy(getCtMethod(mCopyMethods.get(code.substring(<span class="hljs-number">1</span>))),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; code.substring(<span class="hljs-number">1</span>, code.indexOf(<span class="hljs-string">'('</span>)), mCtc, <span class="hljs-keyword">null</span>));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mCtc.addMethod(CtNewMethod.make(code, mCtc));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (mDefaultConstructor) { <span class="hljs-comment">// 生成默认的构造方法</span>
&nbsp; &nbsp; &nbsp; &nbsp; mCtc.addConstructor(CtNewConstructor.defaultConstructor(mCtc));
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (mConstructors != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 生成构造方法</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (String code : mConstructors) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (code.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">':'</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mCtc.addConstructor(CtNewConstructor
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .copy(getCtConstructor(mCopyConstructors.get(code.substring(<span class="hljs-number">1</span>))), mCtc, <span class="hljs-keyword">null</span>));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String[] sn = mCtc.getSimpleName().split(<span class="hljs-string">"\\$+"</span>); <span class="hljs-comment">// inner class name include $.</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mCtc.addConstructor(
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CtNewConstructor.make(code.replaceFirst(SIMPLE_NAME_TAG, sn[sn.length - <span class="hljs-number">1</span>]), mCtc));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">return</span> mCtc.toClass(loader, pd);
}
</code></pre>
<p data-nodeid="1208">第二步，从 PROXY_CLASS_COUNTER 字段（AtomicLong类型）中获取一个 id 值，作为代理类的后缀，这主要是为了避免类名重复发生冲突。</p>
<p data-nodeid="1209">第三步，遍历全部接口，获取每个接口中定义的方法，对每个方法进行如下处理：</p>
<ol data-nodeid="1210">
<li data-nodeid="1211">
<p data-nodeid="1212">加入 worked 集合（Set<code data-backticks="1" data-nodeid="1373">&lt;String&gt;</code> 类型）中，用来判重。</p>
</li>
<li data-nodeid="1213">
<p data-nodeid="1214">将方法对应的 Method 对象添加到 methods 集合（List<code data-backticks="1" data-nodeid="1376">&lt;Method&gt;</code> 类型）中。</p>
</li>
<li data-nodeid="1215">
<p data-nodeid="1216">获取方法的参数类型以及返回类型，构建方法体以及 return 语句。</p>
</li>
<li data-nodeid="1217">
<p data-nodeid="1218">将构造好的方法添加到 ClassGenerator 中的 mMethods 集合中进行缓存。</p>
</li>
</ol>
<p data-nodeid="1219">相关代码片段如下所示：</p>
<pre class="lang-java" data-nodeid="1220"><code data-language="java"><span class="hljs-keyword">long</span> id = PROXY_CLASS_COUNTER.getAndIncrement();
String pkg = <span class="hljs-keyword">null</span>;
ClassGenerator ccp = <span class="hljs-keyword">null</span>, ccm = <span class="hljs-keyword">null</span>;
ccp = ClassGenerator.newInstance(cl);
Set&lt;String&gt; worked = <span class="hljs-keyword">new</span> HashSet&lt;&gt;()
List&lt;Method&gt; methods = <span class="hljs-keyword">new</span> ArrayList&gt;();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ics.length; i++) {
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!Modifier.isPublic(ics[i].getModifiers())) {
&nbsp; &nbsp; &nbsp; &nbsp; String npkg = ics[i].getPackage().getName();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (pkg == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 如果接口不是public的，则需要保证所有接口在一个包下</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkg = npkg;
&nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!pkg.equals(npkg)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"non-public interfaces from different packages"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; ccp.addInterface(ics[i]); <span class="hljs-comment">// 向ClassGenerator中添加接口</span>
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (Method method : ics[i].getMethods()) { <span class="hljs-comment">// 遍历接口中的每个方法</span>
&nbsp; &nbsp; &nbsp; &nbsp; String desc = ReflectUtils.getDesc(method);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 跳过已经重复方法以及static方法</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (worked.contains(desc) || Modifier.isStatic(method.getModifiers())) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">continue</span>;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (ics[i].isInterface() &amp;&amp; Modifier.isStatic(method.getModifiers())) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">continue</span>;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; worked.add(desc); <span class="hljs-comment">// 将方法描述添加到worked这个Set集合中，进行去重</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">int</span> ix = methods.size();
&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; rt = method.getReturnType(); <span class="hljs-comment">// 获取方法的返回值</span>
&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt;[] pts = method.getParameterTypes(); <span class="hljs-comment">// 获取方法的参数列表</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建方法体</span>
&nbsp; &nbsp; &nbsp; &nbsp; StringBuilder code = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"Object[] args = new Object["</span>).append(pts.length).append(<span class="hljs-string">"];"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; pts.length; j++) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; code.append(<span class="hljs-string">" args["</span>).append(j).append(<span class="hljs-string">"] = ($w)$"</span>).append(j + <span class="hljs-number">1</span>).append(<span class="hljs-string">";"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; code.append(<span class="hljs-string">" Object ret = handler.invoke(this, methods["</span>).append(ix).append(<span class="hljs-string">"], args);"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!Void.TYPE.equals(rt)) { <span class="hljs-comment">// 生成return语句</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; code.append(<span class="hljs-string">" return "</span>).append(asArgument(rt, <span class="hljs-string">"ret"</span>)).append(<span class="hljs-string">";"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 将生成好的方法添加到ClassGenerator中缓存</span>
&nbsp; &nbsp; &nbsp; &nbsp; methods.add(method);
&nbsp; &nbsp; &nbsp; &nbsp; ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="1221">这里我们以 Demo 示例（即 dubbo-demo 模块中的 Demo）中的 sayHello() 方法为例，生成的方法如下所示：</p>
<pre class="lang-java" data-nodeid="1222"><code data-language="java"><span class="hljs-keyword">public</span> java.lang.<span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(java.lang.String arg0)</span></span>{
  Object[] args = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">1</span>]; 
  args[<span class="hljs-number">0</span>] = ($w)$<span class="hljs-number">1</span>; 
  <span class="hljs-comment">// 这里通过InvocationHandler.invoke()方法调用目标方法</span>
  Object ret = handler.invoke(<span class="hljs-keyword">this</span>, methods[<span class="hljs-number">3</span>], args); 
  <span class="hljs-keyword">return</span> (java.lang.String)ret;
}
</code></pre>
<p data-nodeid="1223">这里的方法调用其实是：委托 InvocationHandler 对象的 invoke() 方法去调用真正的实例方法。</p>
<p data-nodeid="1224">第四步，开始创建代理实例类（ProxyInstance）和代理类。这里我们先创建代理实例类，需要向 ClassGenerator 中添加相应的信息，例如，类名、默认构造方法、字段、父类以及一个 newInstance() 方法，具体实现如下：</p>
<pre class="lang-java" data-nodeid="1225"><code data-language="java">String pcn = pkg + <span class="hljs-string">".proxy"</span> + id; <span class="hljs-comment">// 生成并设置代理类类名</span>
ccp.setClassName(pcn); 
<span class="hljs-comment">// 添加字段，一个是前面生成的methods集合，另一个是InvocationHandler对象</span>
ccp.addField(<span class="hljs-string">"public static java.lang.reflect.Method[] methods;"</span>);
ccp.addField(<span class="hljs-string">"private "</span> + InvocationHandler.class.getName() + <span class="hljs-string">" handler;"</span>);
<span class="hljs-comment">// 添加构造方法</span>
ccp.addConstructor(Modifier.PUBLIC, <span class="hljs-keyword">new</span> Class&lt;?&gt;[]{InvocationHandler.class}, <span class="hljs-keyword">new</span> Class&lt;?&gt;[<span class="hljs-number">0</span>], <span class="hljs-string">"handler=$1;"</span>);
ccp.addDefaultConstructor(); <span class="hljs-comment">// 默认构造方法</span>
Class&lt;?&gt; clazz = ccp.toClass();
clazz.getField(<span class="hljs-string">"methods"</span>).set(<span class="hljs-keyword">null</span>, methods.toArray(<span class="hljs-keyword">new</span> Method[<span class="hljs-number">0</span>]));
</code></pre>
<p data-nodeid="1226">这里得到的代理实例类中每个方法的实现，都类似于上面提到的 sayHello() 方法的实现，即通过 InvocationHandler.invoke()方法调用目标方法。</p>
<p data-nodeid="1227">接下来创建代理类，它实现了 Proxy 接口，并实现了 newInstance() 方法，该方法会直接返回上面代理实例类的对象，相关代码片段如下：</p>
<pre class="lang-java" data-nodeid="1228"><code data-language="java">String fcn = Proxy.class.getName() + id;
ccm = ClassGenerator.newInstance(cl);
ccm.setClassName(fcn);
ccm.addDefaultConstructor(); <span class="hljs-comment">// 默认构造方法</span>
ccm.setSuperClass(Proxy.class); <span class="hljs-comment">// 实现Proxy接口</span>
<span class="hljs-comment">// 实现newInstance()方法，返回上面创建的代理实例类的对象</span>
ccm.addMethod(<span class="hljs-string">"public Object newInstance("</span> + InvocationHandler.class.getName() + <span class="hljs-string">" h){ return new "</span> + pcn + <span class="hljs-string">"($1); }"</span>);
Class&lt;?&gt; pc = ccm.toClass();
proxy = (Proxy) pc.newInstance();
</code></pre>
<p data-nodeid="1229">生成的代理类如下所示：</p>
<pre class="lang-java" data-nodeid="1230"><code data-language="java"><span class="hljs-keyword">package</span> com.apache.dubbo.common.bytecode;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy0</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Proxy</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Proxy0</span><span class="hljs-params">()</span> </span>{}
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(InvocationHandler h)</span></span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> proxy0(h);
	}
}
</code></pre>
<p data-nodeid="1231">第五步，也就是最后一步，在 finally 代码块中，会释放 ClassGenerator 的相关资源，将生成的代理类添加到 PROXY_CACHE_MAP 缓存中保存，同时会唤醒所有阻塞在 PROXY_CACHE_MAP 缓存上的线程，重新检测需要的代理类是否已经生成完毕。相关代码片段如下：</p>
<pre class="lang-java" data-nodeid="1232"><code data-language="java"><span class="hljs-keyword">if</span> (ccp != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 释放ClassGenerator的相关资源</span>
&nbsp; &nbsp; ccp.release();
}
<span class="hljs-keyword">if</span> (ccm != <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; ccm.release();
}
<span class="hljs-keyword">synchronized</span> (cache) { <span class="hljs-comment">// 加锁</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (proxy == <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; cache.remove(key);
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 填充PROXY_CACHE_MAP缓存</span>
&nbsp; &nbsp; &nbsp; &nbsp; cache.put(key, <span class="hljs-keyword">new</span> WeakReference&lt;Proxy&gt;(proxy));
&nbsp; &nbsp; }
&nbsp; &nbsp; cache.notifyAll(); <span class="hljs-comment">// 唤醒所有阻塞在PROXY_CACHE_MAP上的线程</span>
}
</code></pre>
<h3 data-nodeid="1233">getProxy() 方法实现</h3>
<p data-nodeid="1234">分析完 Proxy 使用 Javassist 生成代理类的完整流程之后，我们再回头看一下 JavassistProxyFactory 工厂的 getProxy() 方法实现。这里首先通过前面分析的 getProxy() 方法获取 Proxy 对象，然后调用 newInstance() 方法获取目标类的代理对象，具体如下所示：</p>
<pre class="lang-java" data-nodeid="1235"><code data-language="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="hljs-keyword">new</span> InvokerInvocationHandler(invoker));
}
</code></pre>
<p data-nodeid="1236">相比之下，JdkProxyFactory 对 getProxy() 方法的实现就简单很多，直接使用 JDK 自带的 java.lang.reflect.Proxy 生成代理对象，你可以参考前面第 8 课时中 JDK 动态代理的基本使用方式以及原理：</p>
<pre class="lang-java" data-nodeid="1237"><code data-language="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, <span class="hljs-keyword">new</span> InvokerInvocationHandler(invoker));
}
</code></pre>
<h3 data-nodeid="1238">InvokerInvocationHandler</h3>
<p data-nodeid="1239">无论是 Javassist 还是 JDK 生成的代理类，都会将方法委托给 InvokerInvocationHandler 进行处理。InvokerInvocationHandler 中维护了一个 Invoker 对象，也是前面 getProxy() 方法传入的第一个参数，这个 Invoker 不是一个简单的 DubboInvoker 对象，而是在 DubboInvoker 之上经过一系列装饰器修饰的 Invoker 对象。</p>
<p data-nodeid="1240">在 InvokerInvocationHandler 的 invoke() 方法中，首先会针对特殊的方法进行处理，比如 toString()、$destroy() 等方法。之后，对于业务方法，会创建相应的 RpcInvocation 对象调用 Invoker.invoke() 方法发起 RPC 调用，具体实现如下：</p>
<pre class="lang-java" data-nodeid="1241"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 对于Object中定义的方法，直接调用Invoker对象的相应方法即可</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> method.invoke(invoker, args);
&nbsp; &nbsp; }
&nbsp; &nbsp; String methodName = method.getName();
&nbsp; &nbsp; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (parameterTypes.length == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 对$destroy等方法的特殊处理</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (<span class="hljs-string">"$destroy"</span>.equals(methodName)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoker.destroy();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
    ... <span class="hljs-comment">// 省略其他特殊处理的方法</span>
    <span class="hljs-comment">// 创建RpcInvocation对象，后面会作为远程RPC调用的参数</span>
&nbsp; &nbsp; RpcInvocation rpcInvocation = <span class="hljs-keyword">new</span> RpcInvocation(method, invoker.getInterface().getName(), args);
&nbsp; &nbsp; String serviceKey = invoker.getUrl().getServiceKey();
&nbsp; &nbsp; rpcInvocation.setTargetServiceUniqueName(serviceKey);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (consumerModel != <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel);
&nbsp; &nbsp; &nbsp; &nbsp; rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method));
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 调用invoke()方法发起远程调用，拿到AsyncRpcResult之后，调用recreate()方法获取响应结果(或是Future)</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> invoker.invoke(rpcInvocation).recreate();
}
</code></pre>
<h3 data-nodeid="1242">Wrapper</h3>
<p data-nodeid="1243">Invoker 是 Dubbo 的核心模型。在 Dubbo 中，Provider 的业务层实现会被包装成一个 ProxyInvoker，然后这个 ProxyInvoker 还会被 Filter、Listener 以及其他装饰器包装。ProxyFactory 的 getInvoker 方法就是将业务接口实现封装成 ProxyInvoker 入口。</p>
<p data-nodeid="1244">我们先来看 JdkProxyFactory 中的实现。JdkProxyFactory 会创建一个匿名 AbstractProxyInvoker 的实现，其中的 doInvoke() 方法是通过 Java 原生的反射技术实现的，具体实现如下：</p>
<pre class="lang-java" data-nodeid="1245"><code data-language="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-meta">@Override</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doInvoke</span><span class="hljs-params">(T proxy, String methodName,
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Class&lt;?&gt;[] parameterTypes, Object[] arguments)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 使用反射方式查找methodName对应的方法，并进行调用</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Method method = proxy.getClass().getMethod(methodName, parameterTypes);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> method.invoke(proxy, arguments);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; };
}
</code></pre>
<p data-nodeid="1246">在前面两个课时中我们已经介绍了 Invoker 接口的一个重要实现分支—— AbstractInvoker 以及它的一个实现 DubboInvoker。AbstractProxyInvoker 是 Invoker 接口的另一个实现分支，继承关系如下图所示，其实现类都是 ProxyFactory 实现中的匿名内部类。</p>
<p data-nodeid="1247"><img src="https://s0.lgstatic.com/i/image/M00/63/B6/CgqCHl-WrSOAU0FXAABwy4VTTF4402.png" alt="Drawing 3.png" data-nodeid="1408"></p>
<p data-nodeid="1248">在 AbstractProxyInvoker 实现的 invoke() 方法中，会将 doInvoke() 方法返回的结果封装成 CompletableFuture 对象，然后再封装成 AsyncRpcResult 对象返回，具体实现如下：</p>
<pre class="lang-java" data-nodeid="1249"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 执行doInvoke()方法，调用业务实现</span>
&nbsp; &nbsp; Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 将value值封装成CompletableFuture对象</span>
&nbsp; &nbsp; CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);
&nbsp; &nbsp; <span class="hljs-comment">//&nbsp;再次转换，转换为CompletableFuture&lt;AppResponse&gt;类型</span>
&nbsp; &nbsp; CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; AppResponse result = <span class="hljs-keyword">new</span> AppResponse();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> CompletionException) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result.setException(t.getCause());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result.setException(t);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result.setValue(obj);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> result;
&nbsp; &nbsp; });
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 将CompletableFuture封装成AsyncRpcResult返回</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);
}
</code></pre>
<p data-nodeid="1250">了解了 AbstractProxyInvoker 以及 JdkProxyFactory 返回的实现之后，我们再来看 JavassistProxyFactory.getInvoker() 方法返回的实现。首先该方法会通过 Wrapper 创建一个包装类，然后创建一个实现了 AbstractProxyInvoker 的匿名内部类，其 doInvoker() 方法会直接委托给 Wrapper 对象的 InvokeMethod() 方法，具体实现如下：</p>
<pre class="lang-java" data-nodeid="1251"><code data-language="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>{
    <span class="hljs-comment">// 通过Wrapper创建一个包装类对象</span>
&nbsp; &nbsp; <span class="hljs-keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="hljs-string">'$'</span>) &lt; <span class="hljs-number">0</span> ? proxy.getClass() : type);
    <span class="hljs-comment">// 创建一个实现了AbstractProxyInvoker的匿名内部类，其doInvoker()方法会直接委托给Wrapper对象的InvokeMethod()方法</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-meta">@Override</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doInvoke</span><span class="hljs-params">(T proxy, String methodName,
&nbsp; &nbsp; &nbsp;Class&lt;?&gt;[] parameterTypes, Object[] arguments)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; };
}
</code></pre>
<p data-nodeid="1252"><strong data-nodeid="1415">Wrapper 类本身是抽象类，是对 Java 类的一种包装</strong>。Wrapper 会从 Java 类中的字段和方法抽象出相应 propertyName 和&nbsp;methodName，在需要调用一个字段或方法的时候，会根据传入的方法名和参数进行匹配，找到对应的字段和方法进行调用。</p>
<p data-nodeid="1253">Wrapper.getWrapper() 方法会根据不同的 Java 对象，使用 Javassist 生成一个相应的 Wrapper 实现对象。下面我们就来一起分析下 getWrapper() 方法实现：</p>
<ul data-nodeid="1254">
<li data-nodeid="1255">
<p data-nodeid="1256">首先检测该 Java 类是否实现了 DC 这个标识接口，在前面介绍 Proxy 抽象类的时候，我们提到过这个接口；</p>
</li>
<li data-nodeid="1257">
<p data-nodeid="1258">检测 WRAPPER_MAP 集合（Map&lt;Class&lt;?&gt;, Wrapper&gt;&nbsp;类型）中是否缓存了对应的 Wrapper 对象，如果已缓存则直接返回，如果未缓存则调用 makeWrapper() 方法动态生成 Wrapper 实现类，以及相应的实例对象，并写入缓存中。</p>
</li>
</ul>
<p data-nodeid="1259">makeWrapper() 方法的实现非常长，但是逻辑并不复杂，该方法会遍历传入的 Class 对象的所有 public 字段和 public 方法，构建组装 Wrapper 实现类需要的 Java 代码。具体实现有如下三个步骤。</p>
<p data-nodeid="1260">第一步，public 字段会构造相应的 getPropertyValue() 方法和 setPropertyValue() 方法。例如，有一个名为“name”的 public 字段，则会生成如下的代码：</p>
<pre class="lang-java" data-nodeid="1261"><code data-language="java">// 生成的getPropertyValue()方法
public Object getPropertyValue(Object o, String n){
    DemoServiceImpl w; 
    try{ 
        w = ((DemoServiceImpl)$1); 
    }catch(Throwable e){ 
        throw new IllegalArgumentException(e); 
    }
    if( $2.equals(" if( $2.equals("name") ){
        return ($w)w.name; 
    }
}
// 生成的setPropertyValue()方法
public void setPropertyValue(Object o, String n, Object v){&nbsp;
&nbsp; &nbsp; DemoServiceImpl w;&nbsp;
&nbsp; &nbsp; try{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;w = ((DemoServiceImpl)$1);&nbsp;
&nbsp; &nbsp; }catch(Throwable e){&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(e);&nbsp;
&nbsp; &nbsp; }&nbsp;
&nbsp; &nbsp; if( $2.equals("name") ){&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; w.name=(java.lang.String)$3; return;&nbsp;
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="1262">第二步，处理 public 方法，这些 public 方法会添加到 invokeMethod 方法中。以 Demo 示例（即 dubbo-demo 模块中的 demo ）中的 DemoServiceImpl 为例，生成的 invokeMethod() 方法实现如下：</p>
<pre class="lang-java" data-nodeid="1263"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invokeMethod</span><span class="hljs-params">(Object o, String n, Class[] p, Object[] v)</span> <span class="hljs-keyword">throws</span> java.lang.reflect.InvocationTargetException </span>{
    org.apache.dubbo.demo.provider.DemoServiceImpl w;
    <span class="hljs-keyword">try</span> {
        w = ((org.apache.dubbo.demo.provider.DemoServiceImpl) $<span class="hljs-number">1</span>);
    } <span class="hljs-keyword">catch</span> (Throwable e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(e);
    }
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 省略getter/setter方法</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"sayHello"</span>.equals($<span class="hljs-number">2</span>) &amp;&amp; $<span class="hljs-number">3.l</span>ength == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> ($w) w.sayHello((java.lang.String) $<span class="hljs-number">4</span>[<span class="hljs-number">0</span>]);
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"sayHelloAsync"</span>.equals($<span class="hljs-number">2</span>) &amp;&amp; $<span class="hljs-number">3.l</span>ength == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> ($w) w.sayHelloAsync((java.lang.String) $<span class="hljs-number">4</span>[<span class="hljs-number">0</span>]);
        }
    } <span class="hljs-keyword">catch</span> (Throwable e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> java.lang.reflect.InvocationTargetException(e);
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodException(<span class="hljs-string">"Not found method"</span>);
}
</code></pre>
<p data-nodeid="1264">第三步，完成了上述 Wrapper 实现类相关信息的填充之后，makeWrapper() 方法会通过 ClassGenerator 创建 Wrapper 实现类，具体原理与前面 Proxy 创建代理类的流程类似，这里就不再赘述。</p>
<h3 data-nodeid="1265">总结</h3>
<p data-nodeid="1266">本课时主要介绍了 dubbo-rpc-api 模块中“代理”相关的内容。首先我们从 ProxyFactory.getProxy() 方法入手，详细介绍了 JDK 方式和 Javassist 方式创建动态代理类的底层原理，以及其中使用的 InvokerInvocationHandler 的实现。接下来我们又通过 ProxyFactory.getInvoker() 方法入手，重点讲解了 Wrapper 的生成过程和核心原理。</p>
<p data-nodeid="1998">下面这张简图很好地展示了 Dubbo 中 Proxy 和 Wrapper 的重要性：</p>
<p data-nodeid="1999" class=""><img src="https://s0.lgstatic.com/i/image/M00/65/9D/Ciqc1F-biguAJK7LAADFmPgsdKQ193.png" alt="Dubbo_28的图（待替换）.png" data-nodeid="2006"></p>
<div data-nodeid="2000"><p style="text-align:center">Proxy 和 Wrapper 远程调用简图</p></div>




<p data-nodeid="1270">Consumer 端的 Proxy 底层屏蔽了复杂的网络交互、集群策略以及 Dubbo 内部的 Invoker 等概念，提供给上层使用的是业务接口。Provider 端的 Wrapper 是将个性化的业务接口实现，统一转换成 Dubbo 内部的 Invoker 接口实现。正是由于 Proxy 和 Wrapper 这两个组件的存在，Dubbo 才能实现内部接口和业务接口的无缝转换。</p>
<p data-nodeid="1271" class="">关于“代理”相关的内容，你若还有什么想法，欢迎你留言跟我分享。下一课时，我们会再做一个加餐，介绍 Dubbo 中支持的 HTTP 协议的相关内容。</p></div>

</body></html>