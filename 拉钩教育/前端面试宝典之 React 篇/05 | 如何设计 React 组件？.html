<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lagou DOC</title>
<style type="text/css">
:root {
    --control-text-color: #777;
    --select-text-bg-color: rgba(223, 197, 223);  /*#7e66992e;*/
    
    /* side bar */
    --side-bar-bg-color: rgb(255, 255, 255);
    --active-file-text-color: #8163bd;
    --active-file-bg-color: #E9E4F0;
    --item-hover-bg-color: #E9E4F0;
    --active-file-border-color: #8163bd;

    --title-color: #6c549c;
    --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
    --purple-1: #8163bd;
    --purple-2: #79589F;
    --purple-3: #fd5eb8;
    --purple-light-1: rgba(99, 99, 172, .05);
    --purple-light-2: rgba(99, 99, 172, .1);
    --purple-light-3: rgba(99, 99, 172, .2);
    --purple-light-4: rgba(129, 99, 189, .3);
    --purple-light-5: #E9E4F0;
    --purple-light-6: rgba(129, 99, 189, .8);
}

/* html {
    font-size: 16px;
} */

body {
    font-family: var(--font-sans-serif);
    color: #34495e;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

/* 页边距 和 页面大小 */
#write {
    padding-left: 6ch;
    padding-right: 6ch;
    margin: 0 auto;
}

#write p {
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: var(--purple-1);
    padding: 0 2px;
    text-decoration: none;
}
.md-content {
    color: var(--purple-light-6);
}
#write a {
    border-bottom: 1px solid var(--purple-1);
    color: var(--purple-1);
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    /* font-weight: bold; */
    font-weight: 500 !important;
    line-height: 1.4;
    cursor: text;
    color: var(--title-color);
    font-family: var(--font-sans-serif);
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}
h2 tt,
h2 code {
    font-size: inherit !important;
}
h3 tt,
h3 code {
    font-size: inherit !important;
}
h4 tt,
h4 code {
    font-size: inherit !important;
}
h5 tt,
h5 code {
    font-size: inherit !important;
}
h6 tt,
h6 code {
    font-size: inherit !important;
}


h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}
h1 {
    text-align: center;
    padding-bottom: 0.3em;
    font-size: 2.2em;
    line-height: 1.2;
    margin: 2.4em auto 1.2em;
}
h1:after {
    content: '';
    display: block;
    margin: 0.2em auto 0;
    width: 100px;
    height: 2px;
    border-bottom: 2px solid var(--title-color);
}

h2 {
    margin: 1.6em auto 0.5em;
    padding-left: 10px;
    line-height: 1.4;
    font-size: 1.8em;
    border-left: 9px solid var(--title-color);
    border-bottom: 1px solid var(--title-color);
}
h3 {
    font-size: 1.5rem;
    margin: 1.2em auto 0.5em;
}
h4 {
    font-size: 1.3rem;
}
h5 {
    font-size: 1.2rem;
}
h6 {
    font-size: 1.1rem;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

/* 引用 */
blockquote {
    /* margin-left: 1rem; */
    border-left: 4px solid var(--purple-light-4);
    padding: 10px 15px;
    color: #777;
    background-color: var(--purple-light-1);
}

/* 表格 */
table {
    padding: 0;
    word-break: initial;
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

/* 表格 背景色 */
table tr:nth-child(2n),
thead {
    background-color: var(--purple-light-1);
}
#write table thead th {
    background-color: var(--purple-light-2);
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

/* 粗体 */
#write strong {
    padding: 0 2px;
    color: var(--purple-1);
}

/* 斜体 */
#write em {
    padding: 0 5px 0 2px;
    /* font-style: normal; */
    color: #42b983;
}

/* inline code */
#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-size: 0.92rem;
    color: var(--purple-3); 
    background-color: rgba(99, 99, 172, .05);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: #f8f8f8;
    color: var(--purple-3);
}

/* heighlight. */
#write mark {
    background-color: #fbd3ea;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 0.9rem;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

/* 图片 */
.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0 0 4px;
    font-size: 0.9em;
    color: inherit;
}
p .md-image:only-child{
    width: auto;
    text-align: left;
    margin-left: 2rem;
}
.md-tag {
    color: inherit;
}
/* 当 “![shadow-随便写]()”写时，会有阴影 */
.md-image img[alt|='shadow'] {
    /* box-shadow: 0 4px 24px -6px #ddd; */
    box-shadow:var(--purple-light-2) 0px 10px 15px;
}

#write a.md-toc-inner {
    line-height: 1.6;
    white-space: pre-line;
    border-bottom: none;
    font-size: 0.9rem;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

/* 代码框 */
/* CodeMirror 3024 Day theme */

/* 代码段 背景 */
pre {
    --select-text-bg-color: rgba(223, 197, 223) !important;
    margin: .5em 0;
    padding: 1em 1.4em;
    border-radius: 8px;
    background: #f6f8fa;
    overflow-x: auto;
    box-sizing: border-box;
    font-size: 14px;
}

/* 边框 */
.md-fences {
    border: 1px solid #e7eaed;
    border-radius: 3px;
}

.cm-s-inner {
  padding: .25rem;
  border-radius: .25rem;
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  background-color: #f8f8f8 !important;
  color: #3a3432 !important;
  border: none;
}

.cm-s-inner .CodeMirror-gutters {
  color: #6d8a88;
}

.cm-s-inner .CodeMirror-cursor {
  border-left: solid thin #5c5855 !important;
}

.cm-s-inner .CodeMirror-linenumber {
  color: #807d7c;
}

.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line > span::selection,
.cm-s-inner .CodeMirror-line > span::-moz-selection,
.cm-s-inner .CodeMirror-line > span > span::selection,
.cm-s-inner .CodeMirror-line > span > span::-moz-selection {
  background: var(--purple-light-2);
}

.cm-s-inner span.cm-comment {
  color: #cdab53;
}

.cm-s-inner span.cm-string, .cm-s-inner span.cm-string-2 {
  color: #f2b01d;
}

.cm-s-inner span.cm-number {
  color: #a34e8f;
}

.cm-s-inner span.cm-variable {
  color: #01a252;
}

.cm-s-inner span.cm-variable-2 {
  color: #01a0e4;
}

.cm-s-inner span.cm-def {
  /* color: #e8bbd0; */
  color: #e2287f;
}

.cm-s-inner span.cm-operator {
  color: #ff79c6;
}

.cm-s-inner span.cm-keyword {
  color: #db2d20;
}

.cm-s-inner span.cm-atom {
  color: #a34e8f;
}

.cm-s-inner span.cm-meta {
  color: inherit;
}

.cm-s-inner span.cm-tag {
  color: #db2d20;
}

.cm-s-inner span.cm-attribute {
  color: #01a252;
}

.cm-s-inner span.cm-qualifier {
  color: #388aa3;
}

.cm-s-inner span.cm-property {
  color: #01a252;
}

.cm-s-inner span.cm-builtin {
  color: #388aa3;
}

.cm-s-inner span.cm-variable-3, .cm-s-inner span.cm-type {
  color: #ffb86c;
}

.cm-s-inner span.cm-bracket {
  color: #3a3432;
}

.cm-s-inner span.cm-link {
  color: #a34e8f;
}

.cm-s-inner span.cm-error {
  background: #db2d20;
  color: #5c5855;
}

/* .md-fences.md-focus .cm-s-inner .CodeMirror-activeline-background {
  background: var(--purple-light-2);
} */

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: #a34e8f !important;
}

#fences-auto-suggest .active {
  background: #ddd;
}

#write .code-tooltip {
  bottom: initial;
  top: calc(100% - 1px);
  background: #f7f7f7;
  border: 1px solid #ddd;
  border-top: 0;
}

.auto-suggest-container {
  border-color: #b4b4b4;
}

.auto-suggest-container .autoComplt-hint.active {
  background: #b4b4b4;
  color: inherit;
}

/* task list */
#write .md-task-list-item > input {
  -webkit-appearance: initial;
  display: block;
  position: absolute;
  border: 1px solid #b4b4b4;
  border-radius: .25rem;
  margin-top: .1rem;
  margin-left: -1.8rem;
  height: 1.2rem;
  width: 1.2rem;
  transition: background 0.3s;
}

#write .md-task-list-item > input:focus {
  outline: none;
  box-shadow: none;
}

#write .md-task-list-item > input:hover {
  background: #ddd;
}

#write .md-task-list-item > input[checked]::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 50%;
  height: 60%;
  width: 2px;
  transform: rotate(40deg);
  background: #333;
}

#write .md-task-list-item > input[checked]::after {
  content: '';
  position: absolute;
  top: 46%;
  left: 25%;
  height: 30%;
  width: 2px;
  transform: rotate(-40deg);
  background: #333;
}

#write .md-task-list-item > p {
  transition: color 0.3s, opacity 0.3s;
}

#write .md-task-list-item.task-list-done > p {
  color: #b4b4b4;
  text-decoration: line-through;
}

#write .md-task-list-item.task-list-done > p > .md-emoji {
  opacity: .5;
}

#write .md-task-list-item.task-list-done > p > .md-link > a {
  opacity: .6;
}

/* sidebar and outline */
.pin-outline .outline-active {
  color: var(--active-file-text-color); 
}

.file-list-item {
    border-bottom: 1px solid;
    border-color: var(--purple-light-5);
}

.file-list-item-summary {
    font-weight: 400;
}

.file-list-item.active {
    color: var(--active-file-text-color);
    background-color: var(--purple-light-5);
}

.file-tree-node.active>.file-node-background {
    background-color: var(--purple-light-5);
    font-weight: 700;
} 

.file-tree-node.active>.file-node-content {
    color: var(--active-file-text-color);
    font-weight: 700;
}

.file-node-content {
    color: #5e676d;
}

.sidebar-tabs {
    border-bottom: none;
}
.sidebar-tab.active {
    font-weight: 400;
}

.sidebar-content-content {
    font-size: 0.9rem;
}

img {
    max-width: 100%;
}

body {
    background-color: rgb(237, 237, 237);
}
#content {
    width: 836px;
    padding: 50px;
    background: #fff;
    margin: 0 auto;
}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/purple.css*/</style><style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style></head>
<body>
  <div id="content"><h1>05 | 如何设计 React 组件？</h1><p data-nodeid="34530" class="">在第 01 讲中，我们知道了&nbsp;React&nbsp;通过组件化的方式，解决了工程实践中代码如何组织的问题，但它并没有指出组件之间应该按照什么样的方式去组合，本讲我们一起来探讨这个问题，即“如何设计 React 组件”。</p>
<h3 data-nodeid="34531">破题</h3>
<p data-nodeid="34532">“如何设计 React 组件？”其实就是在考察你是否了解 React 组件的设计模式。</p>
<p data-nodeid="34533">你有没有发现在实际的工程实践中，如果缺乏一个指导性的设计模式，而直接开发，代码往往会非常凌乱。常见的情况就是：</p>
<ul data-nodeid="34534">
<li data-nodeid="34535">
<p data-nodeid="34536">将一个页面写成一个组件；</p>
</li>
<li data-nodeid="34537">
<p data-nodeid="34538">一个组件包含两三千行的代码。</p>
</li>
</ul>
<p data-nodeid="34539">这些都没有明显的模块划分，缺乏组合的思想。所以如何将组件更好地组合，这是需要探讨的第一个问题。</p>
<p data-nodeid="34540">在明确了“如何组合”这一核心主题后，我们需要思考的是，如何将核心主题以更好的形式展示出来，因为平铺直叙地罗列知识，那内容是非常干瘪的。而基于不同的业务场景，组件的组合形式是不一样的，所以如果结合丰富场景来展示“如何组合”的方式，可以让表述变得有血有肉，也显得你经验十足。</p>
<p data-nodeid="34541">这里你就需要先搞清楚基于场景的设计分类了。</p>
<h3 data-nodeid="34542">承题</h3>
<p data-nodeid="34543">通过以上的分析，我们可以得出“如何设计 React 组件？”这一题的答题套路是“一个主题，多个场景”，即围绕“如何组合”这一核心主题，通过列举场景的方式展现设计模式的分类及用途。</p>
<p data-nodeid="34544">我们先来了解下 React 的组件有哪些分类，这里可以直接采用 React 社区中非常经典的分类模式：</p>
<ul data-nodeid="34545">
<li data-nodeid="34546">
<p data-nodeid="34547">把只作展示、独立运行、不额外增加功能的组件，称为<strong data-nodeid="34700">哑组件</strong>，或<strong data-nodeid="34701">无状态组件</strong>，还有一种叫法是<strong data-nodeid="34702">展示组件</strong>；</p>
</li>
<li data-nodeid="34548">
<p data-nodeid="34549">把处理业务逻辑与数据状态的组件称为有<strong data-nodeid="34712">状态组件</strong>，或<strong data-nodeid="34713">灵巧组件</strong>，灵巧组件一定包含至少一个灵巧组件或者展示组件。</p>
</li>
</ul>
<p data-nodeid="34550">从分类中可以看出<strong data-nodeid="34719">展示组件的复用性更强，灵巧组件则更专注于业务本身</strong>。那么基于以上的思路，你可以整理出如下的知识导图：</p>
<p data-nodeid="36697"><img src="https://s0.lgstatic.com/i/image/M00/84/27/CgqCHl_TIYmAVjAWAAUY2rGM2bc188.png" alt="react面试05金句.png" data-nodeid="36701"></p>
<p data-nodeid="36698" class=""><img src="https://s0.lgstatic.com/i/image/M00/84/1C/Ciqc1F_TIY-ANgywAAB0DSyjFv4894.png" alt="图片1.png" data-nodeid="36704"></p>




<p data-nodeid="34552">接下来我将结合各个场景来为你展开讲解这些组件。</p>
<h3 data-nodeid="34553">入题</h3>
<p data-nodeid="34554">无论是怎样的设计，始终是不能脱离工程实践进行探讨的。回到前端工程中来，如果使用 create-react-app 初始化项目，通常会有类似这样的目录结构：</p>
<pre class="lang-java" data-nodeid="34555"><code data-language="java">.
├── README.md
├── <span class="hljs-keyword">package</span>.json
├── <span class="hljs-keyword">public</span>
│&nbsp; &nbsp;├── favicon.ico
│&nbsp; &nbsp;├── index.html
│&nbsp; &nbsp;├── logo192.png
│&nbsp; &nbsp;├── logo512.png
│&nbsp; &nbsp;├── manifest.json
│&nbsp; &nbsp;└── robots.txt
├── src
│&nbsp; &nbsp;├── App.css
│&nbsp; &nbsp;├── App.js
│&nbsp; &nbsp;├── App.test.js
│&nbsp; &nbsp;├── index.css
│&nbsp; &nbsp;├── index.js
│&nbsp; &nbsp;├── logo.svg
│&nbsp; &nbsp;├── reportWebVitals.js
│&nbsp; &nbsp;└── setupTests.js
└── yarn.lock
</code></pre>
<p data-nodeid="34556">在源码目录，也就是 src 目录中，所有组件就像衣服散落在房间里一样堆在了一起，如果继续添置衣物，可以想象这个房间最后会变得有多乱。就像每件衣服总有它适用的场合，组件也有同样的分类。</p>
<p data-nodeid="34557">我先带你从功能最薄弱的展示组件开始梳理，其次是展示组件中装饰作用的小物件。</p>
<h4 data-nodeid="34558">展示组件</h4>
<p data-nodeid="34559">展示组件内部是没有状态管理的，正如其名，就像一个个“装饰物”一样，完全受制于外部的 props 控制。展示组件具有极强的<strong data-nodeid="34738">通用性</strong>，<strong data-nodeid="34739">复用率</strong>也很高，往往与当前的前端工程关系相对薄弱，甚至可以做到跨项目级的复用。</p>
<p data-nodeid="34560">我们先来看一下展示组件中最常用的代理组件。</p>
<p data-nodeid="34561"><strong data-nodeid="34744">代理组件</strong></p>
<p data-nodeid="34562"><strong data-nodeid="34753">代理组件常用于封装常用属性</strong>，<strong data-nodeid="34754">减少重复代码</strong>。关于代理组件你应该不陌生，可能经常会写。</p>
<p data-nodeid="34563">举一个最常见的例子，当需要定义一个按钮的时候，需要在按钮上添加 button 属性，代码如下：</p>
<pre class="lang-java" data-nodeid="34564"><code data-language="java">&lt;button type=<span class="hljs-string">"button"</span>&gt;
</code></pre>
<p data-nodeid="34565">当然在 React 中使用的时候，不可能每次都写这样一段代码，非常麻烦。常见的做法是<strong data-nodeid="34761">封装</strong>：</p>
<pre class="lang-java" data-nodeid="34566"><code data-language="java"><span class="hljs-keyword">const</span> Button = props =&gt;
&nbsp; &lt;button type=<span class="hljs-string">"button"</span> {...props}&gt;
</code></pre>
<p data-nodeid="34567">在开发中使用 Button 组件替代原生的 button，可以确保 type 保证一致。</p>
<p data-nodeid="34568">在使用 Antd 开发时，你也会采用类似的设计模式，大致情况如下：</p>
<pre class="lang-java" data-nodeid="34569"><code data-language="java"><span class="hljs-keyword">import</span> { Button as AntdButton } from from <span class="hljs-string">'antd'</span>
<span class="hljs-keyword">const</span> Button = props =&gt;
  &lt;AntdButton size=<span class="hljs-string">"small"</span> type=<span class="hljs-string">"primary"</span> {...props}&gt;

export <span class="hljs-keyword">default</span> Button
</code></pre>
<p data-nodeid="34570">虽然进行封装感觉是多此一举，但切断了外部组件库的<strong data-nodeid="34769">强依赖特性</strong>。在大厂中引入外部组件库需要考虑两点：</p>
<ul data-nodeid="34571">
<li data-nodeid="34572">
<p data-nodeid="34573">如果当前组件库不能使用了，是否能实现业务上的无痛切换；</p>
</li>
<li data-nodeid="34574">
<p data-nodeid="34575">如果需要批量修改基础组件的字段，如何解决？</p>
</li>
</ul>
<p data-nodeid="34576">代理组件的设计模式很好地解决了上面两个问题。从业务上看，代理组件隔绝了 Antd，仅仅是一个组件 Props API 层的交互。这一层如若未来需要替换，是可以保证兼容、快速替换的，而不需要在原有的代码库中查找修改。其次，如果要修改基础组件的颜色、大小、间距，代理组件也可以相对优雅地解决，使得这些修改都内聚在当前的 Button 组件中，而非散落在其他地方。</p>
<p data-nodeid="34577">基于展示组件的思想，可以封装类似的其他组件，比如样式组件。</p>
<p data-nodeid="34578"><strong data-nodeid="34777">样式组件</strong></p>
<p data-nodeid="34579">样式组件也是一种代理组件，只是又细分了处理样式领域，将当前的关注点分离到当前组件内。你是否还记得在第 02 讲中提到过“关注点分离”的概念，其中就说到“将代码分隔为不同部分，其中每一部分都会有自己的关注焦点”。</p>
<p data-nodeid="34580">但在工程实践中，我们并不会因为一个按钮需要协商 className 而封装成一个组件，就像下面这样：</p>
<pre class="lang-java" data-nodeid="34581"><code data-language="java"><span class="hljs-keyword">const</span> Button = props =&gt; (
  &lt;button type=<span class="hljs-string">"button"</span> className=<span class="hljs-string">"btn btn-primary"</span>&gt;
)
</code></pre>
<p data-nodeid="34582">这并没有什么意义。真实工程项目的样式管理往往是复杂的，它更接近于下面这个例子：</p>
<pre class="lang-java" data-nodeid="34583"><code data-language="java"><span class="hljs-keyword">import</span> classnames from <span class="hljs-string">"classnames"</span>;

<span class="hljs-keyword">const</span> StyleButton = ({ className, primary, isHighLighted,  ...props }) =&gt; (
&nbsp; &lt;Button
&nbsp; &nbsp; type=<span class="hljs-string">"button"</span>
&nbsp; &nbsp; className={classnames(<span class="hljs-string">"btn"</span>, {
     btn-primary: primary,
     highLight: isHighLighted,
}, className)}
&nbsp; &nbsp; {...props}
&nbsp; /&gt;
);
</code></pre>
<p data-nodeid="34584">复杂的样式管理对于 Button 是没有意义的，如果直接使用 Button，在属性上修改，对工程代码而言就是编写大量的面条代码。而 StyleButton 的思路是将样式判断逻辑分离到自身上，面向未来改动的时候会更为友好。</p>
<p data-nodeid="34585">接下来可以看下基于样式组件的优化设计。</p>
<p data-nodeid="34586"><strong data-nodeid="34786">布局组件</strong></p>
<p data-nodeid="34587">布局组件的基本设计与样式组件完全一样，但它基于自身特性做了一个小小的优化。</p>
<p data-nodeid="34588">首先来看下它的基础使用案例，主要用于安放其他组件，类似于这样的用法：</p>
<pre class="lang-java" data-nodeid="34589"><code data-language="java">&lt;Layout
&nbsp; Top={&lt;NavigationBar /&gt;}
  Content={&lt;Article /&gt;}
&nbsp; Bottom={&lt;BottomBar /&gt;}
/&gt;
</code></pre>
<p data-nodeid="34590">布局本身是确定的，不需要根据外部状态的变化去修改内部组件。所以这也是一个可以减少渲染的优化点。（当然，这里的样式结构写得比较简单）</p>
<pre class="lang-java" data-nodeid="34591"><code data-language="java">class Layout extends React.Component {
&nbsp; shouldComponentUpdate() {
&nbsp; &nbsp; return false;
&nbsp; }
&nbsp; render() {
&nbsp; &nbsp; &lt;div&gt;
&nbsp; &nbsp; &nbsp; &lt;div&gt;{this.props.NavigationBar}&lt;/div&gt;
&nbsp; &nbsp; &nbsp; &lt;div&gt;{this.props.Article}&lt;/div&gt;
      &lt;div&gt;{this.props.BottomBar}&lt;/div&gt;
&nbsp; &nbsp; &lt;/div&gt;
&nbsp; }
}
</code></pre>
<p data-nodeid="34592">由于布局组件无需更新，所以对应到第 3 讲中提到的生命周期，就可以通过写死<strong data-nodeid="34799">shouldComponentUpdate</strong> 的返回值直接阻断渲染过程。对于大型前端工程，类似的小心思可以带来性能上的提升。当然，这也是基于代理组件<strong data-nodeid="34800">更易于维护</strong>而带来的好处。</p>
<h4 data-nodeid="34593">灵巧组件</h4>
<p data-nodeid="34594">由于灵巧组件面向业务，所以相对于展示组件来说，其功能更为丰富、复杂性更高，而复用度更低。<strong data-nodeid="34811">展示组件专注于组件本身特性</strong>，<strong data-nodeid="34812">灵巧组件更专注于组合组件</strong>。那么最常见的案例则是容器组件。</p>
<p data-nodeid="34595"><strong data-nodeid="34816">容器组件</strong></p>
<p data-nodeid="34596">容器组件几乎没有复用性，它主要用在两个方面：<strong data-nodeid="34822">拉取数据与组合组件</strong>。可以看这样一个例子：</p>
<pre class="lang-java" data-nodeid="34597"><code data-language="java">const CardList = ({ cards }) =&gt; (
&nbsp; &lt;div&gt;
&nbsp; &nbsp; {cards.map(card =&gt; (
&nbsp; &nbsp; &nbsp; &lt;CardLayout
        header={&lt;Avatar url={card.avatarUrl} /&gt;}
        Content={&lt;Card {...card} /&gt;}
      /&gt;
&nbsp; &nbsp; &nbsp; &nbsp; {comment.body}-{comment.author}
&nbsp; &nbsp; ))}
&nbsp; &lt;/div&gt;
);
</code></pre>
<p data-nodeid="34598">这是一个 CardList 组件，负责将 cards 数据渲染出来，接下来将获取网络数据。如下代码所示：</p>
<pre class="lang-java" data-nodeid="34599"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CardListContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
&nbsp; state = { cards: [] }
&nbsp;
&nbsp; <span class="hljs-function">async <span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> response = <span class="hljs-function">await <span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-string">'/api/cards'</span>)</span>
    <span class="hljs-keyword">this</span>.<span class="hljs-title">setState</span><span class="hljs-params">({cards: response})</span>
&nbsp; }
&nbsp;
&nbsp; <span class="hljs-title">render</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">return</span> &lt;CardList cards={<span class="hljs-keyword">this</span>.state.cards} /&gt;
&nbsp; }
}
</code></pre>
<p data-nodeid="34600">像这样切分代码后，你会发现容器组件内非常干净，没有冗余的样式与逻辑处理。你有没有发现这也是采取了关注点分离的策略？其实这一策略还可以直接应用到你的工作中。因为互联网人的工作常常是多线并行，如果想把事做得更漂亮，可以尝试把它切分成多个片段，让自己的关注点在短时间内更为集中，从而做到高效快速地处理。</p>
<p data-nodeid="34601">回到组件的问题上来，那么对复用性更强的业务逻辑采用什么方式处理呢？</p>
<p data-nodeid="34602"><strong data-nodeid="34829">高阶组件</strong></p>
<p data-nodeid="34603">React 的官方文档将高阶组件称为 React 中<strong data-nodeid="34835">复用组件逻辑的高级技术</strong>。高阶组件本身并不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。简而言之，高阶组件的参数是组件，返回值为新组件的函数。</p>
<p data-nodeid="34604">这样听起来有一些高阶函数的味儿了。那什么是<strong data-nodeid="34841">高阶函数</strong>呢？如果一个函数可以接收另一个函数作为参数，且在执行后返回一个函数，这种函数就称为高阶函数。在 React 的社区生态中，有很多基于高阶函数设计的库，比如 reselector 就是其中之一。</p>
<p data-nodeid="34605">思想一脉相承，React 团队在组件方向也汲取了同样的设计模式。源自高阶函数的高阶组件，可以同样优雅地抽取公共逻辑。</p>
<p data-nodeid="34606"><strong data-nodeid="34846">抽取公共逻辑</strong></p>
<p data-nodeid="34607">用一个常见的例子来说，就是登录态的判断。假设当前项目有订单页面、用户信息页面及购物车首页，那么对于订单页面与用户信息页面都需要检查当前是否已登录，如果没有登录，则应该跳转登录页。</p>
<p data-nodeid="34608">一般的思路类似于：</p>
<pre class="lang-java" data-nodeid="34609"><code data-language="java"><span class="hljs-keyword">const</span> checkLogin = () =&gt; {
  <span class="hljs-keyword">return</span> !!localStorage.getItem(<span class="hljs-string">'token'</span>)
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
   ...
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  componentDidMount() {
    <span class="hljs-keyword">if</span>(!checkLogin) {
      <span class="hljs-comment">// 重定向跳转登录页面</span>
    }
  }
  ...
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  componentDidMount() {
    <span class="hljs-keyword">if</span>(!checkLogin) {
      <span class="hljs-comment">// 重定向跳转登录页面</span>
    }
  }
  ...
 }
</code></pre>
<p data-nodeid="34610">虽然已经抽取了一个函数，但还是需要在对应的页面添加<strong data-nodeid="34854">登录态的判断逻辑</strong>。然而如果有高阶组件的话，情况会完全不同。</p>
<pre class="lang-javascript" data-nodeid="34611"><code data-language="javascript"><span class="hljs-keyword">const</span> checkLogin = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> !!localStorage.getItem(<span class="hljs-string">'token'</span>)
}
<span class="hljs-keyword">const</span> checkLogin = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
              <span class="hljs-keyword">return</span> checkLogin() ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginPage</span> /&gt;</span></span>;
          }
<span class="hljs-comment">// 函数写法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RawUserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
<span class="hljs-keyword">const</span> UserPage = checkLogin(RawUserPage)
<span class="hljs-comment">// 装饰器写法</span>
@checkLogin
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
@checkLogin
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
&nbsp; ...
}
</code></pre>
<p data-nodeid="34612">从上面的例子中可以看出无论<strong data-nodeid="34864">采用函数</strong>还是<strong data-nodeid="34865">装饰器</strong>的写法，都使得重复代码量下降了一个维度。</p>
<p data-nodeid="34613">还有一个非常经典的场景就是<strong data-nodeid="34871">页面埋点统计</strong>。如果使用装饰器编写的话，大概是这样的：</p>
<pre class="lang-javascript" data-nodeid="34614"><code data-language="javascript"><span class="hljs-keyword">const</span> trackPageView = (pageName) = { 
   <span class="hljs-comment">// 发送埋点信息请求</span>
   ... 
}
<span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
      componentDidMount() {
        trackPageView(pageName)
      }
 
      render() {
        <span class="hljs-keyword">return</span> (
          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...this.props</span>} /&gt;</span></span>
        );
      }
    }
  };
}
@PV(<span class="hljs-string">'用户页面'</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
@PV(<span class="hljs-string">'购物车页面'</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
@PV(<span class="hljs-string">'订单页面'</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ..
}
</code></pre>
<p data-nodeid="34615">就连埋点这样的烦琐操作都变得优雅了起来。那我想同时使用 checkLogin 与 PV 怎么办呢？这里涉及到了一个新的概念，就是链式调用。</p>
<p data-nodeid="34616"><strong data-nodeid="34876">链式调用</strong></p>
<p data-nodeid="34617">由于高阶组件返回的是一个新的组件，所以链式调用是默认支持的。基于 checkLogin 与 PV 两个例子，链式使用是这样的：</p>
<pre class="lang-java" data-nodeid="34618"><code data-language="java"><span class="hljs-comment">// 函数调用方式</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RawUserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
<span class="hljs-keyword">const</span> UserPage = checkLogin(PV(<span class="hljs-string">'用户页面'</span>)(RawUserPage))
<span class="hljs-comment">// 装饰器调用方式</span>
<span class="hljs-meta">@checkLogin</span>
<span class="hljs-meta">@PV('用户页面')</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
</code></pre>
<p data-nodeid="34619">在链式调用后，装饰器会按照从外向内、从上往下的顺序进行执行。</p>
<p data-nodeid="34620">除了抽取公用逻辑以外，还有一种修改渲染结果的方式，被称为<strong data-nodeid="34883">渲染劫持。</strong></p>
<p data-nodeid="34621"><strong data-nodeid="34887">渲染劫持</strong></p>
<p data-nodeid="34622">渲染劫持可以通过控制 render 函数修改输出内容，常见的场景是显示加载元素，如下情况所示：</p>
<pre class="lang-javascript" data-nodeid="34623"><code data-language="javascript"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withLoading</span>(<span class="hljs-params">WrappedComponent</span>) </span>{
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WrappedComponent</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; render() {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.props.isLoading) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> /&gt;</span></span>;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.render();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; };
}
</code></pre>
<p data-nodeid="34624">通过高阶函数中继承原组件的方式，劫持修改 render 函数，篡改返回修改，达到显示 Loading 的效果。</p>
<p data-nodeid="34625">但高阶组件并非万能，它同样也有缺陷。</p>
<p data-nodeid="34626"><strong data-nodeid="34894">缺陷</strong></p>
<p data-nodeid="34627"><strong data-nodeid="34898">丢失静态函数</strong></p>
<p data-nodeid="34628">由于被包裹了一层，所以静态函数在外层是无法获取的。如下面的案例中 getUser 是无法被调用的。</p>
<pre class="lang-java" data-nodeid="34629"><code data-language="java"><span class="hljs-comment">// UserPage.jsx</span>
<span class="hljs-meta">@PV('用户页面')</span>
export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>{
      ...
  } 
}
<span class="hljs-comment">// page.js</span>
<span class="hljs-keyword">import</span> UserPage from <span class="hljs-string">'./UserPage'</span>
UserPage.checkLogin() <span class="hljs-comment">// 调用失败，并不存在。</span>
</code></pre>
<p data-nodeid="34630">如果希望外界能够被调用，那么可以在 PV 函数中将静态函数复制出来。</p>
<pre class="lang-javascript" data-nodeid="34631"><code data-language="javascript"><span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
      componentDidMount() {
        trackPageView(pageName)
      }
 
      render() {
        <span class="hljs-keyword">return</span> (
          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...this.props</span>} /&gt;</span></span>
        );
      }
    }
    &nbsp;Wrap.getUser = WrappedComponent.getUser;
     <span class="hljs-keyword">return</span> Wrap;
  };
 }
</code></pre>
<p data-nodeid="34632">这样做确实能解决静态函数在外部无法调用的问题，但一个类的静态函数可能会有很多，都需要一一手动复制么？其实也有更为简便的处理方案。社区中早就有了现成的工具，通过 hoist-non-react-statics 来处理，可以自动复制所有静态函数。如下代码所示。</p>
<pre class="lang-javascript" data-nodeid="34633"><code data-language="javascript"><span class="hljs-keyword">import</span> hoistNonReactStatics <span class="hljs-keyword">from</span> <span class="hljs-string">'hoist-non-react-statics'</span>;
<span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
      componentDidMount() {
        trackPageView(pageName)
      }
 
      render() {
        <span class="hljs-keyword">return</span> (
          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...this.props</span>} /&gt;</span></span>
        );
      }
    }
     hoistNonReactStatics(Wrap, WrappedComponent);
     <span class="hljs-keyword">return</span> Wrap;
  };
 }
</code></pre>
<p data-nodeid="34634">虽然缺少官方的解决方案，但社区方案弥补了不足。除了静态函数的问题以外，还有 refs 属性不能透传的问题。</p>
<p data-nodeid="34635"><strong data-nodeid="34906">refs 属性不能透传</strong></p>
<p data-nodeid="34636">ref 属性由于被高阶组件包裹了一次，所以需要进行特殊处理才能获取。React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题，以下是官方文档中的一个案例：</p>
<pre class="lang-javascript" data-nodeid="34637"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withLog</span>(<span class="hljs-params">Component</span>) </span>{
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogProps</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    componentDidUpdate(prevProps) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'old props:'</span>, prevProps);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'new props:'</span>, <span class="hljs-keyword">this</span>.props);
    }
    render() {
      <span class="hljs-keyword">const</span> {forwardedRef, ...rest} = <span class="hljs-keyword">this</span>.props;
      <span class="hljs-comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span>
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{forwardedRef}</span> {<span class="hljs-attr">...rest</span>} /&gt;</span></span>;
    }
  }
  <span class="hljs-comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span>
  <span class="hljs-comment">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span>
  <span class="hljs-comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span>
  <span class="hljs-keyword">return</span> React.forwardRef(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LogProps</span> {<span class="hljs-attr">...props</span>} <span class="hljs-attr">forwardedRef</span>=<span class="hljs-string">{ref}</span> /&gt;</span></span>;
  });
}
</code></pre>
<p data-nodeid="34638">这段代码读起来会有点儿头皮发麻，它正确的阅读顺序应该是从最底下的 React.forwardRef 部分开始，通过 forwardedRef 转发 ref 到 LogProps 内部。</p>
<h4 data-nodeid="34639">工程实践</h4>
<p data-nodeid="34640">通过以上的梳理，接下来看一下如何在目录中给组件安排位置。</p>
<pre class="lang-java" data-nodeid="34641"><code data-language="java">src
├── components
│&nbsp; &nbsp;├── basic
│&nbsp; &nbsp;├── container
│&nbsp; &nbsp;└── hoc
└── pages
</code></pre>
<ul data-nodeid="34642">
<li data-nodeid="34643">
<p data-nodeid="34644">首先将最基本的展示组件放入 basic 目录中；</p>
</li>
<li data-nodeid="34645">
<p data-nodeid="34646">然后将容器组件放入 container；</p>
</li>
<li data-nodeid="34647">
<p data-nodeid="34648">高阶组件放入 hoc 中；</p>
</li>
<li data-nodeid="34649">
<p data-nodeid="34650">将页面外层组件放在页面目录中；</p>
</li>
<li data-nodeid="34651">
<p data-nodeid="34652">通过目录级别完成切分。</p>
</li>
</ul>
<p data-nodeid="34653">在开发中，针对 basic 组件，建议使用类似 Storybook 的工具进行组件管理。因为Storybook 可以有组织地、高效地构建基础组件，有兴趣的话可以查阅下它的<a href="https://storybook.js.org" data-nodeid="34919">官网</a>。</p>
<h3 data-nodeid="34654">答题</h3>
<p data-nodeid="34655">通过以上的归类分析，关于 React 组件设计，我们的脑海中就有比较清晰的认知了。</p>
<blockquote data-nodeid="34656">
<p data-nodeid="34657">React 组件应从设计与工程实践两个方向进行探讨。</p>
<p data-nodeid="34658">从设计上而言，社区主流分类的方案是展示组件与灵巧组件。</p>
<p data-nodeid="34659">展示组件内部没有状态管理，仅仅用于最简单的展示表达。展示组件中最基础的一类组件称作代理组件。代理组件常用于封装常用属性、减少重复代码。很经典的场景就是引入 Antd 的 Button 时，你再自己封一层。如果未来需要替换掉 Antd 或者需要在所有的 Button 上添加一个属性，都会非常方便。基于代理组件的思想还可以继续分类，分为样式组件与布局组件两种，分别是将样式与布局内聚在自己组件内部。</p>
<p data-nodeid="34660">灵巧组件由于面向业务，其功能更为丰富，复杂性更高，复用度低于展示组件。最经典的灵巧组件是容器组件。在开发中，我们经常会将网络请求与事件处理放在容器组件中进行。容器组件也为组合其他组件预留了一个恰当的空间。还有一类灵巧组件是高阶组件。高阶组件被 React 官方称为 React 中复用组件逻辑的高级技术，它常用于抽取公共业务逻辑或者提供某些公用能力。常用的场景包括检查登录态，或者为埋点提供封装，减少样板代码量。高阶组件可以组合完成链式调用，如果基于装饰器使用，就更为方便了。高阶组件中还有一个经典用法就是反向劫持，通过重写渲染函数的方式实现某些功能，比如场景的页面加载圈等。但高阶组件也有两个缺陷，第一个是静态方法不能被外部直接调用，需要通过向上层组件复制的方式调用，社区有提供解决方案，使用 hoist-non-react-statics 可以解决；第二个是 refs 不能透传，使用 React.forwardRef API 可以解决。</p>
<p data-nodeid="34661">从工程实践而言，通过文件夹划分的方式切分代码。我初步常用的分割方式是将页面单独建立一个目录，将复用性略高的 components 建立一个目录，在下面分别建立 basic、container 和 hoc 三类。这样可以保证无法复用的业务逻辑代码尽量留在 Page 中，而可以抽象复用的部分放入 components 中。其中 basic 文件夹放展示组件，由于展示组件本身与业务关联性较低，所以可以使用 Storybook 进行组件的开发管理，提升项目的工程化管理能力。</p>
</blockquote>
<p data-nodeid="34662">还可以通过以下知识导图来检验你的学习成果，看是否能将每部分补充完整。</p>
<p data-nodeid="37575" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/84/27/CgqCHl_TIbaAEiBdAAEujtJGnY8994.png" alt="图片2 (1).png" data-nodeid="37582"></p>

<h3 data-nodeid="34664">进阶</h3>
<p data-nodeid="34665"><strong data-nodeid="34937">“如何在渲染劫持中为原本的渲染结果添加新的样式？”</strong> 这个问题也经常被追问，其实并不难，但是有可能考察手写代码，所以这里我会做一些提示。</p>
<p data-nodeid="34666">首先回滚上面的案例，在调用 super.render 的时候就可以拿到原本的渲染结果。</p>
<pre class="lang-java" data-nodeid="34667"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">withLoading</span><span class="hljs-params">(WrappedComponent)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WrappedComponent</span> </span>{
        render() {
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.props.isLoading) {
                <span class="hljs-keyword">return</span> &lt;Loading /&gt;;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.render();
            }
        }
    };
}
</code></pre>
<p data-nodeid="34668">那 super.render() 返回的是什么呢？你可以结合 JSX 一讲中的内容思考下。</p>
<h3 data-nodeid="34669">总结</h3>
<p data-nodeid="34670">在本讲中主要对 React 组件的设计模式进行了梳理与回顾，并探讨了设计模式在工程实践中的作用。</p>
<p data-nodeid="34671">在面试中面试官不仅希望听到设计模式有哪些，社区的推荐方式有哪些，更希望听到<strong data-nodeid="34947">模式具体用在哪儿</strong>。如果你知道具体的场景，就会显得更有经验。设计模式并非有确定的标准答案，社区流行的分类方式也并非万能。如果你有自己的见解，在面试中与面试官进行探讨，也是非常值得鼓励的。</p>
<p data-nodeid="34672">下一讲我将会介绍 React 中的一个关于 setState 的经典面试题：“setState 是同步更新还是异步更新”。</p>
<p data-nodeid="34673"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="34953"><img src="https://s0.lgstatic.com/i/image/M00/73/68/Ciqc1F_F_CeAHYQKAASyC72ZqWw053.png" alt="Drawing 2.png" data-nodeid="34952"></a><br>
《大前端高薪训练营》</p>
<p data-nodeid="34674" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="34959">点击链接</a>，快来领取！</p></div>

</body></html>