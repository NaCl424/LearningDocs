<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第03讲：排序</title>
<style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style><style type="text/css">/*
 * Copyright (C) 2018 Drake, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

:root {
    --monospace: "JetBrains Mono", HYZhengYuan, "Fira Code", Menlo, "Ubuntu Mono", Consolas; /*code font*/
    --text-font: var(--monospace); /*default font*/
    --title-font: var(--monospace); /*title font*/

    --text-color: #333333;
    --bg-color: #ffffff;
    --control-text-color: var(--text-color);
    --meta-content-color: var(--text-color);
    --active-file-border-color: var(--drake-accent);
    --rawblock-edit-panel-bd: var(--code-block-bg-color);
    --item-hover-bg-color: #E5E5E596;
    --active-file-bg-color: var(--item-hover-bg-color);

    --drake-accent: #e95f59;
    --drake-highlight: #d63200;
    --a-color: #036aca;
    --variable-color: var(--drake-highlight);
    --outline-active-color: var(--a-color);
    --code-block-bg-color: #2b2b2b;
    --code-block-color: #A9B7C6;
    --title-color: #135ce0;
    --blockquote-border-color: #b2aec5;
    --blockquote-color: #595959;
    --blockquote-bg-color: #fff9f9;
    --strong-color: var(--title-color);
    --h2-underline-color: var(--title-color);
    --horizontal-divider-color: var(--title-color);
    --height-light-color: var(--drake-highlight);
    --height-light-border-color: var(--drake-highlight);
    --yaml-color: #777777;
    --yaml-bg-color: #f7f7f7;
    --footnotes-bg-color: #3c3d3e;
    --footnotes-highlight: #FFD760;
    --table-border-color: #dfe2e5;
    --table-header-bg-color: #f6f8fa;
    --table-bg-color: var(--bg-color);
    --table-n2-bg-color: #f6f8fa;
    --input-bg-color: var(--item-hover-bg-color);
    --btn-hover-bg-color: var(--item-hover-bg-color);
    --checkbox-checked: url("data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cpath d='M425.984 726.016l384-384-59.99-61.995-324.01 324.011-152.021-152.021L213.973 512zm384-598.016q36.01 0 61.013 25.984T896 213.974v596.01q0 34.005-25.003 59.99t-61.013 25.983h-596.01q-36.011 0-61.014-25.984t-25.003-59.989v-596.01q0-34.006 25.003-59.99T213.973 128h596.011z' fill='%2365b73b'/%3E%3C/svg%3E");
    --checkbox-unchecked: url("data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cpath d='M810.667 213.333v597.334H213.333V213.333h597.334m0-85.333H213.333C166.4 128 128 166.4 128 213.333v597.334C128 857.6 166.4 896 213.333 896h597.334C857.6 896 896 857.6 896 810.667V213.333C896 166.4 857.6 128 810.667 128z' fill='%23333333'/%3E%3C/svg%3E");
}

html {
    font-size: 15px;
}

body {
    font-family: var(--text-font) !important;
    color: var(--text-color);
    -webkit-font-feature-settings: "liga" on, "calt" on;
    -webkit-font-smoothing: subpixel-antialiased;
    text-rendering: optimizeLegibility;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
    line-height: 1.8rem;
}

img {
    max-width: 100%;
}

#write {
    background-image: linear-gradient(
            90deg
            ,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(
            1turn
            ,rgba(60,10,30,.04) 3%,transparent 0);
    background-size: 20px 20px;
    background-position: 50%;
}

/*code block*/
#write .md-fences {
    font-size: 1rem;
    padding: 0.5rem !important;
    border-radius: 2px;
    word-wrap: normal;
    background-color: var(--code-block-bg-color);
    color: var(--code-block-color);
    border: none;
}

/*code snippet*/
#write code, tt {
    border-radius: 2px;
    color: var(--drake-highlight);
}

/*variable*/
var {
    color: var(--variable-color);
    font-weight: bold;
}

/*raw block*/
.md-rawblock-control:not(.md-rawblock-tooltip) {
    border-radius: 2px 0 2px 2px;
    padding: 0.2rem !important;
}
.md-rawblock:hover > .md-rawblock-container {
    background: none;
}
.md-rawblock-input {
    font-size: 1rem;
}
.md-rawblock-tooltip-btn:hover {
    background: none;
}
.md-rawblock:hover > .md-rawblock-tooltip {
    border-radius: 2px 2px 0 0;
    margin-bottom: 2px !important;
}
.md-rawblock-tooltip.md-rawblock-control {
    border-radius: 2px 2px 0 0;
    color: var(--code-block-color);
}
.md-rawblock-tooltip-name {
    color: var(--code-block-color);
    opacity: 1;
}

/*quote block*/
blockquote:before {
    display: block;
    position: absolute;
    content: '';
    width: 4px;
    left: 0;
    top: 0;
    height: 100%;
    background-color: var(--blockquote-border-color);
    border-radius: 2px;
}

blockquote {
    color: var(--blockquote-color);
    border-radius: 2px;
    padding: 10px 16px;
    background-color: var(--blockquote-bg-color);
    position: relative;
    border-left: none;
}

#write strong {
    color: var(--strong-color);
    font-weight: bold;
}
#write blockquote strong {
    color: var(--blockquote-color);
}

/*link*/
#write a {
    color: var(--a-color);
    text-decoration: none;
}
#write a .md-plain, .md-htmlblock-container a:hover {
    border-bottom: .1rem solid var(--a-color);
}
[md-inline=link] a {
    margin: 0 .2rem;
}
a:any-link {
    color: var(--a-color);
}

img {
    border-left: none;
    border-right: none;
    vertical-align: baseline;
    border-radius: 2px;
}

#write {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px 30px 100px;
}
#typora-source .CodeMirror-lines {
    max-width: 1200px;
}

#write p {
    word-spacing: .05rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    font-family: var(--title-font);
    position: relative;
    margin-top: 2rem;
    margin-bottom: 1rem;
    font-weight: bold;
    cursor: text;
    color: var(--title-color);
}

h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before {
    visibility: hidden;
}

h1 {
    font-size: 1.6rem;
    text-align: center;
    margin-top: 0;
}

h2.md-end-block.md-heading {
    font-size: 1.6rem;
    display: inline-block;
}

h2.md-end-block.md-heading:after {
    display: block;
    content: '';
    height: 2px;
    margin-top: 4px;
    background-color: var(--h2-underline-color);
    border-radius: 2px;
}

h3 {
    font-size: 1.4rem;
}

h4 {
    font-size: 1.2rem;
}

h5 {
    font-size: 1rem;
}

h6 {
    font-size: 1rem;
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}

h2 tt,
h2 code {
    font-size: inherit !important;
}

h3 tt,
h3 code {
    font-size: inherit !important;
}

h4 tt,
h4 code {
    font-size: inherit !important;
}

h5 tt,
h5 code {
    font-size: inherit !important;
}

h6 tt,
h6 code {
    font-size: inherit !important;
}

blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}
p {
    margin: 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: var(--horizontal-divider-color);
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul, ol {
    padding-inline-start: 2em;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

table {
    padding: 0;
    word-break: initial;
    background-color: var(--table-bg-color);
}
table tr {
    border-top: .1em solid var(--table-border-color);
    margin: 0;
    padding: 0;
}
table th {
    font-weight: bold;
    border: .1em solid var(--table-border-color);
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table td {
    border: .1em solid var(--table-border-color);
    margin: 0;
    padding: 6px 13px;
}
table thead {
    background-color: var(--table-header-bg-color);
}
table tr:nth-child(2n) {
    background-color: var(--table-n2-bg-color);
}
table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

#write em {
    padding: 0 5px 0 2px;
}

/* height light */
#write mark {
    border: .1em solid var(--height-light-border-color);
    color: var(--height-light-color);
    background-color: transparent;
    padding: .1rem .5rem;
    border-radius: 2rem;
    margin: 0 .2rem;
    font-size: .95rem;
}

/*shortcut*/
kbd {
    border: .1em solid #5b5b5e;
    background: transparent;
    color: var(--text-color);
    margin: 0 .4rem;
    font-size: .95rem;
    padding: .3em .4em;
    border-radius: .4em;
    vertical-align: top;
    box-shadow: .1em .1em .2em rgba(0, 0, 0, 0.3);
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 12px;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

/*YAML*/
#write pre.md-meta-block {
    padding: 1rem;
    font-size: 1rem;
    background-color: var(--yaml-bg-color);
    border: 0;
    border-radius: 2px;
    color: var(--yaml-color);
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

#write > h3.md-focus:before {
    left: -1.5625rem;
    top: .375rem;
}

#write > h4.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h5.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h6.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

.md-image > .md-meta {
    border-radius: 2px;
    font-family: initial;
    padding: 2px 0 0 4px;
    color: inherit;
}

.md-tag {
    color: inherit;
}

.md-toc {
    margin-top: 20px;
    padding-bottom: 20px;
}

.typora-quick-open-item {
    font-size: 1rem !important;
    height: 50px;
    padding-left: 8px;
    padding-top: 4px;
    padding-bottom: 4px;
}

#typora-quick-open {
    box-shadow: 0 0 8px #00000045;
    padding: 0;
}

.ty-quick-open-category.ty-has-prev .ty-quick-open-category-title {
    border-top: none;
}

#typora-quick-open-input {
    margin: 8px;
    box-shadow: none;
    border-radius: 2px;
}

#typora-quick-open-input input {
    font-size: 1rem;
    box-shadow: none;
    padding-top: 2px;
    padding-left: 10px;
    padding-right: 10px;
    line-height: 32px;
    max-height: 32px;
    border: none;
}

.modal-dialog#typora-quick-open {
    border-radius: 8px;
}

.ty-quick-open-category-title {
    padding-left: 8px;
    color: #BEBEBE;
    font-size: 0.8rem;
    margin-bottom: 4px;
}

.typora-quick-open-item-path {
    font-size: 0.8rem;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-top: 1px;
}

/*search input*/
.form-control {
    border: none;
    border-radius: 2px;
    box-shadow: none;
}

#md-searchpanel .btn {
    border-radius: 2px;
}

#search-panel-replaceall-btn {
    padding-right: 5px !important;
    text-align: center !important;
}

#search-panel-replace-btn {
    text-align: center !important;
}

#md-searchpanel input {
    background: var(--input-bg-color);
    border-radius: 2px;
}

.searchpanel-search-option-btn {
    border-radius: 2px;
    border: none;
    background: transparent;
    color: var(--text-color);
}

.searchpanel-search-option-btn.active {
    background: var(--text-color);
    color: var(--bg-color);
}

.form-control:focus {
    box-shadow: none;
}

#md-notification:before {
    top: 10px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: initial;
}

/*sidebar*/
.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

#typora-sidebar {
    font-size: 1.1rem;
}

.sidebar-tabs {
    border-bottom: none;
}

.file-list-item-summary, .file-list-item-parent-loc, .file-list-item-time, .file-list-item-summary {
    font-size: 0.9rem !important;
    font-family: var(--text-font);
}

.file-list-item-file-ext-part {
    display: none;
}

.outline-item {
    font-size: 1rem;
}

/*footnotes mark*/
#write .md-footnote {
    background-color: inherit;
    color: var(--drake-highlight);
    font-size: 0.9rem;
    border-radius: 0.9rem;
    padding-left: 0;
}

#write .md-footnote:before {
    content: "[";
}

#write .md-footnote:after {
    content: "]";
}

/*footnotes content*/
.md-hover-tip .code-tooltip-content {
    border-radius: 2px;
}

/*footnotes title*/
span.md-def-name {
    padding-right: 3ch;
    padding-left: 0;
    position: relative;
    font-weight: normal;
}

/*footnotes desc*/
.footnotes {
    font-size: 1rem;
    font-weight: normal;
    color: var(--text-color);
    position: relative;
}

/*footnotes tooltip text*/
.code-tooltip-content .md-plain {
    font-size: 0.9rem;
    font-family: inherit;
}

.code-tooltip-content code {
    padding: 0 2px;
    font-family: inherit;
    color: var(--footnotes-highlight);
    background-color: inherit;
}

.code-tooltip-content a {
    color: var(--footnotes-highlight);
}

div.code-tooltip-content {
    box-shadow: 0 0 8px #00000045;
    background: var(--footnotes-bg-color);
}

.footnotes {
    opacity: 1;
}

.md-def-name:after {
    content: ". ^";
    color: var(--text-color);
}

.md-def-footnote .md-def-name:before {
    content: "";
    color: var(--text-color);
    position: absolute;
}

.md-def-name:before {
    content: "";
    color: var(--text-color);
    position: absolute;
}

.md-content.md-url, .md-def-content.md-def-url.md-auto-disp {
    text-decoration: none;
    border-bottom: .1rem solid var(--text-color);
}

.CodeMirror-scroll::-webkit-scrollbar {
    display: none;
}

.file-list-item-summary {
    font-size: 1em;
}

.pin-outline #outline-content .outline-active strong, .pin-outline .outline-active {
    font-weight: 500;
    color: var(--outline-active-color);
}

.file-list-item.active {
    border-left: 4px solid var(--drake-accent);
}

#md-searchpanel .btn:not(.close-btn):hover {
    box-shadow: none;
    background: var(--btn-hover-bg-color);
}

/*checkbox*/
#write input[type=checkbox] {
    opacity: 0;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
    margin-top: 0;
    top: 0;
}

#write .ul-list li.md-task-list-item.task-list-done::before {
    content: "";
    background: var(--checkbox-checked) 0 0 no-repeat;
    background-size: 100%;
    display: inline-block;
    position: absolute;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
}

#write .ul-list li.md-task-list-item.task-list-not-done::before {
    content: "";
    background: var(--checkbox-unchecked) 0 0 no-repeat;
    background-size: 100%;
    display: inline-block;
    position: absolute;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
}

/*insert table*/
.btn {
    border-radius: 2px;
}

.modal-content {
    border-radius: 8px;
}

.btn-primary:hover, .btn-primary:active {
    background-color: var(--btn-hover-bg-color);
    color: var(--drake-highlight);
}

.btn-primary {
    background-color: transparent;
    color: var(--drake-highlight);
}

.btn-default {
    background-color: transparent;
}

.btn:active {
    box-shadow: none;
    border-color: transparent;
}

.modal-footer {
    border-top: none;
}

#table-insert-col, #table-insert-row {
    background: var(--input-bg-color);
    border-radius: 2px;
}

/*preference panel*/
#megamenu-content {
    background-image: none !important;
    background-color: var(--bg-color);
}
#top-titlebar {
    height: inherit;
    background-color: var(--bg-color);
}
#megamenu-menu-sidebar {
    background-color: var(--bg-color);
    color: var(--text-color);
}
.long-btn {
    width: inherit;
    min-width: 300px;
    border: 1px solid var(--text-color);
    border-radius: 6px;
}
.megamenu-menu-panel h1 {
    margin-bottom: 3rem;
    text-align: left;
}
.megamenu-menu-panel h1, .megamenu-menu-panel h2 {
    font-weight: normal;
}
#recent-file-panel-search-input {
    height: 45px;
    border: none;
    border-bottom: 1px solid var(--text-color);
    padding-left: 8px;
}
#recent-file-panel-search-input::placeholder {
    color: var(--text-color);
    opacity: .5;
}
.megamenu-menu-header {
    border-bottom: none;
}
#recent-file-panel-action-btn {
    background: none;
    border: none;
}
#recent-file-panel-action-btn-container {
    float: none;
    display: inline-block;
}
#top-titlebar .toolbar-icon.btn.hover, #top-titlebar .toolbar-icon.btn:hover {
    background-color: var(--btn-hover-bg-color);
    color: var(--text-color);
}
.megamenu-menu-panel .btn:hover {
    background-color: var(--btn-hover-bg-color) !important;
    color: var(--text-color);
}
#recent-file-panel tbody tr:nth-child(2n-1),
.megamenu-menu-panel table thead,
.megamenu-menu-panel table tr {
    background-color: transparent;
}
.megamenu-menu-panel table {
    font-weight: normal;
}
#megamenu-back-btn {
    color: var(--text-color);
    border: 1px solid var(--text-color);
}
.megamenu-menu-header #megamenu-menu-header-title {
    color: var(--text-color);
}
header, .context-menu, .megamenu-content, footer {
    font-family: var(--text-font);
}
.ty-preferences select {
    padding-left: 2px;
}
.preference-item-hint {
    font-size: 14px;
}
a.ty-link {
    color: var(--a-color);
    margin: 0 .2rem;
}

/**
    code render
    Name: IntelliJ IDEA darcula theme
    From IntelliJ IDEA by JetBrains
 */
.cm-s-inner.CodeMirror {
    background: var(--code-block-bg-color);
    color: var(--code-block-color);
}

.cm-s-inner span.cm-meta {
    color: #BBB529;
}

.cm-s-inner span.cm-number {
    color: #6897BB;
}

.cm-s-inner span.cm-keyword {
    color: #CC7832;
}

.cm-s-inner span.cm-def {
    color: #FFD760;
}

.cm-s-inner span.cm-variable {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-variable-2 {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-variable-3 {
    color: #9876AA;
}

.cm-s-inner span.cm-type {
    color: #AABBCC;
}

.cm-s-inner span.cm-property {
    color: #FFC66D;
}

.cm-s-inner span.cm-operator {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-string {
    color: #6A8759;
}

.cm-s-inner span.cm-string-2 {
    color: #6A8759;
}

.cm-s-inner span.cm-comment {
    color: #787878;
}

.cm-s-inner span.cm-link {
    color: #CC7832;
}

.cm-s-inner span.cm-atom {
    color: #CC7832;
}

.cm-s-inner span.cm-error {
    color: #BC3F3C;
}

.cm-s-inner span.cm-tag {
    color: #E8BF6A;
}

.cm-s-inner span.cm-quote {
    color: #a6e22e;
}

.cm-s-inner span.cm-attribute {
    color: #9876AA;
}

.cm-s-inner span.cm-qualifier {
    color: #6A8759;
}

.cm-s-inner span.cm-bracket {
    color: #E8BF6A;
}

.cm-s-inner span.cm-builtin {
    color: #FF9E59;
}

.cm-s-inner span.cm-special {
    color: #FF9E59;
}

.cm-s-inner span.cm-matchhighlight {
    color: #FFFFFF;
    background-color: rgba(50, 89, 48, .7);
    font-weight: normal;
}

.cm-s-inner span.cm-searching {
    color: #FFFFFF;
    background-color: rgba(61, 115, 59, .7);
    font-weight: normal;
}

.cm-s-inner .CodeMirror-gutters {
    border-right: 1px solid rgba(120, 120, 120, 0.3);
}

.cm-s-inner .CodeMirror-linenumber {
    color: #585b5d;
}

.cm-s-inner .CodeMirror-matchingbracket {
    background-color: #3B514D;
    color: #FFEF28 !important;
}

.cm-s-inner .CodeMirror-selected {
    background: #214283 !important;
}

.cm-s-inner .CodeMirror-selectedtext {
    background: #214283 !important;
}

.cm-s-typora-default .CodeMirror-selectedtext {
    background: var(--select-text-bg-color) !important;
}

.cm-overlay.CodeMirror-selectedtext {
    background: var(--select-text-bg-color) !important;
}

.cm-s-inner div.CodeMirror-cursor {
    border-left: 1px solid var(--code-block-color);
}/*# sourceURL=/Users/didi/Documents/Codes/Fun/lagou/public/drake-juejin.css*/</style></head>
<body>
  <div id="write"><h1>第03讲：排序</h1><p>在前两节课里，我们学习了面试中常用的以及几个较为复杂的数据结构，它们是学好算法的基石。</p> 
<p>算法学习其实是一种提高思维能力的过程。无论是学习算法，还是在面试或实际的工作、生活中，我们都会碰见一些从没遇到过的问题。解决方法也类似，先推敲最直观的解法，再对某个步骤进行优化。例如，讲前缀树的例题时，我们正是为了要提高匹配字符串的速度才借用了前缀树的。</p> 
<p>从这节课开始，我们会将宝贵的时间、精力针对性地去学习面试中最常考的、最核心的算法。而这节课要学习的是排序算法，包括：</p> 
<p>1. 基本的排序算法</p> 
<ul> 
 <li><p>冒泡排序（Bubble Sort）</p></li> 
 <li><p>插入排序（Insertion Sort）</p></li> 
</ul> 
<p>2. 常考的排序算法</p> 
<ul> 
 <li><p>归并排序（Merge Sort）</p></li> 
 <li><p>快速排序（Quick Sort）</p></li> 
 <li><p>拓扑排序（Topological Sort）</p></li> 
</ul> 
<p>3. 其他排序算法</p> 
<ul> 
 <li><p>堆排序（Heap Sort）</p></li> 
 <li><p>桶排序（Bucket Sort)</p></li>
</ul> 
<p><strong>注意</strong>：</p> 
<ol> 
 <li><p>冒泡排序和插入排序是最基础的，面试官有时候喜欢拿它们来考察你的基础知识，并且看看你能不能快速地写出没有 bug 的代码。</p></li> 
 <li><p>归并排序、快速排序和拓扑排序的思想是解决绝大部分涉及排序问题的关键，我们将在这节课里重点介绍它们。</p></li> 
 <li><p>堆排序和桶排序，本节课不作深入研究，但有时间的话一定要看看，尤其是桶排序，在一定的场合中（例如知道所有元素出现的范围时），能在线性的时间复杂度里解决战斗，掌握好它的解题思想能开阔解题思路。</p></li> 
</ol> 
<h1></h1> 
<h3>冒泡排序（Bubble Sort）</h3> 
<h2></h2> 
<h4>基本思想</h4> 
<p>给定一个数组，我们把数组里的元素通通倒入到水池中，这些元素将通过相互之间的比较，按照大小顺序一个一个地像气泡一样浮出水面。</p> 
<h2></h2> 
<h4>实现</h4> 
<p>每一轮，从杂乱无章的数组头部开始，每两个元素比较大小并进行交换，直到这一轮当中最大或最小的元素被放置在数组的尾部，然后不断地重复这个过程，直到所有元素都排好位置。其中，核心操作就是元素相互比较。</p> 
<h2></h2> 
<h4>例题分析</h4> 
<p>给定数组 [2, 1, 7, 9, 5, 8]，要求按照从左到右、从小到大的顺序进行排序。&nbsp;</p> 
<h3></h3>
<h4>解题思路</h4> 
<p>从左到右依次冒泡，把较大的数往右边挪动即可。</p> 
<p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiW2AUgXzAEVU1vdS3ek726.gif">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p> 
<ol> 
 <li><p>首先指针指向第一个数，比较第一个数和第二个数的大小，由于 2 比 1 大，所以两两交换，[1, 2, 7, 9, 5, 8]。</p></li> 
 <li><p>接下来指针往前移动一步，比较 2 和 7，由于 2 比 7 小，两者保持不动，[1, 2, 7, 9, 5, 8]。到目前为止，7 是最大的那个数。</p></li> 
 <li><p>指针继续往前移动，比较 7 和 9，由于 7 比 9 小，两者保持不动，[1, 2, 7, 9, 5, 8]。现在，9 变成了最大的那个数。</p></li> 
 <li><p>再往后，比较 9 和 5，很明显，9 比 5 大，交换它们的位置，[1, 2, 7, 5, 9, 8]。</p></li> 
 <li><p>最后，比较 9 和 8，9 比 8 大，交换它们的位置，[1, 2, 7, 5, 8, 9]。经过第一轮的两两比较，9 这个最大的数就像冒泡一样冒到了数组的最后面。</p></li>
</ol> 
<p>接下来进行第二轮的比较，把指针重新指向第一个元素，重复上面的操作，最后，数组变成了：[1, 2, 5, 7, 8, 9]。</p> 
<p>在进行新一轮的比较中，判断一下在上一轮比较的过程中有没有发生两两交换，如果一次交换都没有发生，就证明其实数组已经排好序了。</p> 
<h2></h2> 
<h4>代码示例</h4> 
<pre>void&nbsp;sort(int[]&nbsp;nums)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//定义一个布尔变量&nbsp;hasChange，用来标记每轮遍历中是否发生了交换
&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;hasChange&nbsp;=&nbsp;true;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;//每轮遍历开始，将&nbsp;hasChange&nbsp;设置为&nbsp;false
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nums.length&nbsp;-&nbsp;1&nbsp;&amp;&amp;&nbsp;hasChange;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasChange&nbsp;=&nbsp;false;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//进行两两比较，如果发现当前的数比下一个数还大，那么就交换这两个数，同时记录一下有交换发生
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;nums.length&nbsp;-&nbsp;1&nbsp;-&nbsp;i;&nbsp;j++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nums[j]&nbsp;&gt;&nbsp;nums[j&nbsp;+&nbsp;1])&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(nums,&nbsp;j,&nbsp;j&nbsp;+&nbsp;1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasChange&nbsp;=&nbsp;true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;}</pre> 
<h3></h3> 
<h3>算法分析</h3> 
<h3></h3> 
<h4><strong>空间复杂度</strong></h4> 
<p>假设数组的元素个数是 n，由于在整个排序的过程中，我们是直接在给定的数组里面进行元素的两两交换，所以空间复杂度是 O(1)。</p> 
<h3></h3>
<h4>时间复杂度</h4> 
<p>1. 给定的数组按照顺序已经排好</p> 
<p>在这种情况下，我们只需要进行 n−1 次的比较，两两交换次数为 0，时间复杂度是 O(n)。这是最好的情况。</p> 
<p>2. 给定的数组按照逆序排列</p> 
<p>在这种情况下，我们需要进行 n(n-1)/2 次比较，时间复杂度是 O(n<sup>2</sup>)。这是最坏的情况。</p> 
<p>3. 给定的数组杂乱无章</p> 
<p>在这种情况下，平均时间复杂度是 O(n<sup>2</sup>)。</p> 
<p>由此可见，冒泡排序的时间复杂度是 O(n<sup>2</sup>)。它是一种稳定的排序算法。（稳定是指如果数组里两个相等的数，那么排序前后这两个相等的数的相对位置保持不变。）</p> 
<h1></h1> 
<h3>插入排序（Insertion Sort）</h3> 
<h2></h2> 
<h4>基本思想</h4> 
<p>不断地将尚未排好序的数插入到已经排好序的部分。</p> 
<h2></h2> 
<h4>特点</h4> 
<p>在冒泡排序中，经过每一轮的排序处理后，数组后端的数是排好序的；而对于插入排序来说，经过每一轮的排序处理后，数组前端的数都是排好序的。</p> 
<h2></h2>
<h4>例题分析</h4> 
<p>对数组 [2, 1, 7, 9, 5, 8] 进行插入排序。</p> 
<h3></h3>
<h4>解题思路</h4> 
<p>首先将数组分成左右两个部分，左边是已经排好序的部分，右边是还没有排好序的部分，刚开始，左边已排好序的部分只有第一个元素 2。接下来，我们对右边的元素一个一个进行处理，将它们放到左边。</p> 
<p>&nbsp;<img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiW-AJFICAFSirGa8QjY019.gif">&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</p> 
<ol> 
 <li><p>先来看 1，由于 1 比 2 小，需要将 1 插入到 2 的前面，做法很简单，两两交换位置即可，[1, 2, 7, 9, 5, 8]。</p></li> 
 <li><p>然后，我们要把 7 插入到左边的部分，由于 7 已经比 2 大了，表明它是目前最大的元素，保持位置不变，[1, 2, 7, 9, 5, 8]。</p></li> 
 <li><p>同理，9 也不需要做位置变动，[1, 2, 7, 9, 5, 8]。</p></li> 
 <li><p>接下来，如何把 5 插入到合适的位置。首先比较 5 和 9，由于 5 比 9 小，两两交换，[1, 2, 7, 5, 9, 8]，继续，由于 5 比 7 小，两两交换，[1, 2, 5, 7, 9, 8]，最后，由于 5 比 2 大，此轮结束。</p></li> 
 <li><p>最后一个数是 8，由于 8 比 9 小，两两交换，[1, 2, 5, 7, 8, 9]，再比较 7 和 8，发现 8 比 7 大，此轮结束。到此，插入排序完毕。</p></li> 
</ol> 
<h2></h2> 
<h4>代码示例</h4> 
<pre>void&nbsp;sort(int[]&nbsp;nums)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;将数组的第一个元素当作已经排好序的，从第二个元素，即&nbsp;i&nbsp;从&nbsp;1&nbsp;开始遍历数组
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1,&nbsp;j,&nbsp;current;&nbsp;i&nbsp;&lt;&nbsp;nums.length;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;外围循环开始，把当前&nbsp;i&nbsp;指向的值用&nbsp;current&nbsp;保存
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;nums[i];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指针&nbsp;j&nbsp;内循环，和&nbsp;current&nbsp;值比较，若&nbsp;j&nbsp;所指向的值比&nbsp;current&nbsp;值大，则该数右移一位
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j&nbsp;=&nbsp;i&nbsp;-&nbsp;1;&nbsp;j&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;nums[j]&nbsp;&gt;&nbsp;current;&nbsp;j--)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nums[j&nbsp;+&nbsp;1]&nbsp;=&nbsp;nums[j];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;内循环结束，j+1&nbsp;所指向的位置就是&nbsp;current&nbsp;值插入的位置
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nums[j&nbsp;+&nbsp;1]&nbsp;=&nbsp;current;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre> 
<h3></h3> 
<h3>算法分析</h3> 
<h3></h3>
<h4>空间复杂度</h4> 
<p>假设数组的元素个数是 n，由于在整个排序的过程中，是直接在给定的数组里面进行元素的两两交换，空间复杂度是 O(1)。</p> 
<h3></h3>
<h4>时间复杂度</h4> 
<p>1. 给定的数组按照顺序已经排好</p> 
<p>只需要进行 n-1 次的比较，两两交换次数为 0，时间复杂度是 O(n)。这是最好的情况。</p> 
<p>2. 给定的数组按照逆序排列</p> 
<p>在这种情况下，我们需要进行 n(n-1)/2 次比较，时间复杂度是&nbsp;O(n<sup>2</sup>)。这是最坏的情况。</p> 
<p>3. 给定的数组杂乱无章</p> 
<p>在这种情况下，平均时间复杂度是&nbsp;O(n<sup>2</sup>)。</p> 
<p>由此可见，和冒泡排序一样，插入排序的时间复杂度是&nbsp;O(n<sup>2</sup>)，并且它也是一种稳定的排序算法。</p> 
<p><strong>建议</strong>：LeetCode 第 147 题，要求对一个链表进行插入排序，希望大家去试一试。</p> 
<h1></h1> 
<h3>归并排序（Merge Sort）</h3> 
<h2></h2> 
<h4>基本思想</h4> 
<p>核心是分治，就是把一个复杂的问题分成两个或多个相同或相似的子问题，然后把子问题分成更小的子问题，直到子问题可以简单的直接求解，最原问题的解就是子问题解的合并。归并排序将分治的思想体现得淋漓尽致。</p> 
<h2></h2> 
<h4>实现</h4> 
<p>一开始先把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，才开始排序。</p> 
<p>排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好。</p> 
<h2></h2> 
<h4>代码示例</h4> 
<p>主体函数的代码实现如下。</p> 
<pre>void&nbsp;sort(int[]&nbsp;A,&nbsp;int&nbsp;lo,&nbsp;int&nbsp;hi)&nbsp;{
&nbsp;&nbsp;//&nbsp;判断是否只剩下最后一个元素
&nbsp;&nbsp;if&nbsp;(lo&nbsp;&gt;=&nbsp;hi)&nbsp;return;
&nbsp;&nbsp;
&nbsp;&nbsp;//&nbsp;从中间将数组分成两个部分
&nbsp;&nbsp;int&nbsp;mid&nbsp;=&nbsp;lo&nbsp;+&nbsp;(hi&nbsp;-&nbsp;lo)&nbsp;/&nbsp;2;
&nbsp;&nbsp;
&nbsp;&nbsp;//&nbsp;分别递归地将左右两半排好序
&nbsp;&nbsp;sort(A,&nbsp;lo,&nbsp;mid);
&nbsp;&nbsp;sort(A,&nbsp;mid&nbsp;+&nbsp;1,&nbsp;hi);

&nbsp;&nbsp;//&nbsp;将排好序的左右两半合并&nbsp;&nbsp;
&nbsp;&nbsp;merge(A,&nbsp;lo,&nbsp;mid,&nbsp;hi);
}</pre> 
<p>归并操作的代码实现如下。</p> 
<pre>void&nbsp;merge(int[]&nbsp;nums,&nbsp;int&nbsp;lo,&nbsp;int&nbsp;mid,&nbsp;int&nbsp;hi)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;复制一份原来的数组
&nbsp;&nbsp;&nbsp;&nbsp;int[]&nbsp;copy&nbsp;=&nbsp;nums.clone();
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;定义一个&nbsp;k&nbsp;指针表示从什么位置开始修改原来的数组，i&nbsp;指针表示左半边的起始位置，j&nbsp;表示右半边的起始位置
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;k&nbsp;=&nbsp;lo,&nbsp;i&nbsp;=&nbsp;lo,&nbsp;j&nbsp;=&nbsp;mid&nbsp;+&nbsp;1;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(k&nbsp;&lt;=&nbsp;hi)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;&gt;&nbsp;mid)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nums[k++]&nbsp;=&nbsp;copy[j++];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(j&nbsp;&gt;&nbsp;hi)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nums[k++]&nbsp;=&nbsp;copy[i++];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(copy[j]&nbsp;&lt;&nbsp;copy[i])&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nums[k++]&nbsp;=&nbsp;copy[j++];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nums[k++]&nbsp;=&nbsp;copy[i++];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre> 
<p>其中，While 语句比较，一共可能会出现四种情况。</p> 
<ul> 
 <li><p>左半边的数都处理完毕，只剩下右半边的数，只需要将右半边的数逐个拷贝过去。</p></li> 
 <li><p>右半边的数都处理完毕，只剩下左半边的数，只需要将左半边的数逐个拷贝过去就好。</p></li> 
 <li><p>右边的数小于左边的数，将右边的数拷贝到合适的位置，j 指针往前移动一位。</p></li> 
 <li><p>左边的数小于右边的数，将左边的数拷贝到合适的位置，i 指针往前移动一位。</p></li> 
</ul> 
<h2></h2>
<h4>例题分析</h4> 
<p>例题：利用归并排序算法对数组 [2, 1, 7, 9, 5, 8] 进行排序。</p> 
<h3></h3>
<h4>解题思路</h4> 
<p><img src="http://s0.lgstatic.com/i/image2/M01/91/0B/CgoB5l2IiXKAR7hcAFhCcVK5jAM221.gif">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p> 
<p>首先不断地对数组进行切分，直到各个子数组里只包含一个元素。</p> 
<p>接下来递归地按照大小顺序合并切分开的子数组，递归的顺序和二叉树里的前向遍历类似。</p> 
<ol> 
 <li><p>合并 [2] 和 [1] 为 [1, 2]。</p></li> 
 <li><p>子数组 [1, 2] 和 [7] 合并。</p></li> 
 <li><p>右边，合并 [9] 和 [5]。</p></li> 
 <li><p>然后合并 [5, 9] 和 [8]。</p></li> 
 <li><p>最后合并 [1, 2, 7] 和 [5, 8, 9] 成 [1, 2, 5, 8, 9]，就可以把整个数组排好序了。</p></li>
</ol> 
<p>合并数组 [1, 2, 7] 和 [5, 8, 9] 的操作步骤如下。</p> 
<p><img src="http://s0.lgstatic.com/i/image2/M01/91/2B/CgotOV2IiXSAfGJAAF-ZK14qZ9Q978.gif"></p> 
<p>&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p> 
<ol> 
 <li><p>把数组 [1, 2, 7] 用 L 表示，[5, 8, 9] 用 R 表示。</p></li> 
 <li><p>合并的时候，开辟分配一个新数组 T 保存结果，数组大小应该是两个子数组长度的总和</p></li> 
 <li><p>然后下标 i、j、k 分别指向每个数组的起始点。</p></li> 
 <li><p>接下来，比较下标i和j所指向的元素 L[i] 和 R[j]，按照大小顺序放入到下标 k 指向的地方，1 小于 5。</p></li> 
 <li><p>移动 i 和 k，继续比较 L[i] 和 R[j]，2 比 5 小。</p></li> 
 <li><p>i 和 k 继续往前移动，5 比 7 小。</p></li> 
 <li><p>移动 j 和 k，继续比较 L[i] 和 R[j]，7 比 8 小。</p></li> 
 <li><p>这时候，左边的数组已经处理完毕，直接将右边数组剩余的元素放到结果数组里就好。</p></li>
</ol> 
<p>合并之所以能成功，先决条件必须是两个子数组都已经分别排好序了。</p> 
<h2></h2>
<h3>算法分析</h3> 
<h3></h3>
<h4>空间复杂度</h4> 
<p>由于合并 n 个元素需要分配一个大小为 n 的额外数组，合并完成之后，这个数组的空间就会被释放，所以算法的空间复杂度就是 O(n)。归并排序也是稳定的排序算法。</p> 
<h3></h3>
<h4>时间复杂度</h4> 
<p>归并算法是一个不断递归的过程。</p> 
<p><strong>举例</strong>：数组的元素个数是 n，时间复杂度是 T(n) 的函数。</p> 
<p><strong>解法</strong>：把这个规模为 n 的问题分成两个规模分别为 n/2 的子问题，每个子问题的时间复杂度就是 T(n/2)，那么两个子问题的复杂度就是 2×T(n/2)。当两个子问题都得到了解决，即两个子数组都排好了序，需要将它们合并，一共有 n 个元素，每次都要进行最多 n-1 次的比较，所以合并的复杂度是 O(n)。由此我们得到了递归复杂度公式：T(n) = 2×T(n/2) + O(n)。</p> 
<p>对于公式求解，不断地把一个规模为 n 的问题分解成规模为 n/2 的问题，一直分解到规模大小为 1。如果 n 等于 2，只需要分一次；如果 n 等于 4，需要分 2 次。这里的次数是按照规模大小的变化分类的。</p> 
<p>以此类推，对于规模为 n 的问题，一共要进行 log(n) 层的大小切分。在每一层里，我们都要进行合并，所涉及到的元素其实就是数组里的所有元素，因此，每一层的合并复杂度都是 O(n)，所以整体的复杂度就是&nbsp;O(nlogn)。</p> 
<p><strong>建议</strong>：归并算法的思想很重要，其中对两个有序数组合并的操作，在很多面试题里都有用到，建议大家一定要把这个算法练熟。</p> 
<h1></h1>
<h3>快速排序（Quick Sort）</h3> 
<h2></h2>
<h4>基本思想</h4> 
<p>快速排序也采用了分治的思想。</p> 
<h2></h2>
<h4>实现</h4> 
<p>把原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。</p> 
<p><strong>举例</strong>：把班里的所有同学按照高矮顺序排成一排。</p> 
<p><strong>解法</strong>：老师先随机地挑选了同学 A，让所有其他同学和 A 比高矮，比 A 矮的都站在 A 的左边，比 A 高的都站在 A 的右边。接下来，老师分别从左边和右边的同学里选择了同学 B 和 C，然后不断地筛选和排列下去。</p> 
<p>在分成较小和较大的两个子数组过程中，如何选定一个基准值（也就是同学 A、B、C 等）尤为关键。</p> 
<h2></h2>
<h4>例题分析</h4> 
<p>对数组 [2, 1, 7, 9, 5, 8] 进行排序。</p> 
<h3></h3>
<h4>解题思路</h4> 
<p><img src="http://s0.lgstatic.com/i/image2/M01/91/2B/CgotOV2IiXaAXXBaADUbuSK_xc4506.gif">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p> 
<ol> 
 <li><p>按照快速排序的思想，首先把数组筛选成较小和较大的两个子数组。</p></li> 
 <li><p>随机从数组里选取一个数作为基准值，比如 7，于是原始的数组就被分成了两个子数组。注意：快速排序是直接在原始数组里进行各种交换操作，所以当子数组被分割出来的时候，原始数组里的排列也被改变了。</p></li> 
 <li><p>接下来，在较小的子数组里选 2 作为基准值，在较大的子数组里选 8 作为基准值，继续分割子数组。</p></li> 
 <li><p>继续将元素个数大于 1 的子数组进行划分，当所有子数组里的元素个数都为 1 的时候，原始数组也被排好序了。</p></li> 
</ol> 
<h2></h2>
<h4>代码示例</h4> 
<p>主体函数代码如下。</p> 
<pre>void&nbsp;sort(int[]&nbsp;nums,&nbsp;int&nbsp;lo,&nbsp;int&nbsp;hi)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(lo&nbsp;&gt;=&nbsp;hi)&nbsp;return;&nbsp;//&nbsp;判断是否只剩下一个元素，是，则直接返回
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;利用&nbsp;partition&nbsp;函数找到一个随机的基准点
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;p&nbsp;=&nbsp;partition(nums,&nbsp;lo,&nbsp;hi);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;递归地对基准点左半边和右半边的数进行排序
&nbsp;&nbsp;&nbsp;&nbsp;sort(nums,&nbsp;lo,&nbsp;p&nbsp;-&nbsp;1);
&nbsp;&nbsp;&nbsp;&nbsp;sort(nums,&nbsp;p&nbsp;+&nbsp;1,&nbsp;hi);
}</pre> 
<p>下面用代码实现 partition 函数获得基准值。</p> 
<pre>int&nbsp;partition(int[]&nbsp;nums,&nbsp;int&nbsp;lo,&nbsp;int&nbsp;hi)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;随机选择一个数作为基准值，nums[hi]&nbsp;就是基准值
&nbsp;&nbsp;&nbsp;&nbsp;swap(nums,&nbsp;randRange(lo,&nbsp;hi),&nbsp;hi);

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;从左到右用每个数和基准值比较，若比基准值小，则放到指针&nbsp;i&nbsp;所指向的位置。循环完毕后，i&nbsp;指针之前的数都比基准值小
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;lo,&nbsp;j&nbsp;=&nbsp;lo;&nbsp;j&nbsp;&lt;&nbsp;hi;&nbsp;j++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nums[j]&nbsp;&lt;=&nbsp;nums[hi])&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(nums,&nbsp;i++,&nbsp;j);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;末尾的基准值放置到指针&nbsp;i&nbsp;的位置，i&nbsp;指针之后的数都比基准值大
&nbsp;&nbsp;&nbsp;&nbsp;swap(nums,&nbsp;i,&nbsp;j);

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;返回指针&nbsp;i，作为基准点的位置
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;
}</pre> 
<h3></h3> 
<h3>算法分析</h3> 
<h3></h3>
<h4>时间复杂度</h4> 
<p>1. 最优情况：被选出来的基准值都是当前子数组的中间数。</p> 
<p>这样的分割，能保证对于一个规模大小为 n 的问题，能被均匀分解成两个规模大小为 n/2 的子问题（归并排序也采用了相同的划分方法），时间复杂度就是：T(n) = 2×T(n/2) + O(n)。</p> 
<p>把规模大小为 n 的问题分解成 n/2 的两个子问题时，和基准值进行了 n-1 次比较，复杂度就是 O(n)。很显然，在最优情况下，快速排序的复杂度也是&nbsp;O(nlogn)。</p> 
<p>2. 最坏情况：基准值选择了子数组里的最大或者最小值</p> 
<p>每次都把子数组分成了两个更小的子数组，其中一个的长度为 1，另外一个的长度只比原子数组少 1。</p> 
<p><strong>举例</strong>：对于数组来说，每次挑选的基准值分别是 9、8、7、5、2。</p> 
<p><strong>解法</strong>：划分过程和冒泡排序的过程类似。</p> 
<p>算法复杂度为&nbsp;O(n<sup>2</sup>)。</p> 
<p>提示：可以通过随机地选取基准值来避免出现最坏的情况。</p> 
<h3></h3>
<h4>空间复杂度</h4> 
<p>和归并排序不同，快速排序在每次递归的过程中，只需要开辟 O(1) 的存储空间来完成交换操作实现直接对数组的修改，又因为递归次数为 logn，所以它的整体空间复杂度完全取决于压堆栈的次数，因此它的空间复杂度是 O(logn)。</p> 
<p><strong>举例</strong>：LeetCode 第 215 题，给定一个尚未排好序的数组，要求找出第 k 大的数。</p> 
<p><strong>解法 1</strong>：直接将数组进行排序，然后得出结果。</p> 
<p><strong>解法 2</strong>：快速排序。</p> 
<p>每次随机选取一个基准值，将数组分成较小的一半和较大的一半，然后检查这个基准值最后所在的下标是不是 k，算法复杂度只需要 O(n)。</p> 
<h1></h1> 
<h3>拓扑排序（Topological Sort）</h3> 
<h2></h2> 
<h4>基本思想</h4> 
<p>和前面介绍的几种排序不同，拓扑排序应用的场合不再是一个简单的数组，而是研究图论里面顶点和顶点连线之间的性质。拓扑排序就是要将这些顶点按照相连的性质进行排序。</p> 
<p>要能实现拓扑排序，得有几个前提：</p> 
<ol> 
 <li><p>图必须是有向图</p></li> 
 <li><p>图里面没有环</p></li>
</ol> 
<p>拓扑排序一般用来理清具有依赖关系的任务。</p> 
<p><strong>举例</strong>：假设有三门课程 A、B、C，如果想要学习课程 C 就必须先把课程 B 学完，要学习课程 B，还得先学习课程 A，所以得出课程的学习顺序应该是 A -&gt; B -&gt; C。</p> 
<h2></h2> 
<h6>实现</h6> 
<ol> 
 <li><p>将问题用一个有向无环图（DAG, Directed Acyclic Graph）进行抽象表达，定义出哪些是图的顶点，顶点之间如何互相关联。</p></li> 
 <li><p>可以利用广度优先搜索或深度优先搜索来进行拓扑排序。</p></li> 
</ol> 
<h2></h2> 
<h4>例题分析</h4> 
<p>有一个学生想要修完 5 门课程的学分，这 5 门课程分别用 1、2、3、4、5 来表示，现在已知学习这些课程有如下的要求：</p> 
<ul> 
 <li><p>课程 2 和 4 依赖于课程 &nbsp;1</p></li> 
 <li><p>课程 3 依赖于课程 2 和 4</p></li> 
 <li><p>课程 4 依赖于课程 1 和 2</p></li> 
 <li><p>课程 5 依赖于课程 3 和 4</p></li>
</ul> 
<p>那么这个学生应该按照怎样的顺序来学习这 5 门课程呢？</p> 
<h3></h3>
<h4>解题思路</h4> 
<p>可以把 5 门课程看成是一个图里的 5 个顶点，用有向线段按照它们的相互关系连起来，于是得出下面的有向图。</p> 
<p>首先可以看到，这个有向图里没有环，无论从哪个顶点出发，都不会再回到那个顶点。并且，这个图里并没有孤岛的出现，因此，我们可以对它进行拓扑排序。</p> 
<p>方法就是，一开始的时候，对每个顶点统计它们各自的前驱（也就是入度）：1(0)，2(1)，3(2)，4(2)，5(2)。</p> 
<p><img src="http://s0.lgstatic.com/plat-home-fed/vue/scripts/libraries/UEditor/themes/default/images/spacer.gif">&nbsp; &nbsp; &nbsp; &nbsp;<img src="http://s0.lgstatic.com/i/image2/M01/91/2B/CgotOV2IiXqAM6cFAFNa8qMI_JU260.gif">&nbsp; &nbsp; &nbsp;</p> 
<p>&nbsp;</p> 
<ol> 
 <li><p>选择其中一个没有前驱（也就是入度为 0）的顶点，在这道题里面，顶点 1 就是我们要找的那个点，将它作为结果输出。同时删除掉该顶点和所有以它作为起始点的有向边，更新顶点的入度表。</p></li> 
 <li><p>接下来，顶点 2 就是下一个没有前驱的顶点，输出顶点 2，并将以它作为起点的有向边删除，同时更新入度表。</p></li> 
 <li><p>再来，顶点 4 成为了没有前驱的顶点，输出顶点 4，删除掉它和顶点 3 和 5 的有向边。</p></li> 
 <li><p>然后，顶点 3 没有了前驱，输出它，并删除它与 5 的有向边。</p></li> 
 <li><p>最后，顶点 5 没有前驱，输出它，于是得出最后的结果为：1，2，4，3，5。</p></li>
</ol> 
<p>一般来说，一个有向无环图可以有一个或多个拓扑排序的序列。</p> 
<h2></h2> 
<h4>代码示例</h4> 
<p>运用广度优先搜索的方法对这个图的结构进行遍历。在构建这个图的过程中，用一个链接矩阵 adj 来表示这个图的结构，用一个 indegree 的数组统计每个顶点的入度，重点看如何实现拓扑排序。</p> 
<pre>void&nbsp;sort()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Queue&lt;Integer&gt;&nbsp;q&nbsp;=&nbsp;new&nbsp;LinkedList();&nbsp;//&nbsp;定义一个队列&nbsp;q

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;将所有入度为&nbsp;0&nbsp;的顶点加入到队列&nbsp;q
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;v&nbsp;=&nbsp;0;&nbsp;v&nbsp;&lt;&nbsp;V;&nbsp;v++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(indegree[v]&nbsp;==&nbsp;0)&nbsp;q.add(v);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;循环，直到队列为空
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(!q.isEmpty())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;v&nbsp;=&nbsp;q.poll();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;每次循环中，从队列中取出顶点，即为按照入度数目排序中最小的那个顶点
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(v);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;将跟这个顶点相连的其他顶点的入度减&nbsp;1，如果发现那个顶点的入度变成了&nbsp;0，将其加入到队列的末尾
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;u&nbsp;=&nbsp;0;&nbsp;u&nbsp;&lt;&nbsp;adj[v].length;&nbsp;u++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(--indegree[u]&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.add(u);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre> 
<h2></h2> 
<h4>算法分析</h4> 
<h3><p><span style="font-weight: bold;">时间复杂度</span></p></h3> 
<p>统计顶点的入度需要 O(n) 的时间，接下来每个顶点被遍历一次，同样需要 O(n) 的时间，所以拓扑排序的时间复杂度是 O(n)。</p> 
<p><strong>建议</strong>：利用深度优先搜索的方法对这道题实现拓扑排序。</p> 
<h1></h1>
<h3>结语</h3> 
<p>这节课复习了面试中经常会被考到的排序算法，最重点内容是归并排序和快速排序。除了要好好理解它们的思路，还必须要能写出没有 bug 的代码，因此建议多做 LeetCode 里面的经典题目。</p> 
<p>&nbsp;</p> 
<p>下一节课，将深入讲解递归算法和回溯算法，它们在算法面试中出现的概率是最高的。</p></div>

</body></html>