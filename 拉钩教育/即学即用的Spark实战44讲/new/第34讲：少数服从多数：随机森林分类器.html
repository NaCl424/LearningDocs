<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第34讲：少数服从多数：随机森林分类器</title>
<style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style><style type="text/css">/*
 * Copyright (C) 2018 Drake, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

:root {
    --monospace: "JetBrains Mono", HYZhengYuan, "Fira Code", Menlo, "Ubuntu Mono", Consolas; /*code font*/
    --text-font: var(--monospace); /*default font*/
    --title-font: var(--monospace); /*title font*/

    --text-color: #333333;
    --bg-color: #ffffff;
    --control-text-color: var(--text-color);
    --meta-content-color: var(--text-color);
    --active-file-border-color: var(--drake-accent);
    --rawblock-edit-panel-bd: var(--code-block-bg-color);
    --item-hover-bg-color: #E5E5E596;
    --active-file-bg-color: var(--item-hover-bg-color);

    --drake-accent: #e95f59;
    --drake-highlight: #d63200;
    --a-color: #036aca;
    --variable-color: var(--drake-highlight);
    --outline-active-color: var(--a-color);
    --code-block-bg-color: #2b2b2b;
    --code-block-color: #A9B7C6;
    --title-color: #135ce0;
    --blockquote-border-color: #b2aec5;
    --blockquote-color: #595959;
    --blockquote-bg-color: #fff9f9;
    --strong-color: var(--title-color);
    --h2-underline-color: var(--title-color);
    --horizontal-divider-color: var(--title-color);
    --height-light-color: var(--drake-highlight);
    --height-light-border-color: var(--drake-highlight);
    --yaml-color: #777777;
    --yaml-bg-color: #f7f7f7;
    --footnotes-bg-color: #3c3d3e;
    --footnotes-highlight: #FFD760;
    --table-border-color: #dfe2e5;
    --table-header-bg-color: #f6f8fa;
    --table-bg-color: var(--bg-color);
    --table-n2-bg-color: #f6f8fa;
    --input-bg-color: var(--item-hover-bg-color);
    --btn-hover-bg-color: var(--item-hover-bg-color);
    --checkbox-checked: url("data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cpath d='M425.984 726.016l384-384-59.99-61.995-324.01 324.011-152.021-152.021L213.973 512zm384-598.016q36.01 0 61.013 25.984T896 213.974v596.01q0 34.005-25.003 59.99t-61.013 25.983h-596.01q-36.011 0-61.014-25.984t-25.003-59.989v-596.01q0-34.006 25.003-59.99T213.973 128h596.011z' fill='%2365b73b'/%3E%3C/svg%3E");
    --checkbox-unchecked: url("data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cpath d='M810.667 213.333v597.334H213.333V213.333h597.334m0-85.333H213.333C166.4 128 128 166.4 128 213.333v597.334C128 857.6 166.4 896 213.333 896h597.334C857.6 896 896 857.6 896 810.667V213.333C896 166.4 857.6 128 810.667 128z' fill='%23333333'/%3E%3C/svg%3E");
}

html {
    font-size: 15px;
}

body {
    font-family: var(--text-font) !important;
    color: var(--text-color);
    -webkit-font-feature-settings: "liga" on, "calt" on;
    -webkit-font-smoothing: subpixel-antialiased;
    text-rendering: optimizeLegibility;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
    line-height: 1.8rem;
}

img {
    max-width: 100%;
}

#write {
    background-image: linear-gradient(
            90deg
            ,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(
            1turn
            ,rgba(60,10,30,.04) 3%,transparent 0);
    background-size: 20px 20px;
    background-position: 50%;
}

/*code block*/
#write .md-fences {
    font-size: 1rem;
    padding: 0.5rem !important;
    border-radius: 2px;
    word-wrap: normal;
    background-color: var(--code-block-bg-color);
    color: var(--code-block-color);
    border: none;
}

/*code snippet*/
#write code, tt {
    border-radius: 2px;
    color: var(--drake-highlight);
}

/*variable*/
var {
    color: var(--variable-color);
    font-weight: bold;
}

/*raw block*/
.md-rawblock-control:not(.md-rawblock-tooltip) {
    border-radius: 2px 0 2px 2px;
    padding: 0.2rem !important;
}
.md-rawblock:hover > .md-rawblock-container {
    background: none;
}
.md-rawblock-input {
    font-size: 1rem;
}
.md-rawblock-tooltip-btn:hover {
    background: none;
}
.md-rawblock:hover > .md-rawblock-tooltip {
    border-radius: 2px 2px 0 0;
    margin-bottom: 2px !important;
}
.md-rawblock-tooltip.md-rawblock-control {
    border-radius: 2px 2px 0 0;
    color: var(--code-block-color);
}
.md-rawblock-tooltip-name {
    color: var(--code-block-color);
    opacity: 1;
}

/*quote block*/
blockquote:before {
    display: block;
    position: absolute;
    content: '';
    width: 4px;
    left: 0;
    top: 0;
    height: 100%;
    background-color: var(--blockquote-border-color);
    border-radius: 2px;
}

blockquote {
    color: var(--blockquote-color);
    border-radius: 2px;
    padding: 10px 16px;
    background-color: var(--blockquote-bg-color);
    position: relative;
    border-left: none;
}

#write strong {
    color: var(--strong-color);
    font-weight: bold;
}
#write blockquote strong {
    color: var(--blockquote-color);
}

/*link*/
#write a {
    color: var(--a-color);
    text-decoration: none;
}
#write a .md-plain, .md-htmlblock-container a:hover {
    border-bottom: .1rem solid var(--a-color);
}
[md-inline=link] a {
    margin: 0 .2rem;
}
a:any-link {
    color: var(--a-color);
}

img {
    border-left: none;
    border-right: none;
    vertical-align: baseline;
    border-radius: 2px;
}

#write {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px 30px 100px;
}
#typora-source .CodeMirror-lines {
    max-width: 1200px;
}

#write p {
    word-spacing: .05rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    font-family: var(--title-font);
    position: relative;
    margin-top: 2rem;
    margin-bottom: 1rem;
    font-weight: bold;
    cursor: text;
    color: var(--title-color);
}

h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before {
    visibility: hidden;
}

h1 {
    font-size: 1.6rem;
    text-align: center;
    margin-top: 0;
}

h2.md-end-block.md-heading {
    font-size: 1.6rem;
    display: inline-block;
}

h2.md-end-block.md-heading:after {
    display: block;
    content: '';
    height: 2px;
    margin-top: 4px;
    background-color: var(--h2-underline-color);
    border-radius: 2px;
}

h3 {
    font-size: 1.4rem;
}

h4 {
    font-size: 1.2rem;
}

h5 {
    font-size: 1rem;
}

h6 {
    font-size: 1rem;
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}

h2 tt,
h2 code {
    font-size: inherit !important;
}

h3 tt,
h3 code {
    font-size: inherit !important;
}

h4 tt,
h4 code {
    font-size: inherit !important;
}

h5 tt,
h5 code {
    font-size: inherit !important;
}

h6 tt,
h6 code {
    font-size: inherit !important;
}

blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}
p {
    margin: 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: var(--horizontal-divider-color);
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul, ol {
    padding-inline-start: 2em;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

table {
    padding: 0;
    word-break: initial;
    background-color: var(--table-bg-color);
}
table tr {
    border-top: .1em solid var(--table-border-color);
    margin: 0;
    padding: 0;
}
table th {
    font-weight: bold;
    border: .1em solid var(--table-border-color);
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table td {
    border: .1em solid var(--table-border-color);
    margin: 0;
    padding: 6px 13px;
}
table thead {
    background-color: var(--table-header-bg-color);
}
table tr:nth-child(2n) {
    background-color: var(--table-n2-bg-color);
}
table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

#write em {
    padding: 0 5px 0 2px;
}

/* height light */
#write mark {
    border: .1em solid var(--height-light-border-color);
    color: var(--height-light-color);
    background-color: transparent;
    padding: .1rem .5rem;
    border-radius: 2rem;
    margin: 0 .2rem;
    font-size: .95rem;
}

/*shortcut*/
kbd {
    border: .1em solid #5b5b5e;
    background: transparent;
    color: var(--text-color);
    margin: 0 .4rem;
    font-size: .95rem;
    padding: .3em .4em;
    border-radius: .4em;
    vertical-align: top;
    box-shadow: .1em .1em .2em rgba(0, 0, 0, 0.3);
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 12px;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

/*YAML*/
#write pre.md-meta-block {
    padding: 1rem;
    font-size: 1rem;
    background-color: var(--yaml-bg-color);
    border: 0;
    border-radius: 2px;
    color: var(--yaml-color);
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

#write > h3.md-focus:before {
    left: -1.5625rem;
    top: .375rem;
}

#write > h4.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h5.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h6.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

.md-image > .md-meta {
    border-radius: 2px;
    font-family: initial;
    padding: 2px 0 0 4px;
    color: inherit;
}

.md-tag {
    color: inherit;
}

.md-toc {
    margin-top: 20px;
    padding-bottom: 20px;
}

.typora-quick-open-item {
    font-size: 1rem !important;
    height: 50px;
    padding-left: 8px;
    padding-top: 4px;
    padding-bottom: 4px;
}

#typora-quick-open {
    box-shadow: 0 0 8px #00000045;
    padding: 0;
}

.ty-quick-open-category.ty-has-prev .ty-quick-open-category-title {
    border-top: none;
}

#typora-quick-open-input {
    margin: 8px;
    box-shadow: none;
    border-radius: 2px;
}

#typora-quick-open-input input {
    font-size: 1rem;
    box-shadow: none;
    padding-top: 2px;
    padding-left: 10px;
    padding-right: 10px;
    line-height: 32px;
    max-height: 32px;
    border: none;
}

.modal-dialog#typora-quick-open {
    border-radius: 8px;
}

.ty-quick-open-category-title {
    padding-left: 8px;
    color: #BEBEBE;
    font-size: 0.8rem;
    margin-bottom: 4px;
}

.typora-quick-open-item-path {
    font-size: 0.8rem;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-top: 1px;
}

/*search input*/
.form-control {
    border: none;
    border-radius: 2px;
    box-shadow: none;
}

#md-searchpanel .btn {
    border-radius: 2px;
}

#search-panel-replaceall-btn {
    padding-right: 5px !important;
    text-align: center !important;
}

#search-panel-replace-btn {
    text-align: center !important;
}

#md-searchpanel input {
    background: var(--input-bg-color);
    border-radius: 2px;
}

.searchpanel-search-option-btn {
    border-radius: 2px;
    border: none;
    background: transparent;
    color: var(--text-color);
}

.searchpanel-search-option-btn.active {
    background: var(--text-color);
    color: var(--bg-color);
}

.form-control:focus {
    box-shadow: none;
}

#md-notification:before {
    top: 10px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: initial;
}

/*sidebar*/
.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

#typora-sidebar {
    font-size: 1.1rem;
}

.sidebar-tabs {
    border-bottom: none;
}

.file-list-item-summary, .file-list-item-parent-loc, .file-list-item-time, .file-list-item-summary {
    font-size: 0.9rem !important;
    font-family: var(--text-font);
}

.file-list-item-file-ext-part {
    display: none;
}

.outline-item {
    font-size: 1rem;
}

/*footnotes mark*/
#write .md-footnote {
    background-color: inherit;
    color: var(--drake-highlight);
    font-size: 0.9rem;
    border-radius: 0.9rem;
    padding-left: 0;
}

#write .md-footnote:before {
    content: "[";
}

#write .md-footnote:after {
    content: "]";
}

/*footnotes content*/
.md-hover-tip .code-tooltip-content {
    border-radius: 2px;
}

/*footnotes title*/
span.md-def-name {
    padding-right: 3ch;
    padding-left: 0;
    position: relative;
    font-weight: normal;
}

/*footnotes desc*/
.footnotes {
    font-size: 1rem;
    font-weight: normal;
    color: var(--text-color);
    position: relative;
}

/*footnotes tooltip text*/
.code-tooltip-content .md-plain {
    font-size: 0.9rem;
    font-family: inherit;
}

.code-tooltip-content code {
    padding: 0 2px;
    font-family: inherit;
    color: var(--footnotes-highlight);
    background-color: inherit;
}

.code-tooltip-content a {
    color: var(--footnotes-highlight);
}

div.code-tooltip-content {
    box-shadow: 0 0 8px #00000045;
    background: var(--footnotes-bg-color);
}

.footnotes {
    opacity: 1;
}

.md-def-name:after {
    content: ". ^";
    color: var(--text-color);
}

.md-def-footnote .md-def-name:before {
    content: "";
    color: var(--text-color);
    position: absolute;
}

.md-def-name:before {
    content: "";
    color: var(--text-color);
    position: absolute;
}

.md-content.md-url, .md-def-content.md-def-url.md-auto-disp {
    text-decoration: none;
    border-bottom: .1rem solid var(--text-color);
}

.CodeMirror-scroll::-webkit-scrollbar {
    display: none;
}

.file-list-item-summary {
    font-size: 1em;
}

.pin-outline #outline-content .outline-active strong, .pin-outline .outline-active {
    font-weight: 500;
    color: var(--outline-active-color);
}

.file-list-item.active {
    border-left: 4px solid var(--drake-accent);
}

#md-searchpanel .btn:not(.close-btn):hover {
    box-shadow: none;
    background: var(--btn-hover-bg-color);
}

/*checkbox*/
#write input[type=checkbox] {
    opacity: 0;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
    margin-top: 0;
    top: 0;
}

#write .ul-list li.md-task-list-item.task-list-done::before {
    content: "";
    background: var(--checkbox-checked) 0 0 no-repeat;
    background-size: 100%;
    display: inline-block;
    position: absolute;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
}

#write .ul-list li.md-task-list-item.task-list-not-done::before {
    content: "";
    background: var(--checkbox-unchecked) 0 0 no-repeat;
    background-size: 100%;
    display: inline-block;
    position: absolute;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
}

/*insert table*/
.btn {
    border-radius: 2px;
}

.modal-content {
    border-radius: 8px;
}

.btn-primary:hover, .btn-primary:active {
    background-color: var(--btn-hover-bg-color);
    color: var(--drake-highlight);
}

.btn-primary {
    background-color: transparent;
    color: var(--drake-highlight);
}

.btn-default {
    background-color: transparent;
}

.btn:active {
    box-shadow: none;
    border-color: transparent;
}

.modal-footer {
    border-top: none;
}

#table-insert-col, #table-insert-row {
    background: var(--input-bg-color);
    border-radius: 2px;
}

/*preference panel*/
#megamenu-content {
    background-image: none !important;
    background-color: var(--bg-color);
}
#top-titlebar {
    height: inherit;
    background-color: var(--bg-color);
}
#megamenu-menu-sidebar {
    background-color: var(--bg-color);
    color: var(--text-color);
}
.long-btn {
    width: inherit;
    min-width: 300px;
    border: 1px solid var(--text-color);
    border-radius: 6px;
}
.megamenu-menu-panel h1 {
    margin-bottom: 3rem;
    text-align: left;
}
.megamenu-menu-panel h1, .megamenu-menu-panel h2 {
    font-weight: normal;
}
#recent-file-panel-search-input {
    height: 45px;
    border: none;
    border-bottom: 1px solid var(--text-color);
    padding-left: 8px;
}
#recent-file-panel-search-input::placeholder {
    color: var(--text-color);
    opacity: .5;
}
.megamenu-menu-header {
    border-bottom: none;
}
#recent-file-panel-action-btn {
    background: none;
    border: none;
}
#recent-file-panel-action-btn-container {
    float: none;
    display: inline-block;
}
#top-titlebar .toolbar-icon.btn.hover, #top-titlebar .toolbar-icon.btn:hover {
    background-color: var(--btn-hover-bg-color);
    color: var(--text-color);
}
.megamenu-menu-panel .btn:hover {
    background-color: var(--btn-hover-bg-color) !important;
    color: var(--text-color);
}
#recent-file-panel tbody tr:nth-child(2n-1),
.megamenu-menu-panel table thead,
.megamenu-menu-panel table tr {
    background-color: transparent;
}
.megamenu-menu-panel table {
    font-weight: normal;
}
#megamenu-back-btn {
    color: var(--text-color);
    border: 1px solid var(--text-color);
}
.megamenu-menu-header #megamenu-menu-header-title {
    color: var(--text-color);
}
header, .context-menu, .megamenu-content, footer {
    font-family: var(--text-font);
}
.ty-preferences select {
    padding-left: 2px;
}
.preference-item-hint {
    font-size: 14px;
}
a.ty-link {
    color: var(--a-color);
    margin: 0 .2rem;
}

/**
    code render
    Name: IntelliJ IDEA darcula theme
    From IntelliJ IDEA by JetBrains
 */
.cm-s-inner.CodeMirror {
    background: var(--code-block-bg-color);
    color: var(--code-block-color);
}

.cm-s-inner span.cm-meta {
    color: #BBB529;
}

.cm-s-inner span.cm-number {
    color: #6897BB;
}

.cm-s-inner span.cm-keyword {
    color: #CC7832;
}

.cm-s-inner span.cm-def {
    color: #FFD760;
}

.cm-s-inner span.cm-variable {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-variable-2 {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-variable-3 {
    color: #9876AA;
}

.cm-s-inner span.cm-type {
    color: #AABBCC;
}

.cm-s-inner span.cm-property {
    color: #FFC66D;
}

.cm-s-inner span.cm-operator {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-string {
    color: #6A8759;
}

.cm-s-inner span.cm-string-2 {
    color: #6A8759;
}

.cm-s-inner span.cm-comment {
    color: #787878;
}

.cm-s-inner span.cm-link {
    color: #CC7832;
}

.cm-s-inner span.cm-atom {
    color: #CC7832;
}

.cm-s-inner span.cm-error {
    color: #BC3F3C;
}

.cm-s-inner span.cm-tag {
    color: #E8BF6A;
}

.cm-s-inner span.cm-quote {
    color: #a6e22e;
}

.cm-s-inner span.cm-attribute {
    color: #9876AA;
}

.cm-s-inner span.cm-qualifier {
    color: #6A8759;
}

.cm-s-inner span.cm-bracket {
    color: #E8BF6A;
}

.cm-s-inner span.cm-builtin {
    color: #FF9E59;
}

.cm-s-inner span.cm-special {
    color: #FF9E59;
}

.cm-s-inner span.cm-matchhighlight {
    color: #FFFFFF;
    background-color: rgba(50, 89, 48, .7);
    font-weight: normal;
}

.cm-s-inner span.cm-searching {
    color: #FFFFFF;
    background-color: rgba(61, 115, 59, .7);
    font-weight: normal;
}

.cm-s-inner .CodeMirror-gutters {
    border-right: 1px solid rgba(120, 120, 120, 0.3);
}

.cm-s-inner .CodeMirror-linenumber {
    color: #585b5d;
}

.cm-s-inner .CodeMirror-matchingbracket {
    background-color: #3B514D;
    color: #FFEF28 !important;
}

.cm-s-inner .CodeMirror-selected {
    background: #214283 !important;
}

.cm-s-inner .CodeMirror-selectedtext {
    background: #214283 !important;
}

.cm-s-typora-default .CodeMirror-selectedtext {
    background: var(--select-text-bg-color) !important;
}

.cm-overlay.CodeMirror-selectedtext {
    background: var(--select-text-bg-color) !important;
}

.cm-s-inner div.CodeMirror-cursor {
    border-left: 1px solid var(--code-block-color);
}/*# sourceURL=/Users/didi/Documents/Codes/Fun/lagou/public/drake-juejin.css*/</style></head>
<body>
  <div id="write"><h1>第34讲：少数服从多数：随机森林分类器</h1><p data-nodeid="93097">从 Pipeline 的角度来说，上一个课时我们主要学习的是 Transformer，从本课时开始将进入 Estimator 的学习，也就是机器学习算法的学习。从本课时开始，我们将从 MLlib 实现的算法中按照算法类型：分类（有监督）、聚类（无监督）、推荐算法，各选取一个算法进行学习，并且<strong data-nodeid="93191">每个课时后还会有基于真实数据的实践训练</strong>，这是本模块与其他模块不同的地方。</p>
<p data-nodeid="93098">上节课的思考题可以看成是本课时的预习，在下面的内容中，我们会通过案例解答这个问题。</p>
<p data-nodeid="93099">分类器是机器学习最常见的应用，MLlib 中也内置了许多分类模型，而其中支持分布式计算最好的也是最常用的方法就是随机森林算法，它的基础是决策树算法。本课时，我将介绍决策树算法和随机森林算法，以及用 Spark MLlib 的随机森林分类器实现根据身体监控数据判断人体状态。</p>
<h3 data-nodeid="93100">决策树</h3>
<p data-nodeid="93101">决策树是一种机器学习的方法，它通过一种树形结构对样本进行分类，每个非叶子结点代表一次判断，每个叶子结点代表的是分类结果。它是一种<strong data-nodeid="93200">典型的监督学习</strong>，需要一定量的样本，常见的决策树构造树算法有 C4.5 与 ID3。</p>
<p data-nodeid="93102">下面先来看一个例子。下表中的内容是信贷审批常见的场景：根据信息判断客户是否会逾期。它的样本一共有 4 个特征，最后得出“是否逾期”的结果，这是一个二分类场景。</p>
<p data-nodeid="93103"><img alt="2.png" src="https://s0.lgstatic.com/i/image/M00/3E/30/CgqCHl8rs1yAeh-3AADxNFeYbKs151.png" data-nodeid="93204"></p>
<p data-nodeid="93104">根据这些样本，我们可以构造出一棵这样的树，如下图所示。</p>
<p data-nodeid="93105"><img alt="1.png" src="https://s0.lgstatic.com/i/image/M00/3E/25/Ciqc1F8rs22AZdTQAAFhkujn7lI795.png" data-nodeid="93208"></p>
<p data-nodeid="93106">构造一棵决策树需要从样本中学习结点分裂的时机，并判断阈值，也就是上图中的 A、B、C、D、E，这个过程被称为特征选择。通过这样的方法，我们可以达到对样本分类的效果。</p>
<p data-nodeid="93107">下面我们先来简要介绍一下决策树构造算法的整个过程。决策树构造算法通常是先选择一个最优特征，将样本分为若干个子集，如果子集已经被正确分类，那么就构造叶子结点，将样本分到叶子结点中；如果某个子集没有被正确分类，那么就对这个子集继续进行选择特征。决策树构造是一个递归过程，递归停止条件是所有样本被基本正确分类，这样就构造出了一棵决策树。</p>
<p data-nodeid="93108">从这个过程中可以看出，决策树通常对训练数据有良好的表现，但对新样本却未必如此，容易出现过拟合，也就是说模型能将训练数据很好地正确分类，而对测试数据和真实数据来说，分类结果却不尽如人意 。因此我们需要对已经生成的树进行剪枝，从而提升模型的泛化能力。如果特征过多，在一开始构造的时候，我们也会对特征进行选择，只留下足够有区分度的特征。决策树的生成对应模型的局部选择，而剪枝对应模型的全局选择。</p>
<p data-nodeid="93109">从上述过程可以看出，构造决策树主要包含<strong data-nodeid="93225">特征选择</strong>、<strong data-nodeid="93226">决策树生成</strong>与<strong data-nodeid="93227">决策树剪枝</strong>。下面我们将来详细介绍。</p>
<h4 data-nodeid="93110">特征选择</h4>
<p data-nodeid="93111">本节主要介绍两种特征选择的方式：<strong data-nodeid="93238">信息增益</strong>与<strong data-nodeid="93239">信息增益率</strong>。在介绍这两种方式前，先来看看熵的概念：熵是表示随机变量的不确定性的度量。</p>
<p data-nodeid="93112"><strong data-nodeid="93302">定义</strong>：假设随机变量 <em data-nodeid="93303">X</em> 的可能取值有 <i>x<sub>1</sub> , x<sub>2</sub> , …, x<sub>n</sub></i> ，对于每一个可能的取值 <i>x<sub>i</sub></i> ，其概率 <em data-nodeid="93304">P（X</em> = <em data-nodeid="93305">x<sub>i</sub>）</em> = <em data-nodeid="93306">p<sub>i</sub> （</em> <em data-nodeid="93307">i</em> = 1, 2, …, <em data-nodeid="93308">n）</em> ，则随机变量 <em data-nodeid="93309">X</em> 的熵为：</p>
<p data-nodeid="93113"><img alt="Drawing 2.png" src="https://s0.lgstatic.com/i/image/M00/3E/36/CgqCHl8ruuSATGy3AAAmmKUzEis127.png" data-nodeid="93312"></p>
<p data-nodeid="93114">对于样本集合 <em data-nodeid="93359">D</em> 来说，随机变量 <em data-nodeid="93360">X</em> 是样本的类别，即假设样本有 <em data-nodeid="93361">k</em> 个类别，每个类别的概率是<br>
<img alt="Drawing 3.png" src="https://s0.lgstatic.com/i/image/M00/3E/36/CgqCHl8ruwWASQ_iAAANoL6crhU032.png" data-nodeid="93329"><br>
，其中 | <i>C<sub>k</sub></i> | 表示类别 <em data-nodeid="93362">k</em> 的样本个数，| <em data-nodeid="93363">D</em> | 表示样本总数，对于样本集合 <em data-nodeid="93364">D</em> 来说，熵（经验熵）为：</p>
<p data-nodeid="93115"><img alt="Drawing 4.png" src="https://s0.lgstatic.com/i/image/M00/3E/37/CgqCHl8ruxOAHrq8AABK5ZnXoS8805.png" data-nodeid="93367"></p>
<p data-nodeid="93116">而条件熵的概念为：设有随机变量（ <em data-nodeid="93377">X</em> , <em data-nodeid="93378">Y)</em>，其联合概率分布为：</p>
<p data-nodeid="93117"><img alt="Drawing 5.png" src="https://s0.lgstatic.com/i/image/M00/3E/37/CgqCHl8ruxqAOg4aAABq0voqPeg077.png" data-nodeid="93381"></p>
<p data-nodeid="93118">条件熵 <em data-nodeid="93435">H</em>（<em data-nodeid="93436">Y</em> | *X）*表示在已知随机变量 <em data-nodeid="93437">X</em> 的条件下，随机变量 <em data-nodeid="93438">Y</em> 的不确定性。在随机变量 <em data-nodeid="93439">X</em> 给定的条件下，随机变量 <em data-nodeid="93440">Y</em> 的条件熵 <em data-nodeid="93441">H（Y</em> | <em data-nodeid="93442">X）</em>，定义为 <em data-nodeid="93443">X</em> 给定条件下 <em data-nodeid="93444">Y</em> 的条件概率分布的熵对 <em data-nodeid="93445">X</em> 的数学期望：</p>
<p data-nodeid="93119"><img alt="Drawing 6.png" src="https://s0.lgstatic.com/i/image/M00/3E/37/CgqCHl8ruyKAcbBLAABJvNn0hIA847.png" data-nodeid="93448"></p>
<p data-nodeid="93120">当熵和条件熵中的概率由数据估计得到时，所对应的熵与条件熵分别称为经验熵与经验条件熵。从经验熵与经验条件熵可以得到<strong data-nodeid="93454">信息增益的定义</strong>：</p>
<p data-nodeid="93121">特征 <em data-nodeid="93492">A</em> 对训练数据集 <em data-nodeid="93493">D</em> 的信息增益 <em data-nodeid="93494">g</em> （<em data-nodeid="93495">D</em> , <em data-nodeid="93496">A）</em> 的定义，是集合 <em data-nodeid="93497">D</em> 的经验熵 <em data-nodeid="93498">H（D)</em> 与特征 <em data-nodeid="93499">A</em> 给定条件下 <em data-nodeid="93500">D</em> 的经验熵与条件熵之差：</p>
<p data-nodeid="93122"><img alt="Drawing 7.png" src="https://s0.lgstatic.com/i/image/M00/3E/37/CgqCHl8ruyqAQoMqAABDo99VV2A633.png" data-nodeid="93503"></p>
<p data-nodeid="93877">信息增益通常用来选择特征，经验熵 <em data-nodeid="93921">H（D）</em> 表示的是对数据集 <em data-nodeid="93922">D</em> 进行分类的不确定性。而经验条件熵 <em data-nodeid="93923">H（D</em> | <em data-nodeid="93924">A）</em> 表示在特征 <em data-nodeid="93925">A</em> 给定的条件下，对数据集 <em data-nodeid="93926">D</em> 进行分类的不确定性，那么信息增益就表示由于特征 <em data-nodeid="93927">A</em> 而使得对数据集 <em data-nodeid="93928">D</em> 的分类的不确定性的减少程度。显然，对于数据集 <em data-nodeid="93929">D</em> 而言，信息增益依赖于特征，不同特征往往具有不同的信息增益。信息增益大的特征具有更强的分类能力。根据信息增益准则，选择特征的方法是：对训练数据集（或子集） <em data-nodeid="93930">D</em>，计算其每个特征的信息增益，并选择信息增益最大的特征。</p>

<p data-nodeid="93124">信息增益率是对信息增益的改进，特征 <em data-nodeid="93598">A</em> 对训练数据集 <em data-nodeid="93599">D</em> 的信息增益率 <em data-nodeid="93600">g<sub>R</sub>（D</em> , <em data-nodeid="93601">A）</em> 的定义，是其信息增益 <em data-nodeid="93602">g（D</em> , <em data-nodeid="93603">A）</em> 与训练数据集 <em data-nodeid="93604">D</em> 的经验熵 <em data-nodeid="93605">H</em> （<em data-nodeid="93606">D）</em> 之比，如下图所示：</p>
<p data-nodeid="93125"><img alt="Drawing 8.png" src="https://s0.lgstatic.com/i/image/M00/3E/2B/Ciqc1F8ruzGAPP1YAABNXeHlZfw189.png" data-nodeid="93609"></p>
<p data-nodeid="93126">除了信息增益与信息增益率之外，还可以用基尼系数来完成特征选择。</p>
<h4 data-nodeid="93127">决策树生成</h4>
<p data-nodeid="93128">决策树生成算法与特征选择方法相对应，选用信息增益进行特征选择的是 ID3 算法，选择信息增益比进行特征选择的是&nbsp;C4.5&nbsp;算法，选择基尼系数来完成特征选择的是分类回归树（CART）算法。本节将介绍 C4.5 与 ID3 算法。</p>
<p data-nodeid="93129"><strong data-nodeid="93616">ID3 算法如下：</strong></p>
<p data-nodeid="93130">简单来说，ID3 算法会在决策树各个结点上应用信息增益准则选择特征，递归地构建决策树。</p>
<p data-nodeid="93131">给定训练数据集 <em data-nodeid="93631">D</em>，特征集 <em data-nodeid="93632">S</em>，阈值 <em data-nodeid="93633">ϵ</em> ：</p>
<ol data-nodeid="116575">
<li data-nodeid="116576">
<p data-nodeid="116577">若 <em data-nodeid="116611">D</em> 中所有实例属于同一类 <i>C<sub>k</sub></i>，则 <em data-nodeid="116612">T</em> 为单结点树，并将类 <i>C<sub>k</sub></i> 作为该结点的类标记，返回 T；</p>
</li>
<li data-nodeid="116578">
<p data-nodeid="116579">若 <em data-nodeid="116637">S</em> =&nbsp;Æ，则 <em data-nodeid="116638">T</em> 为单结点树，并将 <em data-nodeid="116639">D</em> 中实例数最大的类 <i>C<sub>k</sub></i> 作为该结点的类标记，返回 <em data-nodeid="116640">T</em>；</p>
</li>
<li data-nodeid="116580">
<p data-nodeid="116581">否则，计算 <em data-nodeid="116657">S</em> 中各特征对 <em data-nodeid="116658">D</em> 的信息增益，选择信息增益最大的特征 <i>S<sub>g</sub></i>；</p>
</li>
<li data-nodeid="116582">
<p data-nodeid="116583">如果 <i>S<sub>g</sub></i> 的信息增益小于阈值 <em data-nodeid="116690">ϵ</em>，则置 <em data-nodeid="116691">T</em> 为单结点树，并将 <em data-nodeid="116692">D</em> 中实例数最大的类 <i>C<sub>k</sub></i> 作为该结点的类标记，返回 <em data-nodeid="116693">T</em>；</p>
</li>
<li data-nodeid="116584">
<p data-nodeid="116585">否则，对 <i>S<sub>g</sub></i> 的每一个可能值 <i>a<sub>i</sub></i>，将 <em data-nodeid="116735">D</em> 分割为若干个非空子集 <i>D<sub>i</sub></i>，将 <i>D<sub>i</sub></i> 中实例数最大的类作为标记，构建子结点，由结点及其子结点构成树 <em data-nodeid="116736">T</em>，返回 <em data-nodeid="116737">T</em>；</p>
</li>
<li data-nodeid="116586">
<p data-nodeid="116587">对第 <em data-nodeid="116771">i</em> 个子结点，以 <i>D<sub>i</sub></i> 为训练集，以 <i>S -S<sub>g</sub></i> 为特征集，递归调用第 1～5 步，得到子树 <i>T<sub>i</sub></i>，返回 <i>T<sub>i</sub></i>。</p>
</li>
</ol>













<p data-nodeid="93145"><strong data-nodeid="93822">C4.5 算法</strong>与 ID3 算法非常类似，只是把用到信息增益的地方换成了信息增益比。</p>
<h4 data-nodeid="93146">剪枝</h4>
<p data-nodeid="93147">通常决策树在训练数据上表现很好，但是在测试数据上就不尽如人意，这就是模型过拟合。决策树剪枝主要分为预剪枝和后剪枝。<strong data-nodeid="93833">预剪枝</strong>是在构造决策树的同时进行剪枝，通常作为停止条件，即设定一个熵的阈值，就算可以继续降低熵，也停止创建分支。而<strong data-nodeid="93834">通常我们说的剪枝是指后剪枝</strong>，后剪枝通常有以下两种做法：</p>
<ul data-nodeid="93148">
<li data-nodeid="93149">
<p data-nodeid="93150"><strong data-nodeid="93839">应用交叉验证的思想</strong>，若局部剪枝能够使得模型在测试集上的错误率降低，则进行局部剪枝。</p>
</li>
<li data-nodeid="93151">
<p data-nodeid="93152"><strong data-nodeid="93844">应用正则化的思想</strong>，综合考虑不确定性和模型复杂度来定出一个新的损失，用该损失作为一个结点是否应该局部剪枝的标准。这种做法的核心是定义新的代价函数，通常会采用树的结构复杂度与模型预测误差之和作为代价衡量。</p>
</li>
</ul>
<p data-nodeid="93153">在 ID3、C4.5 中我们会应用前者做法，而在分类回归树中，我们会采取后者做法。</p>
<h3 data-nodeid="93154">随机森林</h3>
<p data-nodeid="93155">在决策树的基础上了解随机森林的原理相对容易。随机森林就是通过集成学习的思想将多棵树集成的一种算法，它的基本单元是决策树，属于机器学习的一大分支——集成学习（Ensemble Learning）方法。集成学习是通过构建多个弱分类器，并按一定规则组合起来的分类系统，常常比单一分类器具有显著优越的泛化性能，常见集成学习算法有随机森林、AdaBoost、XgBoost、梯度提升树等，在风险建模、疾病预测等领域应用相当广泛。</p>
<p data-nodeid="93156">随机森林将 N 棵决策树集成，每一棵决策树都是一个分类器，相当于每个分类器都会对结果进行投票，随机森林会综合所有的分类结果，并将票数最高的分类结果作为最终结果输出。可以想到，在随机森林中，每一棵决策树的生成是算法的关键。<strong data-nodeid="93853">每棵树的生成规则如下</strong>：</p>
<ol data-nodeid="119905">
<li data-nodeid="119906">
<p data-nodeid="119907">如果训练集大小为 N，对每棵树而言，随机且有放回地从训练集中抽取 N 个训练样本（这种采样方式称为 Bootstrap Sample 方法），作为该树的训练集。</p>
</li>
<li data-nodeid="119908">
<p data-nodeid="119909">如果每个样本的特征维度为 M，指定一个常数 m&lt;&lt;M，随机地从 M 个特征中选取 m 个特征子集，每次树进行分裂时，从这 m 个特征中选择最优的。</p>
</li>
<li data-nodeid="119910">
<p data-nodeid="119911">每棵树都尽最大限度地生长，并且没有剪枝过程。</p>
</li>
</ol>


<p data-nodeid="93164">随机森林中所谓“随机”的含义，就是模型在这里引入了随机性（随机抽取训练集、随机抽取特征），两个随机性的引入对随机森林的分类性能至关重要。由于它们的引入，使得随机森林不容易陷入过拟合，并且具有很好的抗噪能力。随机森林的特点有：</p>
<ul data-nodeid="93165">
<li data-nodeid="93166">
<p data-nodeid="93167">在当前所有算法中，具有极佳的准确率，在国内外最近几年的数据挖掘大赛中，随机森林取得了令人瞩目的成绩。</p>
</li>
<li data-nodeid="93168">
<p data-nodeid="93169">能够高效地运行在大数据集上，很容易可以看出，随机森林是非常容易分布式的。</p>
</li>
<li data-nodeid="93170">
<p data-nodeid="93171">能够处理具有高维特征的输入样本。</p>
</li>
<li data-nodeid="93172">
<p data-nodeid="93173">能够评估各个特征在分类问题上的重要性。</p>
</li>
<li data-nodeid="93174">
<p data-nodeid="93175">在生成过程中，能够获取到内部生成误差的一种无偏估计。</p>
</li>
<li data-nodeid="93176">
<p data-nodeid="93177">对于缺省值问题也能够获得很好的结果。</p>
</li>
</ul>
<h3 data-nodeid="93178">人体状态监测器</h3>
<p data-nodeid="121478">下面，我们将用真实的数据（数据集下载链接： <a href="https://pan.baidu.com/s/1rUxHKl119qGDlV6KeTtkLA" data-nodeid="121482">https://pan.baidu.com/s/1rUxHKl119qGDlV6KeTtkLA</a>提取码：ev1d）拟合出一个随机森林分类器。案例的内容是通过身体监测数据来判断人体状态，比如监测走路、骑行、跑步、看电视。数据集包括时间戳、心跳、活动标签和 3 个传感器，传感器分别佩戴在手上、胸部、踝关节处，每个传感器有 17 个检测指标 （温度、3D 加速度、陀螺仪和磁强计数据、方位数据） 。数据集共计 54 个属性，3850505 条样本，包含了 18 种人体活动。代码如下：</p>

<pre class="lang-scala hljs" data-nodeid="93180"><code data-language="scala"><span class="hljs-keyword">import</span>&nbsp;org.apache.spark.ml.<span class="hljs-type">Pipeline</span> 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.ml.classification.{<span class="hljs-type">RandomForestClassificationModel</span>,&nbsp;<span class="hljs-type">RandomForestClassifier</span>} 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.ml.evaluation.<span class="hljs-type">MulticlassClassificationEvaluator</span> 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.sql.{<span class="hljs-type">Dataset</span>,&nbsp;<span class="hljs-type">Row</span>,&nbsp;<span class="hljs-type">SparkSession</span>} 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.rdd.<span class="hljs-type">RDD</span> 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.mllib.regression.<span class="hljs-type">LabeledPoint</span> 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.mllib.linalg.<span class="hljs-type">Vectors</span> 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.ml.feature.{<span class="hljs-type">IndexToString</span>,&nbsp;<span class="hljs-type">StringIndexer</span>,&nbsp;<span class="hljs-type">VectorAssembler</span>} 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.sql.types._ 
<span class="hljs-keyword">import</span>&nbsp;scala.collection.mutable 

<span class="hljs-class"><span class="hljs-keyword">object</span><span class="hljs-title">&nbsp;RandomForestBodyDetection&nbsp;</span></span>{ 

&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">&nbsp;main</span></span>(args:&nbsp;<span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]):&nbsp;<span class="hljs-type">Unit</span>&nbsp;=&nbsp;{ 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;spark&nbsp;=&nbsp;<span class="hljs-type">SparkSession</span> 
&nbsp;&nbsp;&nbsp;&nbsp;.builder() 
&nbsp;&nbsp;&nbsp;&nbsp;.appName(<span class="hljs-string">"RandomForestBodyDetection"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.master(<span class="hljs-string">"local[2]"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.enableHiveSupport() 
&nbsp;&nbsp;&nbsp;&nbsp;.getOrCreate() 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">import</span>&nbsp;spark.implicits._ 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;读取数据集 </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;dataFiles&nbsp;=&nbsp;spark.read.textFile(<span class="hljs-string">"data/bodydetect"</span>) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;rawData&nbsp;=&nbsp;dataFiles.map(r=&gt;r.toString().split(<span class="hljs-string">"&nbsp;"</span>)).rdd.map(row&nbsp;=&gt;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;list&nbsp;=&nbsp;mutable.<span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Any</span>]()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(i&nbsp;&lt;-&nbsp;row.toSeq)&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.append(i) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">Row</span>.fromSeq(list.map(v=&gt;<span class="hljs-keyword">if</span>&nbsp;(v.toString.toUpperCase&nbsp;==&nbsp;<span class="hljs-string">"NAN"</span>)&nbsp;<span class="hljs-type">Double</span>.<span class="hljs-type">NaN</span>&nbsp;<span class="hljs-keyword">else</span>&nbsp;v.toString.toDouble)) 
&nbsp;&nbsp;&nbsp;&nbsp;}) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;schema&nbsp;=&nbsp;<span class="hljs-type">StructType</span>(<span class="hljs-type">Array</span>( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"timestamp"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"activityId"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hr"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_temp"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_accel1X"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_accel1Y"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_accel1Z"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_accel2X"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_accel2Y"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_accel2Z"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_gyroX"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_gyroY"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_gyroZ"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_magnetX"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_magnetY"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_magnetZ"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_orientX"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_orientY"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_orientZ"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"hand_orientD"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_temp"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_accel1X"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_accel1Y"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_accel1Z"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_accel2X"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_accel2Y"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_accel2Z"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_gyroX"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_gyroY"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_gyroZ"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_magnetX"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_magnetY"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_magnetZ"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_orientX"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_orientY"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_orientZ"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"chest_orientD"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_temp"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_accel1X"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_accel1Y"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_accel1Z"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_accel2X"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_accel2Y"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_accel2Z"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_gyroX"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_gyroY"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_gyroZ"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_magnetX"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_magnetY"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_magnetZ"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_orientX"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_orientY"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_orientZ"</span>,&nbsp;<span class="hljs-type">DoubleType</span>),&nbsp;<span class="hljs-type">StructField</span>(<span class="hljs-string">"ankle_orientD"</span>,&nbsp;<span class="hljs-type">DoubleType</span>))) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;df&nbsp;=&nbsp;spark.createDataFrame(rawData,schema) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;数据集的列名，sensor_name&nbsp;表示某个传感器的某个指标数据，例如，手上的传感器的温度指标为&nbsp;hand_temp </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;allColumnNames&nbsp;=&nbsp;<span class="hljs-type">Array</span>( 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"timestamp"</span>,&nbsp;<span class="hljs-string">"activityId"</span>,&nbsp;<span class="hljs-string">"hr"</span>)&nbsp;++&nbsp;<span class="hljs-type">Array</span>( 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"hand"</span>,&nbsp;<span class="hljs-string">"chest"</span>,&nbsp;<span class="hljs-string">"ankle"</span>).flatMap(sensor&nbsp;=&gt; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">Array</span>( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"temp"</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"accel1X"</span>,&nbsp;<span class="hljs-string">"accel1Y"</span>,&nbsp;<span class="hljs-string">"accel1Z"</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"accel2X"</span>,&nbsp;<span class="hljs-string">"accel2Y"</span>,&nbsp;<span class="hljs-string">"accel2Z"</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"gyroX"</span>,&nbsp;<span class="hljs-string">"gyroY"</span>,&nbsp;<span class="hljs-string">"gyroZ"</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"magnetX"</span>,&nbsp;<span class="hljs-string">"magnetY"</span>,&nbsp;<span class="hljs-string">"magnetZ"</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"orientX"</span>,&nbsp;<span class="hljs-string">"orientY"</span>,&nbsp;<span class="hljs-string">"orientZ"</span>,&nbsp;<span class="hljs-string">"orientD"</span>).map(name&nbsp;=&gt;&nbsp;<span class="hljs-string">s"<span class="hljs-subst">\${sensor}</span>_<span class="hljs-subst">\${name}</span>"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;数据集中不需要的列、时间戳和方位数据，分别表示手、胸部、踝关节上传感器的第一个方位指标 </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;ignoredColumns&nbsp;=&nbsp;<span class="hljs-type">Array</span>(<span class="hljs-number">0</span>,&nbsp;<span class="hljs-number">16</span>,&nbsp;<span class="hljs-number">17</span>,&nbsp;<span class="hljs-number">18</span>,&nbsp;<span class="hljs-number">19</span>,&nbsp;<span class="hljs-number">33</span>,&nbsp;<span class="hljs-number">34</span>,&nbsp;<span class="hljs-number">35</span>,&nbsp;<span class="hljs-number">36</span>,&nbsp;<span class="hljs-number">50</span>,&nbsp;<span class="hljs-number">51</span>,&nbsp;<span class="hljs-number">52</span>,&nbsp;<span class="hljs-number">53</span>) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;inputColNames&nbsp;=&nbsp;ignoredColumns.map(l&nbsp;=&gt;&nbsp;allColumnNames(l)) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;columnNames&nbsp;=&nbsp;allColumnNames. 
&nbsp;&nbsp;&nbsp;&nbsp;filter&nbsp;{&nbsp;!inputColNames.contains(_)&nbsp;} 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;滤掉不需要的列，并填充缺失值 </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;typeTransformer&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-type">FillMissingValueTranformer</span>().setInputCols(inputColNames) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;构造标签列 </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;labelIndexer&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-type">StringIndexer</span>() 
&nbsp;&nbsp;&nbsp;&nbsp;.setInputCol(<span class="hljs-string">"activityId"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setOutputCol(<span class="hljs-string">"indexedLabel"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.fit(df) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;构造特征列 </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;vectorAssembler&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-type">VectorAssembler</span>() 
&nbsp;&nbsp;&nbsp;&nbsp;.setInputCols(columnNames) 
&nbsp;&nbsp;&nbsp;&nbsp;.setOutputCol(<span class="hljs-string">"featureVector"</span>) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;配置分类器 </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;rfClassifier&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-type">RandomForestClassifier</span>() 
&nbsp;&nbsp;&nbsp;&nbsp;.setLabelCol(<span class="hljs-string">"indexedLabel"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setFeaturesCol(<span class="hljs-string">"featureVector"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setFeatureSubsetStrategy(<span class="hljs-string">"auto"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setNumTrees(<span class="hljs-number">350</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setMaxBins(<span class="hljs-number">30</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setMaxDepth(<span class="hljs-number">30</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setImpurity(<span class="hljs-string">"entropy"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setCacheNodeIds(<span class="hljs-literal">true</span>) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;labelConverter&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-type">IndexToString</span>() 
&nbsp;&nbsp;&nbsp;&nbsp;.setInputCol(<span class="hljs-string">"prediction"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setOutputCol(<span class="hljs-string">"predictedLabel"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setLabels(labelIndexer.labels) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;<span class="hljs-type">Array</span>(trainingData,&nbsp;testData)&nbsp;=&nbsp;df.randomSplit(<span class="hljs-type">Array</span>(<span class="hljs-number">0.8</span>,&nbsp;<span class="hljs-number">0.2</span>)) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;构建整个Pipeline </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;pipeline&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-type">Pipeline</span>().setStages( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">Array</span>(typeTransformer, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labelIndexer,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vectorAssembler,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rfClassifier,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labelConverter)) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;model&nbsp;=&nbsp;pipeline.fit(trainingData) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;predictionResultDF&nbsp;=&nbsp;model.transform(testData) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;展示结果 </span>
&nbsp;&nbsp;&nbsp;&nbsp;predictionResultDF.select( 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"hr"</span>,&nbsp;<span class="hljs-string">"hand_temp"</span>,&nbsp;<span class="hljs-string">"hand_accel1X"</span>,&nbsp;<span class="hljs-string">"hand_accel1Y"</span>,&nbsp;<span class="hljs-string">"hand_accel1Z"</span>,&nbsp;<span class="hljs-string">"hand_accel2X"</span>,&nbsp;<span class="hljs-string">"hand_accel2Y"</span>,&nbsp;<span class="hljs-string">"hand_accel2Z"</span>,&nbsp;<span class="hljs-string">"hand_gyroX"</span>,&nbsp;<span class="hljs-string">"hand_gyroY"</span>,&nbsp;<span class="hljs-string">"hand_gyroZ"</span>,&nbsp;<span class="hljs-string">"hand_magnetX"</span>,&nbsp;<span class="hljs-string">"hand_magnetY"</span>,&nbsp;<span class="hljs-string">"hand_magnetZ"</span>,&nbsp;<span class="hljs-string">"chest_temp"</span>,&nbsp;<span class="hljs-string">"chest_accel1X"</span>,&nbsp;<span class="hljs-string">"chest_accel1Y"</span>,&nbsp;<span class="hljs-string">"chest_accel1Z"</span>,&nbsp;<span class="hljs-string">"chest_accel2X"</span>,&nbsp;<span class="hljs-string">"chest_accel2Y"</span>,&nbsp;<span class="hljs-string">"chest_accel2Z"</span>,&nbsp;<span class="hljs-string">"chest_gyroX"</span>,&nbsp;<span class="hljs-string">"chest_gyroY"</span>,&nbsp;<span class="hljs-string">"chest_gyroZ"</span>,<span class="hljs-string">"chest_magnetX"</span>,&nbsp;<span class="hljs-string">"chest_magnetY"</span>,&nbsp;<span class="hljs-string">"chest_magnetZ"</span>,&nbsp;<span class="hljs-string">"ankle_temp"</span>,&nbsp;<span class="hljs-string">"ankle_accel1X"</span>,&nbsp;<span class="hljs-string">"ankle_accel1Y"</span>,&nbsp;<span class="hljs-string">"ankle_accel1Z"</span>,&nbsp;<span class="hljs-string">"ankle_accel2X"</span>,<span class="hljs-string">"ankle_accel2Y"</span>,&nbsp;<span class="hljs-string">"ankle_accel2Z"</span>,&nbsp;<span class="hljs-string">"ankle_gyroX"</span>,&nbsp;<span class="hljs-string">"ankle_gyroY"</span>,&nbsp;<span class="hljs-string">"ankle_gyroZ"</span>,&nbsp;<span class="hljs-string">"ankle_magnetX"</span>,&nbsp;<span class="hljs-string">"ankle_magnetY"</span>,&nbsp;<span class="hljs-string">"ankle_magnetZ"</span>,&nbsp;<span class="hljs-string">"indexedLabel"</span>,&nbsp;<span class="hljs-string">"predictedLabel"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.show(<span class="hljs-number">20</span>) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;evaluator&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-type">MulticlassClassificationEvaluator</span>() 
&nbsp;&nbsp;&nbsp;&nbsp;.setLabelCol(<span class="hljs-string">"indexedLabel"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setPredictionCol(<span class="hljs-string">"prediction"</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;.setMetricName(<span class="hljs-string">"accuracy"</span>) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;predictionAccuracy&nbsp;=&nbsp;evaluator.evaluate(predictionResultDF) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;模型性能 </span>
&nbsp;&nbsp;&nbsp;&nbsp;println(<span class="hljs-string">"Testing&nbsp;Error&nbsp;=&nbsp;"</span>&nbsp;+&nbsp;(<span class="hljs-number">1.0</span>&nbsp;-&nbsp;predictionAccuracy)) 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;randomForestModel&nbsp;=&nbsp;model.stages(<span class="hljs-number">2</span>).asInstanceOf[<span class="hljs-type">RandomForestClassificationModel</span>] 

&nbsp;&nbsp;&nbsp;&nbsp;println(<span class="hljs-string">"Trained&nbsp;Random&nbsp;Forest&nbsp;Model&nbsp;is:\n"</span>&nbsp;+&nbsp;randomForestModel.toDebugString) 
&nbsp;&nbsp;} 

}
</code></pre>
<p data-nodeid="93181">在处理流程中，用自定义的&nbsp;Transformer&nbsp;过滤掉了不需要的数据，并通过填充缺失值的方式对数据进行预处理。自定义的 Transformer 代码如下：</p>
<pre class="lang-scala hljs" data-nodeid="93182"><code data-language="scala"><span class="hljs-keyword">import</span>&nbsp;org.apache.spark.ml.<span class="hljs-type">Transformer</span> 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.ml.param.{<span class="hljs-type">Param</span>,&nbsp;<span class="hljs-type">ParamMap</span>} 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.ml.util.{<span class="hljs-type">DefaultParamsWritable</span>,&nbsp;<span class="hljs-type">Identifiable</span>} 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.sql.types.{<span class="hljs-type">BooleanType</span>,&nbsp;<span class="hljs-type">NumericType</span>,&nbsp;<span class="hljs-type">StructType</span>} 
<span class="hljs-keyword">import</span>&nbsp;org.apache.spark.sql.{<span class="hljs-type">DataFrame</span>,&nbsp;<span class="hljs-type">Dataset</span>,&nbsp;<span class="hljs-type">Row</span>} 

<span class="hljs-comment">//&nbsp;继承基类Transformer </span>
<span class="hljs-class"><span class="hljs-keyword">class</span><span class="hljs-title">&nbsp;FillMissingValueTranformer&nbsp;extends&nbsp;Transformer</span> </span>
{ 
&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;uid:&nbsp;<span class="hljs-type">String</span>&nbsp;=&nbsp;<span class="hljs-type">Identifiable</span>.randomUID(<span class="hljs-string">"MissingValueTransformer"</span>) 


&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">final</span>&nbsp;<span class="hljs-keyword">val</span>&nbsp;inputCols&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-type">Param</span>[<span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]](<span class="hljs-keyword">this</span>,&nbsp;<span class="hljs-string">"inputCol"</span>,&nbsp;<span class="hljs-string">"The&nbsp;input&nbsp;column"</span>) 

&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">override</span>&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">&nbsp;transformSchema</span></span>(schema:&nbsp;<span class="hljs-type">StructType</span>):&nbsp;<span class="hljs-type">StructType</span>&nbsp;=&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;检查输入和输出是否符合要求,&nbsp;比如数据类型 </span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;返回处理之后的schema </span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;inputColNames&nbsp;=&nbsp;$(inputCols) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;incorrectColumns&nbsp;=&nbsp;inputColNames.flatMap&nbsp;{&nbsp;name&nbsp;=&gt; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schema(name).dataType&nbsp;<span class="hljs-keyword">match</span>&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;_:&nbsp;<span class="hljs-type">NumericType</span>&nbsp;|&nbsp;<span class="hljs-type">BooleanType</span>&nbsp;=&gt;&nbsp;<span class="hljs-type">None</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;other&nbsp;=&gt;&nbsp;<span class="hljs-type">Some</span>(<span class="hljs-string">s"Data&nbsp;type&nbsp;<span class="hljs-subst">$other</span>&nbsp;of&nbsp;column&nbsp;<span class="hljs-subst">$name</span>&nbsp;is&nbsp;not&nbsp;supported."</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(incorrectColumns.nonEmpty)&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">throw</span>&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-type">IllegalArgumentException</span>(incorrectColumns.mkString(<span class="hljs-string">"\n"</span>)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">StructType</span>(schema.fields) 
&nbsp;&nbsp;&nbsp;} 

&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">&nbsp;setInputCols</span></span>(value:&nbsp;<span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]):&nbsp;<span class="hljs-keyword">this</span>.<span class="hljs-keyword">type</span>&nbsp;=&nbsp;set(inputCols,&nbsp;value) 

&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">override</span>&nbsp;<span class="hljs-keyword">def</span>&nbsp;transform(dataset:&nbsp;Dataset[_]):&nbsp;DataFrame&nbsp;=&nbsp;{ 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;inputColNames&nbsp;=&nbsp;$(inputCols) 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;rawdata=dataset 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(i&lt;-inputColNames)&nbsp;{rawdata=rawdata.drop(i)} 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;allColumnNames&nbsp;=&nbsp;dataset.columns 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;过滤掉不需要的列名 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;columnNames&nbsp;=&nbsp;allColumnNames.filter&nbsp;{&nbsp;!inputColNames.contains(_)&nbsp;} 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;心率的空值填充为<span class="hljs-number">60</span>，其他属性的空值填充为<span class="hljs-number">0</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;imputedValues:<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>,<span class="hljs-type">Double</span>]=<span class="hljs-type">Map</span>() 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(colname&lt;-columnNames){ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>(colname==<span class="hljs-string">"hr"</span>){imputedValues&nbsp;+=&nbsp;(colname-&gt;<span class="hljs-number">60.0</span>)} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">else</span>&nbsp;{imputedValues&nbsp;+=&nbsp;(colname-&gt;<span class="hljs-number">0.0</span>)} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">val</span>&nbsp;processdata=rawdata.na.drop(<span class="hljs-number">26</span>,columnNames).na.fill(imputedValues) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processdata.toDF() 
&nbsp;&nbsp;&nbsp;&nbsp;} 

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">override</span>&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">&nbsp;copy</span></span>(extra:&nbsp;<span class="hljs-type">ParamMap</span>):&nbsp;<span class="hljs-type">Transformer</span>&nbsp;=&nbsp;defaultCopy(extra) 

}
</code></pre>
<h3 data-nodeid="93183">小结</h3>
<p data-nodeid="93184">本课时，我们学习了决策树算法与随机森林算法，随机森林算法也曾经是各种数据科学竞赛中的明星算法，属于集成学习的一种。此外，可以发现随机森林算法对于分布式计算来说是很好的方法，这也是 MLlib 将其实现的原因。在本课时中，我们还实现了一个自定义 Transformer，也是对上一节课的复习。</p>
<p data-nodeid="93185">最后给大家留一个思考题： 在配置分类器时，我们一共设置了多少个参数，每个参数有什么用？</p></div>

</body></html>