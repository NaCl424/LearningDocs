<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>01 | 栈：从简单栈到单调栈，解决经典栈问题</title>
<style type="text/css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}/*# sourceURL=/Users/young/Documents/Codes/Fun/lagou/public/atom-one-light.min.css*/</style><style type="text/css">/*
 * Copyright (C) 2018 Drake, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

:root {
    --monospace: "JetBrains Mono", HYZhengYuan, "Fira Code", Menlo, "Ubuntu Mono", Consolas; /*code font*/
    --text-font: var(--monospace); /*default font*/
    --title-font: var(--monospace); /*title font*/

    --text-color: #333333;
    --bg-color: #ffffff;
    --control-text-color: var(--text-color);
    --meta-content-color: var(--text-color);
    --active-file-border-color: var(--drake-accent);
    --rawblock-edit-panel-bd: var(--code-block-bg-color);
    --item-hover-bg-color: #E5E5E596;
    --active-file-bg-color: var(--item-hover-bg-color);

    --drake-accent: #e95f59;
    --drake-highlight: #d63200;
    --a-color: #036aca;
    --variable-color: var(--drake-highlight);
    --outline-active-color: var(--a-color);
    --code-block-bg-color: #2b2b2b;
    --code-block-color: #A9B7C6;
    --title-color: #135ce0;
    --blockquote-border-color: #b2aec5;
    --blockquote-color: #595959;
    --blockquote-bg-color: #fff9f9;
    --strong-color: var(--title-color);
    --h2-underline-color: var(--title-color);
    --horizontal-divider-color: var(--title-color);
    --height-light-color: var(--drake-highlight);
    --height-light-border-color: var(--drake-highlight);
    --yaml-color: #777777;
    --yaml-bg-color: #f7f7f7;
    --footnotes-bg-color: #3c3d3e;
    --footnotes-highlight: #FFD760;
    --table-border-color: #dfe2e5;
    --table-header-bg-color: #f6f8fa;
    --table-bg-color: var(--bg-color);
    --table-n2-bg-color: #f6f8fa;
    --input-bg-color: var(--item-hover-bg-color);
    --btn-hover-bg-color: var(--item-hover-bg-color);
    --checkbox-checked: url("data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cpath d='M425.984 726.016l384-384-59.99-61.995-324.01 324.011-152.021-152.021L213.973 512zm384-598.016q36.01 0 61.013 25.984T896 213.974v596.01q0 34.005-25.003 59.99t-61.013 25.983h-596.01q-36.011 0-61.014-25.984t-25.003-59.989v-596.01q0-34.006 25.003-59.99T213.973 128h596.011z' fill='%2365b73b'/%3E%3C/svg%3E");
    --checkbox-unchecked: url("data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cpath d='M810.667 213.333v597.334H213.333V213.333h597.334m0-85.333H213.333C166.4 128 128 166.4 128 213.333v597.334C128 857.6 166.4 896 213.333 896h597.334C857.6 896 896 857.6 896 810.667V213.333C896 166.4 857.6 128 810.667 128z' fill='%23333333'/%3E%3C/svg%3E");
}

html {
    font-size: 15px;
}

body {
    font-family: var(--text-font) !important;
    color: var(--text-color);
    -webkit-font-feature-settings: "liga" on, "calt" on;
    -webkit-font-smoothing: subpixel-antialiased;
    text-rendering: optimizeLegibility;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
    line-height: 1.8rem;
}

img {
    max-width: 100%;
}

#write {
    background-image: linear-gradient(
            90deg
            ,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(
            1turn
            ,rgba(60,10,30,.04) 3%,transparent 0);
    background-size: 20px 20px;
    background-position: 50%;
}

/*code block*/
#write .md-fences {
    font-size: 1rem;
    padding: 0.5rem !important;
    border-radius: 2px;
    word-wrap: normal;
    background-color: var(--code-block-bg-color);
    color: var(--code-block-color);
    border: none;
}

/*code snippet*/
#write code, tt {
    border-radius: 2px;
    color: var(--drake-highlight);
}

/*variable*/
var {
    color: var(--variable-color);
    font-weight: bold;
}

/*raw block*/
.md-rawblock-control:not(.md-rawblock-tooltip) {
    border-radius: 2px 0 2px 2px;
    padding: 0.2rem !important;
}
.md-rawblock:hover > .md-rawblock-container {
    background: none;
}
.md-rawblock-input {
    font-size: 1rem;
}
.md-rawblock-tooltip-btn:hover {
    background: none;
}
.md-rawblock:hover > .md-rawblock-tooltip {
    border-radius: 2px 2px 0 0;
    margin-bottom: 2px !important;
}
.md-rawblock-tooltip.md-rawblock-control {
    border-radius: 2px 2px 0 0;
    color: var(--code-block-color);
}
.md-rawblock-tooltip-name {
    color: var(--code-block-color);
    opacity: 1;
}

/*quote block*/
blockquote:before {
    display: block;
    position: absolute;
    content: '';
    width: 4px;
    left: 0;
    top: 0;
    height: 100%;
    background-color: var(--blockquote-border-color);
    border-radius: 2px;
}

blockquote {
    color: var(--blockquote-color);
    border-radius: 2px;
    padding: 10px 16px;
    background-color: var(--blockquote-bg-color);
    position: relative;
    border-left: none;
}

#write strong {
    color: var(--strong-color);
    font-weight: bold;
}
#write blockquote strong {
    color: var(--blockquote-color);
}

/*link*/
#write a {
    color: var(--a-color);
    text-decoration: none;
}
#write a .md-plain, .md-htmlblock-container a:hover {
    border-bottom: .1rem solid var(--a-color);
}
[md-inline=link] a {
    margin: 0 .2rem;
}
a:any-link {
    color: var(--a-color);
}

img {
    border-left: none;
    border-right: none;
    vertical-align: baseline;
    border-radius: 2px;
}

#write {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px 30px 100px;
}
#typora-source .CodeMirror-lines {
    max-width: 1200px;
}

#write p {
    word-spacing: .05rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    font-family: var(--title-font);
    position: relative;
    margin-top: 2rem;
    margin-bottom: 1rem;
    font-weight: bold;
    cursor: text;
    color: var(--title-color);
}

h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before {
    visibility: hidden;
}

h1 {
    font-size: 1.6rem;
    text-align: center;
    margin-top: 0;
}

h2.md-end-block.md-heading {
    font-size: 1.6rem;
    display: inline-block;
}

h2.md-end-block.md-heading:after {
    display: block;
    content: '';
    height: 2px;
    margin-top: 4px;
    background-color: var(--h2-underline-color);
    border-radius: 2px;
}

h3 {
    font-size: 1.4rem;
}

h4 {
    font-size: 1.2rem;
}

h5 {
    font-size: 1rem;
}

h6 {
    font-size: 1rem;
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}

h2 tt,
h2 code {
    font-size: inherit !important;
}

h3 tt,
h3 code {
    font-size: inherit !important;
}

h4 tt,
h4 code {
    font-size: inherit !important;
}

h5 tt,
h5 code {
    font-size: inherit !important;
}

h6 tt,
h6 code {
    font-size: inherit !important;
}

blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}
p {
    margin: 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: var(--horizontal-divider-color);
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul, ol {
    padding-inline-start: 2em;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

table {
    padding: 0;
    word-break: initial;
    background-color: var(--table-bg-color);
}
table tr {
    border-top: .1em solid var(--table-border-color);
    margin: 0;
    padding: 0;
}
table th {
    font-weight: bold;
    border: .1em solid var(--table-border-color);
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table td {
    border: .1em solid var(--table-border-color);
    margin: 0;
    padding: 6px 13px;
}
table thead {
    background-color: var(--table-header-bg-color);
}
table tr:nth-child(2n) {
    background-color: var(--table-n2-bg-color);
}
table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

#write em {
    padding: 0 5px 0 2px;
}

/* height light */
#write mark {
    border: .1em solid var(--height-light-border-color);
    color: var(--height-light-color);
    background-color: transparent;
    padding: .1rem .5rem;
    border-radius: 2rem;
    margin: 0 .2rem;
    font-size: .95rem;
}

/*shortcut*/
kbd {
    border: .1em solid #5b5b5e;
    background: transparent;
    color: var(--text-color);
    margin: 0 .4rem;
    font-size: .95rem;
    padding: .3em .4em;
    border-radius: .4em;
    vertical-align: top;
    box-shadow: .1em .1em .2em rgba(0, 0, 0, 0.3);
}

#write del {
    padding: 1px 2px;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media print {
    html {
        font-size: 12px;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

/*YAML*/
#write pre.md-meta-block {
    padding: 1rem;
    font-size: 1rem;
    background-color: var(--yaml-bg-color);
    border: 0;
    border-radius: 2px;
    color: var(--yaml-color);
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

#write > h3.md-focus:before {
    left: -1.5625rem;
    top: .375rem;
}

#write > h4.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h5.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h6.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

.md-image > .md-meta {
    border-radius: 2px;
    font-family: initial;
    padding: 2px 0 0 4px;
    color: inherit;
}

.md-tag {
    color: inherit;
}

.md-toc {
    margin-top: 20px;
    padding-bottom: 20px;
}

.typora-quick-open-item {
    font-size: 1rem !important;
    height: 50px;
    padding-left: 8px;
    padding-top: 4px;
    padding-bottom: 4px;
}

#typora-quick-open {
    box-shadow: 0 0 8px #00000045;
    padding: 0;
}

.ty-quick-open-category.ty-has-prev .ty-quick-open-category-title {
    border-top: none;
}

#typora-quick-open-input {
    margin: 8px;
    box-shadow: none;
    border-radius: 2px;
}

#typora-quick-open-input input {
    font-size: 1rem;
    box-shadow: none;
    padding-top: 2px;
    padding-left: 10px;
    padding-right: 10px;
    line-height: 32px;
    max-height: 32px;
    border: none;
}

.modal-dialog#typora-quick-open {
    border-radius: 8px;
}

.ty-quick-open-category-title {
    padding-left: 8px;
    color: #BEBEBE;
    font-size: 0.8rem;
    margin-bottom: 4px;
}

.typora-quick-open-item-path {
    font-size: 0.8rem;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-top: 1px;
}

/*search input*/
.form-control {
    border: none;
    border-radius: 2px;
    box-shadow: none;
}

#md-searchpanel .btn {
    border-radius: 2px;
}

#search-panel-replaceall-btn {
    padding-right: 5px !important;
    text-align: center !important;
}

#search-panel-replace-btn {
    text-align: center !important;
}

#md-searchpanel input {
    background: var(--input-bg-color);
    border-radius: 2px;
}

.searchpanel-search-option-btn {
    border-radius: 2px;
    border: none;
    background: transparent;
    color: var(--text-color);
}

.searchpanel-search-option-btn.active {
    background: var(--text-color);
    color: var(--bg-color);
}

.form-control:focus {
    box-shadow: none;
}

#md-notification:before {
    top: 10px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: initial;
}

/*sidebar*/
.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

#typora-sidebar {
    font-size: 1.1rem;
}

.sidebar-tabs {
    border-bottom: none;
}

.file-list-item-summary, .file-list-item-parent-loc, .file-list-item-time, .file-list-item-summary {
    font-size: 0.9rem !important;
    font-family: var(--text-font);
}

.file-list-item-file-ext-part {
    display: none;
}

.outline-item {
    font-size: 1rem;
}

/*footnotes mark*/
#write .md-footnote {
    background-color: inherit;
    color: var(--drake-highlight);
    font-size: 0.9rem;
    border-radius: 0.9rem;
    padding-left: 0;
}

#write .md-footnote:before {
    content: "[";
}

#write .md-footnote:after {
    content: "]";
}

/*footnotes content*/
.md-hover-tip .code-tooltip-content {
    border-radius: 2px;
}

/*footnotes title*/
span.md-def-name {
    padding-right: 3ch;
    padding-left: 0;
    position: relative;
    font-weight: normal;
}

/*footnotes desc*/
.footnotes {
    font-size: 1rem;
    font-weight: normal;
    color: var(--text-color);
    position: relative;
}

/*footnotes tooltip text*/
.code-tooltip-content .md-plain {
    font-size: 0.9rem;
    font-family: inherit;
}

.code-tooltip-content code {
    padding: 0 2px;
    font-family: inherit;
    color: var(--footnotes-highlight);
    background-color: inherit;
}

.code-tooltip-content a {
    color: var(--footnotes-highlight);
}

div.code-tooltip-content {
    box-shadow: 0 0 8px #00000045;
    background: var(--footnotes-bg-color);
}

.footnotes {
    opacity: 1;
}

.md-def-name:after {
    content: ". ^";
    color: var(--text-color);
}

.md-def-footnote .md-def-name:before {
    content: "";
    color: var(--text-color);
    position: absolute;
}

.md-def-name:before {
    content: "";
    color: var(--text-color);
    position: absolute;
}

.md-content.md-url, .md-def-content.md-def-url.md-auto-disp {
    text-decoration: none;
    border-bottom: .1rem solid var(--text-color);
}

.CodeMirror-scroll::-webkit-scrollbar {
    display: none;
}

.file-list-item-summary {
    font-size: 1em;
}

.pin-outline #outline-content .outline-active strong, .pin-outline .outline-active {
    font-weight: 500;
    color: var(--outline-active-color);
}

.file-list-item.active {
    border-left: 4px solid var(--drake-accent);
}

#md-searchpanel .btn:not(.close-btn):hover {
    box-shadow: none;
    background: var(--btn-hover-bg-color);
}

/*checkbox*/
#write input[type=checkbox] {
    opacity: 0;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
    margin-top: 0;
    top: 0;
}

#write .ul-list li.md-task-list-item.task-list-done::before {
    content: "";
    background: var(--checkbox-checked) 0 0 no-repeat;
    background-size: 100%;
    display: inline-block;
    position: absolute;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
}

#write .ul-list li.md-task-list-item.task-list-not-done::before {
    content: "";
    background: var(--checkbox-unchecked) 0 0 no-repeat;
    background-size: 100%;
    display: inline-block;
    position: absolute;
    height: 1.6rem;
    width: 1.6rem;
    margin-left: -2em;
}

/*insert table*/
.btn {
    border-radius: 2px;
}

.modal-content {
    border-radius: 8px;
}

.btn-primary:hover, .btn-primary:active {
    background-color: var(--btn-hover-bg-color);
    color: var(--drake-highlight);
}

.btn-primary {
    background-color: transparent;
    color: var(--drake-highlight);
}

.btn-default {
    background-color: transparent;
}

.btn:active {
    box-shadow: none;
    border-color: transparent;
}

.modal-footer {
    border-top: none;
}

#table-insert-col, #table-insert-row {
    background: var(--input-bg-color);
    border-radius: 2px;
}

/*preference panel*/
#megamenu-content {
    background-image: none !important;
    background-color: var(--bg-color);
}
#top-titlebar {
    height: inherit;
    background-color: var(--bg-color);
}
#megamenu-menu-sidebar {
    background-color: var(--bg-color);
    color: var(--text-color);
}
.long-btn {
    width: inherit;
    min-width: 300px;
    border: 1px solid var(--text-color);
    border-radius: 6px;
}
.megamenu-menu-panel h1 {
    margin-bottom: 3rem;
    text-align: left;
}
.megamenu-menu-panel h1, .megamenu-menu-panel h2 {
    font-weight: normal;
}
#recent-file-panel-search-input {
    height: 45px;
    border: none;
    border-bottom: 1px solid var(--text-color);
    padding-left: 8px;
}
#recent-file-panel-search-input::placeholder {
    color: var(--text-color);
    opacity: .5;
}
.megamenu-menu-header {
    border-bottom: none;
}
#recent-file-panel-action-btn {
    background: none;
    border: none;
}
#recent-file-panel-action-btn-container {
    float: none;
    display: inline-block;
}
#top-titlebar .toolbar-icon.btn.hover, #top-titlebar .toolbar-icon.btn:hover {
    background-color: var(--btn-hover-bg-color);
    color: var(--text-color);
}
.megamenu-menu-panel .btn:hover {
    background-color: var(--btn-hover-bg-color) !important;
    color: var(--text-color);
}
#recent-file-panel tbody tr:nth-child(2n-1),
.megamenu-menu-panel table thead,
.megamenu-menu-panel table tr {
    background-color: transparent;
}
.megamenu-menu-panel table {
    font-weight: normal;
}
#megamenu-back-btn {
    color: var(--text-color);
    border: 1px solid var(--text-color);
}
.megamenu-menu-header #megamenu-menu-header-title {
    color: var(--text-color);
}
header, .context-menu, .megamenu-content, footer {
    font-family: var(--text-font);
}
.ty-preferences select {
    padding-left: 2px;
}
.preference-item-hint {
    font-size: 14px;
}
a.ty-link {
    color: var(--a-color);
    margin: 0 .2rem;
}

/**
    code render
    Name: IntelliJ IDEA darcula theme
    From IntelliJ IDEA by JetBrains
 */
.cm-s-inner.CodeMirror {
    background: var(--code-block-bg-color);
    color: var(--code-block-color);
}

.cm-s-inner span.cm-meta {
    color: #BBB529;
}

.cm-s-inner span.cm-number {
    color: #6897BB;
}

.cm-s-inner span.cm-keyword {
    color: #CC7832;
}

.cm-s-inner span.cm-def {
    color: #FFD760;
}

.cm-s-inner span.cm-variable {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-variable-2 {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-variable-3 {
    color: #9876AA;
}

.cm-s-inner span.cm-type {
    color: #AABBCC;
}

.cm-s-inner span.cm-property {
    color: #FFC66D;
}

.cm-s-inner span.cm-operator {
    color: var(--code-block-color);
}

.cm-s-inner span.cm-string {
    color: #6A8759;
}

.cm-s-inner span.cm-string-2 {
    color: #6A8759;
}

.cm-s-inner span.cm-comment {
    color: #787878;
}

.cm-s-inner span.cm-link {
    color: #CC7832;
}

.cm-s-inner span.cm-atom {
    color: #CC7832;
}

.cm-s-inner span.cm-error {
    color: #BC3F3C;
}

.cm-s-inner span.cm-tag {
    color: #E8BF6A;
}

.cm-s-inner span.cm-quote {
    color: #a6e22e;
}

.cm-s-inner span.cm-attribute {
    color: #9876AA;
}

.cm-s-inner span.cm-qualifier {
    color: #6A8759;
}

.cm-s-inner span.cm-bracket {
    color: #E8BF6A;
}

.cm-s-inner span.cm-builtin {
    color: #FF9E59;
}

.cm-s-inner span.cm-special {
    color: #FF9E59;
}

.cm-s-inner span.cm-matchhighlight {
    color: #FFFFFF;
    background-color: rgba(50, 89, 48, .7);
    font-weight: normal;
}

.cm-s-inner span.cm-searching {
    color: #FFFFFF;
    background-color: rgba(61, 115, 59, .7);
    font-weight: normal;
}

.cm-s-inner .CodeMirror-gutters {
    border-right: 1px solid rgba(120, 120, 120, 0.3);
}

.cm-s-inner .CodeMirror-linenumber {
    color: #585b5d;
}

.cm-s-inner .CodeMirror-matchingbracket {
    background-color: #3B514D;
    color: #FFEF28 !important;
}

.cm-s-inner .CodeMirror-selected {
    background: #214283 !important;
}

.cm-s-inner .CodeMirror-selectedtext {
    background: #214283 !important;
}

.cm-s-typora-default .CodeMirror-selectedtext {
    background: var(--select-text-bg-color) !important;
}

.cm-overlay.CodeMirror-selectedtext {
    background: var(--select-text-bg-color) !important;
}

.cm-s-inner div.CodeMirror-cursor {
    border-left: 1px solid var(--code-block-color);
}/*# sourceURL=/Users/didi/Documents/Codes/Fun/lagou/public/drake-juejin.css*/</style></head>
<body>
  <div id="write"><h1>01 | 栈：从简单栈到单调栈，解决经典栈问题</h1><p data-nodeid="6685" class="">今天我们开始学习一个在工作，以及面试中经常被问到的一个数据结构——<strong data-nodeid="7015">栈</strong>。</p>
<p data-nodeid="6686">栈这种数据结构，在计算机中有着广泛地运用，比如编程语言中函数的调用、操作系统中从用户态到内核态寄存器的保存、网络消息的处理等都会用到栈。</p>
<p data-nodeid="6687">今天我们主要介绍面试中经常考察的栈相关的高频题目，主要内容包含两方面：</p>
<ul data-nodeid="6688">
<li data-nodeid="6689">
<p data-nodeid="6690">栈的特性与使用</p>
</li>
<li data-nodeid="6691">
<p data-nodeid="6692">单调栈的解题技巧</p>
</li>
</ul>
<p data-nodeid="6693">针对一道题目，我会深度讲解一种解法，以及其变型，并且带你总结同类问题的解题技巧和规律，从而解决多种相似及变形题目。并且，我会给出 Java/C++/Python 三种代码示例，方便你学习。现在，开始我们的旅程与探险！</p>
<h3 data-nodeid="6694">栈的特性与使用</h3>
<p data-nodeid="6695">简单栈的特点可以用一句话来概括，<strong data-nodeid="7027">先进后出</strong>（LIFO）顺序。比如 Java 代码（解析在注释里）：</p>
<pre class="lang-java hljs" data-nodeid="6696"><code data-language="java">Stack&lt;Character&gt; t = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();
t.push(<span class="hljs-string">'a'</span>);
t.push(<span class="hljs-string">'b'</span>);
t.peek(); <span class="hljs-comment">// 这里得到栈顶元素'b'</span>
t.pop();  <span class="hljs-comment">// 这里将栈顶元素'b'弹出</span>
t.peek(); <span class="hljs-comment">// 此时栈顶元素为'a'</span>
t.pop();  <span class="hljs-comment">// 这里将栈顶元素'a'弹出</span>
</code></pre>
<p data-nodeid="6697">这部分代码片段执行效果如下图所示：</p>
<p data-nodeid="6698"><img src="https://s0.lgstatic.com/i/image6/M00/0B/63/Cgp9HWA4jJaAMKH7ADCb3Og8L1Q358.gif" alt="1.gif" data-nodeid="7031"></p>
<p data-nodeid="6699">那么如何深度利用栈的“<strong data-nodeid="7037">先进后出</strong>”特点来解决实际工作和面试中的问题呢？是否可以总结出什么有用的知识技巧？现在你的大脑里可能已经有了一个栈的“萌芽”，如下图所示：</p>
<p data-nodeid="6700"><img src="https://s0.lgstatic.com/i/image6/M00/0B/64/Cgp9HWA4jLCAYaYWAAAXKWOZhe8052.png" alt="Drawing 2.png" data-nodeid="7040"></p>
<p data-nodeid="6701">接下来我将通过大厂面试题，带你学习这块重点知识。经过不断地“浇灌”，栈这棵“萌芽”才能抽枝散叶，长得更加茁壮。</p>
<h4 data-nodeid="6702">例 1：判断字符串括号是否合法</h4>
<p data-nodeid="6703">【<strong data-nodeid="7056">题目</strong>】字符串中只有字符'('和')'。合法字符串需要括号可以配对。比如：</p>
<p data-nodeid="6704">输入："()"</p>
<p data-nodeid="6705">输出：true</p>
<p data-nodeid="6706"><strong data-nodeid="7066">解释</strong>：()，()()，(())是合法的。)(，()(，(()是非法的。</p>
<p data-nodeid="6707">请你实现一个函数，来判断给定的字符串是否合法。</p>
<pre class="lang-java hljs" data-nodeid="6708"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span></span>;
</code></pre>
<p data-nodeid="6709">【<strong data-nodeid="7085">分析</strong>】虽然这是一道<strong data-nodeid="7086">简单题</strong>，但是我们依然可以拿它来<strong data-nodeid="7087">训练深度思考的能力</strong>。如果你已经知道答案，或者说能够轻松地解决这道题，不妨再跟我一起看看<strong data-nodeid="7088">如何拆解这道题</strong>。</p>
<p data-nodeid="6710">首先，分析题目的时候，要特别注意以下 4 点，归纳为“<strong data-nodeid="7094">四步分析法</strong>”。</p>
<ol data-nodeid="6711">
<li data-nodeid="6712">
<p data-nodeid="6713"><strong data-nodeid="7102">模拟</strong>：<strong data-nodeid="7103">模拟题目的运行。</strong></p>
</li>
<li data-nodeid="6714">
<p data-nodeid="6715"><strong data-nodeid="7111">规律</strong>：<strong data-nodeid="7112">尝试总结出题目的一般规律和特点。</strong></p>
</li>
<li data-nodeid="6716">
<p data-nodeid="6717"><strong data-nodeid="7120">匹配</strong>：<strong data-nodeid="7121">找到符合这些特点的数据结构与算法。</strong></p>
</li>
<li data-nodeid="6718">
<p data-nodeid="6719"><strong data-nodeid="7129">边界</strong>：<strong data-nodeid="7130">考虑特殊情况。</strong></p>
</li>
</ol>
<p data-nodeid="6720">接下来我们就按照上面的步骤来拆解题目。</p>
<p data-nodeid="6721"><strong data-nodeid="7137">1. 模拟</strong></p>
<p data-nodeid="6722">首先我们以字符串 s = "()()(())"，进行模拟，如下动图所示：</p>
<p data-nodeid="6723"><img src="https://s0.lgstatic.com/i/image6/M00/0B/61/CioPOWA4jh2AHCJwACmFB7AcuZA768.gif" alt="2.gif" data-nodeid="7145"></p>
<p data-nodeid="6724"><strong data-nodeid="7151">2. 规律</strong></p>
<p data-nodeid="6725">我们回顾一下模拟过程，可以总结出以下 3 个特点。</p>
<p data-nodeid="6726">（1）每个左括号'('或者右括号')'都完成<strong data-nodeid="7166">配对</strong>，才是合法的。</p>
<p data-nodeid="6727">（2）配对可以通过<strong data-nodeid="7172">消除法</strong>来消掉合法的括号，如果最后没有任何字符了，那么就是合法字符串。</p>
<p data-nodeid="6728">（3）奇数长度的字符串总是非法的。</p>
<p data-nodeid="6729"><strong data-nodeid="7179">3. 匹配</strong></p>
<p data-nodeid="6730">到这里，我们已经弄清楚题目考核的重点，就是<strong data-nodeid="7193">消除法</strong>的模拟。如果仔细观察消除法的行为模式，你会发现，在消除的时候，上图中<strong data-nodeid="7194">红色</strong>的部分和<strong data-nodeid="7195">栈的行为</strong>非常像。因此，可以用栈来进行消除法的模拟。</p>
<p data-nodeid="6731"><strong data-nodeid="7201">4. 边界</strong></p>
<p data-nodeid="6732">当我们找到问题匹配的算法或者数据结构之后，一定要记住，接下来一步并不是马上写代码，而是要考虑一些边界问题，也就是一些特殊情况：</p>
<ul data-nodeid="6733">
<li data-nodeid="6734">
<p data-nodeid="6735">字符串为空</p>
</li>
<li data-nodeid="6736">
<p data-nodeid="6737">字符串只有 1 个或者奇数个</p>
</li>
<li data-nodeid="6738">
<p data-nodeid="6739">字符串是"(((())))"嵌套很多层的是否可以处理</p>
</li>
</ul>
<p data-nodeid="6740">【<strong data-nodeid="7215">画图</strong>】可以采用画图的方法来判断自己是否已经了解题目，或者是否能灵活运用一个算法。在面试中经常需要在白板或者纸上画图，所以在学习算法时候建议你培养多画图的习惯。</p>
<ul data-nodeid="6741">
<li data-nodeid="6742">
<p data-nodeid="6743">当遇到左括号'('时，进行压栈操作</p>
</li>
<li data-nodeid="6744">
<p data-nodeid="6745">当遇到右括号')'时，进行弹栈操作</p>
</li>
</ul>
<p data-nodeid="6746">为了帮助你更好地理解，我将求解过程制作成一张动图，如下所示，注意左边<strong data-nodeid="7231">栈的变化</strong>。</p>
<p data-nodeid="6747"><img src="https://s0.lgstatic.com/i/image6/M01/0B/68/Cgp9HWA4kDOANTojAGASkY8p8QQ593.gif" alt="3.gif" data-nodeid="7234"></p>
<p data-nodeid="6748">【<strong data-nodeid="7240">代码</strong>】到这里时，你可以写出以下核心代码（解析在注释里）：</p>
<pre class="lang-java hljs" data-nodeid="6749"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>{
  <span class="hljs-comment">// 当字符串本来就是空的时候，我们可以快速返回true</span>
  <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  }
  <span class="hljs-comment">// 当字符串长度为奇数的时候，不可能是一个有效的合法字符串</span>
  <span class="hljs-keyword">if</span> (s.length() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
  }
  <span class="hljs-comment">// 消除法的主要核心逻辑: </span>
  Stack&lt;Character&gt; t = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) {
    <span class="hljs-comment">// 取出字符</span>
    <span class="hljs-keyword">char</span> c = s.charAt(i);
    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'('</span>) {
      <span class="hljs-comment">// 如果是'('，那么压栈</span>
&nbsp; &nbsp;   t.push(c);
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">')'</span>) {
      <span class="hljs-comment">// 如果是')'，那么就尝试弹栈</span>
      <span class="hljs-keyword">if</span> (t.empty()) {
        <span class="hljs-comment">// 如果弹栈失败，那么返回false</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      }
      t.pop();
    }

  <span class="hljs-keyword">return</span> t.empty();
}
</code></pre>
<blockquote data-nodeid="6750">
<p data-nodeid="6751">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01.Java" data-nodeid="7244">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01.cpp" data-nodeid="7248">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01.py" data-nodeid="7252">Python</a></p>
</blockquote>
<p data-nodeid="6752"><strong data-nodeid="7257">复杂度分析</strong>：每个字符只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(N)，因为最差情况下可能会把整个字符串都入栈。</p>
<p data-nodeid="6753">做完一道题后，我们还需要从两个角度进行深度思考：</p>
<ul data-nodeid="6754">
<li data-nodeid="6755">
<p data-nodeid="6756">深度，比如这种解法还可以怎么优化呢？</p>
</li>
<li data-nodeid="6757">
<p data-nodeid="6758">广度，比如这种解法具有普适性吗？可以推广吗？</p>
</li>
</ul>
<p data-nodeid="6759"><strong data-nodeid="7266">1. 深度扩展</strong></p>
<p data-nodeid="6760">如果仔细观察，你会发现，栈中存放的元素是一样的。全部都是左括号'('，除此之外，再也没有别的元素，优化方法如下。</p>
<p data-nodeid="6761"><strong data-nodeid="7276">栈中元素都相同时，实际上没有必要使用栈，只需要记录栈中元素个数。</strong> 我们可以通过画图来解决这个问题，如下动图所示：</p>
<p data-nodeid="6762"><img src="https://s0.lgstatic.com/i/image6/M00/0B/65/CioPOWA4kG2AWiD2AAJ2CaCcwJY807.gif" alt="4.gif" data-nodeid="7279"></p>
<p data-nodeid="6763">实际上，就是把入栈与出栈变成了 leftBraceNumber 的加减。代码如下（解析在注释里）：</p>
<pre class="lang-java hljs" data-nodeid="6764"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>{
&nbsp; <span class="hljs-comment">// 当字符串本来就是空的时候，我们可以快速返回true</span>
&nbsp; <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) {
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&nbsp; }
&nbsp; <span class="hljs-comment">// 当字符串长度为奇数的时候，不可能是一个有效的合法字符串</span>
&nbsp; <span class="hljs-keyword">if</span> (s.length() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&nbsp; }
&nbsp; <span class="hljs-comment">// 消除法的主要核心逻辑:</span>
&nbsp; <span class="hljs-keyword">int</span> leftBraceNumber = <span class="hljs-number">0</span>;
&nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) {
&nbsp; &nbsp; <span class="hljs-comment">// 取出字符</span>
&nbsp; &nbsp; <span class="hljs-keyword">char</span> c = s.charAt(i);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'('</span>) {
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果是'('，那么压栈</span>
&nbsp; &nbsp; &nbsp; leftBraceNumber++;
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">')'</span>) {
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果是')'，那么就尝试弹栈</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (leftBraceNumber &lt;= <span class="hljs-number">0</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果弹栈失败，那么返回false</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; --leftBraceNumber;
&nbsp; &nbsp; }
&nbsp; }
&nbsp; <span class="hljs-keyword">return</span> leftBraceNumber == <span class="hljs-number">0</span>;
}
</code></pre>
<blockquote data-nodeid="6765">
<p data-nodeid="6766">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01_D.java" data-nodeid="7284">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01_D.cpp" data-nodeid="7288">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01_D.py" data-nodeid="7292">Python</a></p>
</blockquote>
<p data-nodeid="6767"><strong data-nodeid="7297">复杂度分析</strong>：每个字符只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(1)，因为我们已经只用一个变量来记录栈中的内容。</p>
<p data-nodeid="6768">【<strong data-nodeid="7303">小结</strong>】经过前面的分析，现在我们可以将题目的特点做一下小结：</p>
<p data-nodeid="6769"><img src="https://s0.lgstatic.com/i/image6/M00/0B/77/Cgp9HWA4ny2ASkpXAABGeRYQOyU298.png" alt="Drawing 10.png" data-nodeid="7306"></p>
<p data-nodeid="6770"><strong data-nodeid="7312">2. 广度扩展</strong></p>
<p data-nodeid="6771">接下来再来看看如何进行广度扩展。观察题目可以发现，栈中只存放了一个维度的信息：左括号'('和右括号')'。如果<strong data-nodeid="7326">栈中的内容变得更加丰富</strong>一点，就可以得到下面这道扩展题。</p>
<p data-nodeid="6772">【<strong data-nodeid="7356">题目扩展</strong>】给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。有效字符串需满足：</p>
<ol data-nodeid="6773">
<li data-nodeid="6774">
<p data-nodeid="6775">左括号必须用相同类型的右括号闭合</p>
</li>
<li data-nodeid="6776">
<p data-nodeid="6777">左括号必须以正确的顺序闭合</p>
</li>
<li data-nodeid="6778">
<p data-nodeid="6779">注意空字符串可被认为是有效字符串</p>
</li>
</ol>
<p data-nodeid="6780">请实现接口： public&nbsp;boolean&nbsp;isValid(String&nbsp;s)</p>
<p data-nodeid="6781">对于这道题，我希望你能再走一下：<strong data-nodeid="7382">分析</strong>，<strong data-nodeid="7383">画图</strong>，<strong data-nodeid="7384">代码</strong>，扩<strong data-nodeid="7385">展</strong>，<strong data-nodeid="7386">小结</strong>的五步曲。</p>
<blockquote data-nodeid="6782">
<p data-nodeid="6783">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.java" data-nodeid="7390">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.cpp" data-nodeid="7394">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.py" data-nodeid="7398">Python</a></p>
</blockquote>
<p data-nodeid="6784">【<strong data-nodeid="7408">小结</strong>】接下来，我们对拓展题目进行总结，希望你从中<strong data-nodeid="7409">提炼出经验</strong>，以后再遇到相似的题目能够轻松应对。</p>
<p data-nodeid="6785">对于栈的使用，除了知道“后进先出”这个规律，我们还可以帮它长出一些叶子来，如下图所示：</p>
<p data-nodeid="6786"><img src="https://s0.lgstatic.com/i/image6/M00/0B/74/CioPOWA4nzyAJYfYAABDA_sAa3Q037.png" alt="Drawing 12.png" data-nodeid="7413"></p>
<p data-nodeid="6787">因此，以后你在看到题目中类似<strong data-nodeid="7427">配对</strong>、<strong data-nodeid="7428">消除</strong>之类的动作时，可以采用<strong data-nodeid="7429">栈</strong>来操作。通过这两个方向上的整理和归纳，我们进一步探寻到了题目和解法之间的联系。让我们继续前进。</p>
<h4 data-nodeid="6788">例 2：大鱼吃小鱼</h4>
<p data-nodeid="6789">【<strong data-nodeid="7444">题目</strong>】在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:</p>
<ol data-nodeid="6790">
<li data-nodeid="6791">
<p data-nodeid="6792">所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；</p>
</li>
<li data-nodeid="6793">
<p data-nodeid="6794">当方向相对时，大鱼会吃掉小鱼；</p>
</li>
<li data-nodeid="6795">
<p data-nodeid="6796">鱼的大小都不一样。</p>
</li>
</ol>
<p data-nodeid="6797">输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0]</p>
<p data-nodeid="6798">输出：3</p>
<p data-nodeid="6799">请完成以下接口来计算还剩下几条鱼？</p>
<pre class="lang-java hljs" data-nodeid="6800"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] Size, <span class="hljs-keyword">int</span>[] Dir)</span></span>;
</code></pre>
<p data-nodeid="6801">题目的示意图如下所示：</p>
<p data-nodeid="6802"><img src="https://s0.lgstatic.com/i/image6/M00/0B/74/CioPOWA4n3uAM9nhAACmI5boRa0503.gif" alt="Stack01.大鱼吃小鱼.gif" data-nodeid="7461"></p>
<p data-nodeid="6803">【<strong data-nodeid="7471">分析</strong>】对于这道题而言，大鱼吃掉小鱼的时候，可以认为是一种<strong data-nodeid="7472">消除</strong>行为。只不过与括号匹配时的行为不一样：</p>
<ul data-nodeid="6804">
<li data-nodeid="6805">
<p data-nodeid="6806">括号匹配是会<strong data-nodeid="7478">同时</strong>把左括号与右括号消除掉；</p>
</li>
<li data-nodeid="6807">
<p data-nodeid="6808">大鱼吃小鱼，<strong data-nodeid="7484">只会把小鱼</strong>消除掉。</p>
</li>
</ul>
<p data-nodeid="6809"><strong data-nodeid="7490">1. 模拟</strong></p>
<p data-nodeid="6810">首先我们以如下示例进行演示：</p>
<pre class="lang-java hljs" data-nodeid="6811"><code data-language="java">Size = [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> <span class="hljs-number">5</span>], Dir = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
</code></pre>
<p data-nodeid="6812"><img src="https://s0.lgstatic.com/i/image6/M01/0B/74/CioPOWA4n5yAIhjtAAXAzjrqmCE807.gif" alt="5.gif" data-nodeid="7494"></p>
<p data-nodeid="6813"><em data-nodeid="7498">注意：当鱼的游动方向相同，或者相反时，并不会相遇，此时大鱼不能吃掉小鱼。</em></p>
<p data-nodeid="6814"><strong data-nodeid="7504">2. 规律</strong></p>
<p data-nodeid="6815">通过模拟，可以发现如下规律:</p>
<ul data-nodeid="6816">
<li data-nodeid="6817">
<p data-nodeid="6818">如果两条鱼<strong data-nodeid="7510">相对而游时，那么较小的鱼会被吃掉；</strong></p>
</li>
<li data-nodeid="6819">
<p data-nodeid="6820"><strong data-nodeid="7515">其他情况</strong>没有鱼被吃掉。</p>
</li>
</ul>
<p data-nodeid="6821"><strong data-nodeid="7521">3. 匹配</strong></p>
<p data-nodeid="6822">我们发现，下面活下来的鱼的行为（上图红框部分）就是一个<strong data-nodeid="7527">栈</strong>。每当有新的鱼要进来的时候，就会与栈顶的鱼进行比较。那么我们匹配到的算法就是栈了。</p>
<p data-nodeid="6823"><strong data-nodeid="7533">4. 边界</strong></p>
<p data-nodeid="6824">在正式开始求解之前，我们还是想一想两种边界：</p>
<ul data-nodeid="6825">
<li data-nodeid="6826">
<p data-nodeid="6827">所有的鱼都朝着一个方向游；</p>
</li>
<li data-nodeid="6828">
<p data-nodeid="6829">一条鱼吃掉了其他的所有鱼。</p>
</li>
</ul>
<p data-nodeid="6830">我们在后面设计算法的时候，这些情况都需要考虑到。</p>
<p data-nodeid="6831">【<strong data-nodeid="7547">画图</strong>】<strong data-nodeid="7548">这道题的关键仍然是如何使用栈来模拟鱼的消除行为</strong>。接下来我们用栈画一下图，演示出我们的思路，动图如下：</p>
<p data-nodeid="6832"><img src="https://s0.lgstatic.com/i/image6/M01/0B/74/CioPOWA4n7eAEu-UAAY8UjR-F74828.gif" alt="7.gif" data-nodeid="7551"></p>
<h3 data-nodeid="6833"></h3>
<p data-nodeid="6834">【<strong data-nodeid="7557">代码</strong>】根据之前的思考，可以得到如下解法（解析在注释里）：</p>
<pre class="lang-java hljs" data-nodeid="6835"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] fishSize, <span class="hljs-keyword">int</span>[] fishDirection)</span> </span>{
  <span class="hljs-comment">// 首先拿到鱼的数量</span>
  <span class="hljs-comment">// 如果鱼的数量小于等于1，那么直接返回鱼的数量</span>
&nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fishNumber = fishSize.length;
&nbsp; <span class="hljs-keyword">if</span> (fishNumber &lt;= <span class="hljs-number">1</span>) {
&nbsp; &nbsp; <span class="hljs-keyword">return</span> fishNumber;
&nbsp; }
  <span class="hljs-comment">// 0表示鱼向左游</span>
&nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 1表示鱼向右游</span>
&nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> right = <span class="hljs-number">1</span>;
&nbsp; Stack&lt;Integer&gt; t = <span class="hljs-keyword">new</span> Stack();
&nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fishNumber; i++) {
    <span class="hljs-comment">// 当前鱼的情况：1，游动的方向；2，大小</span>
&nbsp; &nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> curFishDirection = fishDirection[i];
&nbsp; &nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> curFishSize = fishSize[i];
    <span class="hljs-comment">// 当前的鱼是否被栈中的鱼吃掉了</span>
&nbsp; &nbsp; <span class="hljs-keyword">boolean</span> hasEat = <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// 如果栈中还有鱼，并且栈中鱼向右，当前的鱼向左游，那么就会有相遇的可能性</span>
&nbsp; &nbsp; <span class="hljs-keyword">while</span> (!t.empty() &amp;&amp; fishDirection[t.peek()] == right &amp;&amp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;curFishDirection == left) {
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果栈顶的鱼比较大，那么把新来的吃掉</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (fishSize[t.peek()] &gt; curFishSize) {
&nbsp; &nbsp; &nbsp; &nbsp; hasEat = <span class="hljs-keyword">true</span>;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span>;
&nbsp; &nbsp; &nbsp; }
      <span class="hljs-comment">// 如果栈中的鱼较小，那么会把栈中的鱼吃掉，栈中的鱼被消除，所以需要弹栈。</span>
&nbsp; &nbsp; &nbsp; t.pop();
&nbsp; &nbsp; }
    <span class="hljs-comment">// 如果新来的鱼，没有被吃掉，那么压入栈中。</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!hasEat) {
&nbsp; &nbsp; &nbsp; t.push(i);
&nbsp; &nbsp; }
&nbsp; }
&nbsp; <span class="hljs-keyword">return</span> t.size();
}
</code></pre>
<blockquote data-nodeid="6836">
<p data-nodeid="6837">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Fish.java" data-nodeid="7561">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Fish.cpp" data-nodeid="7565">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Fish.py" data-nodeid="7569">Python</a></p>
</blockquote>
<p data-nodeid="6838"><strong data-nodeid="7574">复杂度分析</strong>：每只鱼只入栈一次，出栈一次，所以时间复杂度 为 O(N)，而空间复杂度为 O(N)，因为最差情况下可能把所有的鱼都入栈。</p>
<p data-nodeid="6839">【<strong data-nodeid="7580">小结</strong>】接下来我们一起对这道题做一下归纳。可以发现，与例 1 相比，它们的消除行为有所不同：</p>
<ul data-nodeid="6840">
<li data-nodeid="6841">
<p data-nodeid="6842">在例 1 中，消除行为表现为配对的<strong data-nodeid="7585">两者都会消除；</strong></p>
</li>
<li data-nodeid="6843">
<p data-nodeid="6844">在例 2 中，消除行为表现为配对的两者中<strong data-nodeid="7591">有一个会被消除</strong>。</p>
</li>
</ul>
<p data-nodeid="6845">此外，在与 例 1 的比较中，可以发现，栈中的内容也有所不同：</p>
<ul data-nodeid="6846">
<li data-nodeid="6847">
<p data-nodeid="6848">在例 1 中，栈中的<strong data-nodeid="7598">存放的就是内容本</strong>身；</p>
</li>
<li data-nodeid="6849">
<p data-nodeid="6850">在例 2 中，栈中存<strong data-nodeid="7604">放的只是内容的索引</strong>，可以通过索引得到内容。</p>
</li>
</ul>
<p data-nodeid="6851">再者，我们也发现，在弹栈的时候，不再像以前那样，每次只弹一个元素，而是采用了 while 循环，要一直弹到满足某个条件为止。所以我们总结出，弹栈的时候有两种情况：</p>
<ul data-nodeid="6852">
<li data-nodeid="6853">
<p data-nodeid="6854"><strong data-nodeid="7610">弹一个元素</strong>就可以；</p>
</li>
<li data-nodeid="6855">
<p data-nodeid="6856">用 while 语句<strong data-nodeid="7616">一直弹，直到满足某个条件</strong>为止。</p>
</li>
</ul>
<p data-nodeid="6857">因此，这道题的考点我们也挖掘出来了：</p>
<ul data-nodeid="6858">
<li data-nodeid="6859">
<p data-nodeid="6860">是否会<strong data-nodeid="7623">用栈来存放索引</strong>？</p>
</li>
<li data-nodeid="6861">
<p data-nodeid="6862">是否想到在弹栈的时候一定要<strong data-nodeid="7629">满足某个条件才停止弹栈</strong>？</p>
</li>
</ul>
<p data-nodeid="6863">到这里栈的特点更丰富了，通过我们不断地浇灌也让栈这棵“萌芽”长出了更多的叶子，总结如下图所示：</p>
<p data-nodeid="6864"><img src="https://s0.lgstatic.com/i/image6/M01/0B/77/Cgp9HWA4n9WAA59XAACgLfhWcGY098.png" alt="Drawing 19.png" data-nodeid="7633"></p>
<h3 data-nodeid="6865">单调栈的解题技巧</h3>
<p data-nodeid="6866">大部分数据结构书上都不太会讲单调栈的知识，但是在面试中却经常考察这一类题，这就非常考验你的知识储备了。</p>
<p data-nodeid="6867">首先我们看一下<strong data-nodeid="7653">单调栈的定义</strong>：单调栈就是指栈中的元素<strong data-nodeid="7654">必须</strong>是按照<strong data-nodeid="7655">升序</strong>排列的栈，或者是<strong data-nodeid="7656">降序</strong>排列的栈。对于这两种排序方式的栈，还给它们各自取了小名。</p>
<p data-nodeid="6868">升序排列的栈称为<strong data-nodeid="7662">递增栈</strong>，如下图所示：</p>
<p data-nodeid="6869"><img src="https://s0.lgstatic.com/i/image6/M01/0B/7B/CioPOWA4qWKAWwxXAAClLMMoPFk436.gif" alt="8.gif" data-nodeid="7665"></p>
<p data-nodeid="6870">降序排列的栈称为<strong data-nodeid="7671">递减栈</strong>，如下图所示：</p>
<p data-nodeid="6871"><img src="https://s0.lgstatic.com/i/image6/M01/0B/7F/Cgp9HWA4qXCAM4-PAADnGTexjMk160.gif" alt="9.gif" data-nodeid="7674"></p>
<p data-nodeid="6872"><em data-nodeid="7678">注意：示意图所展示的这两种栈是横向排列的。栈中元素的值，分别用不同高度的矩形来表示，值越大，矩形越高。</em></p>
<p data-nodeid="6873">接下来我们介绍一下递增栈的有序性，一句话：“<strong data-nodeid="7684">任何时候都需要保证栈的有序性</strong>”。</p>
<p data-nodeid="6874">递增栈的特性可以演示如下（上方数组是要依次入栈的元素）：</p>
<p data-nodeid="6875"><img src="https://s0.lgstatic.com/i/image6/M00/0B/7B/CioPOWA4qXmAUt2VAANQuRNAR14194.gif" alt="13.gif" data-nodeid="7688"></p>
<p data-nodeid="6876">递减栈的特性可以演示如下：</p>
<p data-nodeid="6877"><img src="https://s0.lgstatic.com/i/image6/M00/0B/7B/CioPOWA4qYCABi8aAAUfrNnOGUY452.gif" alt="14.gif" data-nodeid="7692"></p>
<p data-nodeid="6878">通过这两个动图，我们可以总结出单调栈的特点，如下图所示：</p>
<p data-nodeid="6879"><img src="https://s0.lgstatic.com/i/image6/M01/0B/7C/CioPOWA4qiiAEfpbAABn_-GStTI565.png" alt="Drawing 29.png" data-nodeid="7696"></p>
<p data-nodeid="6880">接下来我们通过一些小题目来对单调栈进行“浇灌”，也让单调栈长出更多的“叶子”。</p>
<h4 data-nodeid="6881">例 3：找出数组中右边比我小的元素</h4>
<p data-nodeid="6882">【<strong data-nodeid="7704">题目</strong>】一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。</p>
<p data-nodeid="6883">输入：[5, 2]</p>
<p data-nodeid="6884">输出：[1, -1]</p>
<p data-nodeid="6885"><strong data-nodeid="7721">解释</strong>：因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。</p>
<pre class="lang-java hljs" data-nodeid="6886"><code data-language="java">接口：<span class="hljs-keyword">int</span>[] findRightSmall(<span class="hljs-keyword">int</span>[] A);
</code></pre>
<p data-nodeid="6887">【<strong data-nodeid="7731">分析</strong>】每次开始分析题意时，记得要拿出我们的“<strong data-nodeid="7732">四步分析法”</strong>，通过一步步分析找到题目相应的解法。</p>
<p data-nodeid="6888"><strong data-nodeid="7738">1. 模拟</strong></p>
<p data-nodeid="6889">在正式开始上手之后，我们先拿两个例子演示一下，看看能不能发现题目中隐藏的一些有趣规律，动图如下所示：</p>
<p data-nodeid="6890"><img src="https://s0.lgstatic.com/i/image6/M00/0B/7F/Cgp9HWA4qYqASCuDAArtP3-ZB0A448.gif" alt="15.gif" data-nodeid="7742"></p>
<p data-nodeid="6891"><strong data-nodeid="7748">2. 规律</strong></p>
<p data-nodeid="6892">这里我们是照着题意去寻找一个右边比它小的数的下标。可以发现，A[4] = 4 及 A[5] = 0，这两个数字多次被用到。并且：</p>
<ul data-nodeid="6893">
<li data-nodeid="6894">
<p data-nodeid="6895">A[4] 发现有左边 A[3]，A[3] 就匹配成功；</p>
</li>
<li data-nodeid="6896">
<p data-nodeid="6897">结合 A[5] = 0 的例子，我们发现它会把比它大的数都进行<strong data-nodeid="7784">匹配成功</strong>，但是 A[3] 除外；</p>
</li>
<li data-nodeid="6898">
<p data-nodeid="6899">A[3] 可以认为是匹配成功之后，被 A[4]<strong data-nodeid="7797">消除</strong>了。</p>
</li>
</ul>
<p data-nodeid="6900"><strong data-nodeid="7802">这时可以总结出：一个数总是想与左边比它大的数进行匹配，匹配到了之后，小的数会消除掉大的数</strong>。</p>
<p data-nodeid="6901"><strong data-nodeid="7808">3. 匹配</strong></p>
<p data-nodeid="6902">当你发现要解决的题目有两个特点：</p>
<ul data-nodeid="6903">
<li data-nodeid="6904">
<p data-nodeid="6905">小的数要与大的数<strong data-nodeid="7814">配对</strong></p>
</li>
<li data-nodeid="6906">
<p data-nodeid="6907">小的数会<strong data-nodeid="7820">消除</strong>大的数</p>
</li>
</ul>
<p data-nodeid="6908">你的脑海里应该联想到关于<strong data-nodeid="7826">单调栈</strong>的特性。下面我们看看如何利用单调栈解决这道题目。</p>
<p data-nodeid="6909">【<strong data-nodeid="7836">画图</strong>】在这里，依然需要画一个图来描述一下我们的思路及想法，如下图所示：（红色部分表示栈，我们只将<strong data-nodeid="7837">下标绿色值</strong>放到栈中，为了看图方便，把下标对应的值也标在了相应位置。）</p>
<p data-nodeid="6910"><img src="https://s0.lgstatic.com/i/image6/M00/0B/7F/Cgp9HWA4qkaALlpRAHsvPijzTIg101.gif" alt="16.gif" data-nodeid="7840"></p>
<p data-nodeid="6911">Step 1. 首先将 A[0] = 1 的下标 <strong data-nodeid="7850">0</strong> 入栈。</p>
<p data-nodeid="6912">Step 2. 将 A[1] = 2 的下标 1 入栈。满足单调栈。</p>
<p data-nodeid="6913">Step 3. 将 A[2] = 4 的下标 2 入栈。满足单调栈。</p>
<p data-nodeid="6914">Step 4. 将 A[3] = 9 的下标 3 入栈。满足单调栈。</p>
<p data-nodeid="6915">Step 5. 将 A[4] = 4 的下标 4 入栈时，不满足单调性，需要将 A[3] = 9 从栈中弹出去。下标 4 将栈中下标 3 弹出栈，记录 A[3] 右边更小的是 index = 4。</p>
<p data-nodeid="6916">Step 6. 将 A[5] = 0 的下标 5 入栈时，不满足单调性，需要将 A[4] = 4 从栈中弹出去。下标 5 将下标 4 弹出栈，记录 A[4] 右边更小的是 index = 5。A[5] = 0 会将栈中的下标 0, 1, 2 都弹出栈，因此也需要记录相应下标右边比其小的下标为 5，再将 A[5] = 0 的下标 5 放入栈中。</p>
<p data-nodeid="6917">Step 7. 将 A[6] = 5 的下标 6 放入栈中。满足单调性。</p>
<p data-nodeid="6918">Step 8. 此时，再也没有元素要入栈了，那么栈中的元素右边没有比其更小的元素。因此设置为 -1.</p>
<p data-nodeid="6919">【<strong data-nodeid="7911">代码</strong>】到此为止，相信你已经可以根据思路写出代码了，代码如下（解析在注释里）：</p>
<pre class="lang-java hljs" data-nodeid="6920"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] findRightSmall(<span class="hljs-keyword">int</span>[] A) {
&nbsp; <span class="hljs-comment">// 结果数组</span>
&nbsp; <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[A.length];
&nbsp; <span class="hljs-comment">// 注意，栈中的元素记录的是下标</span>
&nbsp; Stack&lt;Integer&gt; t = <span class="hljs-keyword">new</span> Stack();
&nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++) {
&nbsp; &nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = A[i];
&nbsp; &nbsp; <span class="hljs-comment">// 每个元素都向左遍历栈中的元素完成消除动作</span>
&nbsp; &nbsp; <span class="hljs-keyword">while</span> (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 消除的时候，记录一下被谁消除了</span>
&nbsp; &nbsp; &nbsp; ans[t.peek()] = i;
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 消除时候，值更大的需要从栈中消失</span>
&nbsp; &nbsp; &nbsp; t.pop();
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 剩下的入栈</span>
&nbsp; &nbsp; t.push(i);
&nbsp; }
&nbsp; <span class="hljs-comment">// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。</span>
&nbsp; <span class="hljs-keyword">while</span> (!t.empty()) {
&nbsp; &nbsp; ans[t.peek()] = -<span class="hljs-number">1</span>;
&nbsp; &nbsp; t.pop();
&nbsp; }
&nbsp; <span class="hljs-keyword">return</span> ans;
}
</code></pre>
<blockquote data-nodeid="6921">
<p data-nodeid="6922">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.java" data-nodeid="7915">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.cpp" data-nodeid="7919">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.py" data-nodeid="7923">Python</a></p>
</blockquote>
<p data-nodeid="6923"><strong data-nodeid="7928">复杂度分析</strong>：每个元素只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(N)，因为最差情况可能会把所有的元素都入栈。</p>
<p data-nodeid="6924">【<strong data-nodeid="7942">小结</strong>】到这里我们可以得到一个有趣且非常有用的结论：数组中右边<strong data-nodeid="7943">第一个比我小</strong>的元素的位置，求解用<strong data-nodeid="7944">递增栈</strong>。</p>
<p data-nodeid="6925">这里给你留几道<strong data-nodeid="7950">练习题</strong>，请你思考如何求解。</p>
<ol data-nodeid="6926">
<li data-nodeid="6927">
<p data-nodeid="6928">数组中右边第一个比我大的元素的位置</p>
</li>
</ol>
<blockquote data-nodeid="98718">
<p data-nodeid="98719">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%8F%B3%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.java" data-nodeid="98724">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%8F%B3%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.cpp" data-nodeid="98728">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%8F%B3%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.py" data-nodeid="98732">Python</a></p>
</blockquote>
<ol start="2" data-nodeid="162421">
<li data-nodeid="162422" class="">
<p data-nodeid="162423">数组中元素左边离我最近且比我小的元素的位置</p>
</li>
</ol>





























































<blockquote data-nodeid="6934">
<p data-nodeid="6935">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.java" data-nodeid="7968">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.cpp" data-nodeid="7972">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.py" data-nodeid="7976">Python</a></p>
</blockquote>
<ol start="3" data-nodeid="170788">
<li data-nodeid="170789">
<p data-nodeid="170790" class="te-preview-highlight">数组中元素左边离我最近且比我大的元素的位置</p>
</li>
</ol>



<blockquote data-nodeid="6939">
<p data-nodeid="6940">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.java" data-nodeid="7981">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.cpp" data-nodeid="7985">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.py" data-nodeid="7989">Python</a></p>
</blockquote>
<p data-nodeid="6941">如果我们进一步归纳，会发现消除的时候，这里仍然是消除一个元素，保留一个元素。弹栈的时候，仍然是一<strong data-nodeid="7995">直弹栈，直到满足某个条件为止</strong>。只是条件变成了直到元素大于栈顶元素。为了方便你理解，我把内容总结到了一张大图里：</p>
<p data-nodeid="6942"><img src="https://s0.lgstatic.com/i/image6/M01/0B/7F/Cgp9HWA4qrWAR4cuAADTLTA3i8c099.png" alt="Drawing 45.png" data-nodeid="7998"></p>
<h4 data-nodeid="6943">例 4：字典序最小的 k 个数的子序列</h4>
<p data-nodeid="6944">【<strong data-nodeid="8013">题目</strong>】给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. <strong data-nodeid="8014">长度为 k</strong>；2.<strong data-nodeid="8015">字典序最小</strong>。</p>
<p data-nodeid="6945">输入：nums = [3,5,2,6], k = 2<br>
输出：[2,6]</p>
<p data-nodeid="6946"><strong data-nodeid="8058">解释</strong>：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。</p>
<p data-nodeid="6947">所谓字典序就是，给定两个数组：x = [x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>,x<sub>4</sub>]，y = [y<sub>1</sub>,y<sub>2</sub>,y<sub>3</sub>,y<sub>4</sub>]，如果 0 ≤ p &lt; i，x<sub>p</sub> == y<sub>p</sub> 且 x<sub>i</sub> &lt; y<sub>i</sub>，那么我们认为 x 的字典序小于 y。</p>
<pre class="lang-java hljs" data-nodeid="6948"><code data-language="java">接口：<span class="hljs-keyword">int</span>[] findSmallSeq(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> k);
</code></pre>
<p data-nodeid="6949">【<strong data-nodeid="8123">分析</strong>】根据“四步分析法”，我们一步一步拆解题目。</p>
<p data-nodeid="6950"><strong data-nodeid="8129">1. 模拟</strong></p>
<p data-nodeid="6951">首先应该拿例子来模拟一下题目所述的过程，动图如下所示：</p>
<p data-nodeid="6952"><img src="https://s0.lgstatic.com/i/image6/M01/0B/80/Cgp9HWA4qsyASrO1AAMU43HNuI4415.gif" alt="12.gif" data-nodeid="8133"></p>
<p data-nodeid="6953"><strong data-nodeid="8139">2. 规律</strong></p>
<p data-nodeid="6954">通过模拟，我们发现<strong data-nodeid="8145">一个特点：一旦发现更小的数时，就可以把前面已经放好的数扔掉，然后把这个最小的数放在最前面</strong>。</p>
<p data-nodeid="6955">如果机智一点，就会发现这里与<strong data-nodeid="8159">例 2 的</strong>“<strong data-nodeid="8160">大鱼吃小鱼</strong>”结果很像。区别在于消除的过程中，大鱼吃小鱼是大鱼留下来了，而这里较小的数和较大的数相遇时，是<strong data-nodeid="8161">较小的数</strong>留下来了。</p>
<p data-nodeid="6956"><strong data-nodeid="8167">3. 匹配</strong></p>
<p data-nodeid="6957">到这里，我们已经发现了题目的特点——<strong data-nodeid="8181">较小数消除掉较大数</strong>。根据<strong data-nodeid="8182">例 3</strong> 总结出来的规律，此时就可以用上单调栈。并且，由于是较小的数消除掉较大的数，所以应该使用<strong data-nodeid="8183">递增栈</strong>。</p>
<p data-nodeid="6958"><strong data-nodeid="8189">4. 边界</strong></p>
<p data-nodeid="6959">不过我们还是需要小心题目的边界。</p>
<p data-nodeid="6960"><strong data-nodeid="8195">Case 1</strong>：假设数组右边有一个最小的数，这个最小的数会把左边的数全部都消掉，然后递增栈里面就只剩下这 1 个数了。这跟题意有点不符合，题意需要的是找到 k = 2 个出来。</p>
<p data-nodeid="6961"><img src="https://s0.lgstatic.com/i/image6/M01/0B/80/Cgp9HWA4quuAMBDzAALrKCGW33s184.gif" alt="10.gif" data-nodeid="8198"></p>
<p data-nodeid="6962"><strong data-nodeid="8203">解决办法</strong>：不过你可以想一想，是不是可以控制一下消去的数目。当剩下的数字个数与栈中的元素刚好能凑够 k 个数时，就不能再消除了，代码如下 :</p>
<pre class="lang-java hljs" data-nodeid="6963"><code data-language="java">rightLeftNumber + stack.size() == k
</code></pre>
<p data-nodeid="6964">此时，如果还要进行消除，就不能凑够 k 个数了。这样操作可以保证我们取的序列是最小的 k 个数。</p>
<p data-nodeid="6965"><strong data-nodeid="8209">Case 2</strong>：如果数组是一个升序的数组，那么此时所有的元素都会被压栈。栈中的数目有可能远远超出 k 个。</p>
<p data-nodeid="6966"><img src="https://s0.lgstatic.com/i/image6/M00/0B/80/Cgp9HWA4qxqAFbVgAAH8B7oHgJo512.gif" alt="11.gif" data-nodeid="8212"></p>
<p data-nodeid="6967"><strong data-nodeid="8217">解决办法</strong>：只需要把栈中的多出来的数字弹出来即可。</p>
<p data-nodeid="6968">【<strong data-nodeid="8227">画图</strong>】假定输入为[9, 2, 4, 5, 1, 2, 3, 0], k = 3.输出能构成的最小的序列。</p>
<p data-nodeid="6969"><img src="https://s0.lgstatic.com/i/image6/M01/0B/81/Cgp9HWA4qzaAHEjwAGccHgMTVOU699.gif" alt="17.gif" data-nodeid="8230"></p>
<p data-nodeid="6970">Step 1. 首先将 9 加入栈中。</p>
<p data-nodeid="6971">Step 2. 当 2 要入栈时，不满足单调栈，需要将数字 9 出栈。由于后面还有足够多的元素，可以把 9 弹栈，再将 2 入栈。</p>
<p data-nodeid="6972">Step 3. 将 4 入栈，满足单调性。</p>
<p data-nodeid="6973">Step 4. 再将元素 5 入栈，满足单调性。</p>
<p data-nodeid="6974">Step 5. 将要入栈的元素 1，会弹出栈中所有元素。</p>
<p data-nodeid="6975">Step 6. 将元素 1 入栈。</p>
<p data-nodeid="6976">Step 7. 将元素 2 入栈，满足单调性。</p>
<p data-nodeid="6977">Step 8. 将元素 3 入栈，满足单调性。</p>
<p data-nodeid="6978">Step 9. 将 0 入栈时，需要将栈顶元素 3 弹出。</p>
<p data-nodeid="6979">Step 10. 将 0 入栈，不满足单调性。这是因为，如果 0 将前面的元素再弹栈，余下的元素个数就小于 k = 3 个了。所以不能再利用单调性来弹出栈中元素了。</p>
<p data-nodeid="6980">【<strong data-nodeid="8246">代码</strong>】到这里，相信你已经可以根据思路写出代码了，代码如下（解析在注释里）：</p>
<pre class="lang-java hljs" data-nodeid="6981"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findSmallSeq(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) {
&nbsp; <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];
&nbsp; Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> Stack();
  <span class="hljs-comment">// 这里生成单调栈</span>
&nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
&nbsp; &nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = nums[i];
&nbsp; &nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = nums.length - i;
    <span class="hljs-comment">// 注意我们想要提取出k个数，所以注意控制扔掉的数的个数</span>
&nbsp; &nbsp; <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; (s.size() + left &gt; k) &amp;&amp; s.peek() &gt; x) {
&nbsp; &nbsp; &nbsp; s.pop();
&nbsp; &nbsp; }
&nbsp; &nbsp; s.push(x);
&nbsp; }
  <span class="hljs-comment">// 如果递增栈里面的数太多，那么我们只需要取出前k个就可以了。</span>
  <span class="hljs-comment">// 多余的栈中的元素需要扔掉。</span>
&nbsp; <span class="hljs-keyword">while</span> (s.size() &gt; k) {
&nbsp; &nbsp; s.pop();
&nbsp; }
  <span class="hljs-comment">// 把k个元素取出来，注意这里取的顺序!</span>
&nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
&nbsp; &nbsp; ans[i] = s.peek();
&nbsp; &nbsp; s.pop();
&nbsp; }
&nbsp; <span class="hljs-keyword">return</span> ans;
}
</code></pre>
<blockquote data-nodeid="6982">
<p data-nodeid="6983">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example04.java" data-nodeid="8250">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example04.cpp" data-nodeid="8254">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example04.py" data-nodeid="8258">Python</a></p>
</blockquote>
<p data-nodeid="6984"><strong data-nodeid="8263">复杂度分析</strong>：每个元素只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(N)，因为最差情况可能会把所有元素都入栈。</p>
<p data-nodeid="6985">【<strong data-nodeid="8269">小结</strong>】写完代码之后，我们需要对代码和题目做一个小结：</p>
<ul data-nodeid="6986">
<li data-nodeid="6987">
<p data-nodeid="6988">较小的数<strong data-nodeid="8278">消除</strong>掉较大的数的时候，使用<strong data-nodeid="8279">递增栈；</strong></p>
</li>
<li data-nodeid="6989">
<p data-nodeid="6990">要注意控制剩下的元素的个数；</p>
</li>
</ul>
<p data-nodeid="6991">如果更进一步推而广之，会发现<strong data-nodeid="8286">从简单栈到单调栈，层层推进的过程中，不停变化就是入栈与出栈的时机</strong>。</p>
<p data-nodeid="6992">那么，到这里，这个题目的考点也就非常明了了：</p>
<ul data-nodeid="6993">
<li data-nodeid="6994">
<p data-nodeid="6995">递增栈</p>
</li>
<li data-nodeid="6996">
<p data-nodeid="6997">个数控制，我们只需要取 k 个数出来。</p>
</li>
</ul>
<h3 data-nodeid="6998">总结与延伸</h3>
<p data-nodeid="6999">在本讲我带你一起剖析了栈相关的知识和题目，经过我们不断地“浇灌”，栈这棵“萌芽”开始抽枝散叶，终于长成了一棵枝繁叶茂的“大树”。回到知识层面，我把本讲重点介绍、且需要你掌握的内容总结在一张思维导图中，如下图所示：</p>
<p data-nodeid="7000"><img src="https://s0.lgstatic.com/i/image6/M01/0B/7F/CioPOWA4q6qASB-UAADhj7uzOwg933.png" alt="Drawing 65.png" data-nodeid="8294"></p>
<p data-nodeid="7001">除了带你学习知识本身，我还介绍了题目的变形和演进，希望能够帮助你建立深度分析的能力。在学习算法与数据结构的过程中，作为“刷题过来人”，我非常建议你加强总结和归纳 ，建立自己的<strong data-nodeid="8300">学习方法论</strong>。</p>
<p data-nodeid="7002">虽然栈很有趣，不过我们的介绍就要到这里了，我对于栈的总结和归纳只是个开头，期待你还能发现更多栈的特点和巧妙用法，并且将它们总结下来。也欢迎在评论区和我交流，期待看到你的奇思妙想。</p>
<h3 data-nodeid="7003">思考题</h3>
<p data-nodeid="7004">我再给你留一道<strong data-nodeid="8312">思考题</strong>：给定一个数组，数组中的元素代表木板的高度。请你求出<strong data-nodeid="8313">相邻木板</strong>能剪出的最大矩形面积。</p>
<p data-nodeid="7005"><img src="https://s0.lgstatic.com/i/image6/M00/0B/83/Cgp9HWA4q--AZmcbAABdc5tNqDI318.png" alt="尾图.png" data-nodeid="8316"></p>
<p data-nodeid="7006">这道题会涉及一个<strong data-nodeid="8326">非常重要且有用</strong>的单调栈的性质，<strong data-nodeid="8327">希望你能找到它</strong>。你可以把答案写在评论区，我们一起讨论。</p>
<blockquote data-nodeid="7007">
<p data-nodeid="7008">解法 1：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.java" data-nodeid="8331">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.cpp" data-nodeid="8335">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.py" data-nodeid="8339">Python</a><br>
解法 2：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.java" data-nodeid="8344">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.cpp" data-nodeid="8348">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.py" data-nodeid="8352">Python</a></p>
</blockquote>
<p data-nodeid="7009" class="">接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。让我们继续前进。下一讲将介绍 02 | 队列：FIFO 队列与单调队列的深挖与扩展，记得按时来探险。</p></div>

</body></html>